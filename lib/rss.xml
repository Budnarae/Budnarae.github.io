<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[obsidian]]></title><description><![CDATA[Obsidian digital garden]]></description><link>http://github.com/dylang/node-rss</link><image><url>lib\media\favicon.png</url><title>obsidian</title><link></link></image><generator>Webpage HTML Export plugin for Obsidian</generator><lastBuildDate>Sat, 22 Mar 2025 07:44:32 GMT</lastBuildDate><atom:link href="lib\rss.xml" rel="self" type="application/rss+xml"/><pubDate>Sat, 22 Mar 2025 07:43:51 GMT</pubDate><ttl>60</ttl><dc:creator></dc:creator><item><title><![CDATA[코드 블록 html]]></title><description><![CDATA[ 
 <br>


]]></description><link>재료\미사용-template-저장-폴더\코드-블록-html.html</link><guid isPermaLink="false">재료/미사용 template 저장 폴더/코드 블록 html.md</guid><pubDate>Sat, 22 Mar 2025 07:43:51 GMT</pubDate></item><item><title><![CDATA[코드 블록 javascript]]></title><description><![CDATA[ 
 <br>


]]></description><link>재료\미사용-template-저장-폴더\코드-블록-javascript.html</link><guid isPermaLink="false">재료/미사용 template 저장 폴더/코드 블록 javascript.md</guid><pubDate>Sat, 22 Mar 2025 07:43:51 GMT</pubDate></item><item><title><![CDATA[js 문서 임시 템플릿]]></title><description><![CDATA[<a class="tag" href="?query=tag:language/JavaScript" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#language/JavaScript</a> <a class="tag" href="?query=tag:web" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#web</a> <a class="tag" href="?query=tag:참고도서/모던_자바스크립트_Deep_Dive" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/모던_자바스크립트_Deep_Dive</a> 
 <br><br><a href=".?query=tag:language\JavaScript" class="tag" target="_blank" rel="noopener nofollow">#language/JavaScript</a> <a href=".?query=tag:web" class="tag" target="_blank" rel="noopener nofollow">#web</a> <br>__<br><br><br>참고자료<br><a href=".?query=tag:참고도서\모던_자바스크립트_Deep_Dive" class="tag" target="_blank" rel="noopener nofollow">#참고도서/모던_자바스크립트_Deep_Dive</a> <br>]]></description><link>재료\미사용-template-저장-폴더\js-문서-임시-템플릿.html</link><guid isPermaLink="false">재료/미사용 template 저장 폴더/js 문서 임시 템플릿.md</guid><pubDate>Sat, 22 Mar 2025 07:43:52 GMT</pubDate></item><item><title><![CDATA[No title]]></title><description><![CDATA[ 
 <br><br><br>__<br><br><br>참고자료<br><br>]]></description><link>재료\template\개요와-참고자료.html</link><guid isPermaLink="false">재료/template/개요와 참고자료.md</guid><pubDate>Thu, 16 Jan 2025 02:51:16 GMT</pubDate></item><item><title><![CDATA[참고도서]]></title><description><![CDATA[<a class="tag" href="?query=tag:updating" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#updating</a> <a class="tag" href="?query=tag:참고도서" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서</a> <a class="tag" href="?query=tag:참고도서/그림으로_이해하는_네트워크_용어" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/그림으로_이해하는_네트워크_용어</a> <a class="tag" href="?query=tag:참고도서/후니의_쉽게_쓴_시스코_네트워킹" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/후니의_쉽게_쓴_시스코_네트워킹</a> <a class="tag" href="?query=tag:참고도서/윤성우의_열혈_cpp_프로그래밍" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/윤성우의_열혈_cpp_프로그래밍</a> <a class="tag" href="?query=tag:참고도서/윤성우의_열혈_TCP_IP_소켓_프로그래밍" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/윤성우의_열혈_TCP_IP_소켓_프로그래밍</a> <a class="tag" href="?query=tag:참고도서/이득우의_게임_수학" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/이득우의_게임_수학</a> <a class="tag" href="?query=tag:참고도서/그림과_실습으로_배우는_도커_쿠버네티스" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/그림과_실습으로_배우는_도커_쿠버네티스</a> <a class="tag" href="?query=tag:참고도서/시작하세요_도커_쿠버네티스" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/시작하세요_도커_쿠버네티스</a> <a class="tag" href="?query=tag:참고도서/모던_웹_디자인을_위한_HTML5_CSS3_입문" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/모던_웹_디자인을_위한_HTML5_CSS3_입문</a> <a class="tag" href="?query=tag:참고도서/혼자_공부하는_자바스크립트" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/혼자_공부하는_자바스크립트</a> <a class="tag" href="?query=tag:참고도서/모던_자바스크립트_핵심_가이드" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/모던_자바스크립트_핵심_가이드</a> <a class="tag" href="?query=tag:참고도서/모던_자바스크립트_Deep_Dive" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/모던_자바스크립트_Deep_Dive</a> <a class="tag" href="?query=tag:참고도서/포르잔_cpp_바이블" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/포르잔_cpp_바이블</a> 
 <br><br><a href=".?query=tag:updating" class="tag" target="_blank" rel="noopener nofollow">#updating</a> <a href=".?query=tag:참고도서" class="tag" target="_blank" rel="noopener nofollow">#참고도서</a><br><br>]]></description><link>area\참고도서.html</link><guid isPermaLink="false">area/참고도서.md</guid><pubDate>Sat, 22 Mar 2025 07:43:52 GMT</pubDate></item><item><title><![CDATA[참고링크]]></title><description><![CDATA[<a class="tag" href="?query=tag:updating" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#updating</a> <a class="tag" href="?query=tag:참고링크" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고링크</a> <a class="tag" href="?query=tag:참고링크/후니의_IT_블로그" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고링크/후니의_IT_블로그</a> <a class="tag" href="?query=tag:참고링크/ANSI_escape_code_깃헙_정리자료" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고링크/ANSI_escape_code_깃헙_정리자료</a> <a class="tag" href="?query=tag:참고링크/nginx_org" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고링크/nginx_org</a> <a class="tag" href="?query=tag:참고링크/생활코딩" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고링크/생활코딩</a> <a class="tag" href="?query=tag:참고링크/php-fpm_org" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고링크/php-fpm_org</a> 
 <br><br><a href=".?query=tag:updating" class="tag" target="_blank" rel="noopener nofollow">#updating</a> <a href=".?query=tag:참고링크" class="tag" target="_blank" rel="noopener nofollow">#참고링크</a><br><br>]]></description><link>area\참고링크.html</link><guid isPermaLink="false">area/참고링크.md</guid><pubDate>Sat, 22 Mar 2025 07:43:52 GMT</pubDate></item><item><title><![CDATA[흑요석 공예]]></title><description><![CDATA[<a class="tag" href="?query=tag:updating" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#updating</a> <a class="tag" href="?query=tag:obsidian" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#obsidian</a> 
 <br><br><a href=".?query=tag:updating" class="tag" target="_blank" rel="noopener nofollow">#updating</a> <a href=".?query=tag:obsidian" class="tag" target="_blank" rel="noopener nofollow">#obsidian</a><br>옵시디언 사용법, 테마, 플러그인에 관한 문서입니다.<br><br><br>]]></description><link>area\흑요석-공예.html</link><guid isPermaLink="false">area/흑요석 공예.md</guid><pubDate>Sat, 22 Mar 2025 07:43:52 GMT</pubDate></item><item><title><![CDATA[국내 기사]]></title><description><![CDATA[ 
 <br><br><br><a data-tooltip-position="top" aria-label="https://www.newsis.com/view/NISX20160824_0014343648" rel="noopener nofollow" class="external-link" href="https://www.newsis.com/view/NISX20160824_0014343648" target="_blank">기사 1</a><br>
<a data-tooltip-position="top" aria-label="https://www.joongang.co.kr/article/20495498" rel="noopener nofollow" class="external-link" href="https://www.joongang.co.kr/article/20495498" target="_blank">기사 2</a><br>
<a data-tooltip-position="top" aria-label="https://www.kookje.co.kr/news2011/asp/newsbody.asp?key=20160825.22030190902" rel="noopener nofollow" class="external-link" href="https://www.kookje.co.kr/news2011/asp/newsbody.asp?key=20160825.22030190902" target="_blank">기사 3</a><br><br><a data-tooltip-position="top" aria-label="https://www.edinburghzoo.org.uk/news/nils-olav-most-famous-king-penguin-world-parades-his-way-new-honour" rel="noopener nofollow" class="external-link" href="https://www.edinburghzoo.org.uk/news/nils-olav-most-famous-king-penguin-world-parades-his-way-new-honour" target="_blank">기사 1 - 2016년 준장 진급식</a><br>번역(chatgpt)<br>2022년 8월 22일 월요일 아침, 노르웨이 왕국의 왕실 근위대가 에든버러 동물원(RZSS Edinburgh Zoo)을 특별히 방문하여, 우리의 왕 펭귄 '닐스 올라프(Sir Nils Olav) 경'에게 독특한 영예를 안겼습니다. 이미 기사 작위를 가진 세계에서 가장 유명한 왕 펭귄인 닐스 올라프 경은 새로운 직책인 '준장 닐스 올라프 경(Brigadier Sir Nils Olav)'라는 칭호를 부여받았습니다.<br>이 명예로운 칭호는 2022년 왕실 근위대의 군복을 입은 50명 이상의 군인들이 참석한 특별한 의식에서 수여되었습니다. 이들은 올해 로열 에든버러 밀리터리 타투(Royal Edinburgh Military Tattoo)에 참여 중이었습니다. 닐스 경은은 펭귄 워크(Penguin Walk)를 걸으며 근위대 군인들을 점검했습니다.<br>검은색, 흰색, 노란색의 위엄 있는 펭귄은 노르웨이 왕실 근위대의 마스코트이며, 2008년에는 왕 하랄 5세가 승인한 기사 작위를 받았습니다.<br>닐스 올라프 경의 이야기는 1972년으로 거슬러 올라갑니다. 당시 에든버러 동물원의 한 임금 펭귄은 그 펭귄의 입양을 주선한 Nils Egelien 소령과 당시 노르웨이 왕이었던 올라프 왕의 이름을 따서 지어졌습니다. 에든버러 동물원은 1914년, 노르웨이의 크리스티안 살베센 가족이 동물원에 첫 왕 펭귄을 선물하면서 노르웨이와 펭귄들과의 오랜 인연을 이어왔습니다. 1919년에는 왕 펭귄 새끼가 처음으로 부화되었고, 이는 남대서양 이외 지역에서 첫 번째 성공적인 왕 펭귄 부화 사례였습니다. 이후로 에든버러 동물원은 펭귄들의 과학적 연구와 돌봄에 선도적인 역할을 해왔고, 펭귄은 지금까지도 로열 동물학회(RZSS)의 중요한 상징으로 자리잡고 있습니다.<br>로열 동물학회의 바바라 스미스(Barbara Smith) 대행 CEO는 "노르웨이 왕실 근위대가 우리의 왕 펭귄 닐스 올라프 경에게 명예로운 새로운 칭호를 수여하는 것을 맞이하게 되어 영광입니다. 이는 두 나라, 스코틀랜드와 노르웨이 간의 긴밀한 협력 관계를 나타내는 자랑스러운 순간입니다."라고 말했습니다.<br>로열 에든버러 군사 타투의 프로듀서이자 CEO인 데이비드 올프리(Brigadier David Allfrey)는 "이것은 두 나라 간의 훌륭한 관계를 보여주는 멋진 사례이며, 더할 나위 없이 매력적인 전통입니다. 타투에서는 많은 장교들이 있지만, 이만큼 특별한 장교는 없었습니다. 브리가디어 올라프, 축하합니다!"라고 덧붙였습니다.<br>군인들은 매년 에든버러 군사 타투에 참여할 때마다 닐스 경를 방문하여 새로운 진급을 수여합니다. 1972년 입양 이후 서 뉼스는 마스코트에서 시작해 1982년에는 상등병(Corporal), 1987년에는 병장(Sergeant), 1993년에는 연대 원사(Regimental Sergeant Major), 2001년에는 명예 연대 원사(Honourable Regimental Sergeant Major), 2005년에는 명예 연대장(Colonel-in-Chief), 2008년에는 기사 작위(Knighthood), 그리고 이제 준장(Brigadier Sir)으로 진급하게 되었습니다.<br><a data-tooltip-position="top" aria-label="https://www.edinburghzoo.org.uk/news/sir-nils-olav-promoted-edinburgh-zoo" rel="noopener nofollow" class="external-link" href="https://www.edinburghzoo.org.uk/news/sir-nils-olav-promoted-edinburgh-zoo" target="_blank">기사 2 - 2023년 소장 진급식</a><br>번역(chatgpt)<br>2023년, 로열 에든버러 군사 타투(Royal Edinburgh Military Tattoo)에 참여 중인 노르웨이 왕실 근위대 밴드와 훈련 팀은 에든버러 동물원(RZSS Edinburgh Zoo)을 방문하여 왕 펭귄 닐스 올라프 경경(Sir Nils Olav)에게 독특한 영예를 수여했습니다.<br>이미 브리가디어인 세계적으로 유명한 왕 펭귄 서 뉼스 올라프는 이제 "소장 닐스 올라프 3세(Major General Sir Nils Olav III), 부베 섬의 남작(Baron of the Bouvet Islands)"이라는 웅장한 칭호와 함께 노르웨이 왕실 근위대의 공식 마스코트로서 새로운 타이틀을 부여받았습니다.<br>닐스 경은 노르웨이 왕실 근위대 밴드와 훈련 팀의 사전 정해진 퍼레이드를 지나며 펭귄 록(Penguins Rock)에서 열린 특별한 의식에서 새로 부여받은 명예 배지를 수여받았습니다. 이 의식에는 올해 로열 에든버러 군사 타투 쇼 '스토리(Stories)'에 참여 중인 노르웨이 왕실 근위대 군인 160명이 참석했습니다.<br>로열 에든버러 군사 타투의 최고운영책임자(COO)인 제이슨 바렛(Jason Barrett)은 “올해 로열 에든버러 군사 타투의 주제는 ‘스토리’이며, 닐스 올라프 경의 군 계급 상승 이야기가 이 쇼와 잘 연결됩니다. 노르웨이 왕실 근위대는 우리 공연에 풍부한 역사와 명예, 전통을 가져오며, 그들은 수년간 팬들의 사랑을 받아왔습니다. 왕실 근위대와 같은 공연을 통해 타투에서 찾을 수 있는 문화 간 요소가 드러나며, 이는 타투가 다른 엔터테인먼트 행사와 구별되는 점입니다. 로열 에든버러 군사 타투의 모든 출연자와 스태프를 대표하여, 닐스 올라프 3세의 소장 진급을 축하합니다."라고 전했습니다.<br>로열 동물학회(RZSS)의 최고경영자(CEO)인 데이비드 필드(David Field)는 "이번에 노르웨이 왕실 근위대 밴드와 훈련 팀을 다시 한 번 맞이하게 되어 영광입니다. 그들이 우리 왕 펭귄 닐스 올라프 경에게 새로운 명예 칭호를 수여하는 것을 보게 되어 매우 자랑스럽습니다. 이는 두 나라, 스코틀랜드와 노르웨이 간의 지속적인 협력 관계를 나타내는 중요한 순간입니다."라고 말했습니다.<br>노르웨이 왕실 근위대 밴드와 훈련 팀의 병장인 프레드릭 그레세스(Staff Sergeant Fredrik Gresseth)는 "닐스 올라프 경은 노르웨이 왕실 근위대의 마스코트이며, 밴드와 훈련 팀이 로열 에든버러 군사 타투에 참여했을 때 그를 입양했습니다. 닐스 경과 그의 가족에게 생선과 크리스마스 카드 보내기, 그리고 타투 참여 시 그를 방문하는 전통은 근위대 대대의 역사에서 중요한 부분이었습니다. 이번 8월의 진급은 그의 훌륭한 행실과 에든버러 동물원의 다른 펭귄들에게 본보기가 되는 모습 덕분에 이루어진 것이며, 이는 그가 마스코트로서의 경력에서 중요한 이정표입니다. 훈련 팀의 군인들은 자신들의 마스코트를 점검하는 이 드문 기회를 기대하고 있으며, 밴드는 기사 작위를 받은 왕 펭귄에게 걸맞은 분위기를 만들어낼 것입니다."라고 덧붙였습니다.<br>검은색, 흰색, 노란색이 돋보이는 이 위엄 있는 펭귄은 노르웨이 왕실 근위대의 마스코트이며, 그의 이야기는 1972년까지 거슬러 올라갑니다. 그 당시 에든버러 동물원에 있던 왕 펭귄은 두 사람의 이름을 따서 지어졌습니다. 그 한 명은 에든버러 동물원에 펭귄을 입양하는 일을 주선한 니얼스 에겔리엔 소령(Major Nils Egelien)이고, 다른 한 명은 당시 노르웨이 왕이었던 올라프 왕(King Olav)이었습니다.<br>군인들은 매 몇 년마다 에든버러 군사 타투에 참여하면서 서 뉼스를 방문하여 그의 진급을 수여합니다. 1972년 입양 이후 닐스 경은 마스코트로 시작하여 1982년에는 상등병(Corporal), 1987년에는 병장(Sergeant), 1993년에는 연대 원사(Regimental Sergeant Major), 2001년에는 명예 연대 원사(Honourable Regimental Sergeant Major), 2005년에는 명예 연대장(Colonel-in-Chief), 2008년에는 기사 작위(Knighthood), 2016년에 준장(Brigadier Sir), 2023년인 지금 소장(Major General)으로 진급하게 되었습니다.<br><br>계급은 해외랑 국내 기사의 표현이 달라서 통일되지 않은 부분이 있습니다<br>
<br>펭귄 한 마리가 일등병 ~ 준장의 계급을 모두 거친 것이 아니다. 펭귄이 수명을 다해 자연사할 때마다 그 펭귄의 자손이 계급을 이어받아 왔다.
<br>첫 번째 펭귄인 닐스 올라프 1세는 1987년 하사로 진급한 뒤 얼마 안되어 자연사했다.
<br>진급은 노르웨이 왕실 근위대가 에든버러를 방문할 때마다 거듭되었다. 순서는 1972년 마스코트 -&gt; 1982년 상등병 -&gt; 1987년 병장 -&gt; 1993년 연대 원사 -&gt; 2001년 명예 연대 원사 -&gt; 2005년 명예 연대장 -&gt; 2008년 기사 작위 -&gt; 2016년 준장 -&gt; 2023년 소장
<br>노르웨이 작위를 부여받았다고 해서 펭귄이 노르웨이로 옮겨가 사는 것은 아니고, 계속 스코틀랜드 에든버러 동물원에서 거주한다.
<br>노르웨이 왕실 군위대는 매년 영국&nbsp; 에든버러에서 열리는 전 세계 군악대 공연 경연인 ‘에든버러 밀리터리 타투(Royal Edinburgh Military Tattoo)’에 참여하고 있다.
]]></description><link>project\4-2학기\닐스-올라프-경-자료조사.html</link><guid isPermaLink="false">project/4-2학기/닐스 올라프 경 자료조사.md</guid><pubDate>Thu, 06 Mar 2025 16:49:59 GMT</pubDate></item><item><title><![CDATA[42 innercirle 정리]]></title><description><![CDATA[ 
 <br><br>그동안 수행했던 개발자 교육과정 42 서울의 공통 과정 과제들을  정리한 저장소입니다.<br><br><br>
<br>각 폴더마다 컴파일을 위한 Makefile이 존재하지만, 이미 make된 상태로 푸시하였으므로 별도로 Makefile을 실행시키지 않아도 됩니다.
<br>NetPractice, Born2beroot는 42 서울의 인트라넷에서만 테스트 가능한 과제이므로 별도의 실행 가능한 파일을 올리지 않은 점 양해 바랍니다다.
<br><br>C 기초<br>strlcpy, strlcat 같은 c 라이브러리의 함수들을 직접 구현해보는 과제<br><br>파일 입출력, static 변수<br>다음의 기능과 형식을 가진 get_next_line이라는 함수를 만드는 과제<br>
// 입력값 : 파일 디스크립터
// 반환값 : 파일로부터 문장 하나를 추출하여 반환.
// n번째로 get_next_line을 호출하면 파일의 n번째 문장을 반환한다.
char *get_next_line(int fd);

<br>/42_innercircle_course/get_next_line/ 경로의 tester.c 파일을 참조하여 tester 파일을 실행시키면 get_next_line의 동작을 확인할 수 있다.<br><br>가변 인자<br>VA_ARG를 활용하여 c 라이브러리의 printf의 기능을 제한적으로(type, flag, precision의 가짓수가 제한되어 있음) 구현하는 과제<br>/42_innercircle_course/ft_printf/ 경로의 tester.c 파일을 참조하여 tester 파일을 실행시키면 ft_printf의 동작을 확인할 수 있다.<br><br>가상 머신, 리눅스 기초<br>VirtualBox를 사용하여 linux 가상 환경을 띄운 후, 그 환경에서 여러 서비스들을 설정하는 과제<br><br>멀티 프로세싱, 프로세스 간 통신<br>fork, pipe 시스템 콜을 활용하여 쉘의 파이프 기능을 구현해보는 과제<br>
&lt; infile ls -l | wc -l &gt; outfile

<br>위와 같은 쉘의 파이프 기능을 아래와 같은 형식으로 구현한다.<br>
./pipex infile "ls -l" "wc -l" outfile

<br>2개 이상의 명령어를 이을 수도 있다.<br>
&lt; infile cmd1 | cmd2 | cmd3 | ... | cmdn &gt; outfile

<br>
./pipex infile cmd1 cmd2 cmd3 ... cmdn outfile

<br>heredoc 기능을 사용할 수도 있다.<br>
cmd &lt;&lt; LIMITER | cmd1 &gt;&gt; file

<br>
./pipex here_doc LIMITER cmd cmd1 file

<br><br>자료구조, 알고리즘<br>두 개의 스택을 사용하여 뒤섞인 숫자 배열을 정렬하는 과제<br>다음과 같은 조건 하에 문제를 해결해야 한다.<br>
<br>스택 a, 스택 b 총 두 개의 스택이 있다.
<br>입력받은 뒤섞인 숫자 배열은 스택 a에 위치한다.
<br>후술할 스택의 동작들을 활용하여 최종적으로 스택 a에 숫자들이 정렬되도록 한다.
<br>이 과제에서 제시하는 스택은 일반적인 스택과 달리 다음의 추가적인 동작들을 적용할 수 있다(사실 말이 스택이지 별도의 자료구조라 보는 게 무방하다).<br>
<br>sa (swap a): 스택 a의 맨 위 두 개 요소를 바꾼다. 요소가 하나 이하일 때는 아무것도 하지 않는다.
<br>sb (swap b): 스택 b의 맨 위 두 개 요소를 바꾼다. 요소가 하나 이하일 때는 아무것도 하지 않는다.
<br>ss: sa와 sb를 동시에 한다.
<br>pa (push a): 스택 b의 맨 위 요소를 꺼내서 스택 a의 맨 위에 넣는다. 만약 스택 b가 비어 있으면 아무것도 하지 않는다.
<br>pb (push b): 스택 a의 맨 위 요소를 꺼내서 스택 b의 맨 위에 넣는다. 만약 스택 a가 비어 있으면 아무것도 하지 않는다.
<br>ra (rotate a): 스택 a의 모든 요소를 위로 1칸씩 이동시킨다. 첫 번째 요소가 마지막 요소가 된다.
<br>rb (rotate b): 스택 b의 모든 요소를 위로 1칸씩 이동시킨다. 첫 번째 요소가 마지막 요소가 된다.
<br>rr: ra와 rb를 동시에 한다.
<br>rra (reverse rotate a): 스택 a의 모든 요소를 아래로 1칸씩 이동시킨다. 마지막 요소가 첫 번째 요소가 된다.
<br>rrb (reverse rotate b): 스택 b의 모든 요소를 아래로 1칸씩 이동시킨다. 마지막 요소가 첫 번째 요소가 된다.
<br>rrr: rra와 rrb를 동시에 한다.
<br>push_swap에 뒤섞인 숫자 배열을 입력하면 숫자들을 정렬하기 위한 명령어의 나열을 출력한다.<br>
참고로 입력하는 숫자 배열의 숫자들은 서로 중복되지 않아야 한다.<br>
./push_swap 5 2 1 4 7 6 3

sa
pb
rra
pb
sa
pb
rb
sa
pb
pb
sa
pb
pb
pa
pa
pa
pa
pa
pa
pa

<br><a data-tooltip-position="top" aria-label="https://windowdong11.github.io/push_swap_visualizer/" rel="noopener nofollow" class="external-link" href="https://windowdong11.github.io/push_swap_visualizer/" target="_blank">push swap visualizer</a>를 활용하면 push_swap의 동작을 시각적으로 확인할 수 있다. 단, 이 저장소를 사용하는 사람들은 WSL 환경에서 push_swap을 실행시킬 것이므로 push_swap [뒤섞인 숫자 나열] | clip, push_swap [뒤섞인 숫자 나열] | pbcopy가 아닌 push_swap [뒤섞인 숫자 나열] | xclip -selection clipboard를 사용해야 한다.<br><br>그래픽스 기초<br>아래와 같은 형태의 map 파일을 사용하여<br>
cat 42.fdf

0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 10 10 0 0 10 10 0 0 0 10 10 10 10 10 0 0 0
0 0 10 10 0 0 10 10 0 0 0 0 0 0 0 10 10 0 0
0 0 10 10 0 0 10 10 0 0 0 0 0 0 0 10 10 0 0
0 0 10 10 10 10 10 10 0 0 0 0 10 10 10 10 0 0 0
0 0 0 10 10 10 10 10 0 0 0 10 10 0 0 0 0 0 0
0 0 0 0 0 0 10 10 0 0 0 10 10 0 0 0 0 0 0
0 0 0 0 0 0 10 10 0 0 0 10 10 10 10 10 10 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0

<br>아래의 예시와 같이 3차원의 형상(wire frame이긴 하지만)으로 투사하는 과제이다.<br><img alt="FdF.png" src="lib\media\fdf.png"><br>map 파일의 숫자들은 다음과 같이 해석된다.<br>
<br>숫자의 열 위치 : x축 좌표값
<br>숫자의 행 위치 : y축 좌표값
<br>숫자의 값 : z축 좌표값
<br>과제 수행을 위하여 행렬을 통한 공간 변환, 브레젠험 알고리즘 같은 지식을 배우게 된다.<br>fdf를 실행하기 전 의존성 문제를 해결하기 위해 다음의 명령어를 실행해야한다.<br>
sudo apt-get update &amp;&amp; sudo apt-get install xorg libxext-dev zlib1g-dev libbsd-dev

<br>아래와 같은 명령어를 통해 테스트 해볼 수 있다. 예제 map 파일들은 test_maps 경로에 위치해 있다.<br>
./fdf ./test_maps/42.fdf

<br>창을 띄우는 데까지 성공했다면, 다음의 키들을 활용하여 추가 기능을 테스트할 수 있다.<br>scale<br>
<br>위 화살표 : 확대
<br>아래 화살표 : 축소
<br>rotate<br>
<br>A, D : y 축 회전
<br>W, S : x 축 회전
<br>Q, E : z 축 회전
<br>translate<br>
<br>I, K : x 축 이동
<br>J, L :  y 축 이동
<br>U, E : z 축 이동
<br>기타<br>
<br>space : 투영법 변환(등각 투영 &lt;-&gt; 캐비넷 투영)
<br>esc : 나가기
<br><br>파일 입출력, 멀티 프로세스, 시그널 심화<br>제한된 기능의 bash shell을 구현하는 과제<br>minishell 실행 파일은 readline 라이브러리에 의존성을 가지므로 아래의 명령어를 실행시킨 후 실행시켜야 한다.<br>
sudo apt-get install libreadline-dev

<br>microshell은 아래와 같은 기능을 가지고 있다.<br>
<br>히스토리 : 위, 아래 화살표를 이용해 과거에 사용했던 명령어를 편리하게 조회, 재사용할 수 있다.
<br>쌍따옴표, 따옴표 파싱
<br>괄호 파싱
<br>&lt;, &gt;, &lt;&lt;, &gt;&gt;, &amp;&amp;, || 연산자
<br>파이프라인(|)
<br>환경변수 관리
<br>$?를 통한 exit status 조회
<br>ctrl-C, ctrl-D, ctrl-\ 입력이 bash shell과 동일한 동작을 보장함
<br>와일드 카드(*)
<br><br>멀티 스레드<br>pthread, mutex_lock 등을 사용하여 식사하는 철학자 문제(dining philosophers problem)를 구현, 멀티 스레딩, 데이터 레이스(data race), 데드 락(dead lock)을 공부하는 과제<br>각 철학자(스레드)는 제한된 숫자의 포크(공유 자원)을 사용하여 굶어죽지 않고 무사히 식사를 마칠 수 있어야 한다.<br>philo 실행 파일은 다음의 인자를 받아 실행된다.<br>
<br>철학자 인원
<br>죽는 데 걸리는 시간
<br>먹는 데 걸리는 시간
<br>자는 데 걸리는 시간
<br>각 철학자가 먹어야 하는 횟수(없어도 무방하며, 입력하지 않을 시 철학자들은 무한히 식사하게 된다)
<br>즉, 아래와 같이 사용된다.<br>
./philo 2 450 200 200 4

<br>philo_bonus 실행 파일은 멀티 스레드 대신 멀티 프로세스, 세마포어를 사용하여 구현한 철학자 모델이다.<br>phlio 또는 philo_bonus 파일의 실행결과를 <a data-tooltip-position="top" aria-label="https://nafuka11.github.io/philosophers-visualizer/" rel="noopener nofollow" class="external-link" href="https://nafuka11.github.io/philosophers-visualizer/" target="_blank">philosopher visualizer</a>에 붙여넣기 하면 보다 시각적으로 결과를 확인할 수 있다.<br><br>ray tracing<br>phong lighting model을 구현하는 과제이다.<br>miniRR 실행 파일은 환경광(ambient lighting), 카메라, 광원, 구체, 평면, 원기둥 정보가 담겨 있는 .rt 파일을 파싱하여 3차원으로 렌더링할 수 있어야 한다. FdF의 wire frame 렌더링이 아닌, 보다 현실감 있는 3차원 렌더링으로 말이다.<br>아래와 같이 사용한다.<br>
./miniRT rtFileName.rt

<br>예제 rt 파일은 maps 경로에 위치한다.<br><br>네트워크 기초<br>NetPractice는 가상의 네트워크 망이 서로 잘 통신할 수 있도록 빈 칸에 알맞은 ip 주소를 채워넣는 퍼즐 문제이다.<br>공인 ip, 사설 ip, LAN, WAN, 서브넷 마스킹 등을 공부하게 된다.<br><br>C++ 기초<br>CPP Module은 cpp 언어의 기초를 학습하기 위한 과제이다. 각 모듈은 다음의 주제를 다룬다.<br>
<br>모듈 0 : Namespaces, classes, member functions, stdio streams, initialization lists, static, const
<br>모듈 1 : Memory allocation, pointers to members, references, switch statement
<br>모듈 2 : Ad-hoc polymorphism, operator overloading and Orthodox Canonical class form
<br>모듈 3 : Inheritance
<br>모듈 4 : Subtype polymorphism, abstract classes, interfaces
<br>모듈 5 : Repetition and Exceptions
<br>모듈 6 : C++ casts
<br>모듈 7 : C++ templates
<br>모듈 8 : Templated containers, iterators, algorithms
<br>모듈 9 : STL
<br><br>socket programming<br>C++ 언어를 사용하여 irc 서버를 만드는 과제이다.<br>
irc란, 채팅 서버를 만들기 위한 프로토콜이다. 물론 irc 서버를 온전히 구현하는 것은 너무 벅찬 일이므로, 일부 기능을 제외하고 구현하였다(ex. 서버 간 통신).<br>클라이언트와 통신하는 기능을 만들기 위해 소켓 프로그래밍 socket programming을, 정해진 프로토콜 대로 서버를 만들기 위해 rfc 문서를 보는 방법을 배우게 된다.<br>nc(netcat) 같은 간단한 클라이언트 프로그램으로도 서버를 테스트할 수 있지만, 사용자 친화적이지 못하므로 제대로 된 irc 클라이언트를 설치하여 테스트하는 것을 권장한다.<br>
sudo apt install irssi

<br>그리고 먼저 서버를 실행시킨다. 첫번째 인자는 서버가 통신에 사용할 포트 번호, 두번째 인자는 서버에 연결하는데 사용할 비밀번호이다.<br>
./ircserv 4242 4242

<br>그리고 irssi 클라이언트를 실행시킨다.<br>
./irssi

<br>화면에 irssi 윈도우가 띄워지면, 다음의 명령어를 사용하여 서버에 접속한다.<br>
/connect -nocap localhost 4242 4242 nickname

<br>연결에 성공하였다면 <a data-tooltip-position="top" aria-label="https://www.rfc-editor.org/rfc/rfc2812.html" rel="noopener nofollow" class="external-link" href="https://www.rfc-editor.org/rfc/rfc2812.html" target="_blank">rfc 2812</a> 문서를 참고하여 irc 프로토콜의 다양한 명령어를 테스트하여보자.<br><br>Docker<br>도커를 사용하여 wordpress 페이지를 서비스하기 위한 MSA(micro service architecture)를 띄우는 과제.<br>이 과제를 테스트하기 위해선 리눅스에 docker가 설치되어 있어야 한다.<br>
sudo apt install docker

<br>sudo make build로 MSA를 올릴 수 있고 호스트에서 https://localhost로 접속할 수 있다. sudo make fclean으로 MSA를 내릴 수 있다.<br><br>웹 프로그래밍 기초<br>플레이어들이 서로 ping pong 게임을 즐길 수 있는 웹페이지를 만드는 과제<br>
다음의 스택을 사용한다.<br>
<br>프론트엔드 : pure vanila javascript, html, css, bootstrap, socket.io, three.js
<br>백엔드 : Django
<br>과제를 테스트하기 위해서는 backend 경로로 이동하여 sudo make하고 호스트에서 chrome을 사용하여 https://localhost로 접속하면 된다.<br>sudo make fclean으로 MSA를 내릴 수 있다.]]></description><link>project\42seoul\42-innercircle-정리\42-innercirle-정리.html</link><guid isPermaLink="false">project/42Seoul/42 innercircle 정리/42 innercirle 정리.md</guid><pubDate>Fri, 28 Feb 2025 15:02:18 GMT</pubDate><enclosure url="lib\media\fdf.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;lib\media\fdf.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[authentication.mjs]]></title><description><![CDATA[<a class="tag" href="?query=tag:42Seoul" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#42Seoul</a> <a class="tag" href="?query=tag:ft_transcendence" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#ft_transcendence</a> 
 <br><br><a href=".?query=tag:42Seoul" class="tag" target="_blank" rel="noopener nofollow">#42Seoul</a> <a href=".?query=tag:ft_transcendence" class="tag" target="_blank" rel="noopener nofollow">#ft_transcendence</a><br><br><br>인증 모듈은 로그인 시 사용자 인증에 필요한 기능들을 클래스의 정적 메소드의 형태로 지원한다.<br>FtOauth 클래스는 42 oauth 인증에 관련된 기능을 지원한다.<br>
TwoFactorOauth 클래스는 2fa 인증에 관련된 기능을 지원한다.<br><br>
<br>clientId : 42 api의 클라이언트 id
<br>redirectUri : 42 api에서 콜백할 uri
<br>authUrl : 42 oauth 페이지로 넘어가기 위한 최종 url
<br><br>
<br>static isAlreadyAuth() : 현재 url에 code가 포함되어 있으면 code를, 그렇지 않으면 undefined를 반환한다.
]]></description><link>project\42seoul\ft_transcendence\모듈-설계\authentication.mjs.html</link><guid isPermaLink="false">project/42Seoul/ft_transcendence/모듈 설계/authentication.mjs.md</guid><pubDate>Fri, 24 Jan 2025 07:12:26 GMT</pubDate></item><item><title><![CDATA[page.mjs]]></title><description><![CDATA[<a class="tag" href="?query=tag:42Seoul" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#42Seoul</a> <a class="tag" href="?query=tag:ft_transcendence" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#ft_transcendence</a> 
 <br><br><a href=".?query=tag:42Seoul" class="tag" target="_blank" rel="noopener nofollow">#42Seoul</a> <a href=".?query=tag:ft_transcendence" class="tag" target="_blank" rel="noopener nofollow">#ft_transcendence</a><br><br><br>페이지 모듈은 각 페이지를 화면에 렌더링하는 기능을 지원한다.<br><br><br>
<br>static renderLoginPage(ftOauthUrl) : 화면에 로그인 페이지를 렌더링한다. 이 때, 버튼에 42 인증 페이지로의 링크를 부여하기 위해 42 Oauth url을 인자로 주어야 한다.
<br>static destroyLoginPage() : 로그인 페이지를 화면에서 지운다.
<br><br>
<br>static renderTwoFAPage() : 화면에 2fa(google otp) 인증 페이지를 렌더링한다.
<br>static destroyTwoFAPage() : 2fa 인증 페이지를 화면에서 지운다.
]]></description><link>project\42seoul\ft_transcendence\모듈-설계\page.mjs.html</link><guid isPermaLink="false">project/42Seoul/ft_transcendence/모듈 설계/page.mjs.md</guid><pubDate>Tue, 21 Jan 2025 08:00:53 GMT</pubDate></item><item><title><![CDATA[42 oauth 기반 로그인 구현 방법]]></title><description><![CDATA[ 
 <br><a data-tooltip-position="top" aria-label="https://yeslee-v.medium.com/django%EB%A1%9C-42api-%EB%A1%9C%EA%B7%B8%EC%9D%B8-%EA%B5%AC%ED%98%84%ED%95%98%EA%B8%B0-1f7a206cb4a4" rel="noopener nofollow" class="external-link" href="https://yeslee-v.medium.com/django%EB%A1%9C-42api-%EB%A1%9C%EA%B7%B8%EC%9D%B8-%EA%B5%AC%ED%98%84%ED%95%98%EA%B8%B0-1f7a206cb4a4" target="_blank">링크</a>]]></description><link>project\42seoul\ft_transcendence\42-oauth-기반-로그인-구현-방법.html</link><guid isPermaLink="false">project/42Seoul/ft_transcendence/42 oauth 기반 로그인 구현 방법.md</guid><pubDate>Mon, 20 Jan 2025 11:15:34 GMT</pubDate></item><item><title><![CDATA[참고할만한 것들]]></title><description><![CDATA[<a class="tag" href="?query=tag:42Seoul" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#42Seoul</a> <a class="tag" href="?query=tag:ft_transcendence" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#ft_transcendence</a> 
 <br><br><a href=".?query=tag:42Seoul" class="tag" target="_blank" rel="noopener nofollow">#42Seoul</a> <a href=".?query=tag:ft_transcendence" class="tag" target="_blank" rel="noopener nofollow">#ft_transcendence</a><br><br><br><br>Start-Process "C:\Program Files\Google\Chrome\Application\chrome.exe" -- "--disable-web-security --user-data-dir=C:\chrome_dev"<br><br>&lt;script src="https://cdn.jsdelivr.net/npm/qrcode@1.4.4/build/qrcode.min.js"&gt;&lt;/script&gt;<br><br>
QRCode.toCanvas(qrcodeUrl, { width:256 } , function (error, canvas) {
        if (error) {
          console.error(error);
        }
        else {
          target.appendChild(canvas); // qr code가 담겨있는 캔버스를 원하는 대상에 추가시킨다.
        }
      });

<br><br><br>
document.cookie.split(";").forEach((value) =&gt; {
      let property = value.trim();
      if (property.startsWith(accessTokenString))
        tokens.accessToken = property.substring(accessTokenString.length);
      if (property.startsWith(refreshTokenString))
        tokens.refreshToken = property.substring(refreshTokenString.length);
    });

<br>
<br>쿠키를 ;로 쪼갠다.
<br>앞뒤에 있는 whitespace를 날린다.
<br>propertyName=value 꼴로 되어 있는 각 문자열 중 원하는 프로퍼티를  찾아 propertyName= 부분만 제거한다.
<br><br>
document.cookie = `${accessTokenString}${access_token};`;
document.cookie = `${refreshTokenString}${refresh_token};`;

<br>document.cookie = propertyName=value; 형식으로 저장하면 된다. 이미 쿠키에 저장된 내용이 있는 경우 기존의 내용이 지워지진 않는다. 마치 객체에 새로운 내용을 동적할당하는 것처럼 동작한다.<br>쿠키의 내용을 수정할 때도 마찬가지로 document.cookie = propertyName=newValue; 같이 사용한다.<br><br>강제로 쿠키의 유효기간을 만료시켜 제거한다.<br>
static clearCookie() {
    document.cookie =
      accessTokenString + "; expires=Thu, 01 Jan 1970 00:00:01 GMT;";
    document.cookie =
      refreshTokenString + "; expires=Thu, 01 Jan 1970 00:00:01 GMT;";
  }

<br><br><a data-tooltip-position="top" aria-label="https://ko.javascript.info/websocket" rel="noopener nofollow" class="external-link" href="https://ko.javascript.info/websocket" target="_blank">자바스크립트 튜토리얼 ko</a><br>
<a data-tooltip-position="top" aria-label="https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API" rel="noopener nofollow" class="external-link" href="https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API" target="_blank">모질라</a>]]></description><link>project\42seoul\ft_transcendence\참고할만한-것들.html</link><guid isPermaLink="false">project/42Seoul/ft_transcendence/참고할만한 것들.md</guid><pubDate>Mon, 27 Jan 2025 08:35:01 GMT</pubDate></item><item><title><![CDATA[낙서장]]></title><description><![CDATA[<a class="tag" href="?query=tag:inception" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#inception</a> <a class="tag" href="?query=tag:memo" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#memo</a> 
 <br><br><a href=".?query=tag:inception" class="tag" target="_blank" rel="noopener nofollow">#inception</a> <a href=".?query=tag:memo" class="tag" target="_blank" rel="noopener nofollow">#memo</a><br>중요하지만 세세하기에 적기에는 너무 피말리는 것<br><br><br>nginx.conf 파일에 외부의 환경변수를 적용시키려면 envsubst를 사용해야 한다.<br>envsubst "\$&lt;변수명&gt;" &lt; &lt;환경변수를 적용하기를 원하는 파일&gt; &gt; 결과 파일<br>결과 파일은 별도로 생성되므로 입력 파일의 이름은 target.before이나 target.template 등의 형태로 만드는 것이 좋다.<br>주의 : 이 명령어는 이미지 빌드 타임에는 환경 변수를 제대로 읽지 못한다. 따라서 반드시 Dockerfile의 RUN이 아니라 ENTRYPOINT로 넘겨서 실행시켜야 한다.<br><a data-tooltip-position="top" aria-label="https://gukjan9.tistory.com/134" rel="noopener nofollow" class="external-link" href="https://gukjan9.tistory.com/134" target="_blank">envsubst 자료 출처</a><br><a data-tooltip-position="top" aria-label="https://make.wordpress.org/cli/handbook/guides/quick-start/" rel="noopener nofollow" class="external-link" href="https://make.wordpress.org/cli/handbook/guides/quick-start/" target="_blank">wp cli</a><br><br><br><a data-tooltip-position="top" aria-label="https://ko.wordpress.org/plugins/redis-cache/" rel="noopener nofollow" class="external-link" href="https://ko.wordpress.org/plugins/redis-cache/" target="_blank">redis cache란?</a> = Redis로 구동되는 영구 객체 캐시 <br><br><a data-tooltip-position="top" aria-label="https://hoing.io/archives/53699" rel="noopener nofollow" class="external-link" href="https://hoing.io/archives/53699" target="_blank">참고 링크</a><br>systemctl을 쓰지 않고 redis-server를 백그라운드로 실행하는 법 -&gt;<br>
redis-server --daemonize yes<br>php-predis 설치 -&gt;<br>
apt install php-predis<br>wordpress의 redis object cache 플러그인 설치(주의!!! redis-object-cache가 아닌 redis-cache를 설치해야 함(Tlqkf))<br>
wp plugin install --allow-root redis-cache]]></description><link>project\42seoul\inception\낙서장.html</link><guid isPermaLink="false">project/42Seoul/inception/낙서장.md</guid><pubDate>Sat, 22 Mar 2025 07:43:56 GMT</pubDate></item><item><title><![CDATA[마이크로서비스]]></title><description><![CDATA[ 
 <br><br>microservice<br><br>마이크로서비스 아키텍처는 하나의 애플리케이션 내에 있는 각 핵심 기능이 독립적으로 존재할 수 있도록 소프트웨어를 구축하는 클라우드 네이티브 접근 방식이다.<br><br>애플리케이션 빌드의 전통적인 방식은 모눌리식 위주이다. 모눌리식 아키텍처에서는 애플리케이션 내의 모든 기능과 서비스가 함께 맞물려 단일 유닛으로 운영된다. 애플리케이션이 어떤 방식으로든 추가되면 아키텍처는 더 복잡해진다. 그 결과 전체 애플리케이션을 분리하지 않고는 애플리케이션 내의 단일 기능을 최적화하기가 더 어려워지고, 만약 애플리케이션 내의 하나의 프로세스가 확장되어야 할 때는 전체 애플리케이션도 확장되어야 한다.<br>마이크로서비스 아키텍처에서 애플리케이션은 애플리케이션 내의 각 핵심 기능이 독립적으로 작동하도록 빌드된다. 따라서 개발 팀은 애플리케이션 전체를 중단하지 않고 변화하는 비즈니스 요구 사항을 충족하기 위한 새로운 구성 요소를 구축하고 업데이트할 수 있다.<br><br>마이크로서비스는 분산형 개발을 통해 팀의 역량과 일상적인 업무 능력을 향상시킨다. 또한, 여러 마이크로서비스를 동시에 개발하는 것도 가능하다. 따라서 동일한 애플리케이션 개발에 더 많은 개발자들이 동시 참여할 수 있으므로 개발에 소요되는 시간을 단축할 수 있다.<br><br>더 자세한 정보를 원한다면 아래로<br><a data-tooltip-position="top" aria-label="https://www.redhat.com/ko/topics/microservices/what-are-microservices" rel="noopener nofollow" class="external-link" href="https://www.redhat.com/ko/topics/microservices/what-are-microservices" target="_blank">redhat 홈페이지</a><br>]]></description><link>project\42seoul\inception\마이크로서비스.html</link><guid isPermaLink="false">project/42Seoul/inception/마이크로서비스.md</guid><pubDate>Sat, 22 Mar 2025 07:43:56 GMT</pubDate></item><item><title><![CDATA[캐시]]></title><description><![CDATA[<a class="tag" href="?query=tag:computer_science" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#computer_science</a> 
 <br><br><a href=".?query=tag:computer_science" class="tag" target="_blank" rel="noopener nofollow">#computer_science</a><br>cache<br><br>캐시는 컴퓨터 과학에서 데이터나 값을 미리 복사해 놓는 임시 장소를 가리킨다. 캐시는 캐시의 접근 시간에 비해 미가공 데이터 또는 1차 데이터(raw data or primary data)에 접근하는 시간이 오래 걸리는 경우나 값을 다시 계산하는 시간을 절약하고 싶은 경우에 사용한다. 캐시에 데이터를 미리 복사해 놓으면 계산이나 접근 시간 없이 더 빠른 속도로 데이터에 접근할 수 있다.<br>캐시는 시스템의 효율성을 위해 다음과 같은 여러 분야에서 두루 쓰이고 있다.<br>
<br>CPU 캐시
<br>디스크 캐시
<br>기타 캐시
<br><br>CPU 캐시는 하드웨어를 통해 관리되고, 그 밖에 다른 캐시들은 대개 소프트웨어적으로 관리된다. 운영 체제의 메인 메모리를 하드 디스크에 복사해 놓는 페이퍼 캐시는 운영 체제 커널과 파일 시스템을 통해 관리된다. BIND DNS 데몬은 도메인 이름과 IP 주소 사이의 매핑을 저장해 둔다.<br>신뢰성이 적은 네트워크(이더넷 등)에서, 네트워크 사이에 주고 받는 데이터를 캐시해 놓는 것은 매우 흔한 일이다. 이를테면, 웹 브라우저는 최근 방문한 사이트를 캐시에 저장해 놓는다. 많은 인터넷 제공업체들과 대규모 네트워크의 운영자들은 인기 있는 웹 페이지의 캐시를 프록시 서버에 저장하여 웹 페이지 요청에 응답하게 함으로써 네트워크 대역폭을 아낀다.<br>구글 검색 엔진은 검색 대상 사이트들의 내용을 캐시에 저장해 검색 엔진에 사용하기도 하고, 검색 결과의 일부로서 사용자들에게 보여 주기도 한다.<br><br>캐시가 효율적으로 동작하려면, 캐시에 저장할 데이터가 지역성을 가져야 한다. 지역성이란 데이터 접근이 시간적, 혹은 공간적으로 가깝게 일어나는 것을 의미한다.<br><br>특정 데이터가 한번 접근되었을 경우, 가까운 미래에 또 한번 데이터에 접근할 가능성이 높은 것을 시간적 지역성이라고 한다.<br>메모리 상의 같은 주소에 여러 차례 읽기 쓰기를 수행할 경우 상대적으로 작은 크기의 캐시를 사용해도 효율성을 꾀할 수 있다.<br><br>특정 데이터와 가까운 주소가 순서대로 접근되었을 경우를 공간적 지역서이라고 한다. CPU 캐시나 디스크 캐시의 경우 한 메모리 주소에 접근할 때 그 주소뿐 아니라 해당 블록을 전부 캐시에 가져오게 된다. 이때 메모리 주소를 오름차순이나 내림차순으로 접근한다면, 캐시에 이미 저장된 같은 블록의 데이터를 접근하게 되므로 캐시의 효율성이 크게 향상된다.<br><br>참고자료<br><br>]]></description><link>project\42seoul\inception\캐시.html</link><guid isPermaLink="false">project/42Seoul/inception/캐시.md</guid><pubDate>Sat, 22 Mar 2025 07:43:56 GMT</pubDate></item><item><title><![CDATA[NGINX]]></title><description><![CDATA[<a class="tag" href="?query=tag:web" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#web</a> <a class="tag" href="?query=tag:server/web_server" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#server/web_server</a> <a class="tag" href="?query=tag:uncomplete" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#uncomplete</a> <a class="tag" href="?query=tag:참고링크/nginx_org" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고링크/nginx_org</a> 
 <br><br><a href=".?query=tag:web" class="tag" target="_blank" rel="noopener nofollow">#web</a> <a href=".?query=tag:server\web_server" class="tag" target="_blank" rel="noopener nofollow">#server/web_server</a> <a href=".?query=tag:uncomplete" class="tag" target="_blank" rel="noopener nofollow">#uncomplete</a><br>engine x<br><br>본 문서는 미완성 문서입니다.<br>본 문서는 필요에 따라 <a data-tooltip-position="top" aria-label="https://nginx.org/" rel="noopener nofollow" class="external-link" href="https://nginx.org/" target="_blank">nginx 공식 문서</a>의 일부분만을 정리한 것입니다.<br>
누락한 부분은 누락과 같이 표시됩니다.<br>
누락한 부분은 차후 보충될 수도, 그렇지 않을 수도 있습니다.<br><br>nginx는 다음의 기능을 수행할 수 있는 프로그램이다.<br>
<br>http 웹 서버
<br>리버스 프록시
<br>콘텐츠 캐시
<br>로드 밸런서
<br>tcp/udp 프록시 서버
<br>메일 프록시 서버
<br>nginx는 하나의 master 프로세스와 여러 개의 worker 프로세스로 수행된다.<br>master 프로세스는 config 파일을 읽고 분석하며, worker 프로세스를 유지 및 관리한다.<br>
worker 프로세스는 요청을 처리하는 작업을 담당한다.<br>nginx는 event-based 모델을 사용하며 운영체제(아마도 리눅스)에 의존적이다. 이는 worker 프로세스들에게 작업을 효율적으로 분배하기 위해서이다. worker 프로세스의 개수는 configuration 파일에서 정의되며 현재 가용한 cpu 코어 수에 따라 조정될 수 있다.<br>nginx가 동작하는 방식은 configuration 파일에 의해 정의된다. 일반적으로 configuration 파일은 nginx.conf라는 이름을 가지며 다음의 디렉토리 중 하나에 위치한다.<br>
<br>/usr/local/nginx/conf
<br>/etc/nginx
<br>/usr/local/etc/nginx
<br><br><a data-tooltip-position="top" aria-label="https://nginx.org/en/docs/install.html" rel="noopener nofollow" class="external-link" href="https://nginx.org/en/docs/install.html" target="_blank">nginx 공식 문서</a> 참조<br><br><br>nginx를 시작하기 위해선 실행파일을 동작시킨다.<br>동작 중인 nginx를 제어하기 위해서는 -s 매개변수를 사용하여 응용 프로그램을 동작시킨다.<br>
다음의 문법을 따른다.<br>nginx -s &lt;signal&gt;<br>signal 위치에는 다음의 인자들이 위치할 수 있다.<br>
<br>stop : 빠른 강제 종료
<br>quit : 우아한(graceful) 종료
<br>reload : configuration file을 reload함
<br>reopen : log 파일을 다시 염
<br>예를 들어, 현재 요청을 처리하기 위해 동작 중인 worker 프로세스들을 정지하기 위해서는 아래의 커맨드를 동작한다.<br>nginx -s quit<br>
이 커맨드는 nginx를 실행시킨 유저와 동일한 유저에 의하여 호출되어야 한다.
<br>configuration 파일이 수정되어도 그것이 reload 되거나 nginx가 다시 시작하기 전까지는 수정사항이 반영되지 않는다. configuration 파일을 reload 하려면 아래의 커맨드를 동작시킨다.<br>nginx -s reload<br>master 프로세스는 reload configuration 신호를 받으면, 수정된 configuration 파일의 유효성을 확인하고 변경사항을 적용한다.<br>이 작업이 성공한다면, master 프로세스는 새로운 worker 프로세스를 생성하고 기존에 존재하던 worker 프로세스에게는 종료 명령을 보낸다.<br>이 작업이 실패한다면, master 프로세스는 변경 사항을 롤백하고 기존 configuration 파일에 따라 작업을 계속한다.<br>종료 명령을 받은 worker 프로세스는 새로운 요청을 받는 것을 중단한 후, 제공하고 있던 요청(=서비스)를 마저 제공한다. 그런 후 exit 한다.<br>unix의 kill 유틸리티를 이용하여 신호를 보낼 수도 있다. 이 경우 신호를 보내고자 하는 프로세스의 id를 알아야 한다. nginx master 프로세스의 id는 일반적으로 /usr/local/nginx/logs/nginx.pid에 저장되어 있다.<br>
아래와 같은 명령어를 사용한다.<br>kill -s QUIT &lt;nginx master process id&gt;<br>ps 명령을 통해 현재 동작 중인 nginx 프로세스들의 목록을 가져올 수도 있다.<br>ps -ax | grep nginx<br><br>nginx는 configuration 파일에 열거된 지침(directives)을 따른다. 지시 사항은 단순한 지침(simple directives)와 블록 지침(block directives)로 나뉜다.<br>단순한 지침은 아래와 같은 형식을 취한다.<br>name parameter;<br>블록 지침은 다른 여러 개의 지침들을 {, }로 둘러싸는 형태로 보유할 수 있으며, 이를 context(문맥)라고 부른다(예 : events, http, server, location).<br>http {
	server {
	}
}
<br>configuration 파일에 있는 모든 지침들은 어디에 위치해있던지 main context에 존재하는 것으로 간주한다(오역의 가능성 있음).<br># 기호 뒤에 오는 문장은 주석으로 간주한다.<br><br>웹 서버의 주요 업무는 이미지나 정적 html 페이지 같은 파일을 제공하는 것이다.<br>html 파일은 보통 /data/www 디렉토리에 위치해 있고<br>
이미지 파일은 보통 /data/images에 위치해 있다.<br>http 블록 내부의 server 블록에 두 개의 location 블록을 설정함으로서 이를 설정할 수 있다.<br>
아래와 같은 절차를 통해 예제를 진행해보자.<br>
<br>
/data/www 디렉토리를 만든 후 그 안에 index.html을 위치시킨다. index.html에는 어떠한 내용이 있어도 괜찮다.

<br>
/data/image 디렉토리를 만든 후 그 안에 아무 이미지나 넣는다.

<br>
configuration 파일을 연다. 파일 안에는 이미 여러 개의 server 블록이 있을 것이고 그 중에서는 주석 처리가 된 것도, 그렇지 않은 것도 있을 것이다. 주석 처리되지 않은 모든 server 블록을 주석처리하고 아래와 같이 새로운 server 블록을 만든다.
http {
	server {
	}
}


<br>
일반적으로 configuration 파일 내부에는 수신하고 있는 포트 번호, 그리고 서버의 이름에 따라 여러 개의 server 블록이 있다. nginx는 요청의 헤더 부분에 있는 URI를 분석하여 server 블록 내부의 location 지침에 있는 인자와 대조함으로서 어느 서버가 요청을 수행할지를 결정한다.
<br>
<br>
다음의 location 블록을 server 블록에 더한다.
location / {
	root /data/www;
}

location /images/ {
	root /data;
}


<br>
URI의 경로는 root 지침의 인자와 location 지침의 인자를 조합한 결과물과 대조된다. /data/images 블록을 보면 경로가 역순으로 되어 있는데(하위 디렉토리인 /images/ 가 상단에 있고 상위 디렉토리인 /data/가 하단에 있음) 이는 탐색의 효율성을 위해서이다.<br>
예를 들어 /data/www와 /data/images를 구별하는 것은 상위 디렉토리인 /data가 아니라 하위 디렉토리인 /www와 /images이다. 따라서 둘 중 /data/www를 탐색하는 경우 상위 디렉토리 -&gt; 하위 디렉토리 순으로 검색하는 것보다 하위 디렉토리 -&gt; 상위 디렉토리 순으로 검색하는 것이 빠를 것이다.<br>
따라서 configuration 파일에서는 하위 디렉토리를 location 지침의 인자로, 상위 디렉토리를 root 지침의 인자로 전달한다.<br>
참고로 configuration 파일은 인자의 길이가 긴 location 블록을 우선적으로 탐색한다.
<br>위 과정이 완료되면 위 설정 파일은 80 포트(nginx의 기본 포트이다)로 웹 서비스를 제공하라는 의미를 가지게 된다.<br>http://localhost/ 뒤에 /images/가 붙으면 /data/images/의 파일을 제공하게 된다.<br>
<br>ex. http://localhost/images/example.png 주소는 /data/images/example.png를 제공하라는 뜻
<br>/images/ 외의 다른 경로는 /data/www/의 파일을 제공하게 된다.<br>
<br>ex. http://localhost/images/some/example.html은 /data/www/some/example.html을 제공하라는 뜻
<br>
예상대로 작업이 수행되지 않는다면 access.log와 error.log 파일에 이유가 기록되어 있을 수 있다. 두 파일은 보통 /usr/local/nginx/logs나 /var/log/nginx에 위치해 있다.
<br><br>nginx의 주된 기능 중 하나는 프록시 서버를 구축하는 것이다. 프록시 서버란 클라이언트부터 요청을 받아 또다른 서버(보통 proxied 서버라 칭한다.)에게 그 요청을 전달해주는, 일종의 중개 역할을 하는 서버를 칭한다.<br>다음의 예제를 진행하여 단순한 프록시 서버를 만들어보자. 우리가 만들 프록시 서버는 이미지 파일 요청은 로컬 디렉토리에 있는 파일을 제공하고, 다른 요청은 proxied 서버로 전달해주는 기능을 한다.<br><a data-tooltip-position="top" aria-label="NGINX > ^0bc08f" data-href="NGINX#^0bc08f" href="project\42seoul\inception\nginx.html#^0bc08f" class="internal-link" target="_self" rel="noopener nofollow">정적 컨텐츠 제공하기</a>에서 만든 configuration 파일에 아래와 같은 서버 블록을 추가한다.<br>server {
	listen 8080;
	root /data/upl;

	location / {
	}
}
<br>
listen 지침은 해당 서버가 어느 포트를 사용해서 수신할 지를 명시한다. 만약 listen이 server 블록 내에 정의되지 않았다면, 기본 포트인 80포트를 사용하여 수신한다.
location / {}와 같이 location 지침 내부에 아무것도 지정이 안 되어 있을 경우, root /data/upl;와 같이 서버 블록이 독자적으로 root 지침을 보유한다.
<br>이제 본격적으로 proxy 서버 설정을 하는 부분을 configuration 파일에 추가해보자.<br>
<a data-tooltip-position="top" aria-label="NGINX > ^0bc08f" data-href="NGINX#^0bc08f" href="project\42seoul\inception\nginx.html#^0bc08f" class="internal-link" target="_self" rel="noopener nofollow">정적 컨텐츠 제공하기</a>에서 만들었던 server 블록을 아래와 같이 수정한다.<br>server {
	location / {
		proxy_pass http://localhost:8080;
	}

	location /images/ {
		root /data;
	}
}
<br>
proxy_pass 지침은 클라이언트의 요청을 전달할 proxied 서버의 server name과 포트 번호를 기재한다. 위 configuration 파일의 경우, http://localhost:8080이다.
<br>아까의 블록에서 location /images/ 블록을 아래와 같이 수정한다.<br>location ~ \.(gif|jpg|png)$ {
	root /data/images;
}
<br>
위 블록은 파일 중 gif, jpg, png 확장자를 가지는 파일만을 로컬의 /data/images 디렉토리로 매핑하겠다는 정규 표현식이다. 이러한 형태의 표현식은 반드시 ~기호로 시작해야 한다.<br>
nginx가 요청을 처리하기 위해 location 블록을 선택할 때, 먼저 접두사를 지정한 location 지시어를 확인하여 가장 긴 접두사를 기억하고, 그 다음에 정규 표현식을 확인한다. 정규 표현식이 일치하는 경우 nginx는 해당 location을 선택하고, 그렇지 않으면 이전에 기억된 location을 선택한다.
<br>server {
	location / {
		proxy_pass http://localhost:8080;
	}

	location ~ \.(gif/jpg/png)$ {
		root /data/images;
	}
}
<br>
즉 위 server 블록에서 요청을 처리하기 위한 location 블록을 선택할 때, gif, jpg, pnd 형식의 파일은 모두 로컬의 /data/images/ 디렉토리로 매핑되고, 그 외 요청은 localhost:8080 서버로 넘어간다.
<br><br>nginx는 FastCGI 서버로 통하는 경로를 요청하는 데 사용될 수도 있다. FastCGI 서버란 다양한 프레임워크와 프로그래밍 언어로 짜여진 응용 프로그램을 실행시켜 주는 서버이다.<br>FastCGI 서버로의 매핑을 요청하려면 fastcgi_pass 지침에 server_name:port의 형태로 인자를 전달해야 한다.<br>
PHP에서는 스크립트의 이름을 정의하기 위해 SCRIPT_FILENAME 인자가 필요하고, 요청 인자를 전달하기 위해 QUERY_STRING 인자가 필요하다.<br>결과적으로 다음과 같은 블록을 사용한다. <a data-tooltip-position="top" aria-label="NGINX > ^7fc5ba" data-href="NGINX#^7fc5ba" href="project\42seoul\inception\nginx.html#^7fc5ba" class="internal-link" target="_self" rel="noopener nofollow">간단한 프록시 서버 구축하기</a>에서 만든 configuration 파일에 다음 블록을 추가하여 보자.<br>server {
	listen 90;
    location / {
        fastcgi_pass  localhost:9000;
        fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;
        fastcgi_param QUERY_STRING    $query_string;
    }
}
<br>
위의 서버 블록은 90 포트로 들어오는 모든 요청을  localhost:9000에 위치한 FastCGI 서버로 전달해주는 역할을 한다.
<br><br>참고자료<br><a href=".?query=tag:참고링크\nginx_org" class="tag" target="_blank" rel="noopener nofollow">#참고링크/nginx_org</a> <br>]]></description><link>project\42seoul\inception\nginx.html</link><guid isPermaLink="false">project/42Seoul/inception/NGINX.md</guid><pubDate>Sat, 22 Mar 2025 07:43:56 GMT</pubDate></item><item><title><![CDATA[No title]]></title><description><![CDATA[<a class="tag" href="?query=tag:참고링크/php-fpm_org" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고링크/php-fpm_org</a> 
 <br><br><br>php fastcgi process manager<br><br>php-fpm은 다음의 특징을 가진 FastCGI(fast common gateway interface) 솔루션이다.<br>
<br>적응형 프로세스 생성
<br>기본 통계(아파치의 mod_status와 유사)
<br>우아한 종료/시작을 지원하는 향상된 프로세스 관리
<br>다른 uid/gid/chroot/environment 및 다른 php.ini로 작업자를 시작할 수 있는 기능(safe_mode를 대체)
<br>Stdout 및 stderr 로깅
<br>실수로 opcode 캐시가 파괴된 경우 긴급 재시작
<br>가속 업로드 지원
<br>"slowlog" 지원
<br>FastCGI에 추가된 fastcgi_finish_request() 기능은 시간이 많이 걸리는 작업(비디오 변환, 통계 처리 등)을 계속 진행하면서 요청을 완료하고 모든 데이터를 플러시하는 특수 기능입니다.
<br><br><a data-tooltip-position="top" aria-label="https://ko.wikipedia.org/wiki/%EA%B3%B5%EC%9A%A9_%EA%B2%8C%EC%9D%B4%ED%8A%B8%EC%9B%A8%EC%9D%B4_%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4" rel="noopener nofollow" class="external-link" href="https://ko.wikipedia.org/wiki/%EA%B3%B5%EC%9A%A9_%EA%B2%8C%EC%9D%B4%ED%8A%B8%EC%9B%A8%EC%9D%B4_%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4" target="_blank">위키백과</a><br>
<a data-tooltip-position="top" aria-label="https://www.ibm.com/docs/ko/i/7.5?topic=functionality-cgi" rel="noopener nofollow" class="external-link" href="https://www.ibm.com/docs/ko/i/7.5?topic=functionality-cgi" target="_blank">IBM 홈페이지</a><br><br>fastCGI는 Fast Common gate interface의 약자이다.<br><a data-tooltip-position="top" aria-label="https://ko.wikipedia.org/wiki/FastCGI" rel="noopener nofollow" class="external-link" href="https://ko.wikipedia.org/wiki/FastCGI" target="_blank">위키백과</a><br><br>참고자료<br><a href=".?query=tag:참고링크\php-fpm_org" class="tag" target="_blank" rel="noopener nofollow">#참고링크/php-fpm_org</a> <br>]]></description><link>project\42seoul\inception\php-fpm.html</link><guid isPermaLink="false">project/42Seoul/inception/php-fpm.md</guid><pubDate>Sat, 22 Mar 2025 07:43:56 GMT</pubDate></item><item><title><![CDATA[tls]]></title><description><![CDATA[ 
 <br><a data-tooltip-position="top" aria-label="https://www.cloudflare.com/ko-kr/learning/ssl/transport-layer-security-tls/" rel="noopener nofollow" class="external-link" href="https://www.cloudflare.com/ko-kr/learning/ssl/transport-layer-security-tls/" target="_blank">참고 링크</a>]]></description><link>project\42seoul\inception\tls.html</link><guid isPermaLink="false">project/42Seoul/inception/tls.md</guid><pubDate>Sat, 22 Mar 2025 07:43:56 GMT</pubDate></item><item><title><![CDATA[microshell 문제 번역]]></title><description><![CDATA[<a class="tag" href="?query=tag:42Seoul" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#42Seoul</a> 
 <br><br><a href=".?query=tag:42Seoul" class="tag" target="_blank" rel="noopener nofollow">#42Seoul</a> <br><br>Assignment name&nbsp; : microshell<br>
Expected files &nbsp; : microshell.c<br>
Allowed functions: malloc, free, write, close, fork, waitpid, signal, kill, exit, chdir, execve, dup, dup2, pipe, strcmp, strncmp<br>과제 이름 : microshell<br>
제출 파일 : microshell.c<br>
허용 함수 : malloc, free, write, close, fork, waitpid, signal, kill, exit, chdir, execve, dup, dup2, pipe, strcmp, strncmp<br>Write a program that will behave like executing a shell command<br>쉘 커맨드를 실행시키는 역할을 하는 프로그램을 작성하시오.<br>
<br>The command line to execute will be the arguments of this program
<br>실행시킬 명령문이 곧 프로그램의 매개인자입니다.<br>
<br>Executable's path will be absolute or relative but your program must not build a path (from the PATH variable for example)
<br>프로그램은 절대 경로와 상대 경로 둘 다 실행 가능하지만 경로를 직접 빌드해선 안됩니다(예를 들어, ls를 입력받았을때 PATH 변수와 조합해서 /bin/ls로 파싱하는 것과 같은 작업을 하지 말라는 뜻).<br>
<br>You must implement "|" and ";" like in bash
<br>당신은 파이프("|")와 세미콜론(";")을 bash 에서와 같이 동작하도록 구현하여야 합니다.<br>
<br>we will never try a "|" immediately followed or preceded by nothing or "|" or ";"
<br>우리는 파이프("|")의 앞과 뒤에 아무것도 없는 경우, 또는 파이프가 위치한 경우, 또는 세미콜론(";")이 위치한 경우를 시험하지 않습니다(syntax error 검사하지 않겠다는 뜻).<br>
<br>Your program must implement the built-in command cd only with a path as argument (no '-' or without parameters)
<br>당신은 빌트 인 커맨드로 cd를 구현해야 합니다. 단, 매개인자가 입력되지 않는 경우는 고려하지 않습니다.<br>
<br>if cd has the wrong number of argument your program should print in STDERR "error: cd: bad arguments" followed by a '\n'
<br>만약에 cd가 잘못된 개수의 매개인자를 받으면 당신의 프로그램은 STDERR로 "error: cd: bad arguments"에 개행을 붙힌 문자열을 출력해야 합니다.<br>
<br>if cd failed your program should print in STDERR "error: cd: cannot change directory to path_to_change" followed by a '\n' with path_to_change replaced by the argument to cd
<br>만약 cd에 잘못된 경로명을 입력하여 프로그램이 실패할 경우 STDERR로 "error: cd: cannot change directory to path_to_change"에 개행을 붙힌 문자열을 출력해야 합니다(path_to change는 cd가 입력받은 경로명으로 대체)<br>
<br>a cd command will never be immediately followed or preceded by a "|"
<br>cd 커맨드는 파이프라인과 같이 사용될 수 없습니다.<br>
<br>You don't need to manage any type of wildcards (*, ~ etc...)
<br>당신은 와일드카드(*, ~ 등등)을 구현할 필요가 없습니다.<br>
<br>You don't need to manage environment variables ($BLA ...)
<br>당신은 환경변수($BLA ... 등등)와 관련된 기능을 구현할 필요가 없습니다.<br>
<br>If a system call, except execve and chdir, returns an error your program should immediatly print "error: fatal" in STDERR followed by a '\n' and the program should exit
<br>execve와 chdir을 제외한 시스템 콜이 에러를 반환하면 프로그램은 즉시 STDERR로 "error: fatal"에 개행을 붙인 문자열을 출력하고 exit하여야 합니다.<br>
<br>If execve failed you should print "error: cannot execute executable_that_failed" in STDERR followed by a '\n' with executable_that_failed replaced with the path of the failed executable (It should be the first argument of execve)
<br>만약 execve가 fail한다면 STDERR로 "error: cannot execute executable_that_failed"에 개행을 붙힌 문자열을 출력해야 합니다(executable_that_failed는 execve가 입력받은 첫번째 매개인자로 대체해야 함).<br>
<br>Your program should be able to manage more than hundreds of "|" even if we limit the number of "open files" to less than 30.  
<br>프로그램은 백 단위의 파이프("|")와 30개 이하의 열린 파일들을 처리할 수 있어야 합니다.<br>for example this should work:<br>예를 들어 아래와 같은 명령문이 동작해야 합니다.<br>$&gt;./microshell /bin/ls "|" /usr/bin/grep microshell ";" /bin/echo i love my microshell<br>microshell<br>i love my microshell<br>$&gt;<br>Hints:<br>
Don't forget to pass the environment variable to execve<br>execve에 환경변수를 전달하는 것을 잊지 마세요.<br>Hints:<br>
Do not leak file descriptors!<br>fd의 누수는 허용하지 않습니다(파이프 잘 닫고 열린 파일 잘 닫으라는 뜻).]]></description><link>project\42seoul\microshell\microshell-문제-번역.html</link><guid isPermaLink="false">project/42Seoul/microshell/microshell 문제 번역.md</guid><pubDate>Sat, 22 Mar 2025 07:43:58 GMT</pubDate></item><item><title><![CDATA[mini_serv 억까 방지용 시트]]></title><description><![CDATA[<a class="tag" href="?query=tag:42Seoul" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#42Seoul</a> <a class="tag" href="?query=tag:network" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#network</a> <a class="tag" href="?query=tag:server" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#server</a> <a class="tag" href="?query=tag:socket_programming" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#socket_programming</a> 
 <br><br><a href=".?query=tag:42Seoul" class="tag" target="_blank" rel="noopener nofollow">#42Seoul</a> <a href=".?query=tag:network" class="tag" target="_blank" rel="noopener nofollow">#network</a> <a href=".?query=tag:server" class="tag" target="_blank" rel="noopener nofollow">#server</a> <a href=".?query=tag:socket_programming" class="tag" target="_blank" rel="noopener nofollow">#socket_programming</a> <br>micro_serv<br><br>Assignment name  : mini_serv<br>
과제 이름 : mini_serv<br>Expected files   : mini_serv.c<br>
제출할 파일 : mini_serv.c<br>Allowed functions: write, close, select, socket, accept, listen, send, recv, bind, strstr, malloc, realloc, free, calloc, bzero, atoi, sprintf, strlen, exit, strcpy, strcat, memset<br>
허용 함수는 위와 같습니다.<br><br>Write a program that will listen for client to connect on a certain port on 127.0.0.1 and will let clients to speak with each other.<br>
클라이언트들로 하여금 127.0.0.1 주소의 특정한 포트로 연결하여 서로 소통할 수 있게끔하는 프로그램을 만드세요.<br>This program will take as first argument the port to bind to.<br>
이 프로그램은 첫 번째 인자로 bind에 사용할 포트를 받습니다.<br>If no argument is given, it should write in stderr "Wrong number of arguments" followed by a \n and exit with status 1.<br>
만약에 아무런 인자도 주어지지 않는다면, 표준 에러로 "Wrong number of arguments"에 개행(\n)을 붙여 출력하고 exit status 1로 종료되어야 합니다.<br>If a System Calls returns an error before the program start accepting connection, it should write in stderr "Fatal error" followed by a \n and exit with status 1.<br>
만약에 시스템 콜이 연결이 완료되기 전에(accepting connection) 오류를 반환한다면, 표준 에러로 "Fatal error"에 개행(\n)을 붙여 출력하고 exit status 1로 종료되어야 합니다.<br>If you can't allocate memory it should write in stderr "Fatal error" followed by a \n and exit with status 1<br>
만약에 당신이 메모리를 할당할 수 없다면 표준 오류로 "Fatal error"에 개행(\n)을 붙여 출력하고 exit status 1로 종료되어야 합니다.<br>Your program must be non-blocking but client can be lazy and if they don't read your message you must NOT disconnect them...<br>
당신의 프로그램은 non-block으로 실행되어야 합니다. 하지만 클라이언트는 게으를 수 있으니 그들이 당신의 메시지를 읽지 않는다고 해서 연결을 끊어서는 안됩니다.<br>Your program must not contains #define preproc<br>
당신의 프로그램은 #define preproc을 포함해선 안됩니다.<br>Your program must only listen to 127.0.0.1.<br>
당신의 프로그램은 오직 127.0.0.1 주소로만 수신해야 합니다.<br>The fd that you will receive will already be set to make 'recv' or 'send' to block if select hasn't be called before calling them, but will not block otherwise.<br>
당신에게 주어지는 파일 디스크립터(fd)는 recv 또는 send를 위해 쓰일 것이고, select를 앞선 함수들을 호출하기 전에 호출하면 block을 방지할 수 있습니다.<br>
<br>
When a client connect to the server:<br>
<br>the client will be given an id. the first client will receive the id 0 and each new client will received the last client id + 1
<br>%d will be replace by this number
<br>a message is sent to all the client that was connected to the server: "server: client %d just arrived\n"<br>
클라이언트가 서버에 연결할 때:
<br>클라이언트는 id를 부여받습니다. 첫번째 클라이언트는 id 0을 부여받고 새로운 클라이언트는 그 직전 클라이언트의 id + 1을 id로 부여받습니다.
<br>%d는 이 id로 대체되어야 합니다.
<br>서버에 접속해 있던 모든 클라이언트에게 다음의 메세지를 보냅니다: "server: client %d just arrived\n"
<br>clients must be able to send messages to your program.<br>
<br>message will only be printable characters, no need to check
<br>a single message can contains multiple \n
<br>when the server receive a message, it must resend it to all the other client with "client %d: " before every line!
<br>클라이언트는 당신의 프로그램에 메시지를 전송할 수 있어야 합니다.<br>
<br>메시지는 출력 가능한(printable) 캐릭터로만 구성되며, 이를 체크할 필요는 없습니다(예외 처리할 필요 없다는 뜻).
<br>하나의 메시지는 여러 개의 개행(\n)을 포함할 수 있습니다.
<br>서버가 메시지를 수신할 때, 다른 모든 클라이언트에게 "client %d: "를 접두사로 붙여 해당 메시지를 broadcast해야 합니다.
<br>When a client disconnect from the server:<br>
<br>a message is sent to all the client that was connected to the server: "server: client %d just left\n"
<br>클라이언트가 서버와의 연결을 끊을 때:<br>
<br>서버에 연결되어 있는 모든 클라이언트에게 다음의 메시지를 보내야 합니다: "server: client %d just left\n"
<br>Memory or fd leaks are forbidden<br>
메모리나 fd의 누수는 용납되지 않습니다.<br>To help you, you will find the file main.c with the beginning of a server and maybe some useful functions. (Beware this file use forbidden functions or write things that must not be there in your final program)<br>
당신을 돕기위해서, 우리는 서버의 기초와 몇몇 유용한 함수를 포함하고 있는 main.c 파일을 준비했습니다(이 파일이 당신의 최종 프로그램에 포함되어서는 안될 금지 함수와 출력을 포함하고 있다는 사실에 유의하세요).<br>Warning our tester is expecting that you send the messages as fast as you can. Don't do un-necessary buffer.<br>
저희의 테스터기는 당신의 프로그램이 가능한 한 빠르게 메시지를 전송할 것을 가정한다는 사실에 유의하세요. 불필요하게 프로그램을 지연시키지 마세요.<br>Evaluation can be a bit longer than usual...<br>
평가는 평소보다 좀 더 오래 걸릴 수 있습니다...<br>Hint: you can use nc to test your program<br>
힌트: 당신은 테스트를 위해서 nc를 사용할 수 있습니다.<br>Hint: you should use nc to test your program<br>
힌트: 당신은 테스트를 위해서 nc를 사용해야만 합니다.<br>Hint: To test you can use fcntl(fd, F_SETFL, O_NONBLOCK) but use select and NEVER check EAGAIN (man 2 send)<br>
힌트: 테스트를 위해서 당신은 fcntl(fd, F_SETFL, O_NONBLOCK)을 사용할 수 있지만 select를 사용하여야 하며 절대 EAGAIN 옵션을 체크해서는 안됩니다.<br><br><br><br>이상이 exam 06 mini_serv의 subject 원본이다. 언뜻 보면 일반적인 echo 서버에 접두사(client : %d)를 붙이는 기능만 추가하면 되는 간단한 과제로 보인다. 하지만 불친절하기 짝이 없는 42 교육 과정의 exam답게 본 시험에는 숨겨진 조건이 존재한다. 사실 tcp의 특성을 알고 있는 사람이라면 다음과 같은 의문이 들 것이다.<br>
<br>tcp 프로토콜은 임의로 자신이 필요하다고 판단할 시(ex. 한 번에 송신하기에는 너무 대량의 데이터일 경우) 패킷을 분할하여 송신한다. 예를 들어 10000 바이트 길이의 데이터를 송신할 시 1000바이트씩 쪼개서 보내지는 것이 가능하다.
<br>데이터를 송신하는 쪽은 당연히 메시지가 온전히 보전되기를 바라고 송신할 것이다. 즉, 접두사(client : %d) 뒤의 데이터는 전송되기 전과 동일하기를 기대할 것이다.
<br>하지만 앞서 설명했듯이 패킷은 tcp 프로토콜에 의하여 임의로 분할될 수 있으므로 용량이 큰 메시지를 보낼 경우 높은 확률로 훼손된다. 분할된 메시지의 앞부분마다 접두사가 끼어들어 버리기 때문이다.
<br>// client 0이 매우 긴 메시지를 보내는 상황이라고 가정하자

보내는 메시지 : vvvveeeerrrryyyy lllloooonnnngggg mmmmssssgggg

// 전송자는 다음과 같이 메시지가 전송되기를 바랄 것이다.

client 0: vvvveeeerrrryyyy lllloooonnnngggg mmmmssssgggg

// 하지만 현실은 다음과 같을 확률이 높다.

client 0: vvvveeeerrrryyyy client 0: lllloooonnnngggg client 0: mmmmssssgggg 

<br>
<br>일반적인 echo 서버는 위와 같은 걱정을 할 필요가 없다. 왜냐하면 접두사를 붙여서 보내지 않기 때문이다. 클라이언트에서 패킷을 분할해서 보내도 보내는 대로 받아서 send back하면 그만이다. 하지만 접두사를 앞에 붙여서 보내야 한다는 조건이 추가되는 순간 이는 중대한 문제가 된다. 분할된 패킷 사이에 들어가는 접두사는 불순물로 전락해버린다. 접두사는 메시지의 맨 앞에 단 한 번만 들어가야 한다.
<br>이와 같은 문제를 해결하는 가장 간단한 방법은 구분자(delimeter, seperator)을 지정하는 것이다. 예를 들어 마침표(.)를 구분자로 지정했다고 가정해보자. 그러면 메시지가 분할되어 도착해도 구분자가 없음을 확인한 후 버퍼에 저장해두었다가, 구분자가 도착하면 합쳐서 한꺼번에 처리하는 방식이 가능할 것이다.
<br>// 메시지가 다음과 같이 분할되어 전송된다.

packet0: vvvveeeerrrryyyy
packet1: lllloooonnnngggg
packet2: mmmmssssgggg.

// 하지만 구분자(.)가 발견될 때까지 패킷은 전송되지 않고 버퍼에 저장된다.

buffer: vvvveeeerrrryyyy + lllloooonnnngggg + (waiting for '.' ....)

// 구분자가 도착하면 비로소 전송한다.

client 0: vvvveeeerrrryyyy lllloooonnnngggg mmmmssssgggg.

<br>
<br>그런데 subject에는 구분자가 무엇인지 명시되어 있지 않다.
<br>결론부터 말하자면, exam 06을 통과하기 위해선 구분자를 지정해야 한다. subject에 명시가 되어있지 않더라도 말이다. exam 06의 test case 08을 통과하기 위해서는 약 36만 바이트 길이의 메시지를 문제없이 echo 시킬 수 있어야 한다. 당연히 메시지는 분할되어서 들어올 것이고, 구분자를 지정하지 않으면 echo되는 메시지 사이사이에는 client: %d이 덕지덕지 붙어있을 것이다.<br>그나마 exam 06은 trace를 제공해주기 때문에, subject에 명시가 안되어 있는 구분자가 무엇인지 trace를 뜯어서 알아맞히는 식의 접근이 가능하다. 하지만 문제는 trace가 영어도 아니고 프랑스어로 되어있다는 점이다. 그리고 그렇게 자세히 나와있지도 않다. 따라서 사전 지식 없이 exam 06을 보는 사람은 높은 확률로 모르면 뒤져야지 당할 확률이 높다.<br>여러 삽질을 한 끝에 알아낸 결과<br>mini_serv는 개행(\n)을 구분자로 삼아 메시지를 처리해야 한다.<br>사실 subject 폴더에서 제공하는 main.c의 extract_message 함수에 개행을 기준으로 메시지를 추출하는 기능이 구현되어 있기 때문에 이게 힌트라면 힌트였던 셈이다.<br>즉, exam 06은 추가적으로 다음의 조건을 따라야 한다.<br>
<br>수신받은 메시지에 개행이 포함되어 있다면 그냥 평범하게 send back 하면 된다.
<br>수신받은 메시지에 개행이 포함되어 있지 않다면 버퍼에 저장해두었다가 나중에 구분자가 도착했을 때 합쳐서 보내야 한다. 따라서 클라이언트마다 별개로 버퍼가 존재해야 하고, 새로운 클라이언트가 서버에 접속할 때마다 버퍼도 새로 만들어야 한다.
<br>subject에는 이런 내용이 포함되어 있다.

<br>a single message can contains multiple \n
<br>하나의 메시지에는 여러 개의 개행(\n)이 포함될 수 있다.<br>
-&gt; 이러한 경우, 개행을 기준으로 서버가 메시지를 직접 분할하여 송신해야 한다.


<br><br>subject에는 다음과 같은 조건이 있다.<br>
<br>when the server receive a message, it must resend it to all the other client with "client %d: " before every line!
<br>서버가 메시지를 수신할 때, 다른 모든 클라이언트에게 "client %d: "를 접두사로 붙여 해당 메시지를 broadcast해야 합니다.
<br>위 문장에서 다른에 강조를 건 이유는, 자기 자신에게는 send back 하지 말아야 하기 때문이다.<br>예를 들어 서버에 클라이언트 1, 2, 3, 4, 5가 접속하고 있는 상황을 가정해보자.<br>
1이 보낸 메시지는 2, 3, 4, 5에게는 전달되어야 하지만, 메시지를 보낸 당사자인 1에게는 전달되지 말아야 한다.<br>참고로 이 조건은 클라이언트가 서버에 접속할 때 보내지는 메시지, 클라이언트가 연결을 해제했을 때의 메시지에도 해당한다.<br>즉, 클라이언트는 서버와 연결을 끊을 때 자기 자신의 left 메시지를 받지 못하며(사실 이건 당연하다), 서버에 접속했을 때 자기 자신의 arrive 메시지를 받지 못한다.<br><br>이 문서를 읽으시는 모든 분들은 저처럼 시간 낭비하지 마시고 1트에 mini_serv 통과하시길 바랍니다.]]></description><link>project\42seoul\mini_serv\mini_serv-억까-방지용-시트.html</link><guid isPermaLink="false">project/42Seoul/mini_serv/mini_serv 억까 방지용 시트.md</guid><pubDate>Sat, 22 Mar 2025 07:43:58 GMT</pubDate></item><item><title><![CDATA[메모장]]></title><description><![CDATA[<a class="tag" href="?query=tag:42Seoul" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#42Seoul</a> <a class="tag" href="?query=tag:graphics" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#graphics</a> <a class="tag" href="?query=tag:memo" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#memo</a> 
 <br><br><a href=".?query=tag:42Seoul" class="tag" target="_blank" rel="noopener nofollow">#42Seoul</a> <a href=".?query=tag:graphics" class="tag" target="_blank" rel="noopener nofollow">#graphics</a> <a href=".?query=tag:memo" class="tag" target="_blank" rel="noopener nofollow">#memo</a><br><br>minirt logic<br>
<br>원시 도형의 중점과 방향 벡터를 입력받는다.
<br>중점과 방향 벡터가 별도로 있으면 중점에는 이동 행렬을, 벡터에는 회전 행렬을 별도로 적용해야 한다. 그러면 행렬은 압축하여 연산량을 줄일 수 없으므로

<br>점 1(중점)과 점 2(중점 + 방향 벡터의 결과값)를 저장한다.
<br>2개의 점에 각각 압축된 행렬을 적용한다.
<br>점 2에서 점 1을 빼 방향 벡터를 복구한다.


<br>최적화

<br>도형이 절투체 바깥에 위치하는지 검사한다 -&gt; 안쪽에 위치하는 도형에만 별도로 태그


<br>투영 평면의 위치를 계산한다.
<br>카메라 -&gt; 투영 평면 방향으로, 스크린의 각 픽셀에 대응하는 위치로 광선을 발사한다.
<br>3-4에서 태그하였던 도형들과 광선의 충돌 테스트를 진행한다.(이 때, 벡터의 내적을 계산하여 충돌 지점이 카메라를 등지고 있는 경우는 배제한다.) 충돌하는 도형이 여러 개일 경우, 가장 충돌 거리가 가까운 지점을 계산에 사용한다.
<br>충돌 지점이 산출되면, 충돌한 도형의 종류를 고려하여 법선벡터를 산출한 후, 충돌 지점과 법선 벡터를 저장한다.
<br>충돌 지점과 광원을 잇는 선분의 방정식을 구한다.
<br>8에서 구한 선분과 존재하는 모든 도형과의 충돌 테스트를 진행한다. 만약 한 번이라도 충돌이 있으면 픽셀에 색상 가중치를 주지 않는다.
<br>충돌이 없다면, (광원의 위치 - 충돌 지점)인 벡터 l을 구한 후 정규화하여 7에서 저장한 법선 벡터와 내적하여 픽셀의 색상 가중치를 계산한다(diffuse reflection).
<br>벡터 l의 반사 벡터 r, 충돌 지점에서 카메라로 뻗어나가는 벡터 정규 벡터 v를 구한 후 내적하여 픽셀의 색상 가중치를 계산한다(specular reflection).
<br>존재하는 모든 광원에 대하여 8 ~ 11을 진행한다.
<br>모든 픽셀에 대하여 5 ~ 12을 진행한다.
]]></description><link>project\42seoul\minirt\메모장.html</link><guid isPermaLink="false">project/42Seoul/miniRT/메모장.md</guid><pubDate>Sat, 22 Mar 2025 07:44:00 GMT</pubDate></item><item><title><![CDATA[miniRT.pdf]]></title><description><![CDATA[<a class="tag" href="?query=tag:42Seoul" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#42Seoul</a> <a class="tag" href="?query=tag:graphics" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#graphics</a> 
 <br><br><a href=".?query=tag:42Seoul" class="tag" target="_blank" rel="noopener nofollow">#42Seoul</a> <a href=".?query=tag:graphics" class="tag" target="_blank" rel="noopener nofollow">#graphics</a><br>ray tracing<br><br><br>When it comes to rendering 3-dinemsional computer-generated images there are 2 possible approaches: "Rasterization", which is used by almost all graphic engines because of its efficiency and "Ray Tracing"<br>컴퓨터로 3차원 이미지를 렌더링하는 방식은 2가지가 있다. 첫번째는 효율성 때문에 대부분의 그래픽 엔진에 의해 사용되는 Rasterization이다. 두번째는 Ray Tracing이다.<br>The "Ray Tracing" method, developed for the first time in 1968 (but improved upon since) is even today more expensive in computation than the "Rasterization" method.<br>Ray Tracing 기법은 1968년에 처음 고안되었고, 큰 발전을 거듭했음에도 Rasterization 방법에 비해 훨신 많은 연산이 필요하다.<br>As a result, it is not yet fully adapted to real time use-cases but it produce a much higher degree of visual realism.<br>결과적으로, Ray Tracing은 실시간으로 무언가를 투영해야 하는 경우에는 아직 적합하지 않지만, 훨씬 시각적으로 사실적인 표현이 가능하다.<br>Before you can even begin to produce such high-quality grapics, you must master the basics: the miniRT is your first ray tracer coded in C, normed and humble but functional.<br>높은 품질의 그래픽을 구현하기 전에, 당신은 우선 기초를 숙달해야 한다: miniRT는 C 언어로 짜인 당신의 표준적이고, 소박하지만 기능적인 첫번째 광선 추적기가 될 것이다.<br>The main goal of miniRT is to prove to yourself that you can implement any mathematics or physics formulas without being a mathematician, we will only implement the most basic ray tracing features here so just keep calm, take a deep breath and don't panic! After this project you'll be able to show off nice-looking pictures to justify the number of hours you're spending at school...<br>miniRT 과제의 주목적은 수학 그리고 물리 공식을 구현할 수 있음을 스스로에게 증명하는 것이다. 우리는 가장 기초적인 Ray Tracing의 특징만을 구현할 것이므로 너무 겁먹지 말라. 이번 프로젝트가 끝나면 여러분이 얼마나 많은 시간을 노력했는지 증명할 멋진 이미지를 얻을 것이다.<br><br><br><br>The constraints are as follows:<br>다음의 제약을 따라야 한다.<br>You must use the miniLibX. Either the version that is available on the operatiing system, or from its sources. If you choose to work with the sources, you will need to apply the same rules for your libft as those written above in Common Instructions part.<br>반드시 miniLibX를 사용해야 한다. 운영체제에 설치되어 있는 버전을 써도 되고, 소스 파일을 다운받아 사용해도 된다. 만약 소스 파일을 다운받는다면, Common Instructions에 기술된 libft의 사용규칙을 그대로 적용해야 한다.<br>The management of your window must remain fluid: switching to another window, minimization, ect..<br>프로그램 창의 관리는 유동적이어야 한다: 다른 창으로의 전환, 최소화 등등이 적용되야 한다는 뜻.<br>When you change the resolution of the window, the content of the window must remain unchanged and be adjusted accordingly.<br>화면의 해상도를 바꿀 때, 화면의 구성은 그대로 유지한 채 보정만을 적용해야한다.<br>You need at least these 3 simple geometric objects: plane, sphere, cylinder.<br>적어도 3개의 간단한 기하학적 사물을 배치해야 한다: 평면, 구, 원기둥.<br>If applicable, all possible intersections and the inside of the object must be handled correctly.<br>사물 간의 중첩과 도형의 내부를 잘 제어할 수 있어야 한다.<br>Your program must be able to resize the object's unique properties: diameter for a sphere and the width and height for a cylinder.<br>사물의 크기 요소를 다시 설정할 수 있어야 한다: 원의 지름, 원기둥의 넓이 높이 등등.<br>Your program must be able to apply translation and rotation transformation to objects, lights and cameras (except for spheres and lights that cannot be rotated)<br>사물, 광원, 카메라의 이동과 회전을 구현해야 한다 (구와 회전이 적용될 수 없는 광원은 예외)<br>Light management: spot brightness, hard shodows, ambiance lighting (objects are never completely in the dark). You must implement Ambient and diffuse lighting.<br>광원 관리 : 점 광원 밝기, hard shadows(그림자의 경계가 명확하게 끊어지는 렌더링 기법), 환경광 Ambiance lighting(사물이 완전히 검게 물드는 부분이 없어야 함). 당신은 환경광과 난반사를 구현해야 한다.<br>The program displays the image in a window and respect the following rules:<br>
<br>Pressing Esc must close the window and quit the program cleanly.
<br>Clicking on the red cross on the window's frame must close the window and uit the program cleanly.
<br>The use of images of the minilibX is strongly recommanded.
<br>프로그램은 창에 이미지를 띄워야 하며 다음의 규칙을 따라야 한다.<br>
<br>Esc를 누르면 창이 닫히고 프로그램이 종료되어야 한다.
<br>창의 틀에 있는 빨간 십자 버튼을 누르면 창이 닫히고 프로그램이 종료되어야 한다.
<br>minilibX의 이미지를 사용하는 것이 강력하게 권장된다.
<br>Your program must take as a first argument a scene description fiie with the .rt extension.<br>
<br>Each type of element can be seperated by one or more line break(s).
<br>Each type of imformation from an element can be separated by one or more space(s).
<br>Each type of element cat be set in any order in the file.
<br>Elements which are defined by a capital letter can only be declared once in the scene.
<br>프로그램은 .rf 확장자를 가진, 장면을 정의하는 파일을 첫번째 인자로 받아야 한다.<br>
<br>각각의 요소는 하나 이상의 개행으로 분리되어야 한다.
<br>요소로부터 비롯된 각각의 속성은 하나 이상의 공백으로 분리되어야 한다.
<br>각각의 요소는 파일의 어떠한 위치에도 존재할 수 있다.
<br>대문자로 정의되는 요소들은 하나의 장면에 하나만 존재할 수 있다.
<br>Each element first’s information is the type identifier (composed by one or two character(s)), followed by all specific information for each object in a strict order such as:<br>요소의 첫번째 속성은 타입 정의자(하나 혹은 두 개의 문자로 구성된다)이며, 그 뒤의 속성들은 사물의 정보를 아래와 같이 구체적으로 명시해야 한다:<br><br>Ambient lightning:<br>A 0.2 255,255,255<br>
<br>identifier: A
<br>ambient lighting ratio in range [0.0, 1.0]: 0.2
<br>R,G,B colors in range [0-255]: 255, 255, 255
<br>환경광:<br>A 0.2 255,255,255<br>
<br>식별자: A
<br>환경광 비율([0.0, 1.0]의 범위를 가진다.): 0.2
<br>R,G,B 색상([0-255]의 범위를 가진다.): 255, 255, 255
<br><br>Camera:<br>C -50.0,0,20 0,0,1 70<br>
<br>identifier: C
<br>x,y,z coordinates of the view point: -50.0,0,20
<br>3d normalized orientation vector. In range [-1, 1] for each x,y,z axis: 0.0,0.0,1.0
<br>FOV : Horizontal field of view in degrees in range [0,180]: 70
<br>카메라:<br>C -50.0,0,20 0,0,1 70<br>
<br>식별자: C
<br>시점 veiw point의 x, y, z 좌표값 : -50.0, 0, 20
<br>정규화된 3차원 방향 벡터. x, y, z 축 모두 [-1, 1] 범위를 가진다.
<br>FOV : 수평 시야각. ([0, 180] 사이의 범위를 가지고 있다.) : 70
<br><br>Light:<br>L -40.0,50.0,0.0. 0.6  10,0,255<br>
<br>identifier: L 
<br>x,y,z coordinates of the light point: -40.0,50.0,0.0
<br>the light brightness ratio in range [0.0,1.0]: 0.6
<br>(unused in mandatory part)R,G,B colors in range [0-255]: 10, 0, 255
<br>광원:<br>L -40.0,50.0,0.0. 0.6  10,0,255<br>
<br>식별자: L
<br>광원의 x, y, z 좌표: -40.0,50.0,0.0
<br>빛의 밝기 비율. ([0.0,1.0]의 범위를 가짐): 0.6
<br>(mendatory part에서는 사용되지 않음)R,G,B 색상 ([0-255]의 범위를 가짐): 10, 0, 255
<br><br>Sphere:<br>sp 0.0,0.0,20.6 12.6 10,0,255<br>
<br>identifier: sp
<br>x,y,z coordinates of the sphere center: 0.0,0.0,20.6
<br>the sphere diameter: 12.6
<br>R,G,B colors in range [0-255]: 10, 0, 255
<br>구:<br>sp 0.0,0.0,20.6 12.6 10,0,255<br>
<br>식별자: sp
<br>구의 중심의 x, y, z 좌표: 0.0,0.0,20.6
<br>구의 지름: 12.6
<br>R,G,B 색상. ([0-255] 사이의 범위를 가짐.): 10, 0, 255
<br><br>Plane:<br>pl 0.0,0.0,-10.0 0.0,1.0,0.0 0,0,255<br>
<br>identifier: pl
<br>x,y,z coordinates of a point in the plane: 0.0,0.0,-10.0
<br>3d normalized normal vector. In range [-1,1] for each x,y,z axis: 0.0,1.0,0.0
<br>R,G,B colors in range [0-255]: 0,0,225
<br>평면:<br>pl 0.0,0.0,-10.0 0.0,1.0,0.0 0,0,255<br>
<br>식별자: pl
<br>x,y,z 평면의 중점 좌표: 0.0,0.0,-10.0
<br>정규화된 3차원 법선 벡터 (x,y,z 축 좌표의 값은 [-1,1] 범위를 가짐): 0.0,1.0,0.0
<br>R,G,B 색상 범위 : 0,0,225
<br><br>Cylinder:<br>cy 50.0,0.0,20.6 0.0,0.0,1.0 14.2 21.42 10,0,255<br>identifier: cy<br>
x,y,z coordinates of the center of the cylinder: 50.0,0.0,20.6<br>
3d normalized vector of axis of cylinder. In range [-1,1] for each x,y,z axis: 0.0,0.0,1.0<br>
the cylinder diameter: 14.2<br>
the cylinder height: 21.42<br>
R,G,B colors in range [0,255]: 10, 0, 255<br>원기둥: cy<br>
실린더 중심의 x,y,z 좌표값: 50.0,0.0,20.6<br>
실린더 축의 3차 정규화 벡터. x,y,z 축 모두 [-1,1] 범위: 0.0,0.0,1.0<br>
원기둥 지름: 14.2<br>
원기둥 높이: 21.42<br>
[0,255] 범위의 R,G,B 색상: 10, 0, 255<br><br><br>The Ray-Tracing technique could handle many more things like reflection, transparency, refraction, more complex objects, soft shadows, caustics, global illumination, bump mapping, .obj file rendering etc..<br>Ray-Tracing 기술은 반사, 투명도, 굴절, 더 복잡한 모양의 사물, 부드러운 그림자, 물결, 채색, 범프 매핑, 목적 파일 렌더링 등 더 복잡한 것들을 다룰 수 있다.<br>But for the miniRT project, we want to keep things simple for your first raytracer and your first steps in CGI.<br>하지만 miniRT 과제는 여러분의 첫번째 광선 추적기이자 컴퓨터 생성 화상 과제이므로, 최대한 단순함을 지키고 싶습니다.<br>So here is a list of few simple bonuses you could implement, if you want to do bigger bonuses we strongly advise you to recode a new ray-tracer later in your developer life after this little one is finished and fully functionnal.<br>그러므로 우리는 당신에게 단순한 보너스 목록 - 당신이 충분히 구현할 수 있을만한 - 을 제시합니다. 만약에 당신이 더 어려운 무언가를 구현하고 싶다면 우리는 우선 이 과제를 완전히 끝난 후에 새로운 광선 추적기를 만들면서 구현하기를 강력하게 권장합니다.<br>Bonus list:<br>보너스 목록:<br>
<br>
Add specular reflection to have a full Phong reflection model.

<br>
Color disruption: checkerboard.

<br>
Colored and multi-spot lights.

<br>
One other 2nd degree object: Cone, Hyperboloid, Paraboloid..

<br>
Handle bump map textures.

<br>
퐁 반사 모델을 완벽히 구현하기 위해 정반사를 추가할 것

<br>
색상 왜곡: 체커보드.

<br>
색상이 있고 여러 군데 존재하는 광원.

<br>
다른 2차 사물을 구현할 것: 원뿔, 쌍곡면, 포물면 등등

<br>
범프맵 텍스처를 다룰 것.

]]></description><link>project\42seoul\minirt\minirt.pdf.html</link><guid isPermaLink="false">project/42Seoul/miniRT/miniRT.pdf.md</guid><pubDate>Sat, 22 Mar 2025 07:44:00 GMT</pubDate></item><item><title><![CDATA[NetPractice]]></title><description><![CDATA[<a class="tag" href="?query=tag:42Seoul" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#42Seoul</a> <a class="tag" href="?query=tag:network" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#network</a> 
 <br><br><a href=".?query=tag:42Seoul" class="tag" target="_blank" rel="noopener nofollow">#42Seoul</a> <a href=".?query=tag:network" class="tag" target="_blank" rel="noopener nofollow">#network</a> <br>about IP addressing &amp; subnet masking<br><br><br><img alt="NetPractice_lv1_before.png" src="lib\media\netpractice_lv1_before.png"><br>
<br>A1과 D1의 IP 주소가 잘못되었다. IP 주소의 각 옥텟은 255를 넘을 수 없다.
<br>A1과 B1, C1과 D1의 네트워크 주소 부분이 서로 일치하지 않는다.
<br><br><img alt="NetPractice_lv2_before.png" src="lib\media\netpractice_lv2_before.png"><br>
<br>A1과 B1의 서브넷 마스크, 네트워크 주소가 서로 일치하지 않는다.
<br>C1과 D1 : 127은 스스로를 가리키는 특수 IP 주소이기 때문에 서로 통신하는 데 사용할 수 없다.
<br><img alt="NetPractice_lv2_after.png" src="lib\media\netpractice_lv2_after.png"><br><br><img alt="NetPractice_lv3_before.png" src="lib\media\netpractice_lv3_before.png"><br>
<br>같은 LAN 안의 IP 주소는 네트워크 주소와 서브넷 마스크가 모두 일치해야 한다.
<br><img alt="NetPractice_lv3_after.png" src="lib\media\netpractice_lv3_after.png"><br><br><img alt="NetPractice_lv4_before.png" src="lib\media\netpractice_lv4_before.png"><br>
<br>라우터 인터페이스 포함 같은 LAN 안의 IP 주소는 네트워크 주소와 서브넷 마스크가 모두 일치해야 한다.
<br>라우터의 인터페이스는 서로 중복되지 않아야 한다.
<br><img alt="NetPractice_lv4_after.png" src="lib\media\netpractice_lv4_after.png"><br><br><img alt="NetPractice_lv5_before.png" src="lib\media\netpractice_lv5_before.png"><br>
<br>라우터의 인터페이스는 서로 중복되지 않아야 한다.
<br>경로가 하나 밖에 없으면 디폴트 라우팅이 유리하다.
<br>당장 목적지로 가기 위한 경로를 모를 경우, 해당 경로의 정보를 가지고 있는 라우터로 전송하도록 정적 라우팅한다.
<br><br><img alt="NetPractice_lv6_before.png" src="lib\media\netpractice_lv6_before.png"><br>
<br>인터넷에서는 디폴트 라우팅을 사용할 수 없다.
<br>인테넷에서 라우트를 지정할 때, 사설 ip 주소를 destination으로 삼을 수 없다.
<br><img alt="NetPractice_lv6_after.png" src="lib\media\netpractice_lv6_after.png"><br><br><img alt="NetPractice_lv7_before.png" src="lib\media\netpractice_lv7_before.png"><br>
<br>라우터끼리 잇는 인터페이스는 서로 같은 네트워크에 속해야 한다.
<br><img alt="NetPractice_lv7_after.png" src="lib\media\netpractice_lv7_after.png"><br><br>이하의 문제는 상술한 개념들의 응용<br><br><br><img alt="NetPractice_lv8_before.png" src="lib\media\netpractice_lv8_before.png"><br><img alt="NetPractice_lv8_after.png" src="lib\media\netpractice_lv8_after.png"><br><br><img alt="NetPractice_lv9_before.png" src="lib\media\netpractice_lv9_before.png"><br><img alt="NetPractice_lv9_after.png" src="lib\media\netpractice_lv9_after.png"><br><br><img alt="NetPractice_lv10_before.png" src="lib\media\netpractice_lv10_before.png"><br><img alt="NetPractice_lv10_after.png" src="lib\media\netpractice_lv10_after.png">]]></description><link>project\42seoul\netpractice.html</link><guid isPermaLink="false">project/42Seoul/NetPractice.md</guid><pubDate>Sat, 22 Mar 2025 07:44:00 GMT</pubDate><enclosure url="lib\media\netpractice_lv1_before.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;lib\media\netpractice_lv1_before.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[그래프]]></title><description><![CDATA[<a class="tag" href="?query=tag:algorithm" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#algorithm</a> <a class="tag" href="?query=tag:graph" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#graph</a> 
 <br><br><a href=".?query=tag:algorithm" class="tag" target="_blank" rel="noopener nofollow">#algorithm</a> <a href=".?query=tag:graph" class="tag" target="_blank" rel="noopener nofollow">#graph</a><br>graph<br><br><br>그래프는 노드 vertex와 간선 edge을 이용한 비선형 데이터 구조이다. 보통 그래프는 데이터 간의 관계를 표현하는 데 사용한다. 데이터를 노드로, 노드 간의 관계나 흐름을 간선으로 표현한다.<br><br>그래프는 방향성 가중치, 순환 특성에 따라 종류를 구분할 수 있다.<br><br>간선은 방향을 가질 수도 있고 없을 수도 있다.<br>방향이 있는 간선을 포함하면 방향 그래프 directed graph, 방향이 없는 간선을 포함하면 무방향 그래프 undirected graph라고 한다.<br>이때 방향 그래프는 어느 한쪽으로만 간선이 있는 것이 아니라 서로 반대를 가리키는 간선이 있을 수 있다.<br><br>두 번째 특성은 가중치이다. 어떤 데이터는 흐름의 방향뿐 아니라 양도 중요할 수 있다. 그런 정도를 간선에 표현할 때 이를 가중치라고 한다.<br>가중치가 있는 그래프를 가중치 그래프 weight graph라고 한다.<br><br>마지막 특성은 순환이다. 순환은 특정 노드에서 시작해 간선을 따라 다시 돌아오는 경로가 있는 것을 말한다.<br>순환이 존재하는 그래프를 순환 그래프 cycle graph라 하고, 순환이 존재하지 않는 그래프를 비순환 그래프 acyclic graph라고 한다.<br><br>그래프의 구현 방식에는 인접 행렬 adjacency matrix과 인접 리스트 adjacency list가 있다.<br><br>인접 행렬은 이중 배열을 활용하여 구현하는 경우가 많다.<br>이때의 배열의 인덱스는 노드, 배열의 값은 노드의 가중치로 생각하고, 인덱스의 세로 방향을 출발 노드, 가로 방향을 도착 노드로 생각하면 자연스럽게 그래프를 표현할 수 있다.<br>예를 들어 아래의 그래프는<br>
서울(0) - 400(km) -&gt; 부산(1)

<br>다음과 같이 표현할 수 있다.<br><br><br>인접 리스트로 그래프를 표현하려면 우선 적절한 노드를 정의해야 한다. 정점(v), 가중치(w)를 묶어 관리한다.<br>인접 리스트 그래프 표현 방식은 다음과 같은 과정으로 동작한다.<br>
<br>우선은 노드 개수만큼 배열을 준비한다.
<br>배열의 인덱스는 각 시작 노드를 의미하며 배열의 값에는 해당 노드를 시작 노드로 하는 노드들을 추가한다. 이때, v가 도착 노드를 의미한다.
<br><br>참고자료<br><br>]]></description><link>resource\algorithm\그래프.html</link><guid isPermaLink="false">resource/Algorithm/그래프.md</guid><pubDate>Tue, 18 Mar 2025 07:02:40 GMT</pubDate></item><item><title><![CDATA[브루트 포스]]></title><description><![CDATA[<a class="tag" href="?query=tag:algorithm" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#algorithm</a> 
 <br><br><a href=".?query=tag:algorithm" class="tag" target="_blank" rel="noopener nofollow">#algorithm</a><br>brute force<br><br><br>brute : 짐승 같은, 난폭한<br>
force : 힘<br>즉  브루트 포스는 직역하자면 (정제되지 않은) 난폭한 힘, 폭력이라는 뜻이다.<br>브루트 포스의 실질적으로 가능한 모든 경우의 수를 시도하여 문제를 해결하는 방식을 칭하는 표현이다. 얼핏 보면 우격다짐 식으로 보여 이러한 명칭이 붙었지만, 컴퓨팅 파워가 충분하다면 가장 단순하면서도 확실한 방법이기도 하다.<br>원래는 보안 분야에서 유래한 표현이다. 예를 들어, 가능한 모든 경우의 수를 암호에 대입하여 보안 요소를 무력화하는 것을 브루트 포스 공격이라고 한다.<br>키 전수조사(exhaustive key search), 무차별 대입 공격이라 칭하기도 한다.<br><br>브루트 포스 방식은 문제의 복잡도(Complexity)에 매우 민감하다는 단점이 있다.<br>이 때문에 실제로 브루트 포스는 문제의 규모가 현재의 자원으로 충분히 커버가 가능한 경우에만 쓰이고, 대부분은 <a data-href="동적 계획법" href="동적 계획법" class="internal-link" target="_self" rel="noopener nofollow">동적 계획법</a> 등으로 많이 우회하는 편이다. 정확도를 조금 희생하더라도 어떻게든 '이론상 가능한' 자원으로 해결할 수 있게 알고리즘을 설계하기도 한다.]]></description><link>resource\algorithm\브루트-포스.html</link><guid isPermaLink="false">resource/Algorithm/브루트 포스.md</guid><pubDate>Thu, 06 Mar 2025 04:10:04 GMT</pubDate></item><item><title><![CDATA[데이터베이스란]]></title><description><![CDATA[<a class="tag" href="?query=tag:database" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#database</a> <a class="tag" href="?query=tag:참고링크/생활코딩" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고링크/생활코딩</a> 
 <br><br><a href=".?query=tag:database" class="tag" target="_blank" rel="noopener nofollow">#database</a><br>database<br><br><br><br>대규모의 데이터를 편리하게 저장, 관리, 열람할 수 있게 해주는 소프트웨어.<br><br><br>데이터베이스의 가장 본질적인 기능은 입력 Input과 출력 Output이다.<br>
입력 기능은 다시 생성 Create, 갱신 Update, 삭제 Delete으로 세분화할 수 있고 출력 기능은 읽기 Read 기능을 포함한다.<br>데이터베이스에서 가장 본질적인 이 네가지 기능을 통틀어 CRUD라고 한다.<br><br><br>굳이 공들여 데이터베이스를 공부해야하는 이유를 제시하기 위해선 사람들이 보편적으로 데이터를 관리하기 위해 사용하는 수단인 파일에 비교했을 때 데이터베이스가 확실한 강점을 보유하고 있어야 한다.<br>데이터베이스의 대표적인 장점으로 다음을 제시할 수 있다.<br>
<br>정보를 구조화하여 저장한다.

<br>예를 들어, 정보를 여러 개의 속성(ex. 주제, 제목, 내용, 작성자, 프로필 등등)으로 나누어 저장할 수 있고, 특정 속성을 기준으로 정렬할 수 있고, 특정 속성만 표시하거나 숨길 수 있고, 특정 속성의 값을 사용하여 검색하는 등의 일을 할 수 있다.


<br>프로그래밍 언어를 사용하여 이러한 작업을 자동화 할 수 있다.

<br>1의 작업을 사람이 수동으로 명령어를 입력하는 것이 아닌, 프로그래밍 언어를 사용하여 자동화 로직을 구성할 수 있다.


<br><br><br>주의 : 위 가이드는 2018년 기준으로 작성되었으므로 현 시류와 맞지 않는 부분이 있을 수 있습니다 (그런데 2024년 기준으로 검색해봐도 통계가 비슷한게 함정)<br><br>참고자료<br><a href=".?query=tag:참고링크\생활코딩" class="tag" target="_blank" rel="noopener nofollow">#참고링크/생활코딩</a> <br>]]></description><link>resource\database\데이터베이스.html</link><guid isPermaLink="false">resource/Database/데이터베이스.md</guid><pubDate>Sat, 22 Mar 2025 07:31:38 GMT</pubDate></item><item><title><![CDATA[MySQL]]></title><description><![CDATA[<a class="tag" href="?query=tag:database" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#database</a> <a class="tag" href="?query=tag:uncomplete" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#uncomplete</a> <a class="tag" href="?query=tag:참고링크/생활코딩" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고링크/생활코딩</a> 
 <br><br><a href=".?query=tag:database" class="tag" target="_blank" rel="noopener nofollow">#database</a> <a href=".?query=tag:uncomplete" class="tag" target="_blank" rel="noopener nofollow">#uncomplete</a><br>MySQL의 my는 개발자의 딸의 이름에서 유래한 것이다.<br><br>들어가기에 앞서<br>본 문서는 42 seoul의 프로젝트 inception의 해결을 위해 작성되었습니다. inception은 MariaDB 지식을 요구하고 아래에서 제시되는 자료들은 모두 MySQL을 기준으로 하나 MySQL의 커맨드는 대부분이 MaraiDB에서 호환되기 때문에 문제가 없다고 생각하여 첨부합니다.<br><br><br><br><a data-href="데이터베이스" href="resource\database\데이터베이스.html" class="internal-link" target="_self" rel="noopener nofollow">데이터베이스</a> 문서 참고.<br>
현 데이터베이스의 가장 보편적인 형식은 관계형 데이터베이스이며 데이터를 표의 형태로 관리하여 정렬, 검색, 표시 및 숨김 그 외에도 많은 기능들을 편리하게 사용할 수 있다.<br>MySQL의 가장 큰 장점은 무료이면서 관계형 데이터베이스의 핵심 기능들을 포함하고 있다는 것이다. 웹이 폭발적으로 성장하면서 웹 개발자들에게 선택받은 MySQL은 많은 수요를 확보하였다.<br><br><br>MySQL은 SQL이라는 언어를 사용해서 데이터를 조작할 수 있다.<br><br><a data-tooltip-position="top" aria-label="https://opentutorials.org/course/3161/19532" rel="noopener nofollow" class="external-link" href="https://opentutorials.org/course/3161/19532" target="_blank">다음 참고</a><br><br><br>MySQL은 3가지 구성요소로 되어 있다.<br>
<br>표 table : 정보가 저장되는 장소
<br>데이터베이스 database 또는 스키마 schema: 여러 개의 표들을 묶어 관리하는 단위
<br>데이터베이스 서버 database server : 여러 개의 스키마를 묶어 관리하는 단위
<br><br><br>데이터베이스의 효용<br>
<br>보안성이 좋다.

<br>자체적인 보안 체계를 가지고 있다.
<br>사용자 권한 설정을 할 수 있다.


<br>다음의 커맨드를 이용하여 서버에 접속한다.<br>./mysql -uroot -p<br><br>다음의 커맨드를 사용하여 서버와의 연결을 끊는다.<br>exit<br><br> <br>다음의 명령어를 사용하여 새로운 스키마를 만든다.<br>CREATE DATABASE &lt;만들고자 하는 스키마의 이름&gt;;<br>다음의 명령어를 사용하여 기존의 스키마를 삭제한다.<br>DROP DATABASE &lt;제거하고자 하는 스키마의 이름&gt;;<br>다음의 명령어를 사용하여 현재 있는 스키마들의 목록을 출력한다.<br>SHOW DATABASES;<br>다음의 명령어를 사용하여 MySQL에게 지금부터 작업할 스키마를 통지한다.<br>USE &lt;작업하고자 하는 스키마의 이름&gt;;<br><br><br>SQL은 Structured Query Language의 약자이다. 여기서 Query는 요청하다, 질의하다라는 뜻이다.<br>표 table은 열 colume과 행 row으로 이루어져 있다.<br><br><br><br>;을 붙이고 줄바꿈하면 해당 line이 실행되지만 그냥 줄바꿈하면 line이 실행되지 않고 계속 입력을 받는다 -&gt; 긴 line을 입력할 때 줄바꿈을 해가며 가독성 좋게 입력할 수 있다.<br>다음의 커맨드를 사용하여 새로운 열을 만든다.<br>CREATE TABLE topic(
	&lt;Field의 이름&gt; &lt;topic의 data type&gt;(&lt;얼만큼의 길이만큼 저장할 수 있는가&gt;) &lt;필드 공백의 허용 여부&gt;
);
<br>topic의 data type<br>
<a data-tooltip-position="top" aria-label="https://incodom.kr/DB_-_%EB%8D%B0%EC%9D%B4%ED%84%B0_%ED%83%80%EC%9E%85/MYSQL" rel="noopener nofollow" class="external-link" href="https://incodom.kr/DB_-_%EB%8D%B0%EC%9D%B4%ED%84%B0_%ED%83%80%EC%9E%85/MYSQL" target="_blank">다음 참고</a><br>필드 공백의 허용 여부란 무엇인가<br>
해당 열(Field)에 무조건 값이 들어가야 하는지, 아니면 비어있을 수 있는지를 설정하는 영역이다.<br>
<br>NOT NULL : 무조건 값을 대입하여야 한다.
<br>NULL : 비어있는 채로 둘 수 있다.
<br>AUTO_INCREMENT<br>
특정 열의 값을 위의 행의 공간 + 1로 자동으로 대입해주는 옵션<br>다음은 실행 가능한 구체적인 예이다.<br>CREATE TABLE topic(
	id INT(11) NOT NULL AUTO_INCREMENT,
	title VARCHAR(100) NOT NULL,
	description TEXT NULL,
	created DATETIME NOT NULL,
	author VARCHAR(30) NULL,
	profile VARCHAR(100) NULL,
	PRIMARY KEY(id)
);
<br>PRIMARY KEY(&lt;Field의 이름&gt;)<br>
<br>해당 열(Field)에서는 중복을 허용하지 않는다는 의미
<br>ERROR1820 (HY000)<br>MySQL에 처음 접속하면 기본적으로 유저마다 비밀번호를 자동으로 할당해주는데, 이 비밀번호를 갱신하지 않고 작업을 시도하면 ERROR1820 (HY000)을 맞게 된다.<br>아래의 커맨드를 사용하여 비밀번호를 갱신하여 해결할 수 있다.<br>SET PASSWORD = PASSWORD('&lt;갱신하고자 하는 새로운 비밀번호&gt;')<br><br>MySQL은 사용자로 하여금 정해진 포맷대로 데이터를 저장하도록 강제할 수 있다.<br><br><br><br><br>다음의 명령어를 통해 테이블의 구조를 볼 수 있다.<br>DESC &lt;구조를 보고자 하는 표의 이름&gt;;<br>다음의 명령어를 통해 표에 새로운 행을 입력할 수 있다.<br>INSERT INTO &lt;삽입하고자하는 table 이름&gt; (&lt;Field의 이름 입력, 이름 2, ..., 이름 n&gt;) VALUES(&lt;Field에 대응하는 값 입력, 값 2, ..., 값 n&gt;)<br><br><br>다음의 명령어를 통해 표를 출력할 수 있다.<br>SELECT &lt;option&gt; FROM &lt;출력하고자 하는 표의 이름&gt; WHERE &lt;field&gt;='&lt;value&gt;' ORDER BY &lt;field&gt; &lt;정렬 옵션&gt; LIMIT &lt;출력할 행 개수의 상한&gt;<br>
<br>option : 표에서 어떤 요소들을 노출할 것인지 설정한다.
<br><br>
<br>WHERE &lt;field&gt;='&lt;value&gt;' : 특정 field가 value인 행만 출력한다는 뜻
<br>ORDER BY &lt;field&gt; &lt;정렬 옵션&gt; : 특정 field를 기준으로 정렬. &lt;정렬 옵션&gt; 위치에 DESC(descending의 약자)가 오면 큰 값이 위로 가도록 정렬한다.
<br>LIMIT &lt;출력할 행 개수의 상한&gt; : 출력할 행의 개수를 제한하는 데에 사용한다.
<br><br><br>특정 행의 특정 필드를 수정하려면<br>UPDATE &lt;table 이름&gt; SET &lt;고치고자 하는 필드의 이름&gt;='&lt;수정할 내용&gt;', ... WHERE &lt;field&gt;=&lt;value&gt;<br>SET을 통해 고치고자 하는 필드의 이름(=열)을 설정하고 WHERE을 통해 고치고자 하는 행의 정보를 설정한다.<br>
WHERE을 빼먹어 행 정보를 제한하지 않으면 모든 행의 정보가 바뀌는 대참사가 일어나므로 꼭 WHERE을 포함하도록 하자.<br><br><br>특정 행을 삭제하려면<br>DELETE FROM &lt;삭제를 진행하고자 하는 table 이름&gt; WHERE &lt;field&gt;='&lt;value&gt;'<br>ex)<br> DELETE FROM topic WHERE id = 5<br>삭제 범위를 규정하는 WHERE 구문을 뺴먹으면 테이블의 모든 행이 삭제된다. 때와 상황에 따라서 인생이 바뀔 수도 있는 문제이니 매우 주의하도록 하자.<br><br><br><br><br><br><br><br><br><br><br>참고자료<br><a href=".?query=tag:참고링크\생활코딩" class="tag" target="_blank" rel="noopener nofollow">#참고링크/생활코딩</a> <br>]]></description><link>resource\database\mysql.html</link><guid isPermaLink="false">resource/Database/MySQL.md</guid><pubDate>Mon, 20 Jan 2025 07:29:41 GMT</pubDate></item><item><title><![CDATA[도커]]></title><description><![CDATA[<a class="tag" href="?query=tag:docker" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#docker</a> <a class="tag" href="?query=tag:참고도서/그림과_실습으로_배우는_도커_쿠버네티스" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/그림과_실습으로_배우는_도커_쿠버네티스</a> 
 <br><br><a href=".?query=tag:docker" class="tag" target="_blank" rel="noopener nofollow">#docker</a><br>virtual machine과 비슷하지만 좀 더 가볍다.<br><br>도커란 데이터 또는 프로그램을 격리시키는 기능을 하는 소프트웨어이다.<br><br><img alt="도커의 구조.jpeg" src="lib\media\도커의-구조.jpeg"><br>일반적인 도커의 구조.<br><img alt="윈도우에서의 도커의 구조.png" src="lib\media\윈도우에서의-도커의-구조.png" style="width: 700px; max-width: 100%;"><br>윈도우에서의 도커의 구조. 도커는 리눅스용으로 설계되었기 때문에, 윈도우용 도커 패키지에는 리눅스를 윈도우 상에 올리기 위한 하이퍼바이저와 가상 머신이 포함되어 있다. 즉, 윈도우 -&gt; (가상 머신 위의) 리눅스 -&gt; 도커 형식.<br><br><br>
<br>환경이 독립되어 있다.

<br>동일한 프로그램을 한 컴퓨터에 여러 개 설치, 실행할 수 있다 (일반적으로는 불가능).
<br>예를 들어 A 프로그램은 아파지 5.0 버전으로만 실행가능하고, B 프로그램은 아파치 8.0 버전으로만 실행 가능한 경우, 도커를 사용하면 서로 다른 컨테이너에 각각 5.0, 8.0 버전을 설치함으로서 간단하게 해결할 수 있다.
<br>프로그램 간의 충돌, 간섭을 예방할 수 있다.


<br>이미지를 만들 수 있다.

<br>그렇게 만든 <a data-href="이미지" href="resource\docker\이미지.html" class="internal-link" target="_self" rel="noopener nofollow">이미지</a>를 <a data-href="도커 허브" href="resource\docker\도커-허브.html" class="internal-link" target="_self" rel="noopener nofollow">도커 허브</a>에 올릴 수 있다( = 배포가 용이하다)
<br>반대로 도커 허브로부터 필요한 이미지를 쉽게 다운로드 받을 수도 있다.
<br>이미지를 통해 간단하게 컨테이너를 만들 수 있으므로 교체 및 업데이트가 용이하다.
<br>컨테이너를 자유자재로 옮길 수 있다 (정확히는 이미지의 형태로 컨테이너를 추출한 다음 해당 이미지를 기반으로 다른 환경에서 컨테이너를 복원할 수 있다).


<br>컨테이너에 '커널'을 포함시지 않으며, 운영체제의 주변 영역만을 포함한다.

<br>따라서 가볍다.
<br>또한 컨테이너에 올라가는 운영체제의 배포판을 자유자재로 바꿀 수 있다.


<br><br>
<br>리눅스 운영체제를 사용하는 것을 전제로 만들어졌기 때문에 리눅스용 소프트웨어 밖에 지원하지 않는다.
<br>물리 장치 하나에 여러 개의 컨테이너를 띄우는 형태이기 때문에 호스트 서버에 문제가 생기면 여러 컨테이너에 영향이 미친다. 따라서 물리 장치의 이상에 확실한 대책을 세워야 한다.
<br>애초에 컨테이너 여러 개를 사용하는 형태를 가정하여 만든 기술이므로 컨테이너 하나를 장시간에 걸쳐 사용할 때는 큰 장점을 느끼기 어렵다. 도커를 사용하려면 반드시 도커 엔진을 구동해야 하는데, 컨테이너를 하나밖에 사용하지 않으면 도커 엔진이 단순한 오버헤드에 지나지 않는다.
<br><br>
<br>리눅스에서 사용되는 것을 전제로 만들어졌기 때문에 리눅스 운영체제가 필요하다.
<br>따라서, 도커의 <a data-href="컨테이너" href="resource\docker\컨테이너.html" class="internal-link" target="_self" rel="noopener nofollow">컨테이너</a>에서 동작할 수 있는 프로그램도 리눅스용 프로그램으로 한정된다.
<br>본격적인 도커 사용법은 <a data-href="도커 명령어" href="resource\docker\도커-명령어.html" class="internal-link" target="_self" rel="noopener nofollow">도커 명령어</a>를 참고.<br><br>참고자료<br><a href=".?query=tag:참고도서\그림과_실습으로_배우는_도커_쿠버네티스" class="tag" target="_blank" rel="noopener nofollow">#참고도서/그림과_실습으로_배우는_도커_쿠버네티스</a> <br>]]></description><link>resource\docker\도커.html</link><guid isPermaLink="false">resource/Docker/도커.md</guid><pubDate>Fri, 20 Dec 2024 13:58:24 GMT</pubDate><enclosure url="lib\media\도커의-구조.jpeg" length="0" type="image/jpeg"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;lib\media\도커의-구조.jpeg&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[도커 네트워크]]></title><description><![CDATA[<a class="tag" href="?query=tag:docker" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#docker</a> <a class="tag" href="?query=tag:참고도서/그림과_실습으로_배우는_도커_쿠버네티스" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/그림과_실습으로_배우는_도커_쿠버네티스</a> <a class="tag" href="?query=tag:참고도서/시작하세요_도커_쿠버네티스" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/시작하세요_도커_쿠버네티스</a> 
 <br><br><a href=".?query=tag:docker" class="tag" target="_blank" rel="noopener nofollow">#docker</a><br>docker network<br><br><a data-href="컨테이너" href="resource\docker\컨테이너.html" class="internal-link" target="_self" rel="noopener nofollow">컨테이너</a>를 다루다 보면 하나가 아닌 여러 개의 프로그램을 연동해 사용해야 하는 경우가 있다.<br>
예를 들어, 간단한 웹사이트를 만드는 데에도 워드프레스 + php 런타임 + apache + mysql 콤보가 필요하다.<br>
이러한 프로그램들을 하나의 컨테이너에 때려넣을 수도 있지만, 그러면 프로그램을 격리해 관리한다는 <a data-href="도커" href="resource\docker\도커.html" class="internal-link" target="_self" rel="noopener nofollow">도커</a>의 목적이 퇴색된다.<br>따라서 각각의 프로그램을 별도의 컨테이너에 보관하는 것이 바람직한데, 앞서 말했듯이 컨테이너는 격리되어 있기 때문에 프로그램 간 연동이 안된다는 문제가 있다.<br>컨테이너는 가상 ip 주소를 할당받는다. 컨테이너 안에서 ifconfig 명령어를 사용한 후 출력되는 목록 중에서 eth0(도커의 NAT IP) 부분이 컨테이너가 할당받은 가상 ip 주소이다.<br>따라서 이 가상 ip를 통해 접근하면 다른 컨테이너와 통신할 수 있다. 예를 들어, B 컨테이너의 ip가 172.17.0.3이라면 A 컨테이너는 이 ip를 써서 B 컨테이너에 접근할 수 있다. 그러나 도커 엔진은 컨테이너가 시작할 때마다 가상 ip를 재할당하므로 매번 변경되는 컨테이너의 ip로 접근하기는 어렵다.<br><br>--link 옵션은 컨테이너에 별명(alias)를 붙인 후 그 컨테이너에 ip가 아닌 별명으로 접근하게 해주는 설정이다. --link 옵션을 사용할 때 --link에 입력된 컨테이너가 실행 중이지 않거나 존재하지 않는다면 --link를 적용한 컨테이너 또한 실행할 수 없다는 점을 주의해야 한다.<br>이처럼 --link 옵션은 컨테이너 간에 이름으로 서로를 찾을 수 있게 도와주지만, 현재 deprecated 된 옵션이며 추후 삭제될 수 있다. 따라서 얌전히 후술할 도커 네트워크를 쓰는 편이 좋다.<br><br>도커는 컨테이너끼리 연결할 수 있는 가상 네트워크를 제공한다. 이를 도커 네트워크라고 한다.<br>토커는 컨테이너를 생성할 때마다 veth(virtual eth)라는 가상 네트워크 인터페이스를 생성한다. docker0이라는 브릿지는 각 veth 인터페이스와 바인딩되어 호스트의 eth0 인터페이스와 이어주는 역할을 한다. 즉, 컨테이너와 호스트의 네트워크는 아래의 그림과 같은 구조를 띈다.<br><img alt="도커 네트워크 구조.png" src="lib\media\도커-네트워크-구조.png"><br>아무런 설정을 하지 않고 컨테이너를 생성하면 컨테이너는 자동으로 docker0을 사용한다.<br>
docker0 브릿지 이외에도 사용자의 선택에 따라 여러 네트워크 드라이브를 사용할 수 있다.<br>
<br>브리지 bridge
<br>호스트 host
<br>논 none
<br>컨테이너 container
<br>오버레이 overlay
<br>사용자 정의 네트워크는 컨테이너에 유동적으로 연결하고 분리할 수 있다.<br>#분리
docker network disconnect &lt;네트워크 이름&gt; &lt;컨테이너 이름&gt;

#연결
docker network connect &lt;컨테이너 이름&gt; &lt;네트워크 이름&gt;
<br>네트워크의 서브넷, 게이트웨이, ip 할당 범위 등을 임의로 설정하려면 네트워크를 생성할 때 아래와 같이 --subnet, --ip-range, --gateway 옵션을 추가한다. 단, --subnet과 --ip-range는 같은 대역이여야 한다.<br>ex)<br>
docker network create --driver=&lt;network type&gt; --subnet=172.72.0.0/16 --ip-range=172.72.0.0/24 --gateway=172.72.0.1 &lt;network_name&gt;<br><br>브리지 네트워크는 docker0이 아닌 사용자 정의 브릿지를 새로 생성해 각 컨테이너에 연결하는 네트워크 구조이다.<br>컨테이너는 연결된 브릿지를 통해 외부와 통신할 수 있다.<br>
아래와 같은 명령어를 통해 생성한다.<br>docker network create --driver=&lt;네트워크 타입. 브리지 네트워크를 만들고 싶다면 bridge가 들어간다.&gt; &lt;만들고자 하는 네트워크 이름&gt;<br><br>docker run에 --net host 인자를 붙이면 컨테이너의 네트워크를 호스트로 설정할 수 있다.<br>네트워크를 호스트로 설정하면 호스트의 네트워크 환경을 그대로 쓸 수 있다.<br>
즉, 별도의 포트 포워딩 없이 외부와 통신할 수 있다.<br><br>docker run에 --net none 인자를 붙이면 컨테이너의 네트워크를 논으로 설정할 수 있다.<br>논 none은 말 그대로 아무런 네트워크를 쓰지 않는 것을 뜻한다. 논 네트워크로 컨테이너를 설정하면 해당 컨테이너는 외부와 단절된다. <br><br>docker run에 --net container:&lt;다른 컨테이너의 id&gt;와 인자를 붙이면 해당 컨테이너 네트워크의 네임스페이스 환경을 공유할 수 있다. 공유되는 속성은 내부 ip, 네트워크 인터페이스의 맥(MAC) 주소 등이다.<br><br>참고자료<br><a href=".?query=tag:참고도서\그림과_실습으로_배우는_도커_쿠버네티스" class="tag" target="_blank" rel="noopener nofollow">#참고도서/그림과_실습으로_배우는_도커_쿠버네티스</a><br>
<a href=".?query=tag:참고도서\시작하세요_도커_쿠버네티스" class="tag" target="_blank" rel="noopener nofollow">#참고도서/시작하세요_도커_쿠버네티스</a><br>]]></description><link>resource\docker\도커-네트워크.html</link><guid isPermaLink="false">resource/Docker/도커 네트워크.md</guid><pubDate>Fri, 20 Dec 2024 13:58:19 GMT</pubDate><enclosure url="lib\media\도커-네트워크-구조.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;lib\media\도커-네트워크-구조.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[도커 명령어]]></title><description><![CDATA[<a class="tag" href="?query=tag:docker" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#docker</a> <a class="tag" href="?query=tag:참고도서/그림과_실습으로_배우는_도커_쿠버네티스" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/그림과_실습으로_배우는_도커_쿠버네티스</a> <a class="tag" href="?query=tag:참고도서/시작하세요_도커_쿠버네티스" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/시작하세요_도커_쿠버네티스</a> 
 <br><br><a href=".?query=tag:docker" class="tag" target="_blank" rel="noopener nofollow">#docker</a><br>docker command는 상위 커맨드와 하위 커맨드로 이루어져 있다.<br><br><a data-href="도커" href="resource\docker\도커.html" class="internal-link" target="_self" rel="noopener nofollow">도커</a>는 도커 명령어를 사용하여 조작한다.<br>도커 명령어는 일반적으로 아래의 형식을 취한다.<br>docker &lt;상위 커맨드&gt;&lt;하위 커맨드&gt; &lt;옵션&gt; &lt;대상&gt; &lt;인자&gt;<br><br>상위 커맨드는 원칙적으로 삭제될 수 없으나 상위 커맨드가 container인 경우, 그리고 version 같은 특수한 커맨드를 사용하는 경우엔 예외로 한다.<br><br><br>
<br>대상이 id를 가지고 있을 경우, 대상의 이름 대신 id를 입력하여 커맨드를 입력할 수 있다. 보통 2~3 글자만 입력하여도 된다.
<br>아래 서술에서 옵션, 인자에 대한 설명이 없는 커맨드는 옵션, 인자를 거의 활용하지 않거나, 아예 없는 커맨드이다.
<br><br><br>컨테이너를 생성해 실행하는 커맨드이다. docker image pull, docker container create, docker container start의 기능을 하나로 합친 것과 같다. 현재 해당 이미지를 내려받은 상태가 아니라면 먼저 이미지를 내려받는다.<br>기본적으로 다음의 형식을 가진다.<br>docker run &lt;옵션&gt; &lt;대상 : 컨테이너를 만드는데 사용할 이미지의 이름&gt; &lt;인자&gt;<br><br>-d를 붙이지 않고 컨테이너를 실행하면 실행된 컨테이너가 프로그램의 실행을 마칠 때까지 터미널의 제어를 차지하므로 그다음 명령을 입력할 수 없는 상태가 된다.<br>
또한 -it 옵션을 붙이지 않으면 컨테이너 안의 파일 시스템에 접근할 수 없다.<br>

docker run = docker pull(이미지가 없을 때 한정) -&gt; docker create -&gt; docker start -&gt; docker attach(-it 옵션을 사용했을 때 한정)<br>
docker create = docker pull(이미지가 없을 때 한정) -&gt; docker create
<br><br>컨테이너의 목록을 출력하는 커맨드.<br>docker ps는 현재 실행 중인 컨테이너의 목록을 출력한다.<br>
docker ps -a는 모든 컨테이너의 목록을 출력한다.<br>
docker ps -q는 컨테이너의 id만을 출력한다. 이를 이용하여<br>docker stop $(docker ps -a -q)
docker rm $(docker ps -a -q)
<br>와 같이 모든 컨테이너를 정지 및 삭제할 수 있다.<br><br>호스트의 파일을 컨테이너에, 또는 컨테이너의 파일을 호스트에 복사하기 위하여 사용하는 명령어.<br>
아래와 같이 원본경로 복사할경로 순서로 인자를 기재하면 된다.<br>컨테이너로 파일을 복사하는 커맨드 사용 예(호스트 -&gt; 컨테이너)<br>
docker cp 호스트_경로 컨테이너_이름:컨테이너_경로<br>호스트로 파일을 복사하는 커맨드 사용 예(컨테이너 -&gt; 호스트)<br>
docker cp 컨테이너_이름:컨테이너_경로 호스트 경로<br><br>기존에 존재하는 컨테이너를 이미지로 변환.<br>
기존 컨테이너를 복제하거나 이동해야 할 때 편리하다.<br>docker commit &lt;컨테이너_이름&gt; &lt;새로운 이미지 이름&gt;<br><br>컨테이너의 내부로 들어가는 명령어. docker exec -it &lt;container id&gt; /bin/bash 명령어와 유사하다.<br>docker attach &lt;container_name&gt;<br>이 명령어의 반대로, ctrl + P, Q로 컨테이너에서 빠져나올 수 있다. exit과 달리 컨테이너를 정지시키지 않고 빠져나올 수 있다는 장점이 있다.<br><br><br><br><br><br>이미지를 대상으로 하는 명령어는 버전을 지정하지 않아도 아래와 같이 동작한다.<br>`docker run --name ubuntoCont -it ubuntu'<br>그러면 이미지의 최신 버전(latest tag)을 내려받는다.<br>
하지만 특정 버전을 사용해야 할 때도 있다. 그런 경우에는 아래와 같은 형식으로 버전을 지정할 수 있다.<br>image:image_version<br><br>docker image --filter "label=..."은 특정 <a data-tooltip-position="top" aria-label="Dockerfile > ^c135e6" data-href="Dockerfile#^c135e6" href="resource\docker\dockerfile.html#^c135e6" class="internal-link" target="_self" rel="noopener nofollow">라벨</a>만을 가진 이미지만들 출력한다.<br><br><br><br><br><br>build는 도커의 일반적인 명령어와 달리 상위 커맨드와 하위 커맨드의 구분이 존재하지 않는 독립된 특수한 명령어이다.<br><a data-href="Dockerfile" href="resource\docker\dockerfile.html" class="internal-link" target="_self" rel="noopener nofollow">Dockerfile</a>과 재료 파일들이 들어 있는 재료 폴더를 대상으로 사용해 새로운 이미지를 만드는 명령어이다.<br>docker build -t &lt;생성할 이미지 이름&gt; &lt;재료 폴더 경로&gt;<br>-t 인자는 생성할 이미지의 이름을 지정하기 위한 옵션이다.<br><br>참고자료<br><a href=".?query=tag:참고도서\그림과_실습으로_배우는_도커_쿠버네티스" class="tag" target="_blank" rel="noopener nofollow">#참고도서/그림과_실습으로_배우는_도커_쿠버네티스</a><br>
<a href=".?query=tag:참고도서\시작하세요_도커_쿠버네티스" class="tag" target="_blank" rel="noopener nofollow">#참고도서/시작하세요_도커_쿠버네티스</a> <br>]]></description><link>resource\docker\도커-명령어.html</link><guid isPermaLink="false">resource/Docker/도커 명령어.md</guid><pubDate>Fri, 20 Dec 2024 13:58:29 GMT</pubDate></item><item><title><![CDATA[도커 컴포즈]]></title><description><![CDATA[<a class="tag" href="?query=tag:docker" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#docker</a> 
 <br><br><a href=".?query=tag:docker" class="tag" target="_blank" rel="noopener nofollow">#docker</a><br>docker compose<br><br>도커 컴포즈는 다음과 같이 정의할 수 있다. <br>
<br>시스템 구축과 관련된 명령어를 하나의 텍스트 파일(정의 파일)에 기재해 명령어 한번에 시스템 전체를 실행하고 종료와 폐기까지 한 번에 하도록 도와주는 도구.
<br>시스템 구축에 필요한 설정을 YAML(YAML Ain't a Markup Language) 포맷으로 기재한 정의 파일을 이용해 전체 시스템을 일괄 실행(run) 또는 일괄 종료 및 삭제(down)할 수 있는 도구다.
<br>본래 도커 엔진과 별개의 프로그램으로 존재했지만(구버전. docker-compose로 실행) 도커 측에서 도커 엔진을 설치할 때 도커 컴포즈도 패키지로 같이 설치되도록 방침을 바꾸었다(신버전. docker compose로 실행). 따라서 별도의 파일을 설치할 필요는 없다.<br><br>컴포즈 파일의 이름은 미리 정해진 docker-compose.yml이라는 이름을 사용해야 한다.<br>정의 파일은 한 폴더에 하나만 있을 수 있다.<br><br>정의 파일은 YAML 형식을 따른다.<br>
정의 파일에는 services와 networks, volumes를 기재할 수 있다.<br>

도커 컴포즈에서는 컨테이너가 모인 것을 '서비스'라고 부른다.<br>
공식 참조 문서에서는 컨테이너와 서비스라는 두 가지 용어가 함께 사용되는데, 그냥 모두 컨테이너로 이해하면 되므로 큰 문제는 없다.
<br><br><br><br><br>
<br>depends_on : 은 다른 서비스에 대한 의존 관계를 나타낸다. 컨테이너를 생성하는 순서를 정의할 수 있다. 예를 들어, penguin 컨테이너의 정의에 
depends_on
  - namgeuk


<br>라는 내용이 포함되어 있다면 namgeuk 컨테이너를 생성한 다음에 penguin 컨테이너를 만든다.
<br>restart : 컨테이너 종료 시 재시작 여부를 설정한다.
<br>
restart 설정 옵션

<br><br><br><br>build 항목에 정의된 컨텍스트 디렉토리에서 이미지를 빌드해 서비스의 컨테이너를 생성하도록 설정한다. image 항목을 기재한다면, build한 이미지의 이름은 image 항목에 기재된 것이 된다. 만약 image 항목을 기재하지 않는다면, 이미지의 이름은 [프로젝트 이름]:[서비스 이름]이 된다.<br>또한 build 항목에서는 도커 파일에 사용될 컨텍스트나 도커 파일의 이름, 도커 파일에서 사용될 인자 값을 설정할 수 있다.<br>services:
  web:
    build: ./composetest
    context: ./composetest
    dockerfile: myDockerfile
    args:
      HOST_NAME: web
      HOST_CONFIG: self_config
<br><br><br><br>도커 컴포즈는 생성된 컨테이너를 위해 기본적으로 브리지 타입의 네트워크를 생성한다. 그러나 YAML 파일에서 driver 항목을 정의해 서비스의 컨테이너가 브리지 네트워크가 아닌 다른 네트워크를 사용하도록 설정할 수 있다. 특정 드라이버에 필요한 옵션은 하위 항목인 driver_ops로 전달할 수 있다.<br>다음 예제는 docker-compose up -d 명령어로 컨테이너를 생성할 때 mynetwork라는 overlay 타입의 네트워크도 함께 생성하고, myservice 서비스의 네트워크가 mynetwork 네트워크를 사용하도록 설정한다. 단, overlay 타입의 네트워크는 스웜 모드나 주키퍼를 사용하는 환경이어야만 생성할 수 있다.<br>services:
  myservice:
    image: nginx
    networks:
      - mynetwork
networks:
  mynetwork:
    driver: overlay
    driver_opts:
      subnet: "255.255.255.0"
      IPAdress: "10.0.0.2"
<br><br><br><br><br><br>도커 컴포즈는 YAML 파일에서 volume, volumes-from 옵션 등을 사용하면 프로젝트마다 볼륨을 생성한다. 이때 external 옵션을 설정하면 볼륨을 프로젝트를 생성할 때마다 매번 생성하지 않고 기존 볼륨을 사용하도록 설정한다.<br>다음 예제에서 myvolume이라는 이름의 외부 볼륨을 web서비스의 컨테이너에 마운트한다.<br>volumes:
  myvolume:
    external: true
<br><br>
services:
  mysql000ex11:
    image: mysql:5.7
    networks:
      - wordpress000net1
    volumes:
	  - mysql000vol11:/var/lib/mysql
	restart: always
	environment:
	  MYSQL_ROOT_PASSWORD: myrootpass
	  MYSQL_DATABASE: wordpress000db
	  MYSQL_USER: wordpress000kun
	  MYSQL_PASSWORD: kunpass
	wordpress000ex12:
	  depends_on:
	    - mysql000ex11
	  image: wordpress
	  networks:
	    - wordpress000net1
	  volumes:
	    - wordpress000vol12:/var/www/html
	  ports:
	    - 8080:80
	  restart: always
	  environment:
	    WORDPRESS_DB_HOST: mysql1000ex11
	    WORDPRESS_DB_NAME: wordpress000db
	    WORDPRESS_DB_USER: wordpress000kun
	    WORDPRESS_DB_PASSWORD: wkunpass
networks:
  wordpress000net1:
volumes:
  mysql000vol11:
  wordpress000vol12:

<br><br>모든 docker compose 커맨드는 docker compose로 시작한다.<br>현재 작업 디렉토리에 도커 컴포즈 파일이 있다면 그냥 사용한다.<br>
그렇지 않다면, -f 옵션으로 컴포즈 파일의 경로를 지정하여야 한다.<br>docker-compose -f &lt;도커 컴포즈 파일 경로&gt; command &lt;옵션 ...&gt;<br><br><a data-tooltip-position="top" aria-label="도커 명령어 > ^8a9da8" data-href="도커 명령어#^8a9da8" href="resource\docker\도커-명령어.html#^8a9da8" class="internal-link" target="_self" rel="noopener nofollow">docker run 커맨드</a>와 유사하다.<br>정의 파일에 기재된 내용대로 이미지를 내려받고 컨테이너를 생성 및 실행한다. 정의 파일에는 네트워크나 볼륨에 대한 정의도 기재할 수 있어서 주변 환경을 한꺼번에 생성할 수 있다.<br><br>docker compose up 명령어의 끝에 서비스의 이름을 입력해 docker-compose.yml 파일에 명시된 특정 서비스의 컨테이너만 생성할 수 있다.<br>docker compose up &lt;도커 컴포즈에서 정의된 서비스 이름&gt;<br><br>docker compose run 명령어로 컨테이너를 생성할 수도 있다. docker compose up과의 차이점은 Interactive 셸을 사용할 수 있다는 것이다.<br><br>정의 파일에 기재된 컨테이너와 네트워크를 정지 및 삭제한다. 볼륨과 이미지는 삭제하지 않는다. 컨테이너와 네트워크 삭제 없이 종료만 하고 싶다면 stop 커맨드를 사용한다.<br><br><br>정의 파일에 기재된 컨테이너를 정지한다.<br><br>docker-compose.yml 파일의 포맷이 적절한지 검사한다.<br>
기본적으로 현재 디렉토리의 docker-compose.yml 파일을 검사한다.<br>docker compose config<br>아래와 같이  검사할 파일의 경로를 설정할 수 있다.<br> docker compose -f &lt;yml 파일 경로&gt; config<br><br>도커 컴포즈 파일에 기재된 서비스를 여러 개 복제하는 명령어이다.<br>docker compose scale &lt;도커 컴포즈 파일에 명시된 서비스 이름&gt;=&lt;복제하고자 하는 개수&gt;<br>예를 들어 도커 컴포즈 파일에 mysql이라는 서비스가 정의되어 있다면, 다음의 명령어를 통해 mysql 컨테이너 4개를 한 번에 만들 수 있다.<br>docker compose scale mysql=4<br><br>YAML 파일에 네트워크 항목을 정의하지 않으면 도커 컴포즈는 프로젝트 별로 브리지 타입의 네트워크를 생성한다. 생성된 네트워크의 이름은 {프로젝트 이름}_default로 설정되며, docker compose up 명령어로 생성되고 docker-compose down 명령어로 삭제된다.<br>서비스 내의 컨테이너는 --net-alias가 서비스의 이름을 갖도록 자동으로 설정되므로 이 네트워크에 속한 컨테이너는 서비스의 이름으로 서비스 내의 컨테이너에 접근할 수 있다.<br>예를 들어, web 서비스와 mysql 서비스가 각기 존재할 때 web 서비스의 컨테이너가 mysql이라는 호스트 이름으로 접근하면 mysql이라는 호스트 이름으로 접근하면 mysql 서비스의 컨테이너 중 하나의 IP로 변환(resolve)되며, 컨테이너가 여러 개 존재할 경우 라운드 로빈으로 연결을 분산한다.<br><br>도커 컴포즈는 컨테이너를 프로젝트 및 서비스 단위로 구분하므로 컨테이너의 이름은 일반적으로 다음과 같은 형식으로 정해진다.<br>[프로젝트 이름]_[서비스 이름]_[서비스 내에서 컨테이너의 번호]<br>도커 컴포즈는 기본적으로 docker-compose.yml 파일이 위치한 디렉터리의 이름을 프로젝트 이름으로 사용한다. 하지만 다음과 같이 -p 옵션을 사용해 프로젝트의 이름을 명시하고 명령어를 적용할 대상(=프로젝트)를 지정할 수 있다<br>docker compose -p &lt;project_name&gt; &lt;cmd&gt; &lt;option&gt;<br>하나의 프로젝트는 여러 개의 서비스로 구성되고, 각 서비스는 여러 개의 컨테이너로 구성된다. 더 나아가, 하나의 서비스에는 컨테이너의 복사본 여러 개가 포함되어 있을 수 있으므로(ex. 서버 컨테이너를 여러 개 올려 부하를 분산한다던가) 차례대로 증가하는 컨테이너의 번호를 붙여 서비스 내의 컨테이너를 구별한다.<br>ubuntu_mysql_1, ubuntu_mysql_2, ..., ubuntu_mysql_n<br>컨테이너의 복제품을 만드는 방법은 앞선 <a data-tooltip-position="top" aria-label="도커 컴포즈 > ^c5d140" data-href="도커 컴포즈#^c5d140" href="resource\docker\도커-컴포즈.html#^c5d140" class="internal-link" target="_self" rel="noopener nofollow">도커 컴포즈 커맨드</a> 단락에 기술되어 있다.<br><br>참고자료<br>]]></description><link>resource\docker\도커-컴포즈.html</link><guid isPermaLink="false">resource/Docker/도커 컴포즈.md</guid><pubDate>Sat, 22 Mar 2025 07:31:39 GMT</pubDate></item><item><title><![CDATA[도커 허브]]></title><description><![CDATA[<a class="tag" href="?query=tag:docker" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#docker</a> <a class="tag" href="?query=tag:참고도서/그림과_실습으로_배우는_도커_쿠버네티스" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/그림과_실습으로_배우는_도커_쿠버네티스</a> 
 <br><br><a href=".?query=tag:docker" class="tag" target="_blank" rel="noopener nofollow">#docker</a><br>docker hub<br><br>도커 허브란 공식적으로 운영되는 도커 레지스트리(도커 이미지를 배포하는 서비스)의 이름이다.<br>
도커 허브에는 공개된 <a data-href="이미지" href="resource\docker\이미지.html" class="internal-link" target="_self" rel="noopener nofollow">이미지</a>들이 모여 있으며 이중에서 원하는 것을 다운로드 받을 수 있다.<br>
반대로 사용자가 자신이 만든 이미지를 도커 허브에 업로드하는 것도 가능하다.<br>도커 허브에 등록된 이미지는 공식 이미지와 그렇지 않은 이미지로 나뉜다.<br><br>도커에서 직접 배포하거나 해당 소프트웨어를 개발 및 관리하는 기업이나 조직에서 제공하는 이미지를 일컫는다.<br>
이미지 선택이 쉬우며 보안도 챙길 수 있다는 장점이 있다.<br>공식 이미지가 아니더라도 유용하고 안전한 이미지도 많지만 경험이 쌓이지 않으면 신중하게 이미지를 선택하는 것이 좋다.<br><br>참고자료<br><a href=".?query=tag:참고도서\그림과_실습으로_배우는_도커_쿠버네티스" class="tag" target="_blank" rel="noopener nofollow">#참고도서/그림과_실습으로_배우는_도커_쿠버네티스</a> <br>]]></description><link>resource\docker\도커-허브.html</link><guid isPermaLink="false">resource/Docker/도커 허브.md</guid><pubDate>Sat, 22 Mar 2025 07:31:39 GMT</pubDate></item><item><title><![CDATA[마운트]]></title><description><![CDATA[<a class="tag" href="?query=tag:docker" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#docker</a> <a class="tag" href="?query=tag:참고도서/그림과_실습으로_배우는_도커_쿠버네티스" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/그림과_실습으로_배우는_도커_쿠버네티스</a> <a class="tag" href="?query=tag:참고도서/시작하세요_도커_쿠버네티스" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/시작하세요_도커_쿠버네티스</a> 
 <br><br><a href=".?query=tag:docker" class="tag" target="_blank" rel="noopener nofollow">#docker</a><br>mount<br><br>마운트란 '연결하다'라는 의미 그대로 대상을 연결해 운영체제 또는 소프트웨어의 관리하에 두는 일을 말한다.<br><a data-href="컨테이너" href="resource\docker\컨테이너.html" class="internal-link" target="_self" rel="noopener nofollow">컨테이너</a>는 그 특성상 폐기가 빈번하고(<a data-tooltip-position="top" aria-label="컨테이너 > ^66906a" data-href="컨테이너#^66906a" href="resource\docker\컨테이너.html#^66906a" class="internal-link" target="_self" rel="noopener nofollow">컨테이너의 생애 주기 참고</a>), 폐기 시 내부 데이터도 함께 소멸하기 때문에 보존되어야 하는 데이터를 외부로 대피시켜야 한다는 번거로움이 있다.<br>이러한 문제를 해결하기 위해 도커는 컨테이너와 호스트의 스토리지에 마운트하는 기능을 제공한다.<br>보통 운영체제나 스택 같이 주기적으로 업데이트되는 부분은 컨테이너 형태로 만들어 변경 사항이 있을 때마다 최신 컨테이너로 갈아끼우고(<a data-tooltip-position="top" aria-label="컨테이너 > ^66906a" data-href="컨테이너#^66906a" href="resource\docker\컨테이너.html#^66906a" class="internal-link" target="_self" rel="noopener nofollow">컨테이너의 생애 주기 참고</a>) 사용자 정보 같은 보존되어야 하는 데이터는 마운트된 공간에 보존한다.<br>이를 데이터 퍼시스턴시 data persistency라고 한다.<br>도커의 마운트는 볼륨 마운트와 바인드 마운트로 나뉜다.<br><br><br>볼륨이란 스토리지의 한 영역을 분할한 것을 말한다.<br>도커에서는 <a data-tooltip-position="top" aria-label="도커 명령어" data-href="도커 명령어" href="resource\docker\도커-명령어.html" class="internal-link" target="_self" rel="noopener nofollow">docker volume 명령어</a>로 볼륨을 만들 수 있으며, 이렇게 만들어진 볼륨은 도커 엔진이 관리하는 영역 내에 만들어지게 된다. 볼륨 마운트란 도커가 관리하는 볼륨에 마운트하는 방식이다.<br>이름만으로 관리가 가능하므로 다루기 쉽지만 볼륨에 비해 직접 조작하기 어려우므로 '임시 목적의 사용'이나 '자주 쓰지는 않지만 지우면 안되는 파일'을 두는 목적으로 많이 사용한다.<br>
<br>
장점

<br>도커 엔지의 관리 하에 있으므로 사용자가 파일 위치를 신경 쓸 필요가 없다.
<br>운영체제에 따른 의존성 문제가 일어나지 않는다.


<br>
단점

<br>도커 컨테이너를 경유하지 않고 직접 볼륨에 접근할 방법이 없다.
<br>백업을 하기 위해 복잡한 절차가 필요하다.


<br><br>어느 마운트 방식을 사용하든 스토리지 마운트는 <a data-tooltip-position="top" aria-label="도커 명령어 > ^8a9da8" data-href="도커 명령어#^8a9da8" href="resource\docker\도커-명령어.html#^8a9da8" class="internal-link" target="_self" rel="noopener nofollow">run 커맨드</a>의 옵션 형태로 지정한다. 마운트하려는 스토리지의 경로가 컨테이너 속 특정 경로와 연결되도록 설정하는 형태이다.<br>볼륨 마운트의 경우 마운트와 동시에 볼륨을 만들 수도 있지만 이 방법은 권장하지 않는다. 마운트 전에 별도로 볼륨을 먼저 생성하는 것이 좋다.<br>구체적인 커맨드는 아래와 같다.<br>docker run (생략) -v &lt;볼륨 이름:컨테이너_마운트_경로&gt; (생략)<br>만약 -v 옵션을 입력할 때 -v /root와 같이 볼륨의 이름을 기입하지 않으면 컨테이너가 자동으로 생성한다.<br><br>상술했듯이 컨테이너를 거치지 않으면 볼륨을 확인할 수 있는 방법이 없다.<br>따라서 <a data-tooltip-position="top" aria-label="도커 명령어 > ^d619a1" data-href="도커 명령어#^d619a1" href="resource\docker\도커-명령어.html#^d619a1" class="internal-link" target="_self" rel="noopener nofollow">docker volume inspect</a>나 <a data-tooltip-position="top" aria-label="도커 명령어" data-href="도커 명령어" href="resource\docker\도커-명령어.html" class="internal-link" target="_self" rel="noopener nofollow">docker container inspect</a> 같이 간접적으로 확인하는 방법이 아닌, 직접적으로 볼륨 내부를 확인하고 싶다면 아래와 같은 절차를 거쳐야 한다.<br>
<br>해당 볼륨에 마운트된 컨테이너가 -it 옵션으로 실행되어 docker exec -it &lt;container_name&gt; /bin/bash로 외부에서 조작이 가능한 경우, 그 컨테이너를 통해 볼륨을 확인한다.
<br>그렇지 않다면, -it 옵션, linux 운영체제 이미지를 사용하여, 관찰하고자 하는 볼륨에 마운트하여 컨테이너를 새로 만든다. 그리고 해당 컨테이너에 docker exec -it &lt;container_name&gt; /bin/bash를 사용하여 볼륨을 확인할 수 있다.
<br><br>볼륨 자체를 복사하는 것은 불가능하다.<br>따라서 볼륨을 확인할 때처럼 별도의 리눅스 컨테이너를 연결하여 볼륨의 내용을 압축해 저장하여야 한다.<br>아래는 볼륨 백업 커맨드의 예시이다.<br>docker run --rm -v &lt;백업할 볼륨명:/source&gt; -v &lt;백업_저장_폴더명:/target&gt; busybox tar cvzf /target/ 백업파일이름.tar.gz -C /source<br>
<br>run 커맨드로 리눅스 운영체제(busybox) 컨테이너를 실행한다.
<br>--rm : 이 컨테이너는 실행 후 바로 삭제할 예정이므로 옵션에 --rm을 추가했다.
<br>-v &lt;백업할 볼륨명:/source&gt; : 백업할 볼륨을 컨테이너의 /source에 마운트한다.
<br>-v &lt;백업_저장_폴더명:/target&gt; : 압축된 백업 파일을 저장할 호스트의 디렉토리를 마운트한다.
<br>tar cvzf /target/백업파일이름.tar.gz -C /source

<br>tar은 tar 압축을 사용하는 명령어이다.
<br>czvf : 압축 옵션
<br>-C /source : 압축 대상을 /source로 지정
<br>/target/백업파일이름.tar.gz : 압축 결과물을 /target/의 백업파일이름.tar.gz 파일로 저장


<br><br>바인드 마운트는 도커가 설치된 컴퓨터의 문서 폴더 또는 바탕화면 폴더 등 도커에서 관리하지 않는 영역의 기존 디렉터리를 컨테이너에 마운트하는 방식이다. 디렉터리가 아닌 파일 단위로도 마운트가 가능하다.<br>폴더(디렉토리) 속에 파일을 직접 두거나 열어볼 수 있기 떄문에 자주 사용하는 파일을 두는 데 사용한다.<br>
<br>장점

<br>도커가 관리하지 않는 어디라도 파일을 둘 수 있다.
<br>기존과 동일한 방식으로 파일을 사용할 수 있으므로 다른 소프트웨어를 사용해 쉽게 편집할 수 있다.


<br><br>아래와 같은 커맨드로 사용한다.<br>docker run (생략) -v &lt;호스트의 마운트하고자하는 디렉토리 경로:컨테이너 마운트 경로&gt; (생략)<br><br>컨테이너를 생성할 때 --volumes-from 옵션을 설정하면 -v 또는 --volume 옵션을 적용한 컨테이너의 볼륨 디렉토리를 공유할 수 있다. 이는 직접 볼륨을 공유하는 것이 아닌 -v 옵션을 적용한 컨테이너를 통해 공유하는 것이다.<br>docker run -it --name &lt;볼륨을 공유받을 컨테이너의 이름&gt; --volumes-from &lt;볼륨을 공유해 줄 컨테이너의 이름&gt; &lt;image name&gt;<br><br>컨테이너 안의 파일이 마운트된 디렉토리로 복사되는 것이 아닌, 아예 같은 디렉토리로 처리된다는 점에 유의해야 한다.<br>-v 옵션에 존재하지 않는 호스트의 디렉토리를 전달하면 해당 디렉토리가 생성되며 컨테이너 상의 파일이 옮겨온다.<br>만약 호스트와 컨테이너 모두에 디렉토리가 존재하고 해당 컨테이너 안에 파일이 있다면 컨테이너의 디렉토리가 호스트의 디렉토리로 덮어씌워진다(즉, 호스트의 경로가 우선권을 가진다).<br><br>디스크가 아닌 주 메모리 영역을 마운트한다. 디스크보다 훨씬 빠른 속도로 읽고 쓰기가 가능하기 때문에 접근 속도를 높일 목적으로 사용하지만 도커 엔진이 정지되거나 호스트가 재부팅하면 소멸한다.<br><br>두 가지 마운트 방식의 차이점은<br>
<br>간단한지 복잡한지
<br>호스트 컴퓨터에서 파일을 다룰 필요가 있는지
<br>환경의 의존성을 배제해야 하는지
<br>이다.<br>보통 파일을 직접 편집해야 할 일이 많다면 바인드 마운트, 그렇지 않다면 볼륨 마운트를 사용한다.<br><br>스테이트리스 stateless : 컨테이너가 아닌 외부에 데이터를 저장하고 컨테이너는 그 데이터로 동작하도록 설계하는 것. 다르게 말하자면, 컨테이너 자체는 상태가 없고 상태를 결정하는 데이터는 외부로부터 제공받는다.<br>스테이트 풀 stateful : 컨테이너 자체가 데이터를 포함하고 있어 상태가 존재하는 경우<br><br>--mount 옵션은 -v 옵션을 대체하여 사용할 수 있는 옵션이다.<br>
<br>
볼륨 마운트의 경우<br>
docker run -it --name &lt;컨테이너의 이름&gt; --mount type=volume,source=&lt;볼륨의 이름&gt;,target=&lt;마운트할 컨테이너의 경로&gt; &lt;이미지 이름&gt;

<br>
바인드 마운트의 경우<br>
docker run -it --name &lt;컨테이너의 이름&gt; --mount type=bind,source=&lt;호스트의 디렉토리&gt;,target=&lt;마운트할 컨테이너의 경로&gt; &lt;이미지 이름&gt;

<br><br>참고자료<br><a href=".?query=tag:참고도서\그림과_실습으로_배우는_도커_쿠버네티스" class="tag" target="_blank" rel="noopener nofollow">#참고도서/그림과_실습으로_배우는_도커_쿠버네티스</a><br>
<a href=".?query=tag:참고도서\시작하세요_도커_쿠버네티스" class="tag" target="_blank" rel="noopener nofollow">#참고도서/시작하세요_도커_쿠버네티스</a> <br>]]></description><link>resource\docker\마운트.html</link><guid isPermaLink="false">resource/Docker/마운트.md</guid><pubDate>Sat, 22 Mar 2025 07:31:39 GMT</pubDate></item><item><title><![CDATA[이미지]]></title><description><![CDATA[<a class="tag" href="?query=tag:docker" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#docker</a> <a class="tag" href="?query=tag:참고도서/그림과_실습으로_배우는_도커_쿠버네티스" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/그림과_실습으로_배우는_도커_쿠버네티스</a> <a class="tag" href="?query=tag:참고도서/시작하세요_도커_쿠버네티스" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/시작하세요_도커_쿠버네티스</a> 
 <br><br><a href=".?query=tag:docker" class="tag" target="_blank" rel="noopener nofollow">#docker</a><br>container의 설계도<br><br><a data-href="도커" href="resource\docker\도커.html" class="internal-link" target="_self" rel="noopener nofollow">도커</a>의 <a data-href="컨테이너" href="resource\docker\컨테이너.html" class="internal-link" target="_self" rel="noopener nofollow">컨테이너</a>를 만들기 위해 사용되는 설정 파일이다. 이미지를 사용하면 컨테이너를 간편하게 만들 수 있기 때문에 배포에 용이하다.<br><a data-href="Dockerfile" href="resource\docker\dockerfile.html" class="internal-link" target="_self" rel="noopener nofollow">Dockerfile</a> 스크립트를 작성하고 이 스크립트를 빌드해 이미지를 직접 만들 수도 있다.<br>거꾸로, 컨테이너로부터 이미지를 추출할 수도 있다(<a data-tooltip-position="top" aria-label="도커 명령어 > ^1afd73" data-href="도커 명령어#^1afd73" href="resource\docker\도커-명령어.html#^1afd73" class="internal-link" target="_self" rel="noopener nofollow">도커 명령어의 commit 참조</a>). 이 방법을 사용하면<br>
<br>이미지로부터 컨테이너를 만듬 
<br>컨테이너에서 변경 사항을 적용
<br>해당 컨테이너로부터 이미지를 추출하면 이미지에도 변경사항이 적용
<br>따라서 변경 사항을 이미지의 형태로 편하게 배포 가능
<br>하다는 장점이 있다.<br><br>도커 이미지는 아래와 같은 구조를 가지고 있다.<br>&lt;저장소 이름&gt;/&lt;이미지 이름&gt;:&lt;태그&gt;<br>
<br>저장소(Repository) 이름 : 이미지가 저장된 장소. 저장소 이름이 명시되지 않은 이미지는 도커 허브의 공식 이미지를 뜻한다.
<br>이미지 이름 : 해당 이미지가 어떤 역할을 하는 지 나타낸다. 생략할 수 없다.
<br>태그 : 이미지의 버전 또는 리비전(Revision) 관리에 사용한다. 태그를 생략하면 도커 엔진은 이미지의 버전을 latest라고 인식한다.
<br><br>도커 이미지는 (직접 Dockerfile을 건드리거나 하지 않는다면) 수정이 불가능한 읽기 전용 레이어이다.<br>
반대로, 도커 컨테이너 레이어는 임의로 수정이 가능하다.<br>도커 컨테이너는 도커 이미지 레이어 위에 컨테이너 레이어가 올라간 구조이다.<br><br>참고자료<br><a href=".?query=tag:참고도서\그림과_실습으로_배우는_도커_쿠버네티스" class="tag" target="_blank" rel="noopener nofollow">#참고도서/그림과_실습으로_배우는_도커_쿠버네티스</a><br>
<a href=".?query=tag:참고도서\시작하세요_도커_쿠버네티스" class="tag" target="_blank" rel="noopener nofollow">#참고도서/시작하세요_도커_쿠버네티스</a><br>]]></description><link>resource\docker\이미지.html</link><guid isPermaLink="false">resource/Docker/이미지.md</guid><pubDate>Sat, 22 Mar 2025 07:31:39 GMT</pubDate></item><item><title><![CDATA[컨테이너]]></title><description><![CDATA[<a class="tag" href="?query=tag:docker" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#docker</a> <a class="tag" href="?query=tag:참고도서/그림과_실습으로_배우는_도커_쿠버네티스" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/그림과_실습으로_배우는_도커_쿠버네티스</a> 
 <br><br><a href=".?query=tag:docker" class="tag" target="_blank" rel="noopener nofollow">#docker</a><br>container<br><br><a data-href="도커" href="resource\docker\도커.html" class="internal-link" target="_self" rel="noopener nofollow">도커</a>에 의해 생성된 운영체제의 다른 영역과 독립된 공간.<br>
<a data-href="이미지" href="resource\docker\이미지.html" class="internal-link" target="_self" rel="noopener nofollow">이미지</a>를 통해 생성한다. 반대로, 기존의 컨테이너로부터 <a data-href="이미지" href="resource\docker\이미지.html" class="internal-link" target="_self" rel="noopener nofollow">이미지</a>를 추출할 수 있다. 이를 통해 변경사항을 빠르게 배포할 수 있다.<br><img alt="컨테이너의 구조.png" src="lib\media\컨테이너의-구조.png" style="width: 700px; max-width: 100%;"><br>운영체제는 커널 + 주변 영역의 구조로 이루어져 있는데, 컨테이너에는 주변 영역만 포함되고 커널은 호스트의 것을 빌려쓴다. 이를 통해 가벼움을 확보할 수 있다.<br>용량이 허용하는 한 컨테이너는 얼마든지 올릴 수 있다.<br><br>일반적으로 컨테이너는 한 번 생성한 것을 오랫동안 유지보수하기보다는, 오래된 컨테이너는 폐기하고 업데이트가 반영된 최신 이미지를 사용하여 새로운 컨테이너를 만들어 쓴다.<br>이는 애초에 도커가 여러 개의 컨테이너를 동시에 돌리는 상황을 가정하여 만들어졌기 때문으로, 이러한 상황에서는 업데이트 사항을 컨테이너 하나하나에 일일히 적용하기 보다는 새로운 컨테이너를 사용하는 방식이 비용이 적다.<br>이러한 컨테이너의 제작 -&gt; 실행 -&gt; 종료 -&gt; 폐기 -&gt; 제작 -&gt; ... 과정을 컨테이너의 생애 주기라 부른다.<br><br>컨테이너에 stop, start 등의 명령어를 사용할 때 도커 엔진은 해당 명령을 수행하기 위해 해당 컨테이너의 pid 1번에 signal을 전달한다. 컨테이너의 pid 1번 프로세스가 종료하면, 도커 엔진은 해당 컨테이너가 동작을 마친 것으로 간주하고 해당 컨테이너를 exited 상태로 만든다. 주의할 점은 도커는 foreground로만 동작하는 프로세스만 인식한다는 것이다. background로 ENTRYPOINT를 지정하면 해당 컨테이너가 즉각 종료되어 버릴 수 있다.<br>따라서 서버(ex. nginx) 같이 무한히 실행되어야 하는 프로세스의 경우, foreground로 실행시켜야 해당 서비스를 제공하는 컨테이너가 지속적인 생명력을 가질 수 있다.<br>본 문단은 chatgpt 발 정보이므로 오류가 있을 수 있습니다.<br><br>참고자료<br><a href=".?query=tag:참고도서\그림과_실습으로_배우는_도커_쿠버네티스" class="tag" target="_blank" rel="noopener nofollow">#참고도서/그림과_실습으로_배우는_도커_쿠버네티스</a> <br>]]></description><link>resource\docker\컨테이너.html</link><guid isPermaLink="false">resource/Docker/컨테이너.md</guid><pubDate>Sat, 22 Mar 2025 07:31:39 GMT</pubDate><enclosure url="lib\media\컨테이너의-구조.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;lib\media\컨테이너의-구조.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Dockerfile]]></title><description><![CDATA[<a class="tag" href="?query=tag:docker" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#docker</a> <a class="tag" href="?query=tag:uncomplete" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#uncomplete</a> <a class="tag" href="?query=tag:참고도서/그림과_실습으로_배우는_도커_쿠버네티스" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/그림과_실습으로_배우는_도커_쿠버네티스</a> <a class="tag" href="?query=tag:참고도서/시작하세요_도커_쿠버네티스" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/시작하세요_도커_쿠버네티스</a> 
 <br><br><a href=".?query=tag:docker" class="tag" target="_blank" rel="noopener nofollow">#docker</a> <a href=".?query=tag:uncomplete" class="tag" target="_blank" rel="noopener nofollow">#uncomplete</a> <br>Dockerfile<br><br>Dockerfile은 <a data-href="이미지" href="resource\docker\이미지.html" class="internal-link" target="_self" rel="noopener nofollow">이미지</a>를 직접 만들기 위한 설정 파일이다.<br>Dockerfile 스크립트에는 토대가 될 이미지나 실행할 명령어 등을 기재한다.<br>이 파일을 호스트 컴퓨터의 이미지 재료가 들어있는 폴더(위치는 어디라도 상관없다.)에 넣는다.<br>
재료 폴더에는 그 외 컨테이너에 넣을 파일을 함께 둔다. 실제 컨테이너를 만들 필요는 없다.<br><br><br>생성할 이미지의 베이스가 될 이미지를 뜻한다. FROM 명령어는 Dockderfile을 작성할 때 반드시 한 번 이상 입력해야 한다. 이미지 이름의 포맷은 docker run 명령어에서 이미지 이름을 사용했을 때와 같다. 사용하려는 이미지가 도커에 없다면 자동으로 pull 한다.<br><br>이미지를 생성한 개발자의 정보를 나타낸다. 일반적으로 Dockefile을 작성한 사람과 연락할 수 있는 메일 등을 입력한다. 단, MAINTAINER는 도커 1.13.0 버전 이후로 사용하지 않는다. 대신 아래와 같은 LABEL로 교체해 표현할 수 있다.<br>LABEL maintainer "alicek106 &lt;alicek106@naver.com&gt;"<br><br>이미지에 메타데이터를 추가한다. 메타데이터는 '키:값'의 형태로 저장되며, 여러 개의 메타데이터가 저장될 수 있다. 추가된 메다데이터는 docker inspect 명령어로 이미지의 정보를 구해서 확인할 수 있다.<br>docker images --filter "label=... <a data-tooltip-position="top" aria-label="도커 명령어 > ^2a04f8" data-href="도커 명령어#^2a04f8" href="resource\docker\도커-명령어.html#^2a04f8" class="internal-link" target="_self" rel="noopener nofollow">명령어</a>를 통해 특정 라벨만을 가지는 이미지를 출력할 수 있다.<br><br>이미지를 만들기 위해 컨테이너 내부에서 명령어를 실행한다. 주의할 사항으로, 이미지를 빌드할 때 별도의 입력을 받아야 하는 RUN이 있다면 build 명령어는 이를 오류로 간주하고 빌드를 종료한다.<br>RUN 명령어에 ["/bin/bash", "echo hello &gt;&gt; test2.html"]과 같이 입력하면 /bin/bash 셸을 이용해 echo hello &gt;&gt; test2.html을 실행한다. Dockerfile의 일부 명령어는 이저철 배열의 형태로 사용할 수 있다. RUN의 경우에는 다음과 같은 형태로 사용된다.<br>RUN ["실행 가능한 파일", "명령줄 인자 1", "명령줄 인자 2, ... ]<br>이는 JSON 배열의 입력 형식을 따르기 때문에 JSON 형식과 일치해야 한다. 단, JSON 배열 형태로 Dockerfile의 명령어를 사용하면 셸을 실행하지 않는다. 예를 들어, ["echo", "$MY_ENV"]는 $MY_ENV 환경변수를 사용하지 않는다. 이 형태로 셸을 사용하려면  ["sh", "-c", "echo $MY_ENV]와 같이 사용하는 것이 좋다.<br><br>파일을 이미지에 추가한다. 추가하는 파일은 Dockerfile이 위치한 디렉터리인 컨텍스트(Context)에서 가져온다.<br>ADD 명령어는 JSON 배열의 형태로 ["추가할 파일 이름", ... "컨테이너에 추가될 위치"]와 같이 사용할 수 있다. 추가할 파일명은 여러 개를 지정할 수 있으며 배열의 마지막 원소가 컨테이너에 추가될 위치이다.<br><br>COPY 또한 로컨 리렉터리에서 읽어들인 컨텍스트로부터 이미지에 파일을 복사하는 역할을 한다.<br>
COPY를 사용하는 형식은 ADD와 같다.<br>COPY test.html /home/
COPY ["test.html", "/home/"]
<br>ADD와 COPY의 차이점<br>COPY는 로컬의 파일만 이미지에 추가할 수 있지만 ADD는 외부 URL 및 tar 파일에서도 파일을 추가할 수 있다는 점에서 다르다.<br>즉, COPY의 기능이 ADD에 포함되는 셈이다.<br>
예를 들어, ADD 명령어는 다음과 같이 사용할 수 있다.<br>ADD https://raw.github...../test.html /home<br>또는 tar 파일을 추가할 수도 있다. 그러나 tar 파일을 그대로 추가하는 것이 아니라 tar 파일을 자동으로 해체해서 추가한다. 다음 명령어는 test.tar 파일을 이미지의 /home 디렉터리에 푼다.<br>ADD test.tar /home<br>그러나 ADD를 사용하는 것은 그다지 권장하지 않는다. 그 이유는 ADD로 URL이나 tar 파일을 추가할 경우 이미지에 정확히 어떤 파일이 추가될지 알 수 없기 때문이다. 그에 비애 COPY는 로컬 컨텍스트로부터 파일을 직접 추가하기 때문에 빌드 시점에서도 어떤 파일이 추가될지 명확하다.<br><br>명령어를 실행할 디렉터리를 나타낸다. 배시 셸에서 cd 명령어를 입력하는 것과 같은 기능을 한다. 예를 들어, WORKDIR /var/www/html이 실행되고 나서 RUN touch test를 실행하면 /var/www/html 디렉터리에 test 파일이 생성된다.<br><br>Dockerfile의 빌드로 생성된 이미지에서 노출할 포트를 설정한다. 그러나 EXPOSE를 설정한 이미지로 컨테이너를 생성했다고 해서 반드시 이 포트가 호스트의 포트와 바인딩되는 것은 아니며, 단지 컨테이너의 80번 포트를 사용할 것임을 나타내는 것 뿐이다. EXPOSE는 컨테이너를 생성하는 run 명령어에서 모든 노출된 컨테이너의 포트를 호스트에 퍼블리시(publish)하는 <a data-tooltip-position="top" aria-label="도커 명령어 > ^ec27f8" data-href="도커 명령어#^ec27f8" href="resource\docker\도커-명령어.html#^ec27f8" class="internal-link" target="_self" rel="noopener nofollow">-P 플래그</a>와 함께 사용된다.<br>Dockerfile을 작성하는 개발자로서는 EXPOSE를 이용해 이미지가 실제로 사용될 때 어떤 포트가 사용돼야 하는지 명시할 수 있으며, 이미지를 사용하는 입장에서는 컨테이너의 애플리케이션이 컨테이너 내부에서 어떤 포트를 사용하는지 알 수 있게 된다.<br><br>CMD는 컨테이너가 시작될 때마다 실행할 명령어(커맨드)를 설정하며, Dockerfile에서 한 번만 사용할 수 있다. Dockerfile에서 CMD를 명시함으로서 이미지에 apachectl -DFOREGROUND를 내장하면 컨테이너를 생성할 때 별도의 커맨드를 입력하지 않아도 이미지에 내장된 apachectl -DFOREGROUND가 적용되어 컨테이너가 시작될 때 자동으로 아파치 웹서버가 실행된다. 그리고 아파치 웹 서버는 하나의 터미널을 차지하는 포크라운드 모드로 실행되기 때문에 -d 옵션을 사용해 detached 모드로 컨테이너를 생성해야 한다.<br>즉 CMD는 run 명령어의 이미지 이름 뒤에 입력하는 커맨드와 같은 역할을 하지만 docker run 명령어에서 커맨드 명령줄 인자를 입력하면 Dockerfile에서 사용한 CMD의 명령어는 run의 커맨드로 덮어 쓰인다. 이와 마찬가지로 ubuntu:14.04 이미지에 기본적으로 내장된 커맨드인 /bin/bash 또한 Dockerfile의 CMD에 의해 덮어 씌인다.<br>CMD의 입력은 JSON 배열 형태인 ["실행 가능한 파일",  "명령줄 인자 1", "명령줄 인자 2" ...] 형태로도 사용할 수 있다.<br><br>ENTRYPOINT와 CMD의 차이점<br>entrypoint는 커맨드와 동일하게 컨테이너가 시작될 때 수행할 명령을 지정한다는 점에서 같다. 그러나 entrypoint는 커맨드를 인자로 받아 사용할 수 있는 스크립트의 역할을 할 수 있다는 점에서 다르다.<br>entrypoint가 설정되지 않았다면 cmd에 설정된 명령어를 그대로 실행하지만 entrypoint가 설정되었다면 cmd는 단지 entrypoint에 대한 인자의 기능을 한다.<br># # entrypoint: 없음, cmd: /bin/bash
# docker run -it --name no_entrypoint ubuntu:14.04 /bin/bash
-&gt; bash 쉘이 실행
<br># # entrypoint: echo, cmd: /bin/bash
# docker run -i -t --entrypoint="echo" --name yes_entrypoint ubuntu:14.04 /bin/bash
-&gt; /bin/bash가 출력. 즉, /bin/bash는 echo의 인자로 넘어감

<br><br>JSON 배열 형태가 아닌 CMD와 ENTRYPOINT를 사용하면 실제로 이미지를 생성할 때 cmd와 entrypoint에 /bin/sh -c가 앞에 추가된다.<br>따라서 CMD 또는 ENTRYPOINT에 설정하려는 명령어를 /bin/sh로 사용할 수 없다면 JSON 배열의 형태로 명령어를 설정해야 한다.<br># 예시

CMD echo tset
# -&gt; /bin/sh -c echo test

ENTRYPOINT /entrypoint.sh
# -&gt; /bin/sh -c /entrypoint.sh
<br>CMD와  ENTRYPOINT를 JSON 형태로 명령어를 입력하면 입력된 명령어가 그대로 이미지에서 사용된다.<br><br>Dockerfile에서 사용될 환경 변수를 지정한다. 설정한 환경변수는 ${ENV_NAME} 또는 $ENV_NAME의 형태로 사용할 수 있다. 이 환경변수는 Dockerfile 뿐 아니라 이미지에도 저장되므로 빌드된 이미지로 컨테이너를 생성하면 이 환경 변수를 사용할 수 있다.<br>run 명령어에서 -e 옵션을 사용해 같은 이름의 환경변수를 사용하면 기존의 값은 덮어씌어진다.<br>Dockerfile에서 환경변수의 값을 사용할 때 배시 셸에서 사용하는 것처럼 값이 설정되지 않는 경우와 설정된 경우를 구분해 사용할 수 있다.<br>쉘 상에서 ${env_name:-value}는 env_name이라는 환경변수의 값이 설정되지 않았으면 이 환경변수의 값을 value로 사용한다. 반대로 ${env_name:+value}는 env_name의 값이 설정돼 있으면 value를 값으로 사용하고, 값이 설정되지 않았다면 빈 문자열을 생성한다.<br><br>빌드된 이미지로 컨테이너를 생성했을 때 호스트와 공유할 컨테이너 내부의 디렉터리를 설정합니다. VOLUME ["/home/dir", "home/dir2"]처럼 JSON 배열의 형식으로 여러 개를 사용하거나 VOLUME /home/dir /home/dir2로도 사용할 수 있다.<br>VOLUME이 포함된 Dockerfile로 이미지를 빌드한 뒤 컨테이너를 생성하면 자동으로 볼륨이 생성된다.<br><br>build 명령어를 실행할 때 추가로 입력을 받아 Dockerfile 내에서 사용될 변수의 값을 설정한다. 다음 Dockefile은 build 명령어에서 my_arg와 my_arg_2라는 이름의 변수를 추가로 입력받을 것이라고 ARG를 통해 명시한다. ARG의 값은 기본적으로 build 명령어에서 입려받아야 하지만 다음의 my_arg_2와 같이 기본값을 지정할수도 있다.<br>FROM ubuntu:14.04
ARG my_arg
ARG my_arg_2=value2
RUN touch ${my_arg}/mytouch
<br><a data-tooltip-position="top" aria-label="도커 명령어 > ^fb817c" data-href="도커 명령어#^fb817c" href="resource\docker\도커-명령어.html#^fb817c" class="internal-link" target="_self" rel="noopener nofollow">build 명령어</a>를 실행할 때 --build-arg 옵션을 사용해 Dockerfile의 ARG에 값을 입력할 수 있다. 입력하는 형식은 &lt;키&gt;=&lt;값&gt;과 같이 쌍을 이뤄야 한다.<br># docker build --build0-arg my_arg=/home -t myarg:0.0 ./<br>ARG와 ENV의 값을 사용하는 방법은 ${}로 같으므로 Dockerfile에서 ARG로 설정한 변수를 ENV에서 같은 이름으로 다시 정의하면 --build-arg 옵션에서 설정하는 값은 ENV에 의해 덮어쓰여진다.<br>위의 Dockerfile 예제에서는 $(my_arg)의 디렉터리에 mytouch라는 파일을 생성했기 때문에 빌드된 이미지로 컨테이너를 생성해 확인하면 mytouch라는 이름의 파일을 확인할 수 있다.<br># docker run -it --name arg_test myarg:0.0
root@ccdlakjldj:/# ls /home/mytouch
/home/mytouch
<br><br>USER로 컨테이너 내에서 사용될 사용자 계정의 이름이나 UID를 설정하면 그 아래의 명령어는 해당 사용자 권한으로 실행된다. 일반적으로 RUN으로 사용자의 그룹과 계정을 생성한 뒤 사용한다. 루트 권한이 필요하지 않다면 USER를 사용하는 것을 권장한다.<br>RUN groupadd -r author &amp;&amp; useradd -r -g author alicek106
USER alicek106
<br>
기본적으로 컨테이너 내부에서는 root 사용자를 사용하도록 설정된다. 이는 컨테이너가 호스트의 root 권한을 가질 수 있다는 것을 의미하기 때문에 보안 측면에서 매우 바람직하지 않다. 예를 들어 root가 소유한 호스트의 디렉터리를 컨테이너에 공유했을 때, 컨테이너 내부에서는 공유된 root 소유의 디렉터리를 마음대로 조작할 수도 있다.<br>
때문에 컨테이너 애플리케이션을 최종적으로 배포할 때는 컨테이너 내부에서 새로운 사용자를 새롭게 생성해 사용하는 것을 권장한다. docker run 명령어 자체에서도 --user 옵션을 지원하지만, 가능하다면 이미지 자체에 root가 아닌 다른 사용자를 설정해놓는 것이 좋다.
<br><br><br><br><br><br><a data-tooltip-position="top" aria-label="도커 명령어 > ^fb817c" data-href="도커 명령어#^fb817c" href="resource\docker\도커-명령어.html#^fb817c" class="internal-link" target="_self" rel="noopener nofollow">이미지 빌드</a>를 시작하면 도커는 가장 먼저 빌드 컨텍스트를 읽어들인다. 빌드 컨텍스트는 이미지를 생성하는 데 필요한 각종 파일, 소스 코드, 메타 데이터 등을 담고 있는 디렉터리를 의미하며, Dockerfile이 위치한 디렉터리가 빌드 컨텍스트가 된다.<br>빌드 컨텍스트는 Dockerfile에서 빌드될 이미지에 파일을 추가할 때 사용된다. Dockerfile에서 이미지에 파일을 추가하는 방법은 앞에서 설명한 ADD 외에도 COPY가 있는데, 이 명령어들은 빌드 컨테스트의 파일을 이미지에 추가한다.<br>컨테스트에 대한 정보는 이미지를 빌드할 때 출력된 내용 중 맨 위에 위치한다.<br>컨텍스트는 build 명령어의 맨 마지막에 지정된 위치에 있는 파일을 전부 포함한다. 깃(Git)과 같은 외부 URL에서 Dockerfile을 읽어들인다면 해당 저장소(Repository)에 있는 파일과 서브 모듈을 포함한다.<br>따라서 Dockerfile이 위치한 곳에는 이미지 빌드에 필요한 파일만 있는 것이 바람직하다. 컨텍스트는 단순 파일 뿐 아니라 하위 디렉토리도 전부 포함하게 되므르 빌드에 불필요한 파일이 포함된다면 빌드 속도가 느려질 뿐더러 호스트의 메모리를 지나치게 점유할 수도 있다.<br><br>상기한 문제를 방지하기 위해 .dockerignore라는 파일을 작성할 수 있다. 이미지 빌드 시 .dockerignore에서 명시된 파일은 컨텍스트에서 제외된다.<br>.dockerignore 파일은 컨텍스트의 최상위 경로, 즉 build 명령어에서 맨 마지막에 오는 경로인 Dockerfile이 위치한 경로와 같은 곳에 위치해야 한다.<br>다음은 .dockerignore 파일의 예시이다.<br>test2.html
*.html
*/*.html
test.htm?
<br>컨텍스트에서 제외할 파일의 경로는 Dockerfile이 존재하는 경로를 기준으로 한다. 예를 들어, build 명령어에서 설정한 경로가 현재 디렉터리이고 /home/alicek106이라면 *.html은 /home/alicek106/*.html에 해당하는 모든 파일을 뜻한다.<br>test.htm?은 test.htm을 접두어로 두고 ? 자리에 임의의 1자리 문자가 들어가는 파일을 제외한다는 뜻이다. .dockerignore에 test.htm?을 지정하면 test.htma, test.htmb, ... 등이 컨텍스트에서 제외된다.<br>.dockerignore의 제외 목록에 해당하지만 특수한 파일만 포함하도록 설정하고 싶다면 !를 사용한다.<br>
!는 특정 파일을 제외하지 않음을 뜻한다. 다음 예시는 확장자가 html인 파일을 모두 제외하지만 test로 시작하는 html 파일은 컨텍스트에서 제외하지 않는다.<br>*.html
!test*.html
<br><br><br><br><br>참고자료<br><a href=".?query=tag:참고도서\그림과_실습으로_배우는_도커_쿠버네티스" class="tag" target="_blank" rel="noopener nofollow">#참고도서/그림과_실습으로_배우는_도커_쿠버네티스</a><br>
<a href=".?query=tag:참고도서\시작하세요_도커_쿠버네티스" class="tag" target="_blank" rel="noopener nofollow">#참고도서/시작하세요_도커_쿠버네티스</a><br>]]></description><link>resource\docker\dockerfile.html</link><guid isPermaLink="false">resource/Docker/Dockerfile.md</guid><pubDate>Sat, 22 Mar 2025 07:31:40 GMT</pubDate></item><item><title><![CDATA[가상 상속]]></title><description><![CDATA[<a class="tag" href="?query=tag:language/cpp" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#language/cpp</a> <a class="tag" href="?query=tag:참고도서/윤성우의_열혈_cpp_프로그래밍" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/윤성우의_열혈_cpp_프로그래밍</a> 
 <br><br><a href=".?query=tag:language\cpp" class="tag" target="_blank" rel="noopener nofollow">#language/cpp</a><br><br>
#include &lt;iostream&gt;
using namespace std;

class Base
{
	public :
		Base() { cout&lt;&lt;"Base Constructor"&lt;&lt;endl; }
		void SimpleFunc() { cout&lt;&lt;"BaseOne"&lt;&lt;endl; }
};

class MiddleDerivedOne : virtual public Base
{
	public :
		MiddleDerivedOne() : Base()
		{
			cout&lt;&lt;"MiddleDerivedOne Constructor"&lt;&lt;endl;
		}
		void MiddleFuncOne()
		{
			SimpleFunc();
			cout&lt;&lt;"MiddleDerivedOne"&lt;&lt;endl;
		}
};

class MiddleDerivedTwo : virtual public Base
{
	public :
		MiddleDerivedTwo() : Base()
		{
			cout&lt;&lt;"MiddleDerivedTwo Constructor"&lt;&lt;endl;
		}
		void MiddleFuncTwo()
		{
			SimpleFunc();
			cout&lt;&lt;"MiddleDerivedTwo"&lt;&lt;endl;
		}
};

class LastDerived : public MiddleDerivedOne, public MiddleDerivedTwo
{
	public :
		LastDerived() : MiddleDerivedOne(), MiddleDerivedTwo()
		{
			cout&lt;&lt;"LastDerived Constructor"&lt;&lt;endl;
		}
		void ComplexFunc()
		{
			MiddleFuncOne();
			MiddleFuncTwo();
			SimpleFunc();
		}
};

  

int main(void)
{
	cout&lt;&lt;"객체 생성 전 ..... "&lt;&lt;endl;
	
	LastDerived ldr;

	cout&lt;&lt;"객체 생성 후 ..... "&lt;&lt;endl;

	ldr.ComplexFunc();

	return (0);
}

<br><a data-href="다중 상속" href="resource\language\c++\다중-상속.html" class="internal-link" target="_self" rel="noopener nofollow">다중 상속</a>에서 하나의 클래스가 다른 클래스를 간접적으로 여러 번 상속받는 경우, 부모 클래스의 생성자, 소멸자를 여러 번 호출하며, 멤버 변수도 복제되어 여러 번 상속받는다는 문제가 존재한다.<br><a data-href="virtual 키워드" href="resource\language\c++\virtual-키워드.html" class="internal-link" target="_self" rel="noopener nofollow">virtual 키워드</a>를 사용하여 가상으로 클래스를 상속할 수 있으며, 가상 상속하면 생성자, 소멸자가 여러 번 호출되지 않으며, 멤버 변수도 복제되어 상속받지 않는다.<br><br>참고자료<br><a href=".?query=tag:참고도서\윤성우의_열혈_cpp_프로그래밍" class="tag" target="_blank" rel="noopener nofollow">#참고도서/윤성우의_열혈_cpp_프로그래밍</a><br>]]></description><link>resource\language\c++\가상-상속.html</link><guid isPermaLink="false">resource/Language/C++/가상 상속.md</guid><pubDate>Fri, 20 Dec 2024 13:55:24 GMT</pubDate></item><item><title><![CDATA[가상 소멸자]]></title><description><![CDATA[<a class="tag" href="?query=tag:language/cpp" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#language/cpp</a> <a class="tag" href="?query=tag:참고도서/윤성우의_열혈_cpp_프로그래밍" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/윤성우의_열혈_cpp_프로그래밍</a> 
 <br><br><a href=".?query=tag:language\cpp" class="tag" target="_blank" rel="noopener nofollow">#language/cpp</a><br>virtual destructor<br><br>자식 클래스 객체를 부모 포인터로 가리킬 경우, 부모 포인터에서 정의된 함수만 호출할 수 있다.1<br>
이는 소멸자의 경우에도 마찬가지여서, 자식 클래스의 소멸자가 호출되지 않아 할당 해제해야 할 멤버를 해체하지 못하는 등의 문제가 발생한다.<br><a data-href="virtual 키워드" href="resource\language\c++\virtual-키워드.html" class="internal-link" target="_self" rel="noopener nofollow">virtual 키워드</a>를 사용하여 소멸자를 가상 소멸자로 선언할 수 있으며, 부모 클래스가 가상 소멸자를 보유하고 있으면 자식 클래스의 소멸자들도 모두 가상 소멸자가 된다. 그리고 가상 소멸자가 호출되면, 상속의 계층 구조상 맨 아래에 존재하는 자식 클래스의 소멸자가 대신 호출되면서, 부모 클래스의 소멸자가 순차적으로 호출된다.<br><br>참고자료<br><a href=".?query=tag:참고도서\윤성우의_열혈_cpp_프로그래밍" class="tag" target="_blank" rel="noopener nofollow">#참고도서/윤성우의_열혈_cpp_프로그래밍</a><br><br>[^]: <a data-href="상속" href="resource\language\c++\상속.html" class="internal-link" target="_self" rel="noopener nofollow">상속</a> 참조]]></description><link>resource\language\c++\가상-소멸자.html</link><guid isPermaLink="false">resource/Language/C++/가상 소멸자.md</guid><pubDate>Fri, 20 Dec 2024 13:55:25 GMT</pubDate></item><item><title><![CDATA[가상 함수]]></title><description><![CDATA[<a class="tag" href="?query=tag:language/cpp" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#language/cpp</a> <a class="tag" href="?query=tag:참고도서/윤성우의_열혈_cpp_프로그래밍" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/윤성우의_열혈_cpp_프로그래밍</a> 
 <br><br><a href=".?query=tag:language\cpp" class="tag" target="_blank" rel="noopener nofollow">#language/cpp</a> <br>virtual function<br><br><br>부모 클래스 포인터는 자식 관계에 있는 클래스들의 객체를 가리킬 수 있지만, 이 경우 부모 클래스에서 정의된 함수만 호출할 수 있다. <a data-footref="1" href="about:blank#fn-1-0dd0c864fc857925" class="footnote-link" target="_self" rel="noopener nofollow">[1]</a><br>
<a data-href="virtual 키워드" href="resource\language\c++\virtual-키워드.html" class="internal-link" target="_self" rel="noopener nofollow">virtual 키워드</a>를 사용하여  가상 함수를 선언함으로서 이러한 문제를 해결할 수 있다.<br>virtual 키워드는 다음과 같은 특징을 가진다.<br>
<br>가상 함수를 오버라이딩하는 함수는 자동으로 가상 함수가 된다 ( 하지만 코드의 명확성을 위해 virtual 키워드를 사용하여 명시하는 것이 좋다 ).
<br>가상 함수는 해당 함수 호출 시, 포인터의 자료형을 기반으로 호출 대상을 결정하지 않고 포인터의 변수가 실제로 가리키는 객체를 참조하여 호출의 대상을 결정한다.
<br>하나 이상의 가상 함수를 포함한 클래스를 'Polymorphic class'라고 한다.<br>가상 함수의 구체적인 작동 원리는 <a data-href="가상 함수 테이블" href="resource\language\c++\가상-함수-테이블.html" class="internal-link" target="_self" rel="noopener nofollow">가상 함수 테이블</a>을 참고하자.<br><br>클래스 중에서는 객체생성이 목적이 아닌, 순수히 상속을 목적으로 정의된 클래스도 존재한다.<br>
이러한 클래스를 객체로 선언하는 것은 바람직하지 않지만, 문법적으로는 아무런 이상이 없기 떄문에 고치기 쉽지 않다.<br>가상 함수를 순수 가상 함수로 선언하면 이러한 객체의 생성을 문법적으로 막을 수 있다.<br>순수 가상 함수란 함수의 몸체가 정의되어 있지 않은 함수를 의미한다. 이를 표현하기 위해서 함수의 몸체를 작성하지 않고 그 자리에 '0의 대입'을 표시한다.<br>
virtual int GetPay() const = 0;

<br>순수 가상 함수는 아래와 같은 이점을 가진다.<br>
<br>순수 가상 함수를 가진 클래스는 완전하지 않은 클래스로 간주되기 떄문에 객체를 생성하려 하면 컴파일 에러가 발생한다. 이를 이용해 잘못된 객체의 생성을 문법적으로 막는다.
<br>순수히 상속만을 위한 클래스가 존재하는 것처럼, 함수를 순수 가상 함수로 선언함으로서 순수히 오버라이딩만을 위한 함수를 만들 수 있다.
<br>하나 이상의 멤버 함수를 순수 가상 함수로 선언한 클래스를 가리켜 <a data-href="추상 클래스" href="resource\language\c++\추상-클래스.html" class="internal-link" target="_self" rel="noopener nofollow">추상 클래스</a>라 한다.<br><br>참고자료<br><a href=".?query=tag:참고도서\윤성우의_열혈_cpp_프로그래밍" class="tag" target="_blank" rel="noopener nofollow">#참고도서/윤성우의_열혈_cpp_프로그래밍</a><br><br><br>
<br>
<br><a data-href="상속" href="resource\language\c++\상속.html" class="internal-link" target="_self" rel="noopener nofollow">상속</a> 문서를 참고할 것.<a href="about:blank#fnref-1-0dd0c864fc857925" class="footnote-backref footnote-link" target="_self" rel="noopener nofollow">↩︎</a>
]]></description><link>resource\language\c++\가상-함수.html</link><guid isPermaLink="false">resource/Language/C++/가상 함수.md</guid><pubDate>Fri, 20 Dec 2024 13:55:28 GMT</pubDate></item><item><title><![CDATA[가상 함수 테이블]]></title><description><![CDATA[<a class="tag" href="?query=tag:language/cpp" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#language/cpp</a> <a class="tag" href="?query=tag:참고도서/윤성우의_열혈_cpp_프로그래밍" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/윤성우의_열혈_cpp_프로그래밍</a> 
 <br><br><a href=".?query=tag:language\cpp" class="tag" target="_blank" rel="noopener nofollow">#language/cpp</a><br>virtual function table<br><br>본 문서는 가상 함수의 구체적인 작동 방법에 관하여 다룬다.<br>한 개 이상의 가상 함수를 포함하는 클래스에 대해서는 컴파일러가 다음 그림과 같은 형태의 가상 함수 테이블이라는 것을 만든다. 간단히 'V-Table(Virtual Table)'이라고도 하는데, 이는 실제 호출되어야 할 함수의 위치 정보를 담고 있는 테이블이다.<br>클래스의 객체가 생성되면 객체는 클래스의 가상 함수를 참조할 수 있는 주소 값을 저장한다. <br>
#include &lt;iostream&gt;
using namespace std;

class AAA
{
	private :
		int num;
	public :
		virtual void Func1() { cout&lt;&lt;"Func1"&lt;&lt;endl; }
		virtual void Func2() { cout&lt;&lt;"Func2"&lt;&lt;endl; }
};

class BBB : public AAA
{
	private :
		int num2;
	public :
		virtual void Func1() { cout&lt;&lt;"BBB::Func1"&lt;&lt;endl; }
		void Func3() { cout&lt;&lt;"Func3"&lt;&lt;endl; }
};

int main(void)
{
	AAA *aptr = new AAA();
	aptr-&gt;Func1();

	AAA *bptr = new BBB();
	bptr-&gt;Func1();

	return (0);
}

<br><img alt="가상 함수 테이블.png" src="lib\media\가상-함수-테이블.png"><br>가상 함수 테이블에는 key가 있고 value가 있다. 여기서 key는 호출하고자 하는 함수를 구분지어주는 구분자의 역할을 한다. 그리고 value는 구분자에 해당하는 함수의 주소정보를 알려주는 역할을 한다. 그래서 AAA 객체의 Func1 함수를 호출해야 하는 경우, 위의 테이블에 첫 번째 행의 정보를 참조하여 0x1024번지에 등록되어 있는 Func1 함수를 호출하게 되는 것이다.<br>가상 함수의 중요한 특징은 자식 클래스의 가상 함수 테이블에는 부모 함수의 오버라이딩 되기 전 가상 함수의 정보가 포함되지 않는다는 것이다. 그래서 오버라이딩 된 가상 함수를 호출하면, 무조건 가장 마지막에 오버라이딩을 한 자식 클래스의 멤버 함수가 호출된다.<br><br>참고자료<br><a href=".?query=tag:참고도서\윤성우의_열혈_cpp_프로그래밍" class="tag" target="_blank" rel="noopener nofollow">#참고도서/윤성우의_열혈_cpp_프로그래밍</a><br>]]></description><link>resource\language\c++\가상-함수-테이블.html</link><guid isPermaLink="false">resource/Language/C++/가상 함수 테이블.md</guid><pubDate>Fri, 20 Dec 2024 13:55:30 GMT</pubDate><enclosure url="lib\media\가상-함수-테이블.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;lib\media\가상-함수-테이블.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[구조체]]></title><description><![CDATA[<a class="tag" href="?query=tag:language/cpp" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#language/cpp</a> <a class="tag" href="?query=tag:참고도서/윤성우의_열혈_cpp_프로그래밍" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/윤성우의_열혈_cpp_프로그래밍</a> 
 <br><br><a href=".?query=tag:language\cpp" class="tag" target="_blank" rel="noopener nofollow">#language/cpp</a> <br>struct<br><br>본 문서는 c의 구조체와 c++ 구조체의 차이점을 중점으로 설명한다.
<br>구조체의 의의는 서로 연관이 있는 데이터를 하나의 구조체에 넣어 관리할 수 있다는 것이다.<br>경우를 하나 가정해보자.<br>
2차원 좌표계의 정점을 저장하는 Point 구조체가 있고, 정점을 이동시키는 기능을 가진 vertexMove 함수가 있다.<br>
typedef struct Point
{
	int x;
	int y;
} Point;

Point vertexMove(Point vertex1, int moveX, int moveY)
{
	Point movedVertex = {vertex1.x + moveX, vertex1.y + moveY};
	return (movedVertex);
}

<br>vertexMove 함수는 Point 구조체에 종속적이라고 할 수 있다. 그러나 c 언어는 구조체 내부의 함수 선언을 허용하지 않는다는 한계가 있다.<br>하지만 c++ 힘수에서는 구조체 내부 함수 선언을 아래와 같이 허용한다.<br>
struct Point
{
	//멤버변수
	int x;
	int y;

	//멤버함수
	void vertexMove(int moveX, int moveY)
	{
		x + moveX;
		y + moveY;
		return ;
	}
};

<br>c++에서 구조체 내부에 함수선언을 할 때, 다음과 같은 특징이 있다.<br>
<br>구조체의 변수를 멤버변수, 구조체의 함수를 멤버함수라고 한다.
<br>멤버함수는 매개변수에 멤버변수를 전달하지 않아도 멤버함수에 접근할 수 있다.
<br>멤버함수의 원형선언과 함수의 정의를 아래와 같은 형식으로 분리할 수 있다.
<br>
struct Car
{
	//. . .
	//함수의 원형선언
	void ShowCarStat();
	void Accel();
	//. . .
};

//함수의 정의
//structName::functionName의 형식으로 어느 구조체의 멤버함수인지를 지정해야 한다.
void Car::ShowCarState()
{
	//. . .
}

void Car::Accel()
{
	//. . .
}

<br>
<br>멤버함수는 기본적으로 <a data-tooltip-position="top" aria-label="인라인 함수" data-href="인라인 함수" href="resource\language\c++\인라인-함수.html" class="internal-link" target="_self" rel="noopener nofollow">인라인</a>으로 처리된다. 그러나 함수의 선언과 정의를 분리하면 인라인 처리되지 않는다. 키워드 inline을 이용해서 선언과 정의를 분리하고도 함수가 인라인 처리되도록 할 수 있다.
<br>
inline void Car::ShowCarState() { . . . . . }

<br>
<br>멤버 함수는 객체 외부의 별도의 공간에 선언된다 ( 객체가 아직 생성되지 않은 시점에서도 그러하다 ). 객체는 외부에 있는 멤버 함수의 주소를 참조한다.
<br>별도의 <a data-href="접근제어 지시자" href="resource\language\c++\접근제어-지시자.html" class="internal-link" target="_self" rel="noopener nofollow">접근제어 지시자</a>가 없을 경우, 구조체의 멤버함수와 멤버변수는 기본적으로 public으로 선언된다.
<br><br>참고자료<br><a href=".?query=tag:참고도서\윤성우의_열혈_cpp_프로그래밍" class="tag" target="_blank" rel="noopener nofollow">#참고도서/윤성우의_열혈_cpp_프로그래밍</a><br>]]></description><link>resource\language\c++\구조체.html</link><guid isPermaLink="false">resource/Language/C++/구조체.md</guid><pubDate>Fri, 20 Dec 2024 13:55:32 GMT</pubDate></item><item><title><![CDATA[깊은 복사]]></title><description><![CDATA[<a class="tag" href="?query=tag:language/cpp" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#language/cpp</a> <a class="tag" href="?query=tag:참고도서/윤성우의_열혈_cpp_프로그래밍" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/윤성우의_열혈_cpp_프로그래밍</a> 
 <br><br><a href=".?query=tag:language\cpp" class="tag" target="_blank" rel="noopener nofollow">#language/cpp</a><br><br>객체 간 복사의 한 형태이다.<br>heap 영역의 공간을 가리키는 포인터를 멤버 변수로 삼는 객체를 복사할 때, <a data-href="얕은 복사" href="resource\language\c++\얕은-복사.html" class="internal-link" target="_self" rel="noopener nofollow">얕은 복사</a>의 형태로 복사할 경우 원본 객체와 복사본 객체가 동일한 공간을 가리켜, 원본 객체가 소멸할 경우 ( = heap에 할당된 공간이 해제될 경우 ) 복사본 객체 또한 heap 영역에 대한 참조를 상실한다는 문제가 있다.<br>이러한 문제를 방지하기 위하여, heap에 할당된 공간을 복사하여 복사본 객체에 할당하는 방식의 복사 형태를 깊은 복사라 한다.<br><img alt="얕은 복사 깊은 복사.png" src="lib\media\얕은-복사-깊은-복사.png"><br><br>참고자료<br><a href=".?query=tag:참고도서\윤성우의_열혈_cpp_프로그래밍" class="tag" target="_blank" rel="noopener nofollow">#참고도서/윤성우의_열혈_cpp_프로그래밍</a><br>]]></description><link>resource\language\c++\깊은-복사.html</link><guid isPermaLink="false">resource/Language/C++/깊은 복사.md</guid><pubDate>Fri, 20 Dec 2024 13:55:39 GMT</pubDate><enclosure url="lib\media\얕은-복사-깊은-복사.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;lib\media\얕은-복사-깊은-복사.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[다중 상속]]></title><description><![CDATA[<a class="tag" href="?query=tag:language/cpp" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#language/cpp</a> <a class="tag" href="?query=tag:참고도서/윤성우의_열혈_cpp_프로그래밍" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/윤성우의_열혈_cpp_프로그래밍</a> 
 <br><br><a href=".?query=tag:language\cpp" class="tag" target="_blank" rel="noopener nofollow">#language/cpp</a><br><br>하나의 클래스가 복수의 클래스를 상속받는 것이 가능하다. 이를 다중 상속이라고 한다.<br>
다중 상속은 다음과 같이 선언된다.<br>
class Parent1
{ /* 생략 */ };

class Parent2
{ /* 생략 */ };

class child : public Parent1, protected Parent2
{ /* 생략 */ };


<br>그러나 다중 상속은 대부분의 경우 아예 사용되지 않거나, 특수한 상황에서만 매우 제한적으로 사용된다 ( 이러한 경우에도 다중 상속을 사용하지 않고 처리할 수 있다. 다중 상속을 사용해야만 하는 케이스는 없다. ).<br>다중 상속이 잘 사용되지 않는 이유는 아래와 같은 단점, 모호함들을 가졌기 때문이다.<br>
<br>
부모 클래스 1과 2가 서로 같은 함수명, 매개변수를 가진 함수를 보유한 경우, 컴파일러가 어느 함수를 호출해야 할지 알 수 없어 에러가 발생한다.<br>
-&gt; 아래와 같은 형식으로 어느 클래스의 함수인지 명시하여 해결할 수 있다.<br>
Parent1::Func(); Parent2::Func(); //부모클래스명::함수명()

<br>
아래와 같이 하나의 클래스가 간접적으로 같은 클래스를 2번 상속받을 수 있다.

<br>Parent 클래스를 선언한다.
<br>Child1, Child2 클래스를 선언한다. 이 클래스들은 모두 Parent를 상속받는다.
<br>GrandChild 클래스를 선언한다. 이 클래스는 Child1, Child2 클래스들을 다중 상속한다.
<br>결과적으로 GrandChild 클래스는 간접적으로 Parent 함수를 2번 상속 받는다.


<br>GrandChild 함수는 결과적으로 Parent 클래스의 생성자도 2번, 소멸자도 2번 호출되며, 멤버 변수도 복제되어 2배로 상속받는다. 대부분의 경우에서 이는 의도되지 않은 현상이며, 코드의 직관성을 해친다는 문제가 있다.<br>
-&gt; <a data-href="가상 상속" href="resource\language\c++\가상-상속.html" class="internal-link" target="_self" rel="noopener nofollow">가상 상속</a>을 사용하여 이러한 문제를 해결할 수 있다.


<br><br>참고자료<br><a href=".?query=tag:참고도서\윤성우의_열혈_cpp_프로그래밍" class="tag" target="_blank" rel="noopener nofollow">#참고도서/윤성우의_열혈_cpp_프로그래밍</a><br>]]></description><link>resource\language\c++\다중-상속.html</link><guid isPermaLink="false">resource/Language/C++/다중 상속.md</guid><pubDate>Sat, 22 Mar 2025 07:31:40 GMT</pubDate></item><item><title><![CDATA[다형성]]></title><description><![CDATA[<a class="tag" href="?query=tag:language/cpp" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#language/cpp</a> <a class="tag" href="?query=tag:참고도서/윤성우의_열혈_cpp_프로그래밍" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/윤성우의_열혈_cpp_프로그래밍</a> 
 <br><br><a href=".?query=tag:language\cpp" class="tag" target="_blank" rel="noopener nofollow">#language/cpp</a> <br>polymorphism<br><br>다형성은 객체지향 언어의 특징 중 하나이다.<br>다형성은 사전적으로 다음을 의미한다.<br>동질이상(同質異像)<br>
모습은 같은데 형태는 다르다.<br>이를 컴퓨터의 관점으로 생각하면 다음으로 해석할 수 있다.<br>문장은 같은데 결과가 다르다.<br>
class First
{
	public :
		virtual void SimpleFunc() { cout&lt;&lt;"First"&lt;&lt;endl; }
};

class Second : public First
{
	public :
		virtual void SimpleFunc() { cout&lt;&lt;"Second"&lt;&lt;endl; }
};

int main(void)
{
	First *ptr = new First();
	ptr -&gt; SimpleFunc(); // 아래에 동일한 문장이 존재한다.
	delete ptr;

	ptr = new Second();
	ptr -&gt; SimpleFunc(); // 위에 동일한 문장이 존재한다.
	delete ptr;

	return (0);
}

<br>위 예제에서 ptr은 동일한 포인터 변수이지만, ptr이 참조하는 객체의 자료형이 다르기 때문에 다른 결과를 출력한다. 이것이 '다형성'의 예이다.<br><br>참고자료<br><a href=".?query=tag:참고도서\윤성우의_열혈_cpp_프로그래밍" class="tag" target="_blank" rel="noopener nofollow">#참고도서/윤성우의_열혈_cpp_프로그래밍</a><br>]]></description><link>resource\language\c++\다형성.html</link><guid isPermaLink="false">resource/Language/C++/다형성.md</guid><pubDate>Sat, 22 Mar 2025 07:31:40 GMT</pubDate></item><item><title><![CDATA[디폴트 생성자]]></title><description><![CDATA[<a class="tag" href="?query=tag:language" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#language</a> <a class="tag" href="?query=tag:tag" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#tag</a> <a class="tag" href="?query=tag:참고도서/윤성우의_열혈_cpp_프로그래밍" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/윤성우의_열혈_cpp_프로그래밍</a> 
 <br><br><a href=".?query=tag:language" class="tag" target="_blank" rel="noopener nofollow">#language</a> <a href=".?query=tag:tag" class="tag" target="_blank" rel="noopener nofollow">#tag</a> <br>default constructor<br><br>c++ 언어에서 모든 객체는 생성될 때 하나의 생성자가 호출되어야 한다는 규칙이 있다.<br>이러한 기준에 예외를 두지 않기 위해 생성자가 정의되지 않은 클래스가 있다면 c++ 컴파일러는 디폴트 생성자를 삽입한다. 디폴트 생성자는 아무런 인자도 받지 않으며 아무런 기능도 하지 않는다.<br>그러므로 아래의 첫번째 예제의 클래스 정의는 두번째 예제의 클래스 정의와 완전히 동일하다.<br>
class AAA
{
	private :
		int num;
	public :
		int GetNum() {return num;}
}

<br>
class AAA
{
	private :
		int num;
	public :
		AAA() {} //디폴트 생성자
		int GetNum() {return num;}
}

<br><br><br>상술한 매개변수가 void형으로 선언되는 디폴트 생성자는, 생성자가 하나도 정의되어 있지 않을 때에만 삽입이 된다. 즉, 다음과 같이 정의된 클래스에는 디폴트 생성자가 삽입되지 않는다.<br>
class SoSimple
{
	private:
		int num;
	public:
		SoSimple(int n) : num(n) {}
}

<br>따라서 다음의 형태로는 객체 생성이 가능하지만,<br>
SoSimple simObj1(10);
SoSimple * simPtr1 = new SoSimple(2);

<br>다음의 형태로는 객체생성이 불가능하다. void 입력을 받는 생성자가 정의되지도, 자동으로 삽입되지도 않았기 때문이다.<br>
SoSimple simObj2;
SoSimple * simPtr2 = new SoSimple;

<br>따라서 위의 형태로 객체를 생성하기 원한다면, 다음의 형태로 생성자를 추가해야 한다.<br>SoSimple() : num(0) {}<br><br>동적으로 객체를 할당할 때, <a data-tooltip-position="top" aria-label="new &amp; delete" data-href="new &amp; delete" href="resource\language\c++\new-&amp;-delete.html" class="internal-link" target="_self" rel="noopener nofollow">new</a> 연산자를 사용하면 생성자가 호출된다.<br>
반면에, malloc은 단순히 클래스의 크기 정보만 바이트 단위로 전달받기 때문에 생성자가 호출될 수 없다. 그러므로 객체를 동적으로 할당하는 경우 반드시 new 연산자를 사용해야 한다.<br><br>참고자료<br><a href=".?query=tag:참고도서\윤성우의_열혈_cpp_프로그래밍" class="tag" target="_blank" rel="noopener nofollow">#참고도서/윤성우의_열혈_cpp_프로그래밍</a><br>]]></description><link>resource\language\c++\디폴트-생성자.html</link><guid isPermaLink="false">resource/Language/C++/디폴트 생성자.md</guid><pubDate>Sat, 22 Mar 2025 07:31:40 GMT</pubDate></item><item><title><![CDATA[디폴트 소멸자]]></title><description><![CDATA[<a class="tag" href="?query=tag:language/cpp" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#language/cpp</a> <a class="tag" href="?query=tag:참고도서/윤성우의_열혈_cpp_프로그래밍" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/윤성우의_열혈_cpp_프로그래밍</a> 
 <br><br><a href=".?query=tag:language\cpp" class="tag" target="_blank" rel="noopener nofollow">#language/cpp</a> <br>default destructor<br><br>클래스에 <a data-href="소멸자" href="resource\language\c++\소멸자.html" class="internal-link" target="_self" rel="noopener nofollow">소멸자</a>가 정의되어 있지 않을 떄 컴파일러가 자동으로 삽입하는, 아무런 기능도 하지 않는 소멸자.<br>첫번째 예제는 결과적으로 두번째 예제와 동일하다.<br>
class AAA
{
	//empty class
};

<br>
class AAA
{
	public :
		AAA() {}
		~AAA() {}
};

<br><br>참고자료<br><a href=".?query=tag:참고도서\윤성우의_열혈_cpp_프로그래밍" class="tag" target="_blank" rel="noopener nofollow">#참고도서/윤성우의_열혈_cpp_프로그래밍</a><br>]]></description><link>resource\language\c++\디폴트-소멸자.html</link><guid isPermaLink="false">resource/Language/C++/디폴트 소멸자.md</guid><pubDate>Sat, 22 Mar 2025 07:31:40 GMT</pubDate></item><item><title><![CDATA[리터럴]]></title><description><![CDATA[<a class="tag" href="?query=tag:language/cpp" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#language/cpp</a> <a class="tag" href="?query=tag:참고도서/포르잔_cpp_바이블" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/포르잔_cpp_바이블</a> 
 <br><br><a href=".?query=tag:language\cpp" class="tag" target="_blank" rel="noopener nofollow">#language/cpp</a><br>literal<br><br><br><a data-href="자료형" href="resource\language\c++\자료형.html" class="internal-link" target="_self" rel="noopener nofollow">자료형</a>을 가진 상수값을 의미한다.<br><br>정수 리터럴의 기본값은 부호가 있는 int(signed int)이다. short int는 리터럴로 사용하지 않는다. 만약 int의 범위를 넘는 숫자를 생성하면 long int로 생성된다. 컴파일러에게 명시적으로 우리가 원하는 자료형이 long int라고 알리려면 접미사 l 또는 L을 사용한다. 부호 없이 만들려면 접미사 u 또는 U를 사용한다.<br><br><br>문자 리터럴을 정의하는 방식은 작은 따옴표안에 ASCII 테이블에 정의된 글자를 넣는 것이다.<br>
char c = 'A';

<br>두 번째 방식은 ASCII 테이블에 정의된 정수 값을 사용하는 것이다. 하지만 이것은 엄연히 말하자면 문자 리터럴이 아니라 정수 리터럴이며, c++ 언어가 문자 또한 정수의 형태로 다루기 때문에 가능한 것이다.<br>
char c = 65;

<br>일부 특수한 문자를 정의할 때는 이스케이프 문자(역슬래시로 시작하는 기호)를 활용할 수 있다.<br><br><br>true 혹은 false 키워드로 표현한다.<br>
bool b1 = true;
bool b2 = false;

<br><br><br><br>참고자료<br><a href=".?query=tag:참고도서\포르잔_cpp_바이블" class="tag" target="_blank" rel="noopener nofollow">#참고도서/포르잔_cpp_바이블</a> <br>]]></description><link>resource\language\c++\리터럴.html</link><guid isPermaLink="false">resource/Language/C++/리터럴.md</guid><pubDate>Sat, 22 Mar 2025 07:31:40 GMT</pubDate></item><item><title><![CDATA[매개변수의 디폴트 값]]></title><description><![CDATA[<a class="tag" href="?query=tag:language/cpp" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#language/cpp</a> <a class="tag" href="?query=tag:참고도서/윤성우의_열혈_cpp_프로그래밍" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/윤성우의_열혈_cpp_프로그래밍</a> 
 <br><br><a href=".?query=tag:language\cpp" class="tag" target="_blank" rel="noopener nofollow">#language/cpp</a> <br>default value<br><br>c++ 언어에서는 함수의 매개변수의 기본값을 지정 가능하다. 함수를 호출할 때 인자를 전달하지 않으면, 컴파일러는 지정된 기본값으로 함수가 호출되었다고 간주한다. 여기서 기본값을 디폴트 값이라고 한다.<br>매개변수의 디폴트 값이 설정되어 있으면, 선언된 매개변수의 수보다 적은 수의 인자전달이 가능하다. 그리고 전달되는 인자는 왼쪽에서부터 채워져 나가고, 부족분은 디폴트 값으로 채워진다.<br>함수의 원형을 별도로 선언하는 경우, 매개변수의 디폴트 값은 함수의 원형 선언에만 위치시켜야 한다.<br>매개변수 중 일부에만 디폴트 값을 지정할 수도 있다. 이를 부분적 디폴트 값 설정이라고 한다. 단, 함수의 호출 시 인자는 왼쪽에서 오른쪽으로 전달되기 때문에 부분적 디폴트 값 설정 시 디폴트 값은 오른쪽 매개변수부터 차례대로 지정해야 한다.<br><br>참고자료<br><a href=".?query=tag:참고도서\윤성우의_열혈_cpp_프로그래밍" class="tag" target="_blank" rel="noopener nofollow">#참고도서/윤성우의_열혈_cpp_프로그래밍</a><br>]]></description><link>resource\language\c++\매개변수의-디폴트-값.html</link><guid isPermaLink="false">resource/Language/C++/매개변수의 디폴트 값.md</guid><pubDate>Sat, 22 Mar 2025 07:31:40 GMT</pubDate></item><item><title><![CDATA[멤버 이니셜라이저]]></title><description><![CDATA[<a class="tag" href="?query=tag:language/cpp" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#language/cpp</a> <a class="tag" href="?query=tag:참고도서/윤성우의_열혈_cpp_프로그래밍" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/윤성우의_열혈_cpp_프로그래밍</a> 
 <br><br><a href=".?query=tag:language\cpp" class="tag" target="_blank" rel="noopener nofollow">#language/cpp</a> <br>member initializer<br><br>함수의 몸체 부분을 사용하지 않고 멤버 변수의 초기화를 지원하는 문법적 요소.<br>
멤버 변수가 객체인 경우와 그렇지 않은 경우로 나뉜다.<br><br>클래스 A가 또 다른 클래스 B의 멤버 변수로 존재하는 경우가 있다고 가정하자. 멤버 이니셜라이저를 사용하여 B 객체를 생성할 때( 즉 B의 생성자를 호출할 때 ) 멤버 변수로서 존재하는 A 객체의 생성자를 동시에 호출할 수 있다.<br>아래와 같이 동작한다.<br>
class Point
{
	private :
		int x;
		int y;
	public :
		Point(const int &amp;xpos, const int &amp;ypos);
}

Point::Point(const int &amp;xpos, const int &amp;ypos)
{
	x=xpos;
	y=ypos;
}

class Rectangle
{
	private :
		Point upLeft;
		Point lowRight;
	public :
		Rectangle(const int &amp;x1, const int &amp;y1, const int &amp;x2, \
		const int &amp;y2);
}

Rectangle::Rectangle(const int &amp;x1, const int &amp;y1, const int &amp;x2, \
					 const int &amp;y2):upLeft(x1, y1), lowRight(x2, y2)
{
	//empty;
}

<br>위 예제에서 :upLeft(x1, y1), lowRight(x2, y2) 에 해당하는 부분이 멤버 이니셜라이저이다. 인자 x1, y1으로 upLeft의 생성자를 호출, 인자 x2, y2로 lowRight의 생성자를 호출하라는 의미를 가지고 있다.<br><br>아래와 같이 동작한다.<br>
class SoSimple
{
	private :
		int num1;
		int num2;
	public :
		SoSimple(int n1, int n2) : num1(n1), num2(n2)
		{
			//empty;
		}
}

<br>위의 예제는 결과적으로 아래와 동일하게 동작한다.<br>
class SoSimple
{
	private :
		int num1;
		int num2;
	public :
		SoSimple(int n1, int n2)
		{
			num1 = n1;
			num2 = n2;
		}
}

<br>즉 num1(n1)은 num1 = n1과 동일하게 동작한다.<br>멤버 이니셜라이저를 사용하여 멤버 변수를 초기화하는 방법은 함수의 몸체에서 멤버 변수를 초기화하는 방법과 비교해 아래의 이점이 있다.<br>
<br>초기화의 대상을 명확히 인식할 수 있다.
<br>이니셜라이저를 이용하면 선언과 동시에 초기화가 이뤄지는 형태로 바이너리 코드가 생성된다.

<br>이니셜라이저를 이용한 초기화는 다음의 형태로 바이너리 코드를 구성한다.<br>
num1(n1) //int num1 = n1;
<br>함수의 몸체에서 이뤄지는 초기화는 다음의 형태로 바이너리 코드를 구성한다.<br>
num1 = n1; //int num1; num1=n1;


<br>2.의 이유로, 선언과 동시에 초기화가 이뤄져야 하는 형식의 멤버변수(const, 참조자)는 이니셜라이저로만 초기화시킬 수 있다.
<br><br>참고자료<br><a href=".?query=tag:참고도서\윤성우의_열혈_cpp_프로그래밍" class="tag" target="_blank" rel="noopener nofollow">#참고도서/윤성우의_열혈_cpp_프로그래밍</a><br>]]></description><link>resource\language\c++\멤버-이니셜라이저.html</link><guid isPermaLink="false">resource/Language/C++/멤버 이니셜라이저.md</guid><pubDate>Sat, 22 Mar 2025 07:31:40 GMT</pubDate></item><item><title><![CDATA[범위지정 연산자]]></title><description><![CDATA[<a class="tag" href="?query=tag:language/cpp" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#language/cpp</a> <a class="tag" href="?query=tag:참고도서/윤성우의_열혈_cpp_프로그래밍" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/윤성우의_열혈_cpp_프로그래밍</a> 
 <br><br><a href=".?query=tag:language\cpp" class="tag" target="_blank" rel="noopener nofollow">#language/cpp</a> <br>::(scope resolution operator)<br><br>다음의 기능을 가진 연산자이다.<br>
<br>함수를 호출할 때 함수가 속한 이름공간을 지정.
<br>
std::cout &lt;&lt; "cpp";

<br>
<br>전역변수명과 지역변수명이 같을 경우, 범위지정 연산자를 사용해 전역변수와 지역변수를 구별할 수 있다. 이때, 범위지정 연산자가 붙어있는 변수가 전역변수이다.
<br>
int val=100; //전역변수

int SimpleFunc(void)
{
	int val=20; //지역변수
	val+=3; //지역변수 val의 값 3 증가
	::val+=7; //전역변수 val의 값 7 증가
}

<br><br>참고자료<br><a href=".?query=tag:참고도서\윤성우의_열혈_cpp_프로그래밍" class="tag" target="_blank" rel="noopener nofollow">#참고도서/윤성우의_열혈_cpp_프로그래밍</a><br>]]></description><link>resource\language\c++\범위지정-연산자.html</link><guid isPermaLink="false">resource/Language/C++/범위지정 연산자.md</guid><pubDate>Sat, 22 Mar 2025 07:31:40 GMT</pubDate></item><item><title><![CDATA[복사 생성자]]></title><description><![CDATA[<a class="tag" href="?query=tag:language/cpp" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#language/cpp</a> <a class="tag" href="?query=tag:참고도서/윤성우의_열혈_cpp_프로그래밍" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/윤성우의_열혈_cpp_프로그래밍</a> 
 <br><br><a href=".?query=tag:language\cpp" class="tag" target="_blank" rel="noopener nofollow">#language/cpp</a> <br>copy constructor<br><br>C++ 언어에서는 아래와 같은 형식으로 객체 간 복사가 가능하다.<br>
class SoSimple
{
	private :
		int num1;
		int num2;
	public :
		SoSimple(int n1, int n2) : num1(n1), num2(n2) { }
		void ShowSimpleData()
		{
			cout&lt;&lt;num1&lt;&lt;endl;
			cout&lt;&lt;num2&lt;&lt;endl;
		}
};

int main(void)
{
	SoSimple sim1(15, 20);
	SoSimple sim2 = sim1; //sim2 객체가 sim1 객체의 구성 요소(멤버 변수)를 복사
	
	sim2.ShowSimpleData();

	return (0);
}

<br>위 예제에서, 객체의 복사는 다음 구문에서 일어난다.<br>SoSimple sim2 = sim1;<br>이러한 형태의 구문은 묵시적 변환이 일어나 실제로는 다음의 형태로 해석된다. <a data-footref="1" href="about:blank#fn-1-0dd0c864fc857925" class="footnote-link" target="_self" rel="noopener nofollow">[1]</a><br>SoSimple sim2(sim1);<br>이렇듯 객체 간 복사의 용도로 사용되는 생성자를 복사 생성자라고 한다. 그러나 위 예제에서는 복사 생성자가 생성되어 있지 않다. 그럼에도 복사가 정상적으로 이루어지는 이유는 디폴트 복사 생성자가 자동으로 삽입되기 때문이다.<br>디폴트 복사 생성자는 아래와 같은 형태를 띈다.<br>
SoSimple(const SoSimple &amp;copy) : num1(copy.num1), num2(copy.num2) {}

<br>대부분은 디폴트 복사 생성자만으로 객체 간 복사를 정상적으로 수행할 수 있지만, 개발자가 직접 복사 생성자의 동작을 정의해야하는 경우가 있다.<br><br>복사 생성자가 호출되는 시점은 크게 세가지로 구분할 수 있다.<br>
<br>case 1 : 기존에 생성된 객체를 이용해서 새로운 객체를 초기화하는 경우(앞서 보인 경우)
<br>case 2 : Call-by-value 방식의 함수 호출 과정에서 객체를 인자로 전달하는 경우
<br>case 3 : 객체를 반환하되, 참조형으로 반환하지 않는 경우
<br><br>참고자료<br><a href=".?query=tag:참고도서\윤성우의_열혈_cpp_프로그래밍" class="tag" target="_blank" rel="noopener nofollow">#참고도서/윤성우의_열혈_cpp_프로그래밍</a><br><br><br>
<br>
<br><a data-href="explicit 키워드" href="resource\language\c++\explicit-키워드.html" class="internal-link" target="_self" rel="noopener nofollow">explicit 키워드</a>를 사용하여 이러한 묵시적 변환이 일어나지 않게 할 수 있다.<a href="about:blank#fnref-1-0dd0c864fc857925" class="footnote-backref footnote-link" target="_self" rel="noopener nofollow">↩︎</a>
]]></description><link>resource\language\c++\복사-생성자.html</link><guid isPermaLink="false">resource/Language/C++/복사 생성자.md</guid><pubDate>Sat, 22 Mar 2025 07:31:40 GMT</pubDate></item><item><title><![CDATA[상속]]></title><description><![CDATA[<a class="tag" href="?query=tag:language/cpp" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#language/cpp</a> <a class="tag" href="?query=tag:참고도서/윤성우의_열혈_cpp_프로그래밍" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/윤성우의_열혈_cpp_프로그래밍</a> 
 <br><br><a href=".?query=tag:language\cpp" class="tag" target="_blank" rel="noopener nofollow">#language/cpp</a> <br>inheritance<br><br>클래스가 다른 클래스에게 자신이 가지고 있는 멤버들을 물려주는 것을 상속이라고 한다.<br>상속을 하는 쪽과 상속을 받는 쪽을 각각 다음의 용어들로 정의한다.<br><br>예를 들러, UnivStudent 클래스가 Student 클래스를 상속받을 때, 다음과 같은 형식으로 상속받는다.<br>
#ifndef US_HPP
#define US_HPP

#include &lt;iostream&gt;
#include &lt;cstring&gt;

using namespace std;

//부모 클래스
class Person
{
	private :
		int age;
		char name[50];
	public :
		Person(int myage, char *myname);
		void WhatYourName() const;
		void HowOldAreYou() const;
};

//자식 클래스
class UnivStudent : public Person //UnivStudent가 Person을 'public' 상속함
{
	//부모 클래스로부터 물려받은 멤버에 더해 자신만의 독자적인 멤버를 추가로 선언한다.
	private :
		char major[50]; //전공과목
	public :
		UnivStudent(char *myname, int myage, char *mymajor);
		void WhoAreYou() const;
};

#endif

<br>상속은 다음과 같은 특성을 갖는다.<br>
<br>
<a data-href="접근제어 지시자" href="resource\language\c++\접근제어-지시자.html" class="internal-link" target="_self" rel="noopener nofollow">접근제어 지시자</a>의 접근제한 기준은 객체가 아닌 클래스이기 때문에 부모 클래스에서 private으로 선언한 멤버는 자식 클래스에서 접근이 불가능하다.

<br>따라서 자식 클래스에서 부모 클래스의 private멤버에 접근하기 위해서는 부모 클래스로부터 상속받은 public 함수를 사용하는 우회적인 방법을 사용해야 한다.
<br>이렇듯 정보의 은닉은 하나의 객체 안에서도 진행이 된다.


<br>
자식 클래스는 자신의 멤버 뿐만이 아니라 상속받은 멤버도 초기화하여야 한다.

<br>이를 위하여 생성자를 호출할 때 <a data-tooltip-position="top" aria-label="멤버 이니셜라이저" data-href="멤버 이니셜라이저" href="resource\language\c++\멤버-이니셜라이저.html" class="internal-link" target="_self" rel="noopener nofollow">이니셜라이저</a>를 사용하여 부모의 생성자를 호출한다.
<br>만약 부모의 생성자를 호출하지 않는 경우, 부모의 생성자 중 매개변수가 void인 생성자를 자동으로 호출한다 ( 없을 경우 error ).
<br>구체적인 생성자 호출 순서는 아래와 같다.

<br>자식 클래스 객체의 메모리 공간이 할당된다.
<br>자식 클래스의 생성자가 호출된다 ( 실행은 아직 되지 않은 상태 ).
<br>부모 클래스가 있는 지 확인 후, 있다면 부모 클래스의 생성자를 호출한다.
<br>부모 클래스 생성자를 실행하여 부모의 멤버변수를 초기화한다.
<br>자식 클래스 생성자를 실행한다 자식의 멤버변수를 초기화한다.




<br>
// 부모 클래스의 생성자
Person::Person(int myage, char *myname) : age(myage)
{
	strcpy(name, myname);
}

// 자식 클래스의 생성자
UnivStudent::UnivStudent(char *myname, int myage, char *mymajor) : Person(myage, myname) // -&gt; 이니셜라이저를 사용하여 부모의 생성자를 호출함
{
	strcpy(major, mymajor);
}

<br>
<br>
자식 클래스의 객체가 소멸될 때에는, 자식 클래스의 소멸자가 실행되고 난 다음에 기초 클래스의 소멸자가 실행된다.

<br>스택의 생성된 객체의 소멸 순서는 생성 순서와 반대이다.


<br>
<a data-href="접근제어 지시자" href="resource\language\c++\접근제어-지시자.html" class="internal-link" target="_self" rel="noopener nofollow">접근제어 지시자</a>는 멤버의 접근 범위를 제한하는 것 외에도 상속의 형태를 정의할 수 있다. 따라서 상속애는 public, protected, private 이렇게 3가지 형태의 상속이 있다.

<br>public 상속의 경우, private 멤버를 제외한 나머지(private 멤버는 자식에서 접근이 불가하므로) 그대로 상속한다.
<br>protected 상속의 경우, protected 보다 접근 범위가 넓은 멤버 ( 즉 public ) 의 접근 범위를 protected로 변환시켜 상속한다.
<br>private 상속의 경우, private 보다 접근 범위가 넓은 멤버의 접근 범위를 private으로 변환시켜 상속한다.


<br>
상속은 남용하지 않고 적절한 경우에만 사용되어야 한다. 상속을 사용하기 적합한 클래스와 클래스 사이 관계의 특징은 다음과 같다.

<br>
IS_A 관계.

<br>예를 들어 컴퓨터 정보를 나타내는 Computer 클래스가 있고, 노트북 정보를 나타내는 Notebook 클래스가 있으면 둘은 IS_A 관계라 할 수 있다. 다음의 문장이 성립하기 때문이다.<br>
노트북은 컴퓨터이다<br>
또는<br>
노트북은 컴퓨터의 일종이다.


<br>
HAS_A 관계.

<br>에를 들어 경찰을 나타내는 Police 클래스가 있고, 총을 나타내는 Gun 클래스가 있을 때 다음의 문장이 성립하므로 HAS_A 관계라 할 수 있다.<br>
경찰은 총을 가지고 있다.


<br>
다만 HAS_A 관계는 상속을 사용하기보다는 객체를 다른 객체의 멤버변수로 선언함으로서 표현하는 것이 일반적이다.



<br>
부모 클래스의 함수를 자식 클래스에서 <a data-tooltip-position="top" aria-label="함수 오버로딩" data-href="함수 오버로딩" href="resource\language\c++\함수-오버로딩.html" class="internal-link" target="_self" rel="noopener nofollow">오버로딩</a> 할 수 있다.

<br>
부모 클래스의 함수를 자식 클래스에서 재정의 할 수 있다. 이를 <a data-href="함수 오버라이딩" href="resource\language\c++\함수-오버라이딩.html" class="internal-link" target="_self" rel="noopener nofollow">함수 오버라이딩</a>이라 한다.

<br>
부모 클래스의 포인터로 자식 포인터의 객체를 가리킬 수 있다.

<br>그러나 컴파일러는 포인터 연산의 가능성 여부를 판단할 때, 실제 가리키는 객체의 자료형이 아닌, 포인터의 자료형을 기준으로 판단한다.

<br>따라서 부모 클래스의 포인터로 자식 포인터를 가리킬 경우 부모 포인터에서 정의되지 않은 함수를 사용할 수 없다 ( 이를 <a data-href="가상 함수" href="resource\language\c++\가상-함수.html" class="internal-link" target="_self" rel="noopener nofollow">가상 함수</a>를 통해 극복할 수 있다 ) .
<br>부모 클래스의 함수를 자식 클래스가 <a data-tooltip-position="top" aria-label="함수 오버라이딩" data-href="함수 오버라이딩" href="resource\language\c++\함수-오버라이딩.html" class="internal-link" target="_self" rel="noopener nofollow">오버라이딩</a> 한 경우, 가리키는 포인터의 자료형 클래스에서 선언된 함수가 호출된다.
<br>상술한 모든 특성은 <a data-href="참조자" href="resource\language\c++\참조자.html" class="internal-link" target="_self" rel="noopener nofollow">참조자</a>를 사용한 참조에도 모두 적용된다.




<br>
하나의 객체가 동시에 복수의 객체를 상속받는 것이 가능하다. 이를 <a data-href="다중 상속" href="resource\language\c++\다중-상속.html" class="internal-link" target="_self" rel="noopener nofollow">다중 상속</a>이라고 한다.

<br><br>참고자료<br><a href=".?query=tag:참고도서\윤성우의_열혈_cpp_프로그래밍" class="tag" target="_blank" rel="noopener nofollow">#참고도서/윤성우의_열혈_cpp_프로그래밍</a><br>]]></description><link>resource\language\c++\상속.html</link><guid isPermaLink="false">resource/Language/C++/상속.md</guid><pubDate>Sat, 22 Mar 2025 07:31:41 GMT</pubDate></item><item><title><![CDATA[생성자]]></title><description><![CDATA[<a class="tag" href="?query=tag:language/cpp" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#language/cpp</a> <a class="tag" href="?query=tag:참고도서/윤성우의_열혈_cpp_프로그래밍" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/윤성우의_열혈_cpp_프로그래밍</a> 
 <br><br><a href=".?query=tag:language\cpp" class="tag" target="_blank" rel="noopener nofollow">#language/cpp</a> <br>constructor<br><br>객체 생성 시 단 한번 호출되는 함수.<br>생성자는 다음의 형태를 띈다.<br>
<br>클래스의 이름과 함수의 이름이 동일하다.
<br>반환형이 선언되어 있지 않으며, 실제로 반환하지 않는다.
<br>생성자는 아래의 특성을 갖는다.<br>
<br>생성자도 함수의 일종이니 <a data-tooltip-position="top" aria-label="함수 오버로딩" data-href="함수 오버로딩" href="resource\language\c++\함수-오버로딩.html" class="internal-link" target="_self" rel="noopener nofollow">오버로딩</a>이 가능하다.
<br>생성자도 함수의 일종이니 매개변수에 <a data-tooltip-position="top" aria-label="매개변수의 디폴트 값" data-href="매개변수의 디폴트 값" href="resource\language\c++\매개변수의-디폴트-값.html" class="internal-link" target="_self" rel="noopener nofollow">디폴트 값</a>을 설정할 수 있다.
<br>아래는 생성자의 예시이다.<br>
#include &lt;iostream&gt;

using namespace std;

class SimpleClass
{
	private :
		int num1;
		int num2;

	public :
		SimpleClass()
		{
			num1=0;
			num2=0;
		}

		SimpleClass(int n)
		{
			num1=n;
			num2=0;
		}

		SimpleClass(int n1, int n2)
		{
			num1=n1;
			num2=n2;
		}

		/*

		//이 단락을 주석해제하고 SimpleClass sc2(100); 과 같이 객체 생성을 시도할 경우 컴파일 에러가 발생한다. SimpleClass(int n)과 이 단락의 생성자 중 뭘 호출해야 할 지 명확하지 않기 때문이다.

		SimpleClass(int n1=0;,int n2=0)
		{
			num1=n1;
			num2=n2;
		}
		*/

		void ShowData() const
		{
			cout&lt;&lt;num1&lt;&lt;' '&lt;&lt;num2&lt;&lt;endl;
		}
};

int main(void)
{
	//생성자를 정의한 경우 객체생성과정에서 자동으로 호출되는 생성자에게 전달할 인자의 정보를 다음과 같이 추가해야 한다.
	SimpleClass sc1;
	sc1.ShowData();
	SimpleClass sc2(100);
	sc2.ShowData();
	SimpleClass sc3(100, 200);
	sc3.ShowData();

	return (0);
}

/*
실행결과

0 0
100 0
100 200
*/

<br>생성자도 아래의 예제와 같이 private으로 선언될 수 있다. 이 경우, 클래스 내부의 객체를 초기화시키는 데에만 사용할 수 있다.<br>
//PrivateConstructor.cpp

#include &lt;iostream&gt;

using namespace std;

class AAA
{
	private :
		int num;

	public :
		AAA() : num(0) {}

		AAA &amp;CreateInitObj(int n) const
		{
			AAA *ptr = new AAA(n);
			return (*ptr);
		}

		void ShowNum() const { cout&lt;&lt;num&lt;&lt;endl; }

	private :
		AAA(int n) : num(n) {}
};

int main(void)
{
	AAA base;
	base.ShowNum();

	AAA &amp;obj1 = base.CreateInitObj(3);
	obj1.ShowNum();

	AAA &amp;obj2 = base.CreateInitObj(12);
	obj2.ShowNum();

	delete &amp;obj1;
	delete &amp;obj2;

	return (0);
}

<br>생성자를 정의하지 않으면, 컴파일러의 의해 <a data-href="디폴트 생성자" href="resource\language\c++\디폴트-생성자.html" class="internal-link" target="_self" rel="noopener nofollow">디폴트 생성자</a>가 자동으로 삽입된다.<br>
객체 내부의 멤버로서 존재하는 객체는 <a data-href="멤버 이니셜라이저" href="resource\language\c++\멤버-이니셜라이저.html" class="internal-link" target="_self" rel="noopener nofollow">멤버 이니셜라이저</a>를 통해 초기화될 수 있다.<br><br>참고자료<br><a href=".?query=tag:참고도서\윤성우의_열혈_cpp_프로그래밍" class="tag" target="_blank" rel="noopener nofollow">#참고도서/윤성우의_열혈_cpp_프로그래밍</a><br>]]></description><link>resource\language\c++\생성자.html</link><guid isPermaLink="false">resource/Language/C++/생성자.md</guid><pubDate>Sat, 22 Mar 2025 07:31:41 GMT</pubDate></item><item><title><![CDATA[소멸자]]></title><description><![CDATA[<a class="tag" href="?query=tag:language/cpp" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#language/cpp</a> <a class="tag" href="?query=tag:참고도서/윤성우의_열혈_cpp_프로그래밍" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/윤성우의_열혈_cpp_프로그래밍</a> 
 <br><br><a href=".?query=tag:language\cpp" class="tag" target="_blank" rel="noopener nofollow">#language/cpp</a> <br>destructor<br><br>소멸자는 객체가 소멸할 때 반드시 호출되는 함수이다.<br>소멸자는 다음의 형태를 갖는다.<br>
<br>클래스의 이름 앞에 ~가 붙은 형태의 이름을 갖는다.
<br>반환형이 선언되어 있지 않으며, 실제로 반환하지 않는다.
<br>매개변수는 void형으로 선언되어야 하기 때문에 오버로딩도, 디폴트 값 설정도 불가능하다.
<br>예시<br>~AAA() {//function body}<br>소멸자는 주로 객체의 소멸 전 객체 내에서 <a data-tooltip-position="top" aria-label="new &amp; delete" data-href="new &amp; delete" href="resource\language\c++\new-&amp;-delete.html" class="internal-link" target="_self" rel="noopener nofollow">new</a> 연산자를 이용해 동적으로 할당한 요소들을 <a data-tooltip-position="top" aria-label="new &amp; delete" data-href="new &amp; delete" href="resource\language\c++\new-&amp;-delete.html" class="internal-link" target="_self" rel="noopener nofollow">delete</a>를 이용해 없애는데 사용한다.<br><a data-href="디폴트 생성자" href="resource\language\c++\디폴트-생성자.html" class="internal-link" target="_self" rel="noopener nofollow">디폴트 생성자</a>와 마찬가지로, 클래스에 소멸자가 정의되어 있지 않으면 컴파일러에 의해 <a data-href="디폴트 소멸자" href="resource\language\c++\디폴트-소멸자.html" class="internal-link" target="_self" rel="noopener nofollow">디폴트 소멸자</a>가 삽입된다.<br><br>참고자료<br><a href=".?query=tag:참고도서\윤성우의_열혈_cpp_프로그래밍" class="tag" target="_blank" rel="noopener nofollow">#참고도서/윤성우의_열혈_cpp_프로그래밍</a><br>]]></description><link>resource\language\c++\소멸자.html</link><guid isPermaLink="false">resource/Language/C++/소멸자.md</guid><pubDate>Sat, 22 Mar 2025 07:31:41 GMT</pubDate></item><item><title><![CDATA[얕은 복사]]></title><description><![CDATA[<a class="tag" href="?query=tag:language/cpp" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#language/cpp</a> <a class="tag" href="?query=tag:참고도서/윤성우의_열혈_cpp_프로그래밍" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/윤성우의_열혈_cpp_프로그래밍</a> 
 <br><br><a href=".?query=tag:language\cpp" class="tag" target="_blank" rel="noopener nofollow">#language/cpp</a><br><br>객체 간 복사의 한 형태.<br>순수히 멤버 대 멤버 간 복사가 일어난다. <a data-tooltip-position="top" aria-label="복사 생성자" data-href="복사 생성자" href="resource\language\c++\복사-생성자.html" class="internal-link" target="_self" rel="noopener nofollow">디폴트 복사 생성자</a>는 얕은 복사의 형태로 객체 간 복사한다.<br><img alt="얕은 복사.png" src="lib\media\얕은-복사.png"><br>heap 영역에 할당된 공간을 가리키는 포인터를 복사할 경우, 복수의 객체가 heap 영역의 동일한 공간을 가리키는 형태가 된다.<br><img alt="얕은 복사 깊은 복사.png" src="lib\media\얕은-복사-깊은-복사.png"><br>따라서 원본 객체가 소멸할 경우(= heap 영역에 할당된 공간이 해제될 경우) 복사본 객체의 멤버 또한 공간을 참조할 수 없게 된다. 이러한 경우를 방지하고 싶다면 <a data-href="깊은 복사" href="resource\language\c++\깊은-복사.html" class="internal-link" target="_self" rel="noopener nofollow">깊은 복사</a>를 사용해야 한다.<br><br>참고자료<br><a href=".?query=tag:참고도서\윤성우의_열혈_cpp_프로그래밍" class="tag" target="_blank" rel="noopener nofollow">#참고도서/윤성우의_열혈_cpp_프로그래밍</a><br>]]></description><link>resource\language\c++\얕은-복사.html</link><guid isPermaLink="false">resource/Language/C++/얕은 복사.md</guid><pubDate>Sat, 22 Mar 2025 07:31:41 GMT</pubDate><enclosure url="lib\media\얕은-복사.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;lib\media\얕은-복사.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[연산자 오버로딩]]></title><description><![CDATA[<a class="tag" href="?query=tag:language/cpp" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#language/cpp</a> <a class="tag" href="?query=tag:참고도서/윤성우의_열혈_cpp_프로그래밍" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/윤성우의_열혈_cpp_프로그래밍</a> 
 <br><br><a href=".?query=tag:language\cpp" class="tag" target="_blank" rel="noopener nofollow">#language/cpp</a> <br>operator overloading<br><br><br>연산자 오버로딩이란, 기존의 연산자의 오버로딩을 통하여, 기존에 존재하던 연산자의 기본 기능 이외에 다른 기능을 추가할 수 있게끔 하는 문법적 요소이다.<br>연산자 오버로딩에 사용되는 함수명은 'operation' + '(연산자)' 의 형태를 띈다.<br>
연산자 오버로딩은 기본적으로 아래와 같이 사용된다.<br>
#include &lt;iostream&gt;
using namespace std;

class Point
{
	private :
		int xpos, ypos;
	public :
		Point(int x = 0, int y = 0) : xpos(x), ypos(y) {}
		void ShowPosition() const
		{
			cout&lt;&lt;'['&lt;&lt;xpos&lt;&lt;", "&lt;&lt;ypos&lt;&lt;']'&lt;&lt;endl;
		}
		Point operator+(const Point &amp;ref)
		{
			Point pos(xpos + ref.xpos, ypos + ref.ypos);
			return pos;
		}
};

/*
int main(void)
{
	Point pos1(3, 4);
	Point pos2(10, 20);
	//연산자 오버로딩을 사용하지 않으면 보통 이와 같이 코드를 작성한다.
	Point pos3 = pos1.operator+(pos2);

	pos1.ShowPosition();
	pos2.ShowPosition();
	pos3.ShowPosition();
	
	return (0);
}
*/

int main(void)
{
	Point pos1(3, 4);
	Point pos2(10, 20);
	//연산자 오버로딩을 사용하여 아래와 같이 코드를 축약할 수 있다.
	Point pos3 = pos1 + pos2;
	
	pos1.ShowPosition();
	pos2.ShowPosition();
	pos3.ShowPosition();
	
	return (0);
}

<br>다음은 위 예제에서 연산자 오버로딩이 적용된 문장이다.<br>pos1 + pos2;<br>이 문장은 아래와 같이 분해할 수 있다.<br>pos1<br>
+<br>
pos2<br>연산자 오버로딩은 위 문장의 각 구성요소를 다음과 같이 변환한다.<br>pos<br>
.operator+<br>
(pos2)<br>pos.operator+(pos2);<br><br><br>연산자를 오버로딩 하는 방법에는 다음 두 가지가 있다.<br>
<br>멤버함수에 의한 연산자 오버로딩
<br>전역함수에 의한 연산자 오버로딩
<br>개요에서 소개한 방법은 멤버함수에 의한 연산자 오버로딩이다.<br>
전역함수를 이용해서 오버로딩을 하면 pos1 + pos2는 다음과 같이 해석이 된다.<br>operator+(pos1, pos2);<br>아래 예제를 참조하자.<br>
#include &lt;iostream&gt;
using namespace std;

class Point
{
	private :
		int xpos, ypos;
	public :
		Point(int x = 0, int y = 0) : xpos(x), ypos(y) {}
		void ShowPosition() const
		{
			cout&lt;&lt;'['&lt;&lt;xpos&lt;&lt;", "&lt;&lt;ypos&lt;&lt;']'&lt;&lt;endl;
		}
		/*전역 함수에서 Point 객체의 멤버를 참조할 수 있도록 한다.*/
		friend Point operator+(const Point &amp;pos1, const Point &amp;pos2);
};

//연산자 오버로딩 전역 함수 버전
Point operator+(const Point &amp;pos1, const Point &amp;pos2)
{
	Point pos(pos1.xpos + pos2.xpos, pos1.ypos + pos2.ypos);
	return pos;
}

int main(void)
{
	Point pos1(3, 4);
	Point pos2(10, 20);
	Point pos3 = pos1 + pos2;

	pos1.ShowPosition();
	pos2.ShowPosition();
	pos3.ShowPosition();

	return (0);
}

<br>위 예제와 같이, 연산 대상이 private 멤버 변수인 경우, friend 선언을 통하여 전역 변수에게 멤버의 참조를 허용하여야 한다.<br>전역 함수를 이용한 연산자 오버로딩은 후술할 교환 법칙이 성립하는 연산자 오버로딩의 구현에 유용하게 사용된다.<br><br><br><br>이들 연산자에 대해서 오버로딩을 제한하는 이유는 C++의 문법 규칙을 보존하기 위해서다.<br>
만약 이들 연산자들까지 오버로딩을 허용해 버린다면, C++ 문법 규칙에 어긋나는 문장의 구성이 가능해진다.<br><br><br><br>이들은 객체를 대상으로 진행해야 의미가 통하는 연산자들이기 때문에, 멤버함수 기반으로만 연산자의 오버로딩을 허용한다.<br><br><br>
<br>연산자의 본래 정의를 벗어난 형태의 오버로딩은 좋지 않다.
<br>연산자의 우선 순위와 결합성은 바뀌지 않는다.
<br>매개변수의 디폴트 값 설정이 불가능하다.
<br>클래스가 아닌 일반 자료형 간의 연산을 재정의 할 수는 없다.

<br>부연 : 예를 들어 'int 형 변수 간의 덧셈'과 같은 동작을 재정의할 수는 없다는 말이다.


<br><br><br>피연산자가 두 개인 이항 연산자와 피연산자가 한 개인 단항 연산자의 가장 큰 차이점은 피연산자의 개수이다. 그리고 이에 따른 연산자 오버로딩의 차이점은 매개변수의 개수에서 발견된다.<br>대표적인 단항 연산자로는 다음의 두 가지가 있다.<br>
<br>++
<br>--
<br>단항 연산자는 연산 결과가 피연산자 객체 스스로에 적용되기 때문에 함수에 인자를 전달할 필요가 없다.<br>
따라서 멤버함수의 경우, 다음의 형태를 띈다.<br>
//전위 연산을 담당하는 함수의 형태
Obj &amp;operation++() { /* . . . */ }

<br>위의 연산자들이 피연산자의 앞에 위치하면 전위 연산자, 뒤에 위치하면 후위 연산자가 된다.<br>
둘을 구분하기 위하여, 후위 연산을 담당하는 함수에게만 키워드 int를 표시한다. int 키워드는 오로지 전위와 후위를 구분하기 위해 존재하며, int 형 인자를 전달하는 것이 아니다.<br>
//후위 연산을 담당하는 함수의 형태
Obj &amp;operation++( int ) { /* . . . */ } //키워드 int를 사용하여 전위와 후위를 구분한다.

<br>마찬가지로 전역함수로 단항 연산을 구현할 경우, 이항 연산과 달리 피연산자를 하나만 전달하면 된다.<br>
//전위 연산을 담당하는 함수의 형태
Obj &amp;operation++( Obj &amp;a) { /* . . . */ }
//후위 연산을 담당하는 함수의 형태
Obj &amp;operation++( Obj &amp;a, int ) { /* . . . */ } //키워드 int를 사용하여 전위와 후위를 구분한다.

<br><br><br>위 절의 예제에서 operation++()은 객체의 참조값을 반환한다. 사실 객체의 멤버 변수를 1 더하는 동작만을 정의한다면 다음과 같이 반환형을 void로 하여도 상관없다.<br>
void operation++()
{
	//var1과 var2는 객체의 멤버변수
	var1 += 1;
	var2 += 1;
}

<br>그러나 이러한 형식으로 함수를 정의하면 다음과 같은 형태의 연산이 불가능하다.<br>
<br>++(++obj) //obj에 ++연산을 연속적으로 2번 적용하고자 함
<br>operation++은 void를 반환하므로 위 연산은 다음과 동일하다.<br>
++(void) //error
<br>따라서 위와 같은 연산이 가능하게 하기 위해서는 반환형을 객체의 참조자로 하는 것이 좋다.<br>
Obj &amp;operation++()
{
	var1 += 1;
	var2 += 1;
	
	return (*this); //객체 스스로의 참조값을 반환
}

<br>
<br>++(++obj)를 연산하고자 함.
<br>operation++은 객체의 참조값을 반환하므로 위 연산은 다음과 동일하다.

<br>++(obj.operation++())
<br>++(obj 객체의 참조값)
<br>(obj 객체의 참조값).operation++()


<br><br><br>C++ 언어에서는 다음과 같은 연속적인 후위 연산을 금지하고 있다.<br>(obj--)--;<br>따라서 다음과 같이 operation--()의 반환형을 const 객체로 선언하면 연속적인 후위 연산을 제한할 수 있다.<br>
//전위 연산을 담당하는 함수의 형태
const Obj operation++( Obj &amp;a) { /* . . . */ }
//후위 연산을 담당하는 함수의 형태
const Obj operation++( Obj &amp;a, int ) { /* . . . */ } //키워드 int를 사용하여 전위와 후위를 구분한다.

<br>
<br>(obj--)--;를 연산하고자 함.
<br>operation--는 const 임시 객체를 반환하므로 위 연산은 다음과 동일하다.

<br>(obj.operation--())--
<br>(Obj 클래스의 const 임시 객체)--
<br>(Obj 클래스의 const 임시 객체).operation--() // error : const 임시 객체는 const 멤버 함수가 아닌 operation--()를 호출할 수 없다.


<br><br><br>곱셈과 같은 연산은 다음과 같이 피연산자 2개의 자료형이 서로 다를 수 있다.<br>
class Point
{
	private :
		int xpos, ypos;
	public :
		Point operation*(int n)
		{
			xpos *= n;
			ypos *= n;
			return (*this);
		}
}

int main(void)
{
	Point pos(1, 2);
	Point cpy;

	cpy = pos * 3;
	cpy = pos * 3 * 2;

	return (0);
}

<br>위 예제에서 cpy = pos * 3;은 cpy = 3 * pos;으로도 표현할 수 있어야 한다.<br>
하지만 cpy = 3 * pos;은 다음과 같이 해석될 수는 없기 때문에 연산자 오버로딩이 불가하다.<br>3.operator*(pos);<br>따라서 * 연산자의 교환법칙을 구현하려면 전역 함수를 사용하여 다음과 같이 정의해야 한다.<br>
class Point
{
	private :
		int xpos, ypos;
	public :
		Point operation*(int n)
		{
			xpos *= n;
			ypos *= n;
			return (*this);
		}
	friend Point operator*(int n, Point &amp;pos);
}

Point operator*(int n, Point &amp;pos)
{
	return ref * n;
}

int main(void)
{
	Point pos(1, 2);
	Point cpy;

	cpy = 3 * pos; //operator*(3, pos);로 해석됨.
	cpy = 3 * pos * 2; //operator*(3, pos).operator*(3);으로 해석됨.

	return (0);
}

<br><br><br>대입 연산자는 <a data-href="복사 생성자" href="resource\language\c++\복사-생성자.html" class="internal-link" target="_self" rel="noopener nofollow">복사 생성자</a>와 매우 유사한 성격을 가지고 있다.<br>복사 생성자의 특성<br>
<br>정의하지 않으면 디폴트 복사 생성자가 삽입된다.
<br>디폴트 복사 생성자는 멤버 대 멤버의 복사(얕은 복사)를 진행한다.
<br>생성자 내에서 동적 할당을 한다면, 그리고 깊은 복사가 필요하다면 직접 정의해야 한다.
<br>대입 연산자의 특성<br>
<br>정의하지 않으면 디폴트 대입 연산자가 삽입된다.
<br>디폴트 대입 연산자는 멤버 대 멤버의 복사(얕은 복사)를 진행한다.
<br>연산자 내에서 동적 할당을 한다면, 그리고 깊은 복사가 필요하다면 직접 정의해야 한다.
<br>참고로, 디폴트 대입 연산자는 다음과 같은 형식을 하고 있다.<br>
Obj &amp;operator=(const Obj obj)
{
	objVal1 = obj.objVal1;
	objVal2 = obj.objVal2;
	return *this;
}

<br>그러나 대입 연산자와 복사 생성자는 호출시점에 차이를 갖는다.<br>
<br>복사 생성자 : 새로 생성하는 객체의 초기화에 기존에 생성된 객체가 사용.

<br>ex) Point pos = pos1;


<br>대입 연산자 : 기존의 생성된 객체 사이에 대입 연산이 사용되었을 경우.

<br>ex) pos2 = pos1;


<br>또한 대입 연산자와 복사 생성자는 상속 구조에서의 호출에서 다음의 차이점을 갖는다.<br>
<br>복사 생성자 : 자식 클래스에서 아무런 명시를 하지 않아도 부모 클래스의 생성자가 호출.
<br>대입 연산자

<br>디폴트 대입 연산자 호출의 경우 : 디폴트 대입 연산자가 부모 클래스의 대입 연산자까지 호출한다.
<br>대입 연산자를 직접 정의하는 경우 : 자식 클래스의 대입 연산자에서 명시가 없으면, 부모 클래스의 대입 연산자가 호출되지 않는다. 다음의 형태를 사용하여 부모 클래스의 대입 연산자를 호출할 수 있다.

<br>Parent::operator=(ref); //부모 클래스명::operator=(매개인자);




<br>c++ 언어의 대입연산( =객체 간의 대입 연산 )은 c 언어의 구조체 간의 대입과 유사해 보이지만, 대입 연산자를 오버로딩하였다는 점에서 근본적으로 차이점이 있다.<br>객체 내에서 멤버를 동적 할당하는 경우, 디폴트 대입 연산자 사용 시 다음의 두 가지 문제가 발생한다.<br><img alt="디폴트 대입 연산자의 동작(얕은 복사).png" src="lib\media\디폴트-대입-연산자의-동작(얕은-복사).png"><br>
<br>기존에 가리키던 heap 영역의 공간에 대한 참조를 잃는다.
<br>얕은 복사로 인해서, 객체 소멸 과정에서 지워진 문자열을 중복 소멸하는 문제가 발생한다.
<br>따라서 다음의 원칙을 준수하여 직접 대입 연산자를 정의하여야 한다.<br>
<br>깊은 복사를 진행하도록 정의한다.
<br>메모리 누수가 발생하지 않도록, 깊은 복사에 앞서 메모리 해제의 과정을 거친다.
<br><br><br>앞서 언급했듯이, [] 연산자는 멤버함수 기반으로만 오버로딩 하도록 제한되어 있다.<br>
[] 연산자 오버로딩 함수는 아래와 같은 형식을 가지고 있다.<br>
int operator[](int idx) { . . . . } //int로 선언된 반환형은 임의로 결정한 것이다. 이는 반환하는 값의 자료형에 따라 달라진다.

<br>
/*아래 문장은 다음과 같이 해석된다*/
arrObject[2]; //arrObject는 객체
//arrObject.operator[](2);

<br>[] 연산자 오버로딩은 오류 발생, 잘못된 접근 등을 개발자가 사전에 제약할 수 있다는 장점이 있다. (ex. out of index).<br><br><br>new 연산자가 하는 일은 다음과 같다.<br>
<br>메모리 공간의 할당
<br>생성자의 호출
<br>할당하고자 하는 자료형에 맞게 반환된 주소 값의 형 변환 -&gt; malloc과 달리 반환하는 주소값을 형변환할 필요가 없음.
<br>이 세 가지 동작 중에서 개발자는 1번에 해당하는 메모리 공간의 할당만 오버로딩 할 수 있다. 나머지 두 가지 작업은 C++ 컴파일러에 의해서 진행이 되며, 오버로딩할 수 있는 대상도 아니다.<br>다음과 같은 형식으로 오버로딩하도록 사전에 약속되어 있다.<br>
/*아래의 기본적인 동작에 사용자가 원하는 동작을 추가적으로 정의한다.*/
void *operator new (size_t size)
{
	void *adr = new char[size];
	return (adr);
}

<br>delete 연산자가 호출되면 다음과 같이 동작한다.<br>
<br>다음의 문장으로 객체의 소멸을 명령하면 delete obj;
<br>컴파일러는 먼저 obj가 가리키는 객체의 소멸자를 호출한다.
<br>그 다음 다음의 형태로 정의된 함수에 ptr에 저장된 주소 값을 전달한다.
<br>
void operator delete (void *adr) { . . . . }

<br>따라서 delete 함수는 최소한 다음의 동작을 포함해야 하며, 그 의외에 필요한 추가적인 내용을 개발자가 추가한다.<br>
void operator delete (void *adr)
{
	delete []adr;
}

<br>참고로, 사용하는 컴파일러에서 void 포인터 형 대상의 delete 연산을 허용하지 않는다면, 위의 delete 문을 다음과 같이 작성하면 된다. 즉, char 포인터 형으로 변환해서 delete 연산을 진행하면 된다.<br>delete []((char *)adr);<br>new 연산자는 멤버함수의 형태로 오버로딩되지만, 아래와 같이 객체가 생성되기도 전에 호출할 수 있다.<br>
Obj *ptr = new Obj(3, 4);

<br>이는 operator new, operator delete 함수는 static 함수이기 때문이다. 멤버함수의 형태로 함수를 작성해도 두 함수는 static 함수로 간주되도록 약속이 되어있다.<br><br>new[], delete[] 함수는 배열 할당, 해제 시 호출되는 함수라는 점만 제외하고 new, delete 함수과 동일하다.<br>
void *operator new[] (size_t size) { . . . . }
void operator delete[] (void *adr) { . . . . }

<br><br><br>포인터를 기반으로 하는 연산자에는 다음이 있다.<br><br>그리고 이 두 연산자의 오버로딩은 아래의 예제와 같이 이루어진다.<br>
#include &lt;iostream&gt;
using namespace std;

class Number
{
	priate :
		int num;
	public :
		Number(int n) : num(n) { }
		void ShowData() {cout&lt;&lt;num&lt;&lt;endl;}
		
		/*객체 자신의 주소 값을 반환하도록 -&gt;연산자를 오버로딩 하고 있다. -&gt; 연산자를 다른 형태로 오버로딩 하는 것도 가능하지만, 이 연산자의 오버로딩을 허용하는 이유는 주소 값의 반환이 목적이기 따문에 다른 형태로는 오버로딩하지 않는 것이 좋다.*/
		Number *operator-&gt;()
		{
			return this;
		}
		/*이 함수는 객체 자신을 참조의 형태로 반환하도록 *연산자를 오버로딩하고 있다.*/
		Number &amp;operator*()
		{
			return *this;*
		}
};

int main(void)
{
	Number num(20);
	num.ShowData();
	
	/*객체 num이 포인터 변수인 것처럼 연산문이 구성되었다. 이는 *,-&gt; 연산자의 오버로딩 결과이다.*/
	(*num) = 30;
	num-&gt;ShowData();
	(*num).ShowData();

	return (0);
}

<br>포인터 연산자 오버로딩을 통해, 기존에 포인터 연산자의 기능에 사용자가 정의한 기능을 추가한 포인터 연산자를 만들 수 있다. 이러한 포인터는 객체의 형태로 구현되며, 스마트 포인터(Smart Pointer)라고 한다.<br><br><br>함수의 호출에 사용하는 () 또한 연산자이다. 때문에 이 역시 오버로딩이 가능하다. () 연산자 오버로딩의 목적은 객체를 함수처럼 사용하는 것이다.<br>() 연산자 오버로딩은 아래의 예제와 같이 이루어진다.<br>
class Functor
{
	public :
	//생략
		void operator()(int a, int b) { /*정의된 동작*/ }
}

int main()
{
	Functor obj;
	obj(2, 4); //obj.operator()(2, 4);와 동일하게 동작함.
}

<br>위와 같이 함수처럼 동작하는 클래스를 가리켜 펑터(functor), 또는 함수 오브젝트(Function Object)라고 한다.<br>펑터는 다음과 같이 응용할 수 있다.<br>
<br>부모 클래스에서 operator()()를 순수 가상함수로 선언한다.
<br>자식 클래스에서 operator()()의 동작을 정의한다.
<br>부모 클래스의 참조형으로 입력을 받는 함수가 있다고, 가정할 때, 다양한 기능을 구현한 자식 클래스들을 그 자리에 입력할 수 있으며, 어떤 자식을 입력하는 지에 따라 동작이 달라진다. 이것이 펑터의 이점이다.
<br><br><br>c++에서는 다음과 같은 코드의 실행이 가능한다.<br>
int main(void)
{
	Number num;
	num = 30; //서로 다른 자료형 간의 대입이 가능하다.
	num.ShowNumber();
	return (0);
}

<br>위 예제에서 num = 30;은 다음과 같이 변환되어 처리된다.<br>
num = Number(30); //1단계. 임시 객체의 생성
num.operator=(Number(30)); //2단계. 임시 객체를 대상으로 하는 대입 연산자의 호출

<br>c++에는 다음과 같은 문법적 기준이 존재한다.<br>A형 객체가 와야 할 위치에 B형 데이터(또는 객체)가 왔을 경우, B형 데이터를 인자로 전달받은 A형 클래스의 생성자 호출을 통해서 A형 임시객체를 생성한다.<br><br><br>형 변환 연산자는 객체가 다른 타입의 데이터와 연산이 일어난 때 호출되는 연산자이다.<br>
아래의 예제를 확인하자.<br>
int main(void)
{
	Number num1(30);
	
	Number num2 = num1 + 20; //서로 다른 자료형 간의 + 연산이 일어남.
	num2.ShowNumber();
	return 0;
}

<br>위의 예제가 실행 가능하려면 아래의 두 가지 방법 중 하나를 사용해야 한다.<br>
<br>int 타입 데이터와의 + 연산이 가능하도록 + 연산자를 오버로딩한다.
<br>Number 객체의 int 자료형으로의 형 변환을 구현한다.
<br>c++ 언어에서는 2번 방법을 구현하기 위해 형 변환 연산자의 오버로딩을 사용한다.<br>
아래와 같이 구현한다.<br>
operator int () // 형 변환 연산자의 오버로딩.
{
	return (num);
}

<br>형 변환 연산자 함수는 아래와 같은 특징을 가진다.<br>
<br>'operator + 형 변환하는 데이터 타입' 형식의 함수명을 가진다.
<br>정의된 데이터 타입으로 형 변환해야 하는 경우에 호출된다.
<br>반환형을 명시하지 않는다. 하지만 return을 사용한 반환은 가능하다. 이 때 return으로 반환되는 값은 정의된 데이터 타입으로 형 변환된다.
<br><br>참고자료<br><a href=".?query=tag:참고도서\윤성우의_열혈_cpp_프로그래밍" class="tag" target="_blank" rel="noopener nofollow">#참고도서/윤성우의_열혈_cpp_프로그래밍</a><br>]]></description><link>resource\language\c++\연산자-오버로딩.html</link><guid isPermaLink="false">resource/Language/C++/연산자 오버로딩.md</guid><pubDate>Sat, 22 Mar 2025 07:31:41 GMT</pubDate><enclosure url="lib\media\디폴트-대입-연산자의-동작(얕은-복사).png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;lib\media\디폴트-대입-연산자의-동작(얕은-복사).png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[예외 처리]]></title><description><![CDATA[<a class="tag" href="?query=tag:language/cpp" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#language/cpp</a> <a class="tag" href="?query=tag:참고도서/윤성우의_열혈_cpp_프로그래밍" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/윤성우의_열혈_cpp_프로그래밍</a> 
 <br><br><a href=".?query=tag:language\cpp" class="tag" target="_blank" rel="noopener nofollow">#language/cpp</a><br>exception handling<br><br><br>C++에서 말하는 예외의 정의는 다음과 같다.<br>프로그램 실행 도중에 발생하는 문제상황<br>
프로그램의 논리에 맞기 않는 상황<br>따라서 문법적인 에러는 예외의 범주에 포함되지 않는다.<br>C에서는 보통 if else문을 사용해 분기를 구성함으로서 이러한 예외들을 처리한다. 그러나 이러한 방식은 예외처리를 위한 코드와 프로그램의 흐름을 구성하는 코드를 쉽게 구분하지 못한다는 문제가 있다. C++은 이러한 문제를 해결하기 위해 별도의 예외 처리 매커니즘을 보유하고 있다.<br><br><br>C++에서 예외 처리를 위한 키워드는 아래의 3가지가 있다.<br><br>
<br>try 블록
<br>try 블록은 예외 발생에 대한 검사의 범위를 지정할 때 사용된다. 즉, try 블록 내에서 예외가 발생하면 이는 C++의 예외처리 매커니즘에 의해서 처리가 된다.<br>
try
{
	// 예외발생 예외지역
}

<br>
<br>catch 블록
<br>catch 블록은 try 블록에서 발생한 예외를 처리하는 코드가 담기는 영역으로서, 그 형태가 마치 반환형 없는 함수와 유사하다.<br>
catch(/*처리할 예외의 종류 명시*/)
{
	// 예외처리 코드의 삽입
}

<br>
<br>사실 try와 catch는 하나의 단위이다.

<br>따라서 항상 이어서 등장해야 하며, 중간에 다른 문장이 오면 안된다.


<br>종합적으로, try 블록 내에서 발생하는 예외는 이어서 등장하는 catch 블록에 의해 처리된다.<br>
<br>throw
<br>키워드 throw는 예외가 발생했음을 알리는 문장의 구성에 사용된다.<br>
throw expn;

<br>최종적으로 try, catch, throw는 다음과 같이 동작한다.<br>
<br>throw에 의해서 '예외 데이터'가 던져진다.
<br>'예외 데이터'를 감싸는 try 블록에 의해 감지된다.
<br>이어서 등장하는 catch 블록이 예외를 처리한다.
<br>구체적인 동작은 아래의 예제를 참고하자.<br>
/*HandlingExceptionTryCatch.cpp*/

#include &lt;iostream&gt;
using namespace std;

int main(void)
{
	int num1, num2;
	cout&lt;&lt;"두 개의 숫자 입력: ";
	cin&gt;&gt;num1&gt;&gt;num2;
	
	try //try 블록으로 에러 발생이 예상되는 영역을 묶는다.
	{
		if (num2 == 0) //에러의 조건
			throw num2; //에러 데이터를 던진다
		//만약 에러가 발생하면 발생 지점 이후의 try 블록은 건너뛴다.
		cout&lt;&lt;"나눗셈의 몫: "&lt;&lt;(num1 / num2)&lt;&lt;endl;
		cout&lt;&lt;"나눗셈의 나머지: "&lt;&lt;(num1 % num2)&lt;&lt;endl;
	}
	catch(int expn) //에러 데이터를 받아 블록 내에서 적절한 예외 처리를 한다.
	{
		cout&lt;&lt;"제수는 "&lt;&lt;expn&lt;&lt;"이 될 수 없습니다."&lt;&lt;endl;
		cout&lt;&lt;"프로그램을 다시 실행하세요."&lt;&lt;endl;
	}
	cout&lt;&lt;"end of main"&lt;&lt;endl;
	
	return (0);
}

<br>
<br>팁 : try 블록 내에서, 에러 발생 시점 이후의 문장들은 건너뛴다는 특성을 잘 활용하자. 에러와 직접적으로 관련이 없더라도 에러 발생 시 실행되면 안되는 문장들은 try 블록 안으로 집어넣는 것이 바람직하다.
<br><br><br>try 블록 내에서 직접적으로 catch가 실행되지 않고, try 내부에서 호출한 함수 내부에서 catch가 실행되는 경우가 있다.<br>
/*PassException.cpp*/

#include &lt;iostream&gt;
using namespace std;

void Divide(int num1, int num2)
{
	if (num2 == 0)
		throw num2; //throw는 try, catch 블록이 없다. 이러한 경우에는 함수를 호출한 곳으로 '예외 데이터'를 던진다.
	cout&lt;&lt;"나눗셈의 몫 : "&lt;&lt; num1 / num2 &lt;&lt;endl;
	cout&lt;&lt;"나눗셈의 나머지 : "&lt;&lt; num % num2 &lt;&lt;endl;
}

int main(void)
{
	int num1, num2;
	cout&lt;&lt;"두 개의 숫자 입력 : ";
	cin&gt;&gt;num1&gt;&gt;num2;
	
	try //try 블록 내에서 throw가 직접적으로 호출되지 않고, Divide 내에서 호출된다.
	{
		Divide(num1, num2);
		cout&lt;&lt;"나눗셈을 마쳤습니다."&lt;&lt;endl;
	}
	catch(int expn)
	{
		cout&lt;&lt;"제수는 "&lt;&lt;expn&lt;&lt;"이 될 수 없습니다."&lt;&lt;endl;
		cout&lt;&lt;"프로그램을 다시 실행하세요."&lt;&lt;endl;
	}
	return (0);
}

<br>위 예제에서 다음의 특성을 알 수 있다.<br>예외가 처리되지 않으면, 예외가 발생한 함수를 호출한 영역으로 예외 데이터가(더불어 예외처리에 대한 책임까지) 전달된다.<br>
함수 내에서 함수를 호출한 영역으로 예외 데이터를 전달하면, 해당 함수는 더 이상 실행되지 않고 종료가 된다.<br>다음과 같이 여러 개의 함수를 걸쳐 '예외 데이터'가 전달되는 케이스를 생각하여보자.<br>
/*StackUnwinding.cpp*/

#include &lt;iostream&gt;
using namespace std;

void SimpleFuncOne(void);
void SimpleFuncTwo(void);
void SimpleFuncThree(void);

int main(void)
{
	try
	{
		SimpleFuncOne();
	}
	catch (int expn)
	{
		cout&lt;&lt;"예외코드: "&lt;&lt;expn&lt;&lt;endl;
	}
	return (0);
}

void SimpleFuncOne(void)
{
	cout&lt;&lt;"SimpleFuncOne(void)"&lt;&lt;endl;
	SimpleFuncTwo();
}
void SimpleFuncTwo(void)
{
	cout&lt;&lt;"SimpleFuncTwo(void)"&lt;&lt;endl;
	SimpleFuncThree();
}
void SimpleFuncThree(void)
{
	cout&lt;&lt;"SimpleFuncThree(void)"&lt;&lt;endl;
	throw -1;
}

<br>만약 예외가 발생할 경우, try catch 문을 만날 때까지 호출된 함수의 역순으로 예외 데이터가 전달된다. 예외 데이터를 전달한 함수는 종료되기 때문에, 호출된 함수의 역순으로 함수의 스택은 반환된다.<br>
이를 스택 풀기(스택의 반환)이라고 명명한다.<br>만약 예외가 처리되지 않아서, 예외 데이터가 main 함수에까지 도달했는데, main 함수에서조차 예외를 처리하지 않으면, terminate 함수(프로그램을 종료시키는 함수)가 호출되면서 프로그램이 종료되어 버린다.<br>만약 throw로 던진 '예외 데이터'의 자료형과 catch 블록 인자의 자료형이 일치하지 않으면, catch 블록으로 예외가 전달되지 않는다. 예외 데이터를 던질 수 있는 다른 영역이 있으면 그 곳으로 예외를 던지고, 그렇지 않으면 terminate 함수로 인해 종료된다.<br><br>throw 키워드로 던질 수 있는 '예외 데이터'의 자료형은 복수일 수 있기 때문에, 다음과 같이 catch 문도 여러 개 존재할 수 있다.<br>
#include &lt;iostream&gt;
using namespace std;

int main()
{
	char c;

	cout&lt;&lt;"값 입력 : ";
	cin&gt;&gt;c;

	try
	{
		if (c == "1")
			throw 1; //int 형을 던짐
		else if(c == "a")
			throw "a"; //char 형을 덤짐
	}
	catch (int expn)
	{
		cout&lt;&lt;"입력값은 int type"&lt;&lt;endl;
	}
	catch (char expn)
	{
		cout&lt;&lt;"입력값은 char type"&lt;&lt;endl;
	}
	cout&lt;&lt;endl&lt;&lt;"end of main"&lt;&lt;endl;
}

<br><br><br>함수 내에서 발생할 수 있는 예외의 종류도 함수의 특징으로 간주된다. 따라서 이미 정의된 특정 함수의 호출을 위해서는 함수의 이름, 매개변수 선언, 반환형 정보에 더해서, 함수 내에서 전달될 수 있는 예외의 종류(예외 데이터의 자료형)과 그 상황도 알아야 한다. 따라서 함수를 정의할 때에는 함수 내에서 발생 가능한 예외의 종류를 다음과 같이 명시해 주는 것이 좋다.<br>
int ThrowFunc(int num) throw (int, char)
{
	// . . . .
}

<br>함수에 사전에 명시한 자료형 이외의 '예외 데이터'를 함수가 반환하면, 역시 terminate(unexpected) 함수의 호출로 인해서 프로그램은 종료된다.<br><br>클래스의 객체 또한 '예외 데이터'가 될 수 있다. 예외 발생을 알리는 데 사용되는 객체를 가리켜 '예외 객체'라 하며, 예외 객체의 생성을 위해 정의된 클래스를 '예외 클래스'라고 한다. 객체를 이용해서 예외 상황을 알리면, 예외가 발생한 원인에 대한 정보를 자세히 담을 수 있다는 장점이 있다.<br>또한, 예외클래스 또한 상속이 가능하며, 이를 통하여 예외의 처리를 더욱 단순화할 수 있다.<br><br><br>try 블록의 뒤를 이어서 등장하는 catch 블록이 둘 이상인 경우, 적절한 catch 블록을 찾는 과정은 다음과 같다.<br>
try
{
	//예외 발생
}
catch(type1 param) //1차 : 이 예외에 타당한 catch 블록인가?
{
	//예외 처리
}
//아니라면
catch(type2 param) //2차 : 이 예외에 타당한 catch 블록인가?
{
	//예외 처리
}
//그것도 아니라면
catch(type3 param) //3ck : 이 예외에 타당한 catch 블록인가?
{
	//예외 처리
}
//다 아니라면 다른 영역으로 전달

<br>따라서 클래스 A가 있고, 클래스 B와 C가 A를 상속한다면 다음과 같이 블록을 짜면 안된다. 첫번째 블록에서 걸리기 때문이다.<br>
try
{}
catch (A param) //B와 C도 A의 일종으로 간주되므로 여기서 걸린다.
{}
catch (B param)
{}
catch (C param)
{}

<br>다음과 같이 구성하는 것이 좋다.<br>
try
{}
catch (C param) //A, B는 여기서 걸리지 않음
{}
catch (B param) //A는 걸리지 않음
{}
catch (A param)
{}

<br><br><br>new 연산에 의한 메모리 공간의 할당이 실패하면 bad_alloc이라는 예외가 발생한다. bad_alloc은 헤더파일 &lt;new&gt;에 선언된 예외 클래스로서 메모리 공간의 할당이 실패헀음을 알리는 의도로 정의되었다. 그럼 이와 관련하여 다음 예제를 보자.<br>
/*BadAlloc.cpp*/

#include &lt;iostream&gt;
#include &lt;new&gt;
using namespace std;

int main(void)
{
	int num = 0;
	
	try
	{
		while (1)
		{
			num++;
			cout&lt;&lt;num&lt;&lt;"번째 할당 시도"&lt;&lt;endl;
			new int[10000][10000];
		}
	}
	catch(bad_alloc &amp;bad)
	{
		cout&lt;&lt;bad.what()&lt;&lt;endl;
		cout&lt;&lt;"더 이상 할당 불가!"&lt;&lt;endl;
	}
	return (0);
}

<br><br><br>catch 블록에 전달된 예외는 다시 던져질 수 있다. 그리고 이로 인해서 하나의 예외가 둘 이상의 catch 블록에 의해서 처리되게 할 수 있다.<br>
/*ReThrow.cpp*/

#include &lt;iostream&gt;
using namespace std;

void Divide(int num1, int num2)
{
	try
	{
		if (num2 == 0)
			throw (0);
		cout&lt;&lt;"몫: "&lt;&lt;(num1 / num2)&lt;&lt;endl;
		cout&lt;&lt;"나머지: "&lt;&lt;(num1 % num2)&lt;&lt;endl;
	}
	catch (int expn)
	{
		cout&lt;&lt;"first catch"&lt;&lt;endl;
		throw; //예외를 다시 던진다.
	}
}

int main(void)
{
	try
	{
		Divide(9, 2);
		Divide(4, 0);
	}
	catch (int expn)
	{
		cout&lt;&lt;"second catch"&lt;&lt;endl;
	}
	return (0);
} 

<br><br><br><a data-tooltip-position="top" aria-label="형 변환" data-href="형 변환" href="resource\language\c++\형-변환.html" class="internal-link" target="_self" rel="noopener nofollow">dynamic_cast</a>를 이용한 형 변환 중, 다음의 경우 bad_cast 예외가 발생한다.<br>
<br>변환 대상이 실제로 가리키는 객체의 자료형과, 변환 대상의 변환 후 자료형이 다를 경우
<br>변환 대상의 자료형이 포인터가 아니라 참조형이어서 dynamic_cast가 NULL을 반환할 수 없는 경우
<br>구체적인 동작은 아래의 예제를 참고하자<br>
/*DynamicBadCastRef.cpp*/

#include &lt;iostream&gt;
using namespace std;

class SoSimple
{
	public :
		virtual void ShowSimpleInfo()
		{
			cout&lt;&lt;"SoSimple Base Class"&lt;&lt;endl;
		}
};

class SoComplex : public SoSimple
{
	public :
		void ShowSimpleInfo()
		{
			cout&lt;&lt;"SoComplex Derived Class"&lt;&lt;endl;
		}
};

int main(void)
{
	SoSimple simObj;
	SoSimple &amp;ref = simObj;
	
	try
	{
		SoComplex &amp;comRef = dynamic_cast&lt;SoComplex &amp;&gt;(ref); //bad_cast 예외 발생
		comRef.ShowSimpleInfo();
	}
	catch(bad_cast expt)
	{
		cout&lt;&lt;expt.what()&lt;&lt;endl;
	}
	return (0);
}

<br><br>참고자료<br><a href=".?query=tag:참고도서\윤성우의_열혈_cpp_프로그래밍" class="tag" target="_blank" rel="noopener nofollow">#참고도서/윤성우의_열혈_cpp_프로그래밍</a><br>]]></description><link>resource\language\c++\예외-처리.html</link><guid isPermaLink="false">resource/Language/C++/예외 처리.md</guid><pubDate>Sat, 22 Mar 2025 07:31:42 GMT</pubDate></item><item><title><![CDATA[이름공간]]></title><description><![CDATA[<a class="tag" href="?query=tag:language/cpp" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#language/cpp</a> <a class="tag" href="?query=tag:참고도서/윤성우의_열혈_cpp_프로그래밍" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/윤성우의_열혈_cpp_프로그래밍</a> 
 <br><br><a href=".?query=tag:language\cpp" class="tag" target="_blank" rel="noopener nofollow">#language/cpp</a> <br>namespace<br><br>'이름공간'이란 특정 영역에 이름을 붙여주기 위한 문법적 요소이다.<br>이름공간의 등장 배경<br>여러 명이서 협업을 하는 규모가 큰 프로젝트가 있다고 가정하자. 만약 불운하게 개발자들이 만든 함수들의 이름이 서로 같다면 컴파일 에러가 날 것이다. 서로 같은 이름을 가진 함수라도 서로 다른 영역에 있음을 규정할 수 있다면 컴파일 에러를 막을 수 있을 것이다. 이러한 전제 하에 이름공간의 개념이 등장하게 되었다.<br>이름공간은 아래 예제와 같이 사용될 수 있다.<br>
#include &lt;iostream&gt;

namespace BestComImpl
{
	void SimpleFunc(void)
	{
		std::cout&lt;&lt;"BestCom이 정의한 함수"&lt;&lt;std::endl;
	}
}

namespace ProgComImpl
{
	void SimpleFunc(void)
	{
		std::cout&lt;&lt;"ProgCom이 정의한 함수"&lt;&lt;std::endl;
	}
}

int main(void)
{
	BestComImpl::SimpleFunc();
	ProgComImpl::SimpleFunc();

	return 0;
}

<br>함수를 호출할 때 <a data-href="범위지정 연산자" href="resource\language\c++\범위지정-연산자.html" class="internal-link" target="_self" rel="noopener nofollow">범위지정 연산자</a> ::을 사용해 어느 이름공간의 함수를 호출하는지 정의할 수 있다.<br>이름공간은 다음과 같은 특징을 지닌다.<br>
<br>이름공간에 속한 함수의 원형을 선언할 때는 아래와 같은 형식을 취한다.
<br>
#include &lt;iostream&gt;

namespace BestComImpl
{
	void SimpleFunc(void); //함수의 원형
}

namespace ProgComImpl
{
	void SimpleFunc(void);
}

int main(void)
{
	BestComImpl::SimpleFunc();
	ProgComImpl::SimpleFunc();
	
	return 0;
}

void BestComImpl::SimpleFunc(void) //함수의 정의
{
	std::cout&lt;&lt;"BestCom이 정의한 함수"&lt;&lt;std::endl;
}

void ProgComImpl::SimpleFunc(void)
{
	std::cout&lt;&lt;"ProgCom이 정의한 함수"&lt;&lt;std::endl;
}

<br>
<br>동일한 이름공간에 정의된 함수를 호출할 때는 이름공간을 명시할 필요가 없다.
<br>
#include &lt;iostream&gt;

namespace BestComImpl
{
	void SimpleFunc(void);
}

namespace BestComImpl
{
	void PrettyFunc(void);
}

namespace ProgComImpl
{
	void SimpleFunc(void);
}

int main(void)
{
	BestComImpl::SimpleFunc();
	return 0;
}

void BestComImpl::SimpleFunc(void)
{
	std::cout&lt;&lt;"BestCom이 정의한 함수"&lt;&lt;std::endl;
	PrettyFunc(); //동일한 이름공간의 함수를 호출할 떄는 범위 지정 연산자가 불필요
	ProgComImpl::SimpleFunc();
}

void BestComImpl::PrettyFunc(void)
{
	std::cout&lt;&lt;"So Pretty!!"&lt;&lt;std::endl;
}

void ProgComImpl::SimpleFunc(void)
{
	std::cout&lt;&lt;"ProgCom이 정의한 함수"&lt;&lt;std::endl;
}

<br>
<br>이름공간은 다른 이름공간 안에 삽입될 수 있다. 이러한 특성을 이름공간의 중첩이라 한다.
<br>
#include &lt;iostream&gt;

namespace Parent
{
	int num=2;

	namespace SubOne //이름 공간의 중첩
	{
		int num=3;
	}
	
	namespace SubTwo
	{
		int num=4;
	}
}

int main(void)
{
	//아래와 같은 형태로 호출한다.
	std::cout&lt;&lt;Parent::num&lt;&lt;std::endl;
	std::cout&lt;&lt;Parent::SubOne::num&lt;&lt;std::endl;
	std::cout&lt;&lt;Parent::SubTwo::num&lt;&lt;std::endl;
}

<br>
<br>이름공간이 과다하게 중첩되었을 때 별칭을 지정하여 코드를 축약할 수 있다.
<br>
#include &lt;iostream&gt;

using namespace std;

namespace AAA
{
	namespace BBB
	{
		namespace CCC
		{
			int num1;
			int num2;
		}
	}
}

int main(void)
{
	AAA::BBB::CCC::num1=20;
	AAA::BBB::CCC::num2=30;

	namespace ABC=AAA::BBB::CCC; //이와 같은 형식으로 축약할 수 있다.
	cout&lt;&lt;ABC::num1&lt;&lt;endl;
	cout&lt;&lt;ABC::num2&lt;&lt;endl;
	return 0;
}

<br>
<br>using 키워드를 사용하면 범위지정 연산자를 생략할 수 있다. 함수 안에서 사용된 using 키워드는 지역변수와 같이 함수 안에서만 효력을 가진다. 프로그램 전체에 영향을 끼치려면 전역변수와 마찬가지로 함수 밖에 선언을 해야 한다. using 키워드를 namespace 전체에 적용하면 해당 namespace의 요소 모두를 범위지정 연산자를 생략하여 사용할 수 있다. 하지만 이름충돌의 위험이 증가함으로 상황을 고려해 알맞게 사용해야 한다.
<br>
#include &lt;iostream&gt;

namespace Hybrid
{
	void HybFunc(void)
	{
		std::cout&lt;&lt;"So simple function!"&lt;&lt;std::endl;
		std::cout&lt;&lt;"In namespace Hybrid!"&lt;&lt;std::endl;
	}
}

int main(void)
{
	using Hybrid::HybFunc;
	HybFunc(); //using 키워드가 선언된 함수에 한하여 ::생략
	return 0;
}

<br>
#include &lt;iostream&gt;

using std::cin; //프로그램 전체에 using 키워드 적용
using std::cout;
using std::endl;

int main(void)
{
	int num=20;
	cout&lt;&lt;"Hello World!"&lt;&lt;endl;
	cout&lt;&lt;"Hello "&lt;&lt;"World!"&lt;&lt;endl;
	cout&lt;&lt;num&lt;&lt;' '&lt;&lt;'A';
	cout&lt;&lt;' '&lt;&lt;3.14&lt;&lt;endl;
	return 0;
}

<br>
#include &lt;iostream&gt;

using namespace std; //using 키워드를 이름공간 전체에 적용

int main(void)
{
	int num=20;
	cout&lt;&lt;"Hello World!"&lt;&lt;endl;
	cout&lt;&lt;"Hello "&lt;&lt;"World!"&lt;&lt;endl;
	cout&lt;&lt;num&lt;&lt;' '&lt;&lt;'A';
	cout&lt;&lt;' '&lt;&lt;3.14&lt;&lt;endl;
	return 0;
}

<br><br>참고자료<br><a href=".?query=tag:참고도서\윤성우의_열혈_cpp_프로그래밍" class="tag" target="_blank" rel="noopener nofollow">#참고도서/윤성우의_열혈_cpp_프로그래밍</a><br>]]></description><link>resource\language\c++\이름공간.html</link><guid isPermaLink="false">resource/Language/C++/이름공간.md</guid><pubDate>Sat, 22 Mar 2025 07:31:42 GMT</pubDate></item><item><title><![CDATA[인라인 함수]]></title><description><![CDATA[<a class="tag" href="?query=tag:language/cpp" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#language/cpp</a> <a class="tag" href="?query=tag:참고도서/윤성우의_열혈_cpp_프로그래밍" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/윤성우의_열혈_cpp_프로그래밍</a> 
 <br><br><a href=".?query=tag:language\cpp" class="tag" target="_blank" rel="noopener nofollow">#language/cpp</a> <br>inline function<br><br>인라인 함수를 의역하면, '프로그램 코드라인 안으로 들어가 버린 함수'라는 뜻이다. c 언어의 매크로 함수는 함수의 몸체 부분이 함수의 호출문을 완전히 대체하므로, 인라인 함수의 정의와 일맥상통하는 부분이 있다.<br>매크로 함수의 장점은 아래와 같다.<br>
<br>일반적인 함수에 비해 실행속도의 이점이 있다.
<br>자료형의 제한이 없다
<br>매크로 함수의 단점은 아래와 같다.<br>
<br>정의하기가 어렵다.
<br>복잡한 함수를 매크로의 형태로 정의하는 데 한계가 있다.
<br>인라인 함수는 매크로 함수의 장점을 취하고 단점은 제거하기 위해 만들어진 개념이다.<br>
인라인 함수는 키워드 inline을 사용해 아래와 같이 선언된다.<br>
#include &lt;iostream&gt;

inline int SQUARE(int x) //인라인 함수의 몸체 부분은 호출문을 대체한다.
{
	return x*x;
}

int main(void)
{
	std::cout&lt;&lt;SQUARE(5)&lt;&lt;std::endl;
	std::cout&lt;&lt;SQUARE(12)&lt;&lt;std::endl;

	return 0;
}

<br>단, 인라인 함수는 매개변수의 자료형을 정의해야 하므로 매크로 함수의 모든 장점을 가질 수는 없다. <a data-href="템플릿" href="resource\language\c++\템플릿.html" class="internal-link" target="_self" rel="noopener nofollow">템플릿</a>과 인라인 함수를 같이 사용하면 이러한 한계를 극복할 수 있다.<br>매크로를 이용한 함수의 인라인화는 전처리기에 의해 처리되지만, 키워드 inline을 이용한 함수의 인라인화는 컴파일러에 의해 처리된다. 따라서 함수의 인라인화가 오히려 성능에 해가 된다고 판단할 경우, 컴파일러는 이 키워드를 무시해버리기도 한다. 또한 컴파일러는 필요한 경우 일부 함수를 임의로 인라인 처리하기도 한다.<br>또한 키워드 inline을 이용한 함수의 인라인화는 컴파일러에 의해 처리되기 때문에, 인라인 함수의 원형 선언과 정의는 같은 파일 안에 위치하여 컴파일러가 동시에 참조할 수 있게 해야 한다.<br><br>참고자료<br><a href=".?query=tag:참고도서\윤성우의_열혈_cpp_프로그래밍" class="tag" target="_blank" rel="noopener nofollow">#참고도서/윤성우의_열혈_cpp_프로그래밍</a><br>]]></description><link>resource\language\c++\인라인-함수.html</link><guid isPermaLink="false">resource/Language/C++/인라인 함수.md</guid><pubDate>Sat, 22 Mar 2025 07:31:42 GMT</pubDate></item><item><title><![CDATA[임시 객체]]></title><description><![CDATA[<a class="tag" href="?query=tag:language/cpp" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#language/cpp</a> <a class="tag" href="?query=tag:참고도서/윤성우의_열혈_cpp_프로그래밍" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/윤성우의_열혈_cpp_프로그래밍</a> 
 <br><br><a href=".?query=tag:language\cpp" class="tag" target="_blank" rel="noopener nofollow">#language/cpp</a> <br>temporary object<br><br>함수의 반환형이 <a data-href="클래스" href="resource\language\c++\클래스.html" class="internal-link" target="_self" rel="noopener nofollow">클래스</a>이고, 함수가 값을 반환할 때, 메모리 공간에 임시로 객체를 생성하여 반환을 받는 쪽이 참조할 수 있도록 한다. 이를 임시 객체라고 한다.<br>임시 객체는 개발자가 다음과 같은 형식으로 직접 선언할 수도 있다.<br>
Temporary(200); //클래스명(생성자에게 전달할 인자); 형식

<br>외부에서 객체의 멤버함수를 호출하기 위해 필요한 것은 다음 세 가지 중 하나이다.<br>
<br>객체에 붙여진 이름
<br>객체의 참조 값(객체 참조에 사용되는 정보)
<br>객체의 주소 값
<br>임시객체가 생성된 위치에는 임시객체의 참조 값이 반환되므로, 다음과 같이 임시객체의 멤버함수에 접근할 수 있다.<br>
Temporart(200).ShowTempInfo(); //(임시객체의 참조 값).ShowTempInfo();

<br>
//SimpleFuncObj는 객체를 반환 -&gt; 해당 위치에 임시 객체의 참조값을 생성

SimpleFuncObj(obj).AddNum(30);

<br>임시 객체는 다음과 같은 특징을 가진다.<br>
<br>임시 객체는 다음 행으로 넘어가면 바로 소멸되어 버린다. 이후에 임시 객체를 참조할 수단이 없기 때문이다.
<br>참조자에 의해 참조되는 임시객체는 바로 소멸하지 않는다.
<br>2번 특성에 의하여, 아래 예제는 다음과 같이 해석된다.<br>
SoSimple tempRef = SimpleFuncObj(obj);

<br>위 예제는 다음과 같이 오인되기 쉽다.
-&gt; tempRef라는 새로운 객체를 생성해서, 반환되는 객체를 가지고 대입연산(복사)를 진행한다.
하지만 실제 구문은 다음과 같이 해석된다.
-&gt; 추가로 객체를 생성하지 않고, 반환되는 임시 객체에 tempRef라는 이름을 할당한다. 이는 객체의 생성 수를 하나 줄여서 효율성을 높이기 위해서이다.
<br><br>참고자료<br><a href=".?query=tag:참고도서\윤성우의_열혈_cpp_프로그래밍" class="tag" target="_blank" rel="noopener nofollow">#참고도서/윤성우의_열혈_cpp_프로그래밍</a><br>]]></description><link>resource\language\c++\임시-객체.html</link><guid isPermaLink="false">resource/Language/C++/임시 객체.md</guid><pubDate>Sat, 22 Mar 2025 07:31:42 GMT</pubDate></item><item><title><![CDATA[자료형]]></title><description><![CDATA[<a class="tag" href="?query=tag:language/cpp" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#language/cpp</a> <a class="tag" href="?query=tag:참고도서/포르잔_cpp_바이블" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/포르잔_cpp_바이블</a> 
 <br><br><a href=".?query=tag:language\cpp" class="tag" target="_blank" rel="noopener nofollow">#language/cpp</a> <br>data types<br><br><br>c++ 프로그램은 데이터를 효율적으로 조작하고자 자료를 형태에 따라 구분하며 이렇게 구분해서 인식하는 자료의 형태를 자료형 data types라고 한다.<br>자료형은 크게 내장 자료형과 사용자 정의 자료형으로 나뉜다.<br>내장 자료형 built-in types은 프로그래밍 언어에 정의된 자료형이다. 내장 자료형은 기본 자료형 fundamentals과 복합 자료형 compound types으로 구분한다. 기본 자료형은 이름 그대로 기본적인 자료형이고, 복합 자료형은 기본 자료형을 기반으로 파생된 자료형이다.<br>사용자 정의 자료형 user-defined types은 열거형 enumerated과 클래스 class로 구분한다.<br><br>자료형의 범위는 플랫폼에 따라서 다르다. 예를 들어, long int는 어떤 시스템에서는 4 byte이고 어떤 시스템에서는 8 byte이다. 아래의 표는 일반적인 플랫폼에서의 정수 자료형 범위이다.<br><br><br>원래 c++에 정의되어 있는 문자 자료형의 크기는 1바이트이며 부호가 없다. 하지만 현대에는 1, 2, 4바이트이거나 부호 있는 문자도 있다. 이는 c++ 언어가 세계의 여러 문자를 지원하기 위해 변경된  것이다.<br>이 문서에서는 문자 자료형이 ASCII 인코딩 시스템을 기반으로 하는 1바이트 정수 자료형이라고 가정한다. ASCII 인코딩 시스템은 0 ~ 127 범위의 정수를 사용해서 128개의 글자를 정의한다.<br><br>참 true 또는 거짓 false을 나타내기 위한 1바이트 자료형.<br>c++ 언어는 불 또한 정수를 이용해서 다룬다. 0은 false, 0이 아닌 값은 true로 취급한다.<br><br>소수점을 갖는 숫자를 다루는 자료형.<br><br>void 자료형은 값이 없음을 나타내는 특별한 자료형이다. 주로 '함수가 어떠한 값도 반환하지 않는다'를 나타내기 위해 사용한다.<br><br>참고자료<br><a href=".?query=tag:참고도서\포르잔_cpp_바이블" class="tag" target="_blank" rel="noopener nofollow">#참고도서/포르잔_cpp_바이블</a> <br>]]></description><link>resource\language\c++\자료형.html</link><guid isPermaLink="false">resource/Language/C++/자료형.md</guid><pubDate>Sat, 22 Mar 2025 07:31:42 GMT</pubDate></item><item><title><![CDATA[접근제어 지시자]]></title><description><![CDATA[<a class="tag" href="?query=tag:language/cpp" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#language/cpp</a> <a class="tag" href="?query=tag:참고도서/윤성우의_열혈_cpp_프로그래밍" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/윤성우의_열혈_cpp_프로그래밍</a> 
 <br><br><a href=".?query=tag:language\cpp" class="tag" target="_blank" rel="noopener nofollow">#language/cpp</a> <br>access control modifier<br><br>c++ 언어는 구조체 및 클래스의 멤버 변수 및 멤버 함수의 접근 허용범위를 접근제어 지시자를 통해 별도로 지정할 수 있다.<br>접근제어 지시자는 다음과 같이 총 세가지가 존재한다.<br><br><br>참고자료<br><a href=".?query=tag:참고도서\윤성우의_열혈_cpp_프로그래밍" class="tag" target="_blank" rel="noopener nofollow">#참고도서/윤성우의_열혈_cpp_프로그래밍</a><br>]]></description><link>resource\language\c++\접근제어-지시자.html</link><guid isPermaLink="false">resource/Language/C++/접근제어 지시자.md</guid><pubDate>Sat, 22 Mar 2025 07:31:42 GMT</pubDate></item><item><title><![CDATA[정보은닉]]></title><description><![CDATA[<a class="tag" href="?query=tag:language/cpp" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#language/cpp</a> <a class="tag" href="?query=tag:참고도서/윤성우의_열혈_cpp_프로그래밍" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/윤성우의_열혈_cpp_프로그래밍</a> 
 <br><br><a href=".?query=tag:language\cpp" class="tag" target="_blank" rel="noopener nofollow">#language/cpp</a> <br><br><a data-href="클래스" href="resource\language\c++\클래스.html" class="internal-link" target="_self" rel="noopener nofollow">클래스</a> 또는 <a data-href="구조체" href="resource\language\c++\구조체.html" class="internal-link" target="_self" rel="noopener nofollow">구조체</a>의 멤버변수를 <a data-tooltip-position="top" aria-label="접근제어 지시자" data-href="접근제어 지시자" href="resource\language\c++\접근제어-지시자.html" class="internal-link" target="_self" rel="noopener nofollow">private</a>으로 선언하고, 해당 변수에 접근하는 함수를 별도로 정의해서, 안전한 형태로 멤버변수의 접근을 유도하는 것.<br><br>참고자료<br><a href=".?query=tag:참고도서\윤성우의_열혈_cpp_프로그래밍" class="tag" target="_blank" rel="noopener nofollow">#참고도서/윤성우의_열혈_cpp_프로그래밍</a><br>]]></description><link>resource\language\c++\정보은닉.html</link><guid isPermaLink="false">resource/Language/C++/정보은닉.md</guid><pubDate>Sat, 22 Mar 2025 07:31:42 GMT</pubDate></item><item><title><![CDATA[조정자]]></title><description><![CDATA[<a class="tag" href="?query=tag:language/cpp" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#language/cpp</a> <a class="tag" href="?query=tag:참고도서/포르잔_cpp_바이블" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/포르잔_cpp_바이블</a> 
 <br><br><a href=".?query=tag:language\cpp" class="tag" target="_blank" rel="noopener nofollow">#language/cpp</a><br>manipulator<br><br><br>일반적으로 c++ 언어에서 데이터 입출력 시 표준 형식 standard format으로 값을 입출력한다.<br>하지만 상황에 따라서 이러한 입출력 형식을 바꿔야 할 때가 있다. 이를 위해 조정자 manipulator라는 객체를 사용한다. 조정자는 크게 데이터 출력을 위한 조정자와 데이터 입력을 위한 조정자로 구분할 수 있다.<br><br>출력 조정자는 크게 매개변수가 없는 조정자와 매개변수가 있는 조정자로 나뉜다.<br><br>매개변수가 필요 없는 조정자는 &lt;iostream&gt;에 정의되어있다.<br>endl을 제와한 모든 조정자는 출력 스트림의 상태를 변경해서 1회 사용하면 이후에 다른 조정자를 사용하기 전까지 계속해서 조정자가 적용된다. 즉, 1회만 지정하면 계속해서 적용된다.<br><br>endl 조정자를 사용하면 개행을 추가하여 출력한다.<br><br>기본값 : noboolalpha<br>noboolalpha 조정자는 불 값을 정수(0 또는 1)로 출력한다. boolalpha는 불 값을 리터럴(false 또는 true)로 출력한다.<br><br>기본값 : dec<br>정수를 몇 진법으로 출력할지 결정하는 조정자이다.<br>
<br>dec : 10진법
<br>oct : 8진법
<br>hex : 16진법
<br><br>기본값 : noshowbase<br>숫자를 다른 진법으로 출력할 때, 어떤 진법으로 출력하고 있는지 나타내는 접두사를 지정하는 조정자이다. 10진수는 아무 것도 붙지 않고, 8진수는 0, 16진수는 0x가 접두사로 붙어서 각각의 진법을 나타낸다.<br><br>기본값 : fixed<br>부동 소수점 자료형을 출력할 때는 고정 소수점 fixed format을 사용하는 방법과 과학 scientific 표기법을 사용하는 2가지 방법이 있다.<br><br>기본값: showpoint<br>c++는 기본적으로 소수점 아래 부분이 0일 때 소수점 아래 부분을 출력하지 않는다. 하지만 showpoint 조정자를 사용하면 소수점 아래 부분이 0일 때에도 출력한다.<br><br>기본값 : noshowpos<br>c++는 숫자가 양수일 때 양수 부호(+)를 출력하지 않는다. 음수 부호만 출력된다. showpos 조정자를 사용하면 양수일 때도 양수 기호를 출력한다.<br><br>기본값 :  nouppercase<br>16진수로 정수를 출력할 때 알파벳(a, b, c, d, e, f) 등이 출력되고 부동 소수정의 과학 표기법 때도 알파벳 e가 출력된다. 이러한 문자는 기본적으로 소문자로 출력된다. 이를 대문자로 변경할 때는 uppercase 조정자를 사용한다.<br><br>후술할 매개변수가 있는 조정자를 사용하여 정해진 크기의 영역 field에 값을 출력하는 방법을 다룬다. 정해진 크기의 영역을 잡고 나면 left, right, internal 조정자를 사용해서 숫자를 배치하는 형식을 정할 수 있다.<br><br>매개변수가 있는 조정자의 경우 사용하기 위해 &lt;iomanip&gt; 헤더를 읽어들여야 한다.<br><br>setprecision 조정자는 고정 소수점 출력 방식(과학 표기법 출력 방식 제외)에서만 사용한다. 괄호 안의 정수(n)로 소수점 뒤의 몇 자리까지 출력할지를 지정한다.<br><br>setw 조정자도 고정 소수점 출력 방식(과학 표기법 출력 방식 제외)에서만 사용된다. 괄호 안의 정수(n)은 전체 필드 크기를 의미하고, 이때 필드 크기는 정수 부분, 소수점, 소수점 아래 부분을 모두 합친 길이이다. 참고로 setw 조정자는 출력 스트림의 상태를 변경하지 않는다. 따라서 필요할 때마다 사용해야 한다. setw 조정자를 제외하고 매개변수가 있는 조정자는 출력스트림의 상태를 변경한다.<br><br>setfill 조정자는 필드의 크기가 실제 출력되는 내용보다 클 때 발생하는 패딩을 어떤 문자로 채울지 지정할 때 사용한다. 괄호 안에는 리터럴 문자를 넣는다. 이전에 설명한 조정자(left, interval, right, setw)들과 조합하여 사용한다.<br><br><br>기본값 : noboolalpha<br>불을 0과 1이 아니라, true와 false 문자열로 입력할 수 있는 조정자이다.<br><br>기본값 : dec<br>정수 입력을 10진법, 8진법, 16진법으로 입력할 수 있게 설정하는 조정자이다.<br><br>참고자료<br><a href=".?query=tag:참고도서\포르잔_cpp_바이블" class="tag" target="_blank" rel="noopener nofollow">#참고도서/포르잔_cpp_바이블</a> <br>]]></description><link>resource\language\c++\조정자.html</link><guid isPermaLink="false">resource/Language/C++/조정자.md</guid><pubDate>Sat, 22 Mar 2025 07:31:42 GMT</pubDate></item><item><title><![CDATA[참조자]]></title><description><![CDATA[<a class="tag" href="?query=tag:language/cpp" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#language/cpp</a> <a class="tag" href="?query=tag:참고도서/윤성우의_열혈_cpp_프로그래밍" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/윤성우의_열혈_cpp_프로그래밍</a> 
 <br><br><a href=".?query=tag:language\cpp" class="tag" target="_blank" rel="noopener nofollow">#language/cpp</a> <br>reference<br><br>변수명은 할당된 메모리 공간에 이름을 붙이는 것과 같다. 참조자는 이미 변수명이 붙어있는 메모리 공간이 제 2의 별칭을 붙이는 것과 같다. 변수명을 통해 메모리 공간의 데이터를 조작할 수 있는 것과 마찬가지로, 참조자를 통해서도 메모리 공간의 데이터를 조작할 수 있다.<br>변수를 이용해 참조자를 초기화하면, 변수를 참조할 수 있는 참조 값이 참조자에 저장된다.<br>참조자는 아래와 같이 선언될 수 있다.<br>
#include &lt;iostream&gt;

using namespace std;

int main(void)
{
	int num1=1020;
	int &amp;num2=num1;

	num2=3047;
	cout&lt;&lt;"VAL: "&lt;&lt;num1&lt;&lt;endl;
	cout&lt;&lt;"REF: "&lt;&lt;num2&lt;&lt;endl;

	cout&lt;&lt;"VAL: "&lt;&lt;&amp;num1&lt;&lt;endl;
	cout&lt;&lt;"REF: "&lt;&lt;&amp;num2&lt;&lt;endl;
}

<br>그리고 참조자는 아래와 같은 특징을 가진다.<br>
<br>참조자의 수에는 제한이 없다.
<br>
int num1=2749;
int &amp;num2=num1;
int &amp;num3=num1;
int &amp;num4=num1;

<br>
<br>참조자를 대상으로 참조자를 선언하는 것도 가능하다.
<br>
int1=2759;
int &amp;num2=num1;
int &amp;num3=num2;
int &amp;num4=num3;

<br>
<br>참조자는 변수에 대해서만 선언이 가능하고, 선언됨과 동시에 누군가를 참조해야만 한다. 즉, 다음과 같은 선언은 유효하지 않다.
<br>
int &amp;ref=20; //error

<br>
<br>참조자를 미리 선언했다가 후에 누군가를 참조하는 것은 불가능하며, 참조의 대상을 바꾸는 것도 불가능하다.
<br>
int &amp;ref; //error

<br>
<br>참조자를 선언하면서 NULL로 초기화하는 것도 불가능하다.
<br>
int &amp;ref=NULL; //error

<br>
<br>참조자를 사용하면 <a data-href="Call-by-reference" href="resource\language\c++\call-by-reference.html" class="internal-link" target="_self" rel="noopener nofollow">Call-by-reference</a>의 방식으로 변수를 조작할 수 있다.
<br>
#include &lt;iostream&gt;

using namespace std;

void SwapByRef2(int &amp;ref1, int &amp;ref2)
{
	int temp=ref1;
	ref1=ref2;
	ref2=temp;
}

int main(void)
{
	int val1=10;
	int val2=20;

	SwapByRef2(val1, val2);

	cout&lt;&lt;"val1: "&lt;&lt;val1&lt;&lt;endl;
	cout&lt;&lt;"val2: "&lt;&lt;val2&lt;&lt;endl;

	return 0;
}

<br>c++은 참조자를 사용하여 Call-by-reference를 할 수 있으므로 개발자는 코드리뷰를 할 때 함수 외부에 변수가 변경되는지 아닌지를 확인해야 하는 불편함이 있다.<br>따라서, 함수 내에서, 참조자를 통한 값의 변경을 진행하지 않을 경우, 참조자를 const로 선언해서, 함수의 원형만 봐도 값의 변경이 이뤄지지 않음을 알 수 있게 하는 것이 좋다.<br>
//const -&gt; 함수 HappyFunc 내에서 참조자 ref를 이용한 값의 변경을 하지 않음을 명시
void HappyFunc(const int &amp;ref) { . . . . } 

<br>
<br>참조자는 반환형으로도 사용될 수 있으며, 보통 참조자의 초기화에 함수의 반환을 사용할 때 사용된다.
<br>
//RefReturnOne.cpp
#include &lt;iostream&gt;

using namespace std;

//참조자에서 사용된 지역변수는 함수의 반환과 함께 소멸된다.
//하지만 참조사가 소멸된다고 해서 참조자가 참조하던 변수가 소멸하지는 않는다.
int&amp; RefRetFuncOne(int &amp;ref)
{
	ref++;
	return ref;
}

int main(void)
{
	int num1=1;
	int &amp;num2=RefRetFuncOne(num1);

	num1++;
	num2++;
	cout&lt;&lt;"num1: "&lt;&lt;num1&lt;&lt;endl;
	cout&lt;&lt;"num2: "&lt;&lt;num2&lt;&lt;endl;  

	return 0;
}

//RefReturnTwo.cpp
//참조자 반환을 일반 자료형으로 받는 것 또한 가능하다.
//단, 그러한 경우 참조자를 받은 일반 변수와 참조자로 참조한 변수는 서로 별개이다.
#include &lt;iostream&gt;

using namespace std;

int&amp; RefRetFuncOne(int &amp;ref)
{
	ref++;
	return ref;
}

int main(void)
{
	int num1=1;
	int num2=RefRetFuncOne(num1);

	num1+=1;
	num2+=100;
	cout&lt;&lt;"num1: "&lt;&lt;num1&lt;&lt;endl;
	cout&lt;&lt;"num2: "&lt;&lt;num2&lt;&lt;endl;
	
	return 0;
}

//RefReturnThree.cpp
//함수가 인자를 참조형으로 받지만 반환은 일반형으로 하는 경우
#include &lt;iostream&gt;

using namespace std;

int RefRetFuncTwo(int &amp;ref)
{
	ref++;
	return ref;
}

int main(void)
{
	int num1=1;
	int num2=RefRetFuncTwo(num1);

	num1+=1;
	num2+=100;
	cout&lt;&lt;"num1: "&lt;&lt;num1&lt;&lt;endl;
	cout&lt;&lt;"num2: "&lt;&lt;num2&lt;&lt;endl;

	return 0;
}

<br>
<br>const를 통해 상수화된 변수는 마찬가지로 const 참조자로만 참조할 수 있다.
<br>
const int num=20;
//int &amp;ref=num; -&gt; 컴파일 에러
const int &amp;ref=num;

<br>그리고 const 참조자를 상수화된 변수가 아닌, 상수로 초기화할 경우, 임시변수를 선언하여 참조자가 임시변수를 참조하게 한다.<br>
const int &amp;ref = 30; //임시변수를 선언하여 30을 저장 후 ref가 임시변수를 참조

<br>따라서 아래와 같은 경우가 가능해진다.<br>
int Adder(const int &amp;num1, const int &amp;num2)
{
	return (num1 + num2);
}

int main()
{
	using namespace std;
	cout&lt;&lt;Adder(3, 4)&lt;&lt;endl;
}

<br>
<br>다음과 같이 참조자를 사용하여 포인터를 사용하지 않고 힙 영역에 접근할 수 있다.
<br>
int *ptr = new int;
int &amp;ref = *ptr; //힙 영역에 할당된 변수에 대한 참조자 선언
ref = 20;
cout&lt;&lt;*ptr&lt;&lt;endl; //출력 결과는 20!

<br><br>참고자료<br><a href=".?query=tag:참고도서\윤성우의_열혈_cpp_프로그래밍" class="tag" target="_blank" rel="noopener nofollow">#참고도서/윤성우의_열혈_cpp_프로그래밍</a><br>]]></description><link>resource\language\c++\참조자.html</link><guid isPermaLink="false">resource/Language/C++/참조자.md</guid><pubDate>Sat, 22 Mar 2025 07:31:42 GMT</pubDate></item><item><title><![CDATA[추상 클래스]]></title><description><![CDATA[<a class="tag" href="?query=tag:language/cpp" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#language/cpp</a> <a class="tag" href="?query=tag:참고도서/윤성우의_열혈_cpp_프로그래밍" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/윤성우의_열혈_cpp_프로그래밍</a> 
 <br><br><a href=".?query=tag:language\cpp" class="tag" target="_blank" rel="noopener nofollow">#language/cpp</a><br>abstract class<br><br>하나 이상의 멤버 함수를 <a data-tooltip-position="top" aria-label="가상 함수" data-href="가상 함수" href="resource\language\c++\가상-함수.html" class="internal-link" target="_self" rel="noopener nofollow">순수 가상 함수</a>로 선언한 클래스.<br>
추상 클래스는 컴파일러에 의해 완전하지 못한 클래스로 간주되어 객체의 생성이 금지된다.<br><br>참고자료<br><a href=".?query=tag:참고도서\윤성우의_열혈_cpp_프로그래밍" class="tag" target="_blank" rel="noopener nofollow">#참고도서/윤성우의_열혈_cpp_프로그래밍</a><br>]]></description><link>resource\language\c++\추상-클래스.html</link><guid isPermaLink="false">resource/Language/C++/추상 클래스.md</guid><pubDate>Sat, 22 Mar 2025 07:31:42 GMT</pubDate></item><item><title><![CDATA[컨트롤 클래스]]></title><description><![CDATA[<a class="tag" href="?query=tag:language/cpp" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#language/cpp</a> <a class="tag" href="?query=tag:참고도서/윤성우의_열혈_cpp_프로그래밍" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/윤성우의_열혈_cpp_프로그래밍</a> 
 <br><br><a href=".?query=tag:language\cpp" class="tag" target="_blank" rel="noopener nofollow">#language/cpp</a> <br>control class, handler class<br><br>객체지향 프로그래밍에서 기능의 처리를 실제로 담당하는 클래스를 가리켜 컨트롤 클래스 또는 핸들러 클래스라고 한다.<br><br>참고자료<br><a href=".?query=tag:참고도서\윤성우의_열혈_cpp_프로그래밍" class="tag" target="_blank" rel="noopener nofollow">#참고도서/윤성우의_열혈_cpp_프로그래밍</a><br>]]></description><link>resource\language\c++\컨트롤-클래스.html</link><guid isPermaLink="false">resource/Language/C++/컨트롤 클래스.md</guid><pubDate>Sat, 22 Mar 2025 07:31:42 GMT</pubDate></item><item><title><![CDATA[클래스]]></title><description><![CDATA[<a class="tag" href="?query=tag:language/cpp" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#language/cpp</a> <a class="tag" href="?query=tag:참고도서/윤성우의_열혈_cpp_프로그래밍" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/윤성우의_열혈_cpp_프로그래밍</a> 
 <br><br><a href=".?query=tag:language\cpp" class="tag" target="_blank" rel="noopener nofollow">#language/cpp</a> <br>class<br><br>다른 형태의 <a data-href="구조체" href="resource\language\c++\구조체.html" class="internal-link" target="_self" rel="noopener nofollow">구조체</a>이다. 구조체와 클래스는 한 가지를 뺴고 모든 부분에서 동일하다.<br>
<br>키워드 struct를 이용해서 정의한 구조체에 선언된 변수와 함수에 별도의 접근제어 지시자를 선언하지 않으면, 모든 변수와 함수는 public으로 선언된다.
<br>키워드 class를 이용해서 정의한 클래스에 선언된 변수와 함수에 별도의 접근제어 지시자를 선언하지 않으면, 모든 변수와 함수는 private으로 선언된다.
<br><br>참고자료<br><a href=".?query=tag:참고도서\윤성우의_열혈_cpp_프로그래밍" class="tag" target="_blank" rel="noopener nofollow">#참고도서/윤성우의_열혈_cpp_프로그래밍</a><br>]]></description><link>resource\language\c++\클래스.html</link><guid isPermaLink="false">resource/Language/C++/클래스.md</guid><pubDate>Sat, 22 Mar 2025 07:31:42 GMT</pubDate></item><item><title><![CDATA[클래스 템플릿]]></title><description><![CDATA[<a class="tag" href="?query=tag:language/cpp" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#language/cpp</a> <a class="tag" href="?query=tag:참고도서/윤성우의_열혈_cpp_프로그래밍" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/윤성우의_열혈_cpp_프로그래밍</a> 
 <br><br><a href=".?query=tag:language\cpp" class="tag" target="_blank" rel="noopener nofollow">#language/cpp</a> <br>class template<br><br><br>함수를 <a data-href="템플릿" href="resource\language\c++\템플릿.html" class="internal-link" target="_self" rel="noopener nofollow">템플릿</a>으로 정의하듯이 클래스도 템플릿으로 정의가 가능하다. 그리고 이렇게 정의된 템플릿을 가리켜 클래스 템플릿(class template)이라 하며, 이를 기반으로 컴파일러가 만들어 내는 클래스를 가리켜 템플릿 클래스(template class)라 한다.<br>템플릿 클래스는 아래의 예제와 같이 만들 수 있다.<br>
template &lt;typename T&gt;
class Point
{
	private :
		T xpos, ypos; //다양한 자료형으로 x, y 좌표를 정의할 수 있음
	public :
		Point(T x = 0, T y = 0) : xpos(x), ypos(y) {}
		void ShowPosition() const
		{
			cout&lt;&lt;'['&lt;&lt;xpos&lt;&lt;", "&lt;&lt;ypos&lt;&lt;']'&lt;&lt;endl;
		}
}

int main(void)
{
	Point&lt;int&gt; pos1(3, 4);
	pos1.ShowPosition();

	Point&lt;double&gt; pos2(2.4, 3.6);
	pos2.ShowPosition();

	Point&lt;char&gt; pos3('P', 'F');
	pos3.ShowPosition();

	return (0);
}

<br>템플릿 클래스는 Point&lt;int&gt; 와 같이 표현하여 일반 클래스와 구분을 짓는다.<br><a data-href="템플릿" href="resource\language\c++\템플릿.html" class="internal-link" target="_self" rel="noopener nofollow">템플릿</a>과 달리, 클래스 템플릿은 &lt;int&gt; &lt;double&gt;과 같은 자료형 정보를 생략할 수 없다.<br><br><br>클래스 템플릿도 멤버 함수를 클래스 외부에 정의하는 것이 가능하다.<br>
template &lt;typename T&gt;
class SimpleTemplate
{
	public :
		T SimpleFunc(const T&amp; ref);
};

template &lt;typename T&gt;
T SimpleTemplate&lt;T&gt;::SimpleFunc(const T&amp; ref) { . . . . }

<br>위의 예제에서 SimpleTemplate&lt;T&gt;가 의미하는 바는 다음과 같다.<br>T에 대해 템플릿화 된 SimpleTemplate 클래스 템플릿<br>또한, 클래스 템플릿의 정의와 외부에 선언된 함수의 정의는 완전히 별개이기 때문에 각각에 대해서 문자 T가 무엇을 의미하는 지 설명해야 한다. 따라서 template&lt;typename T&gt;를 생략할 수는 없다.<br>또한 컴파일 과정에서 컴파일러는 템플릿에 관한 모든 정보를 참조해야 하기 때문에, 다음과 같이 파일을 분할하면 컴파일 에러가 난다.<br>
<br>헤더 파일 : 템플릿 클래스 정의, 멤버 함수의 원형 선언
<br>cpp 파일 : 템플릿 클래스 멤버 함수의 정의
<br>cpp 파일2 : main 문
<br>이는 cpp 파일2에서 헤더 파일의 정보만 알 수 있고 템플릿 클래스 멤버 함수의 정의는 알 수 없기 때문으로, 다음의 방법들로 해결할 수 있다.<br>
<br>헤더파일에 템플릿의 생성자와 멤버 함수의 정의를 모두 넣는다.
<br>헤더파일, cpp 파일, cpp 파일2의 파일 명을 각각 header.hpp file.cpp file2.cpp라고 할 때, file2.cpp에 다음의 구문을 추가하여야 한다.
<br>
#include "header.hpp"
#include "file.cpp" //이 문장을 추가하여 완전한 템플릿 정보를 얻을 수 있어야 함

//. . . .

<br><br><br><a data-href="템플릿" href="resource\language\c++\템플릿.html" class="internal-link" target="_self" rel="noopener nofollow">템플릿</a>과 마찬가지로, 클래스 템플릿도 특정 자료형에 한하여 특수화할 수 있다.<br>
클래스 템플릿을 특수화하는 이유는 특정 자료형을 기반으로 생성된 객체에 대해, 구분이 되는 다른 행동양식을 적용하기 위해서이다.<br>클래스 템플릿은 아래와 같은 방식으로 특수화할 수 있다.<br>
template &lt;typename T&gt;
class SoSimple
{
	public :
		T SimpleFunc(T num) { . . . . }
};

template &lt;&gt;
class SoSimple&lt;int&gt;
{
	public :
		int SimpleFunc(int num) { . . . . }
}

<br><br><br>템플릿의 typename이 복수인 경우, 그 중 일부만 특수화를 진행하는 것을 클래스 템플릿의 부분 특수화(class template partial specialization)라고 한다.<br>
/*ClassTemplatePartialSpecialization.cpp*/

#include &lt;iostream&gt;
using namespace std;

template &lt;typename T1, typename T2&gt;
class MySimple
{
	public :
		void WhoAreYou()
		{
			cout&lt;&lt;"size of T1: "&lt;&lt;sizeof(T1)&lt;&lt;endl;
			cout&lt;&lt;"size of T2: "&lt;&lt;sizeof(T2)&lt;&lt;endl;
			cout&lt;&lt;"&lt;typename T1, typename T2&gt;"&lt;&lt;endl;
		}
};

template &lt;&gt;
class MySimple&lt;int, double&gt;
{
	public :
		void WhoAreYou()
		{
			cout&lt;&lt;"size of int : "&lt;&lt;sizeof(int)&lt;&lt;endl;
			cout&lt;&lt;"size of double : "&lt;&lt;sizeof(double)&lt;&lt;endl;
			cout&lt;&lt;"&lt;int, double&gt;"&lt;&lt;endl;
		}
};

/*
template &lt;typename T1&gt;
class MySimple&lt;T1, double&gt;
{
	public :
		void WhoAreYou()
		{
			cout&lt;&lt;"size of T1: "&lt;&lt;sizeof(T1)&lt;&lt;endl;
			cout&lt;&lt;"size of double: "&lt;&lt;sizeof(double)&lt;&lt;endl;
			cout&lt;&lt;"&lt;T1, double&gt;"&lt;&lt;endl;
		}
};
*/

int main(void)
{
	MySimple&lt;char, double&gt; obj1;
	obj1.WhoAreYou();
	
	MySimple&lt;int, long&gt; obj2;
	obj2.WhoAreYou();
	
	MySimple&lt;int, double&gt; obj3;
	obj3.WhoAreYou();

	return (0);
}

<br>참고로 템플릿 함수의 호출형식이 부분 특수화와 전체 특수화를 동시에 만족한다면 전체 특수화된 클래스를 대상으로 객체가 생성된다.<br><br><br>다음과 같이 템플릿 매개변수에는 변수의 선언이 올 수 있다.<br>
template &lt;typename T, int len&gt;
class SimpleArray
{
	private :
		T arr[len];
	public :
		T &amp;operator[] (int idx)
		{
			return arr[idx];
		}
};

int main()
{
	//위의 템플릿을 기반으로 다음과 같이 객체 생성 가능
	SimpleArray&lt;int, 5&gt; i5arr;
	SimpleArray&lt;double, 7&gt; d7arr;
}

/*
	결과적으로 컴파일러에 의해 다음과 같은 객체가 생성됨
	class SimpleArray&lt;int, 5&gt;
	{
		private :
			int arr[5];
		public :
			int &amp;operator[] (int idx) { return arr[idx]; }
	};
	
	class SimpleArray&lt;double, 7&gt;
	{
		private :
			double arr[7];
		public :
			double &amp;operator[] (int idx) { return arr[idx]; }
	}
*/

<br>위 예제에서 템플릿 인자를 사용하여 객체마다 멤버 변수로 존재하는 배열의 길이를 다르게 설정하였다.<br>
<a data-href="생성자" href="resource\language\c++\생성자.html" class="internal-link" target="_self" rel="noopener nofollow">생성자</a>를 사용하여 동일한 기능을 구현할 수 있지만, 다음과 같은 차이점이 있다.<br>SimpleArray&lt;int, 5&gt;와 SimpleArray&lt;int, 7&gt;은 서로 다른 형(type)이다.<br>따라서 위 예제의 경우, 길이가 다른 두 배열 객체간의 대입 및 복사에 대한 부분을 신경쓰지 않아도 된다는 이점이 있다.<br>다음과 같이 템플릿 인자는 디폴트 값 지정 또한 가능하다.<br>
template &lt;typename T = int, int len = 7&gt;

<br><br><br>클래스 템플릿 내에 static 멤버변수가 존재하면 템플릿 클래스 별로 별도의 static 멤버변수를 유지하게 된다.<br>아래와 같이 템플릿 static 멤버변수 초기화한다.<br>
template &lt;typename T&gt;
T SimpleStaticMem&lt;T&gt;::mem = 0;
template &lt;&gt; //템플릿 클래스의 static 매개변수도 특수화를 통하여 특정 자료형에 한해 다르게 초기화할 수 있다.
long SimpleStaticMem&lt;long&gt;::mem = 5;

<br><br>참고자료<br><a href=".?query=tag:참고도서\윤성우의_열혈_cpp_프로그래밍" class="tag" target="_blank" rel="noopener nofollow">#참고도서/윤성우의_열혈_cpp_프로그래밍</a><br>]]></description><link>resource\language\c++\클래스-템플릿.html</link><guid isPermaLink="false">resource/Language/C++/클래스 템플릿.md</guid><pubDate>Sat, 22 Mar 2025 07:31:43 GMT</pubDate></item><item><title><![CDATA[템플릿]]></title><description><![CDATA[<a class="tag" href="?query=tag:language/cpp" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#language/cpp</a> <a class="tag" href="?query=tag:참고도서/윤성우의_열혈_cpp_프로그래밍" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/윤성우의_열혈_cpp_프로그래밍</a> 
 <br><br><a href=".?query=tag:language\cpp" class="tag" target="_blank" rel="noopener nofollow">#language/cpp</a> <br>templete<br><br>템플릿은 다양한 자료형의 함수를 만들어 낼 수 있는 c++의 문법적 요소이다.<br>일반적으로, 템플릿은 함수의 기능은 동일하지만 매개변수의 자료형이나 반환형이 다른 경우 활용될 수 있다.<br>템플릿은 아래와 같은 형식으로 정의된다. 이와 같은 정의를 함수 템플릿(function template)이라 한다.<br>
template &lt;typename T&gt; //T라는 이름을 이용해서 아래의 함수를 템플릿으로 정의한다는 뜻
T Add(T num1, T num2)
{
	return (num1 + num2);
}

<br>위 예제에서 template &lt;typename T&gt; 대신 template &lt;class T&gt;를 사용해도 된다.<br>어떠한 자료형으로 함수를 만들어달라는 요청이 있을 경우, 컴파일러는 함수 템플릿을 기반으로 새로운 함수를 만들어낸다. 이를 템플릿 함수(template function), 또는 생성된 함수(generated function)이라고 한다.<br>
int Add&lt;int&gt;(int num1, int num2)
{
	return (num1 + num2);
}

double Add&lt;double&gt;(double num1, double num2)
{
	return (num1 + num2);
}

<br>위의 템플릿 함수의 표시에서 &lt;int&gt;와  &lt;double&gt;은 일반 함수가 아닌, 컴파일러가 만들어낸 템플릿 기반의 함수임을 표시한 것이다.<br>위의 예제에서 정의된 템플릿은 아래와 같이 사용될 수 있다.<br>
/*AddFunctionTemplate.cpp*/

#include &lt;iostream&gt;
using namespace std;

template &lt;typename T&gt;
T Add(T num1, T num2)
{
	return (num1 + num2);
}

int main(void)
{
	cout&lt;&lt;Add&lt;int&gt;(15, 20)&lt;&lt;endl; //T를 int로 해서 만들어진 Add 함수를 호출한다.
	cout&lt;&lt;Add&lt;double&gt;(2.9, 3.7)&lt;&lt;endl; //T를 double로 해서 만들어진 Add 함수를 호출한다.
	cout&lt;&lt;Add&lt;int&gt;(3.2, 3.2)&lt;&lt;endl; //T를 int로 하도록 정의하였기 때문에 double 형인 입력값이 int로 형변환됨
	cout&lt;&lt;Add&lt;double&gt;(3.14, 2.75)&lt;&lt;endl;

	return (0);
}

<br>템플릿으로 함수를 호출할 때, 자료형에 기반하여 함수를 만드는 것은 컴파일러의 역할이며, 따라서 컴파일 속도의 감소가 발생한다. 그런데 이는 컴파일 시간의 감소이지 실행 속도의 감소가 아니기 때문에 크게 신경쓸 부분이 아니다.<br><br>템플릿을 사용하여 함수를 호출할 때, &lt;&gt; 부분을 생략하여 호출할 수도 있다. 이 경우, 전달되는 인자의 자료형을 참조하여 호출될 함수의 유형을 컴파일러가 결정하기 때문이다.<br>
int main(void)
{
	cout&lt;&lt;Add(15, 20)&lt;&lt;endl;
	cout&lt;&lt;Add(2.9, 3.7)&lt;&lt;endl;
	cout&lt;&lt;Add(3.2, 3.2)&lt;&lt;endl;
	cout&lt;&lt;Add(3.14, 2.75)&lt;&lt;endl;

	return (0);
}

<br><br>템플릿 함수는 일반 함수와 구분이 되기 때문에 동일한 함수명을 가진 템플릿 함수와 일반 함수가 공존할 수 있으며, 이 경우 함수가 호출되었을 때 일반 함수가 우선권을 가지어 호출된다. 물론 이런 경우가 바람직하지는 못하다.<br>
#include &lt;iostream&gt;
using namespace std;

template &lt;typename T&gt;
T Add(T num1, T num2)
{
	cout&lt;&lt;"T Add(T num1, T num2)"&lt;&lt;endl;
	return (num1 + num2);
}

int Add(int num1, int num2)
{
	cout&lt;&lt;"Add(int num1, int num2)"&lt;&lt;endl;
	return (num1 + num2);
}

double Add(double num1, double num2)
{
	cout&lt;&lt;"Add(double num1, double num2)"&lt;&lt;endl;
	return (num1 + num2);
}

int main(void)
{
	//기본적으로는 일반 함수가 우선권을 가지어 호출된다.
	cout&lt;&lt;Add(5, 7)&lt;&lt;endl;
	cout&lt;&lt;Add(3.7, 7.5)&lt;&lt;endl;
	//하지만 &lt;&gt;을 이용해 함수가 템플릿 함수임을 명시하면 템플릿 함수가 호출된다.
	cout&lt;&lt;Add&lt;int&gt;(5, 7)&lt;&lt;endl;
	cout&lt;&lt;Add&lt;double&gt;(3.7, 7.5)&lt;&lt;ednl;
}

<br><br>다음과 같이 복수의 자료형을 사용하여 함수 템플릿, 템플릿 함수를 정의할 수 있다.<br>
#include &lt;iostream&gt;
using namespace std;

template &lt;class T1, class T2&gt;
void ShowData(double num)
{
	cout&lt;&lt;(T1)num&lt;&lt;", "&lt;&lt;(T2)num&lt;&lt;endl;
}

int main(void)
{
	ShowData&lt;char, int&gt;(65);
	ShowData&lt;char, int&gt;(67);
	ShowData&lt;char, double&gt;(68.9);
	ShowData&lt;short, double&gt;(69.2);
	ShowData&lt;short, double&gt;(70.4);
	return (0);
}

<br>참고로, 위 예제의 7행은 다음의 문장으로 대체할 수 있다.<br>cout&lt;&lt;T1(num)&lt;&lt;", "&lt;&lt;T2(num)&lt;&lt;endl;<br>이렇듯 c++에서는 데이터에 소괄호를 묶는 형태로 형 변환을 명령할 수 있다. 즉, 다음의 형 변환문은<br>int num = (int)3.14;<br>다음의 형 변환문과 완전히 일치한다.<br>int num = int(3.14);<br><br>특정 자료형에 한하여 템플릿 함수의 구성방법에 예외를 두어 구현하는 것을 함수 템플릿의 특수화라고 한다.<br>함수 템플릿의 정의 후 template &lt;&gt; 키워드를 사용하여 정의한다.<br>
/*SpecialFunctionTemplate.cpp*/

#include &lt;iostream&gt;
#include &lt;cstring&gt;
using namespace std;

template &lt;typename T&gt;
T Max(T a, T b)
{
	return (a &gt; b ? a : b);
}

template &lt;&gt;
char *Max&lt;char *&gt;(char *a, char *b) //특수화하는 자료형을 명시
{
	cout&lt;&lt;"char *Max&lt;char *&gt;(char *a, char *b)"&lt;&lt;endl;
	return (strlen(a) &gt; strlen(b) ? a : b);
}

template &lt;&gt;
const char *Max(const char *a, const char *b) //특수화하는 자료형을 생략
{
	cout&lt;&lt;"const char *Max&lt;const char *&gt;(const char *a, const char *b)"&lt;&lt;endl;
	return (strcpm(a, b) &gt; 0 ? a : b);
}

int main(void)
{
	cout&lt;&lt;Max(11, 15)&lt;&lt;endl;
	cout&lt;&lt;Max('T', 'Q')&lt;&lt;endl;
	cout&lt;&lt;Max(3.5, 7.5)&lt;&lt;endl;
	cout&lt;&lt;Max("Simple", "Best")&lt;&lt;endl;

	char str1[] = "Simple";
	char str2[] = "Best";
	cout&lt;&lt;Max(str1, str2)&lt;&lt;endl;

	return(0);
}

<br><br><br>함수 템플릿 내에 static 지역변수가 존재하고 이 지역변수의 자료형이 정의되지 않았을 경우, 템플릿 함수가 생성될 때마다 static 지역변수 또한 별개로 생성된다.<br>
template &lt;typename T&gt;
void ShowStaticValue(void)
{
	static T num = 0;
	num += 1;
	cout&lt;&lt;num&lt;&lt;" ";
}

<br><br>참고자료<br><a href=".?query=tag:참고도서\윤성우의_열혈_cpp_프로그래밍" class="tag" target="_blank" rel="noopener nofollow">#참고도서/윤성우의_열혈_cpp_프로그래밍</a><br>]]></description><link>resource\language\c++\템플릿.html</link><guid isPermaLink="false">resource/Language/C++/템플릿.md</guid><pubDate>Sat, 22 Mar 2025 07:31:43 GMT</pubDate></item><item><title><![CDATA[함수 오버라이딩]]></title><description><![CDATA[<a class="tag" href="?query=tag:language/cpp" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#language/cpp</a> <a class="tag" href="?query=tag:참고도서/윤성우의_열혈_cpp_프로그래밍" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/윤성우의_열혈_cpp_프로그래밍</a> 
 <br><br><a href=".?query=tag:language\cpp" class="tag" target="_blank" rel="noopener nofollow">#language/cpp</a> <br>function overriding<br><br>부모 클래스에서 정의된 함수를 자식 클래스에서 함수명, 매개변수의 자료형, 매개변수의 개수를 유지한 채로 다시 정의할 수 있다. 이를 함수 오버라이딩이라고 하며, 함수 오버라이딩이 행해진 경우, 자식 객체에서 해당 함수명으로 함수를 호출하면 부모 클래스에서 정의된 함수가 아닌, 자식 클래스에서 재정의된 함수가 호출된다 ( 이를 함수를 '가린다'라고 표현한다. )<br>만일 함수 오버라이딩되었음에도 부모의 함수를 호출하고 싶다면 다음의 형식으로 호출할 수 있다.<br>
/*자식 클래스의 클래스 내부에서 호출하는 경우*/
//부모 클래스의 클래스명::함수명();
PermanentWorker::GetPay();

/*객체를 통하여 호출하는 경우*/
//자식 클래스의 객체명.부모 클래스의 클래스명::함수명();
seller.PermanentWorker::ShowSalaryInfo();

<br><br>참고자료<br><a href=".?query=tag:참고도서\윤성우의_열혈_cpp_프로그래밍" class="tag" target="_blank" rel="noopener nofollow">#참고도서/윤성우의_열혈_cpp_프로그래밍</a><br>]]></description><link>resource\language\c++\함수-오버라이딩.html</link><guid isPermaLink="false">resource/Language/C++/함수 오버라이딩.md</guid><pubDate>Sat, 22 Mar 2025 07:31:43 GMT</pubDate></item><item><title><![CDATA[함수 오버로딩]]></title><description><![CDATA[<a class="tag" href="?query=tag:language/cpp" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#language/cpp</a> <a class="tag" href="?query=tag:참고도서/윤성우의_열혈_cpp_프로그래밍" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/윤성우의_열혈_cpp_프로그래밍</a> 
 <br><br><a href=".?query=tag:language\cpp" class="tag" target="_blank" rel="noopener nofollow">#language/cpp</a><br>Function Overloading<br><br>c언어는 동일한 이름의 함수가 정의되는 것을 허용하지 않는다.<br>//아래와 같은 코드는 컴파일 오류 발생

int MyFunc(int num)
{
	num++;
	return num;
}

int MyFunc(int a, int b)
{
	return a+b;
}

int main(void)
{
	MyFunc(20);
	MyFunc(30, 40);
	return 0;
}
<br>왜냐면 c언어는 호출한 함수를 찾을 때 함수의 이름만을 사용하기 때문이다.<br>c++언어는 호출한 함수를 찾을 때 함수의 이름과 매개변수의 선언, 총 두 가지 정보를 이용하기 때문에 매개변수의 선언형태가 다르다면, 동일한 이름의 함수정의를 허용할 수 있다. 이러한 형태의 함수정의를 가리켜 함수 오버로딩(Function Overloading)이라고 한다.<br>주의할 점으로, c++ 언어에서 함수의 반환형은 함수를 식별하는 기준이 될 수 없기 떄문에 아래와 같이 함수 오버로딩 할 수 없다. <br>
void MyFunc(int n) {/*...*/}
int MyFunc(int n) {/*...*/}

<br>
<br>const의 선언유무도 함수 오버로딩의 조건에 해당이 된다.
<br><br>참고자료<br><a href=".?query=tag:참고도서\윤성우의_열혈_cpp_프로그래밍" class="tag" target="_blank" rel="noopener nofollow">#참고도서/윤성우의_열혈_cpp_프로그래밍</a><br>]]></description><link>resource\language\c++\함수-오버로딩.html</link><guid isPermaLink="false">resource/Language/C++/함수 오버로딩.md</guid><pubDate>Sat, 22 Mar 2025 07:31:43 GMT</pubDate></item><item><title><![CDATA[형 변환]]></title><description><![CDATA[<a class="tag" href="?query=tag:language/cpp" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#language/cpp</a> <a class="tag" href="?query=tag:참고도서/윤성우의_열혈_cpp_프로그래밍" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/윤성우의_열혈_cpp_프로그래밍</a> 
 <br><br><a href=".?query=tag:language\cpp" class="tag" target="_blank" rel="noopener nofollow">#language/cpp</a> <br>type-casting<br><br><br>C++ 언어의 자료형 변환은 2가지로 나뉜다. 암묵적 자료형 변환과 명시적 자료형 변환이 바로 그것이다. 암묵적 자료형 변환이란 자료형이 자동으로 변환되는 것을 의미하고 명시적 자료형 변환이란 자료형을 강제로 변환하는 것을 의미한다.<br>C++에서는 다음과 같은 코드로 자료형을 확인할 수 있다.<br>
typeid(표현식).name()

<br>이러한 코드를 사용하려면 &lt;typeinfo&gt;라는 헤더 파일을 추가해야 한다.<br><br>서로 다른 자료형을 연산하면 C++ 컴파일러는 연산 전에 암묵적 자료형 변환 implicit type conversion을 수행한다. 암묵적 자료형 변환은 피연산자의 자료형을 적용할 수 있는 다른 자료형으로 자동으로 변환하는 것을 의미한다.<br>암묵적 자료형 변환은 암묵적 자료형 승격 implicit type promotion과 암묵적 자료형 변경 implicit type change이 있다.<br>암묵적 자료형 승격은 작은 자료형의 피연산자를 더 큰 자료형으로 승격하는 행위를 의미한다.<br>암묵적 자료형 변경은 이항 연산자를 사용할 때 두 자료형의 자료형을 맞추는 행위를 말한다.<br>변환은 하나만 일어날 수도 있고 2가지 모두 일어날 수도 있다.<br><br>암묵적 자료형 승격은 산술 연산자의 피연산자에 자동으로 적용된다. 암묵적 자료형 승격은 2가지 경우에 이루어진다.<br>첫 번째, 피연산자의 자료형이 산술 연산에 적합하지 않은 경우(불 또는 문자)<br>두 번째, 피연산자의 자료형에 맞는 연산자가 없는 경우(short 또는 float)<br><br><br>암묵적 자료형 승격이 일어난 이후, 컴파일러는 필요한 경우 암묵적 자료형 변경을 수행한다. 암묵적 자료형 변경은 두 피연산자의 자료형이 다를 때 발생한다. 단항 연산의 경우, 암묵적 자료형 변경이 일어나지 않는다. 이항 연산의 경우, 피연산자를 동일하게 만들기 위해서 암묵적 자료형 변경이 필요할 수 있다. 2가지 상황을 살펴보자<br><br>부가 작용이 없는 표현식의 경우, 아래와 같이 자료형을 상위 계층으로 변환한다.<br>
int -&gt; unsigned int -&gt; long -&gt; unsigned long -&gt; double -&gt; long double

<br>이전에 살펴보았던 암묵적 자료형 승격이 이미 일어난 경우는 계층이 변환된 상태이므로 암묵적 자료형 변경이 일어나지 않는다.<br><br>변수에 값을 할당할 때, 소스 source와 대상 destination의 자료형이 다른 경우에도 자료형 변환이 발생한다. 이때 컴파일러는 소스의 자료형을 대상의 자료형에 맞게 변경한다. 소스의 자료형이 대상의 자료형보다 크기가 큰 경우 소스의 자료형을 강등시키고, 그 반대의 경우 소스의 자료형을 승격시킨다.<br><br>c++에서는 c 스타일의 형 변환 연산자를 가리켜 '오래된 C 스타일 형 변환 연산자(Old C-style cast operator)'라 부르기도 한다. 이렇듯 c 스타일의 형 변환 연산자는 c 언어와의 호환성을 위해서 존재할 뿐, c++에서는 새로운 형 변환 연산자와 규칙을 제공하고 있다.<br>c 스타일의 형 변환 연산자는 그 기능이 강력해서, 아래와 같이 형 변환이 일어나면 안 되는 케이스에서도 형변환이 일어날 수 있다.<br>
class Car
{
	//생략
};

class Truck : public Car
{
	//생략
};

int main(void)
{
	Car *pcar1 = new Truck(80, 200);
	Truck *ptruck1 = (Truck *)pcar1; //문제 없어 보이는 형 변환
	
	Car *pcar2 = new Car(120);
	Truck *ptruck2 = (Truck *)pcar2; //문제가 바로 보이는 형 변환
}

<br>기초 클래스의 포인터 형을 유도 클래스의 포인터 형으로 형 변환하는 것은 일반적인 경우의 형 변환이 아님에도 불구하고, 형 변환 연산자의 기능이 너무 강력하여 형 변환이 이루어지는 모습이다.<br>이러한 문제점 때문에 c++ 에서는 다음과 같이 4개의 연산자를 추가로 제공하면서 용도에 맞는 형 변환 연산자의 사용을 유도하고 있다.<br>
<br>dynamic_cast
<br>static_cast
<br>const_cast
<br>reinterpret_cast
<br><br><br>dynamic_cast 형 변환 연산자는 다음의 형태를 갖는다.<br>
dynamic_cast&lt;T&gt;(expr)

<br>dynamic_cast는 다음의 조건을 충족하여야 정상적으로 컴파일되며, 그렇지 않으면 컴파일 에러가 발생한다.<br>
<br>&lt;&gt; 사이에 변환하고자 하는 자료형의 이름을 둔다. 자료형은 객체의 포인터 또는 참조형이여야 한다.
<br>() 사이에는 변환의 대상이 와야 한다.
<br>상속 관계에 놓여 있는 두 클래스 사이에서 유도 클래스의 포인터 및 참조형 데이터를 기초 클래스의 포인터 및 참조형 데이터로 형 변환하는 경우여야 한다.
<br>종합적으로 dynamic_cast는 다음을 의미한다.<br>상속 관계에 있는 유도 클래스의 포인터 및 참조형 데이터를 기초 클래스의 포인터 및 참조형 데이터로 형 변환한다.<br>
/*DynamicCasting.cpp*/

#include &lt;iostream&gt;
using namespace std;

class Car
{
	// 생략
};

class Truck
{
	// 생략
};

int main(void)
{
	Car *pcar1 = new Truck(80, 200);
	//Truck *ptruck1 = dynamic_cast&lt;Truck *&gt;(pcar1); -&gt; 에러, 그러나 경우에 따라선 필요한 형 변환이므로 그러한 경우 static_cast를 사용

	Car *pcar2 = new Car(120);
	//Truck *ptruck2 = dynamic_cast&lt;Truck *&gt;(pcar2); -&gt; 에러

	Truck *ptruck3 = new Truck(70, 150);
	Car *pcar3 = dynamic_cast&lt;Car *&gt;(ptruck3); //컴파일 OK!
}

<br>그러나 다음의 예외적인 경우에, dynamic_cast는 부모 -&gt; 자식으로의 형변환을 허용한다.<br>부모 클래스가 '<a data-tooltip-position="top" aria-label="가상 함수" data-href="가상 함수" href="resource\language\c++\가상-함수.html" class="internal-link" target="_self" rel="noopener nofollow">Polymorphic 클래스</a>'인 경우<br>
/*PolymorphicDynamicCasting.cpp*/
#include &lt;iostream&gt;
using namespace std;

class SoSimple
{
	public :
		virtual void ShowSimpleInfo()
		{
			cout&lt;&lt;"SoSimple Base Class"&lt;&lt;endl;
		}
};

class SoComplex : public SoSimple
{
	public :
		void ShowSimpleInfo()
		{
			cout&lt;&lt;"SoComplex Derived Class"&lt;&lt;endl;
		}
};

int main(void)
{
	SoSimple *simPtr = new SoComplex;
	SoComplex *comPtr = dynamic_cast&lt;SoComplex *&gt;(simPtr);
	comPtr-&gt;ShowSimpleInfo();
	
	return (0);
}

<br>
<br>static_cast와 dynamic_cast의 차이점
<br>위 예제에서 simPtr은 SoComplex 객체를 가리키고 있다. 부모-&gt;자식으로 dynamic_cast가 성립하려면 포인터가 가리키고 있는 객체의 자료형이 변환 후 자료형과 일치해야 한다. 그렇지 않으면 형 변환의 결과로 NULL이 반환된다.<br>이렇듯 dynamic_cast는 안정적인 형 변환을 보장한다. 특히 다음의 사실에 주목할 필요가 있다.<br>컴파일 시간이 아닌 실행 시간에(프로그램이 실행 중인 동안에) 안정성을 검사하도록 컴파일러가 바이너리 코드를 생성한다<br>이렇게 '동적'으로 안정성 검사 &amp; casting이 이루어지는 특성 때문에 dynamic이라는 명칭이 붙었다.<br>반면에 static_cast는 이러한 안정성 검사가 이루어지지 않는다. 컴파일러는 무조건 형 변환이 되도록 바이너리 코드를 생성한다. 이러한 특성 때문에 'static'이라는 명칭이 붙었다.<br>dynamic_cast를 이용한 형 변환 중 예외가 발생할 경우 bad cast <a data-tooltip-position="top" aria-label="예외 처리" data-href="예외 처리" href="resource\language\c++\예외-처리.html" class="internal-link" target="_self" rel="noopener nofollow">예외</a>가 발생한다.<br><br><br>
static_cast&lt;T&gt;(expr)

<br>dynamic_cast가 자식 -&gt; 부모로의 형 변환만 허용하는데 반하여 static_cast는 보다 넓은 범위의 형변환을 허용한다.<br>
<br>자식 -&gt; 부모로의 형 변환뿐만이 아닌, 부모 -&gt; 자식으로의 형변환 또한 허용한다.
<br>기본 자료형(여기서 기본 자료형이라함은 포인터 자료형을 제외한 것을 말한다) 데이터 간의 형 변환에도 사용이 된다.
<br>따라서 부모 -&gt; 자식으로의 캐스팅 같은 잘못된 형 변환을 할 수 있으므로 이에 대하여 개발자는 보다 신중하게 사용하여야 한다.<br>
/*StaticCasting.cpp*/

#include &lt;iostream&gt;
using namespace std;

class Car
{
	// 생략
};

class Truck
{
	// 생략
};

int main(void)
{
	Car *pcar1 = new Truck(80, 200);
	Truck *ptruck1 = static_cast&lt;Truck *&gt;(pcar1); // 허용

	Car *pcar2 = new Car(120);
	Truck *ptruck2 = dynamic_cast&lt;Truck *&gt;(pcar2); // 허용 -&gt; 그러나 문제가 발생할 수 있는 코드

	Truck *ptruck3 = new Truck(70, 150);
	Car *pcar3 = dynamic_cast&lt;Car *&gt;(ptruck3); //컴파일 OK!
}

<br>
<br>static_cast가 dynamic_cast 보다 빠르기 때문에 dynamic_cast를 사용해도 되는 상황에 static_cast를 사용하는 경우도 있다.
<br><br><br>C++에서는 포인터와 참조자의 const 성향을 제거하는 형 변환을 목적으로, 다음의 형 변환 연산자를 제공한다.<br>
const_cast&lt;T&gt;(expr)

<br>
/*ConstCasting.cpp*/

#include &lt;iostream&gt;
using namespace std;

void ShowString(char *str)
{
	cout&lt;&lt;str&lt;&lt;endl;
}

void ShowAddResult(int &amp;n1, int &amp;n2)
{
	cout&lt;&lt;(n1 + n2)&lt;&lt;endl;
}

int main(void)
{
	const char *name = "Lee Sung Ju";
	ShowString(const_cast&lt;char *&gt;(name));
	
	const int &amp;num1 = 100;
	const int &amp;num2 = 200;
	ShowAddResult(const_cast&lt;int &amp;&gt;(num1), const_cast&lt;int &amp;&gt;(num2));
	
	return (0);
}

<br>위 예제에서와 같이 const_cast 형 변환 연산은, 함수의 인자전달 시 const 선언으로 인한 형(type)의 불일치가 발생해서 인자의 전달이 불가능한 경우에 유용하게 사용이 된다.<br>
<br>const_cast 연산자는 volatile 특성을 제거하는 데에도 사용할 수 있다.
<br><br><br>reinterpret_cast 연산자는 전혀 상관이 없는 자료형으로의 형 변환에 사용이 되며, 기본적인 형태는 다음과 같다(마찬가지로 앞서 설명한 형 변환 연산자들과 동일하다).<br>
reinterpret_cast&lt;T&gt;(expr)

<br>부연하자면, reinterpret_cast 연산자는 포인터를 대상으로 하는, 그리고 포인터와 관련이 있는 모든 유형의 형 변환을 허용한다.<br>reinterpret_cast는 다음과 같은 형변환도 가능할 정도로 강력하다.<br>
class SimpleCar { /*. . . .*/ };
class BestFriend { /*. . . ./*/ };

int main(void)
{
	SimpleCar *car = new Car;
	BestFriend *fren = reinterpret_cast&lt;BestFriend *&gt;(car); //상속 관계도, 그 외에 아무 관계도 없는 자료형 간의 형변환이 가능할 정도로 강력하다.
}

<br>물론 위 예제는 전혀 실용적이지 않다. reinterpret_cast는 일반적으로 다음과 같은 상황에 쓰인다.<br>
#include &lt;iostream&gt;
using namespace std;

int main(void)
{
	/*4 바이트 자료형인 int를 1 바이트 단위로 출력하고자 할 때*/
	int num = 0x010203;
	char *ptr = reinterpret_cast&lt;char *&gt;(&amp;num);
	
	for (int i = 0; i &lt; sizeof(num); i++)
		cout&lt;&lt;static_cast&lt;int&gt;(*(ptr + i))&lt;&lt;endl;
	
	return (0);
}

<br>
int main(void)
{
	int num = 72;
	int *ptr = &amp;num;

	int adr = reinterpret_cast&lt;int&gt;(ptr); //주소 값을 정수로 변환
	cout&lt;&lt;"Addr: "&lt;&lt;adr&lt;&lt;endl; //주소 값 출력

	int *rptr = reinterpret_cast&lt;int *&gt;(adr); //정수를 다시 주소 값으로 변환
	cout&lt;&lt;"value: "&lt;&lt;*rptr&lt;&lt;endl; //주소 값에 저장된 정수 출력
}

<br><br>참고자료<br><a href=".?query=tag:참고도서\윤성우의_열혈_cpp_프로그래밍" class="tag" target="_blank" rel="noopener nofollow">#참고도서/윤성우의_열혈_cpp_프로그래밍</a><br>]]></description><link>resource\language\c++\형-변환.html</link><guid isPermaLink="false">resource/Language/C++/형 변환.md</guid><pubDate>Sat, 22 Mar 2025 07:31:43 GMT</pubDate></item><item><title><![CDATA[a reference]]></title><description><![CDATA[<a class="tag" href="?query=tag:language/cpp" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#language/cpp</a> <a class="tag" href="?query=tag:참고도서/윤성우의_열혈_cpp_프로그래밍" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/윤성우의_열혈_cpp_프로그래밍</a> 
 <br><br><a href=".?query=tag:language\cpp" class="tag" target="_blank" rel="noopener nofollow">#language/cpp</a><br><br>이 디렉토리는 다음의 자료들을 참고하여 작성되었습니다.<br><br>참고자료<br><a href=".?query=tag:참고도서\윤성우의_열혈_cpp_프로그래밍" class="tag" target="_blank" rel="noopener nofollow">#참고도서/윤성우의_열혈_cpp_프로그래밍</a><br>]]></description><link>resource\language\c++\a-reference.html</link><guid isPermaLink="false">resource/Language/C++/a reference.md</guid><pubDate>Sat, 22 Mar 2025 07:31:43 GMT</pubDate></item><item><title><![CDATA[C++ 언어의 객체 배열]]></title><description><![CDATA[<a class="tag" href="?query=tag:language/cpp" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#language/cpp</a> <a class="tag" href="?query=tag:참고도서/윤성우의_열혈_cpp_프로그래밍" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/윤성우의_열혈_cpp_프로그래밍</a> 
 <br><br><a href=".?query=tag:language\cpp" class="tag" target="_blank" rel="noopener nofollow">#language/cpp</a> <br><br>객체 기반의 배열은 다음의 형태로 선언한다.<br>
Obj arr[10];

<br>이를 동적으로 할당하는 경우에는 다음의 형태로 선언한다.<br>
Obj * ptrArr = new Obj[10];

<br>이러한 형태로 배열을 선언하면, 열 개의 객체가 모여 배열을 구성하는 형태가 된다. 이렇듯 구조체 배열의 선언과 차이가 없다. 하지만 배열을 선언하는 경우에도 생성자는 호출이 된다. 단, 배열의 선언과정에서는 호출할 생성자를 별도로 명시하지 못한다(생성자에 인자를 전달하지 못한다.) 즉, 위의 형태로 배열이 형성되려면 다음 형태의 생성자가 반드시 정의되어 있어야 한다.<br>
Obj() { . . . . }

<br><br>참고자료<br><a href=".?query=tag:참고도서\윤성우의_열혈_cpp_프로그래밍" class="tag" target="_blank" rel="noopener nofollow">#참고도서/윤성우의_열혈_cpp_프로그래밍</a><br>]]></description><link>resource\language\c++\c++-언어의-객체-배열.html</link><guid isPermaLink="false">resource/Language/C++/C++ 언어의 객체 배열.md</guid><pubDate>Sat, 22 Mar 2025 07:31:43 GMT</pubDate></item><item><title><![CDATA[C++ 언어의 변수 선언과 초기화]]></title><description><![CDATA[<a class="tag" href="?query=tag:language/cpp" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#language/cpp</a> <a class="tag" href="?query=tag:참고도서/윤성우의_열혈_cpp_프로그래밍" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/윤성우의_열혈_cpp_프로그래밍</a> 
 <br><br><a href=".?query=tag:language\cpp" class="tag" target="_blank" rel="noopener nofollow">#language/cpp</a><br><br>c++ 언어에서는 아래와 같은 형식으로 변수 선언 및 초기화가 가능하다.<br>
// 기존의 C 스타일 변수 선언 및 초기화
int num = 20;
int &amp;ref = num;

// C++ 에서의 새로운 형식의 변수 선언 및 초기화

int num(20);
int &amp;ref(num);

<br><br>참고자료<br><a href=".?query=tag:참고도서\윤성우의_열혈_cpp_프로그래밍" class="tag" target="_blank" rel="noopener nofollow">#참고도서/윤성우의_열혈_cpp_프로그래밍</a><br>]]></description><link>resource\language\c++\c++-언어의-변수-선언과-초기화.html</link><guid isPermaLink="false">resource/Language/C++/C++ 언어의 변수 선언과 초기화.md</guid><pubDate>Sat, 22 Mar 2025 07:31:43 GMT</pubDate></item><item><title><![CDATA[C++ 언어의 헤더파일 형식]]></title><description><![CDATA[<a class="tag" href="?query=tag:language/cpp" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#language/cpp</a> <a class="tag" href="?query=tag:참고도서/윤성우의_열혈_cpp_프로그래밍" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/윤성우의_열혈_cpp_프로그래밍</a> 
 <br><br><a href=".?query=tag:language\cpp" class="tag" target="_blank" rel="noopener nofollow">#language/cpp</a> <br><br>과거에는 입력 및 출력에 관한 일을 하기 위해서 다음과 같이 헤더파일을 선언하였다.<br>#include &lt;iostream.h&gt;<br>그러나 새로운 C++ 표준의 도입 이후 다음 두 가지 이유로 새로운 표준 라이브러리의 사용을 목적으로 하는 헤더파일의 포함에는 확장자를 생략하기로 하였다.<br>
<br>과거의 표준 라이브러리와 새로운 표준 라이브러리를 구분하기 위해
<br>새로운 표준 라이브러리를 사용하는 형태로 소스코드를 쉽게 변경할 수 있도록 하기 위해
<br>때문에 &lt;iostream.h&gt;는 과거의 표준 입출력 라이브러리 및 헤더를 의미하는 것으로 통용이 되고, &lt;iostram&gt;은 새로운 표준 입출력 라이브러리 및 헤더를 의미하는 것으로 통용이 된다. 참고로 C++ 컴파일러는 점차 &lt;iostream.h&gt;을 지원하지 않는 추세로 접어들었다.<br><br>C 언어 라이브러리에 포함되어 있는 대부분의 헤더들을 C++ 언어에서도 사용할 수 있다.<br>
헤더파일의 확장자인 .h를 생략하고 앞에 c를 붙이면 C 언어에 대응하는 C++의 헤더파일 이름이 된다.<br>#include &lt;stdio.h&gt; -&gt; #include &lt;cstdio&gt;<br>
#include &lt;stdlib.h -&gt; #include &lt;cstdlib&gt;<br>
#include &lt;math.h&gt; -&gt; #include &lt;cmath&gt;<br>
#include &lt;string.h -&gt; #include &lt;cstring&gt;<br>참고로 C++ 언어에서도 stdio.h 같은 C 언어의 헤더를 사용할 수 있다. C++ 언어에서 이와 같은 형태로 함수호출을 허용하는 이유는 '하위 버전과의 호환성(backwards compatibility)'을 제공하기 위해서이다. 하지만 C++ 표준 헤더는 C++ 문법을 기반으로 개선된 형태로 라이브러리가 구성되어 있으므로, 가급적 C++의 표준헤더를 이용해서 함수를 호출하는 것이 좋다.<br><br>참고자료<br><a href=".?query=tag:참고도서\윤성우의_열혈_cpp_프로그래밍" class="tag" target="_blank" rel="noopener nofollow">#참고도서/윤성우의_열혈_cpp_프로그래밍</a><br>]]></description><link>resource\language\c++\c++-언어의-헤더파일-형식.html</link><guid isPermaLink="false">resource/Language/C++/C++ 언어의 헤더파일 형식.md</guid><pubDate>Sat, 22 Mar 2025 07:31:43 GMT</pubDate></item><item><title><![CDATA[C++ 언어의 bool 자료형]]></title><description><![CDATA[<a class="tag" href="?query=tag:language/cpp" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#language/cpp</a> <a class="tag" href="?query=tag:참고도서/윤성우의_열혈_cpp_프로그래밍" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/윤성우의_열혈_cpp_프로그래밍</a> 
 <br><br><a href=".?query=tag:language\cpp" class="tag" target="_blank" rel="noopener nofollow">#language/cpp</a> <br><br><br>C 언어와 C++ 언어 모두 정수 '0'을 거짓을 의미하는 숫자로, '0'을 제외한 모든 숫자를 참으로 규정한다. C 언어에서는 참과 거짓의 표현을 위해서 다음과 같이 상수를 정의하는 것이 보통이다.<br>
#define TRUE 1
#define FALSE 0

<br>그러나 C++ 언어에서는 true와 false 키워드를 지원하므로 참과 거짓을 좀 더 직관적으로 표현할 수 있다.<br>true와 false 키워드는 정수형으로 변환하여 출력하면 각각 1과 0을 출력한다.<br>
std::cout&lt;&lt;"true: "&lt;&lt;true&lt;&lt;endl; //1 출력
std::cout&lt;&lt;"false: "&lt;&lt;false&lt;&lt;endl; //0 출력

<br>그러나 true와 false는 1과 0이 아니며, '참'과 '거짓'을 표현하기 위한 1바이트 크기의 데이터일 뿐이다. 따라서 이 둘을 출력하거나 정수의 형태로 형 변환하는 경우에 각각 1과 0으로 변환하도록 정의되어 있을 뿐이다.<br>따라서 true와 false는 그 자체를 '참'과 '거짓'을 나타내는 목적으로 인식하는 것이 바람직하다.<br><br>bool은 true와 false 데이터를 저장하기 위해 정의되어 있는 자료형이다.<br>
아래와 같이 사용될 수 있다.<br>
bool IsPositive(int num)
{
	if (num &lt;= 0)
		return false;
	else
		return true;
}

<br><br>참고자료<br><a href=".?query=tag:참고도서\윤성우의_열혈_cpp_프로그래밍" class="tag" target="_blank" rel="noopener nofollow">#참고도서/윤성우의_열혈_cpp_프로그래밍</a><br>]]></description><link>resource\language\c++\c++-언어의-bool-자료형.html</link><guid isPermaLink="false">resource/Language/C++/C++ 언어의 bool 자료형.md</guid><pubDate>Sat, 22 Mar 2025 07:31:43 GMT</pubDate></item><item><title><![CDATA[Call-by-reference]]></title><description><![CDATA[<a class="tag" href="?query=tag:language/cpp" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#language/cpp</a> <a class="tag" href="?query=tag:참고도서/윤성우의_열혈_cpp_프로그래밍" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/윤성우의_열혈_cpp_프로그래밍</a> 
 <br><br><a href=".?query=tag:language\cpp" class="tag" target="_blank" rel="noopener nofollow">#language/cpp</a> <br><br>주소 값을 전달받아서, 함수 외부에 선언된 변수에 접근하는 형태의 함수호출<br><br>참고자료<br><a href=".?query=tag:참고도서\윤성우의_열혈_cpp_프로그래밍" class="tag" target="_blank" rel="noopener nofollow">#참고도서/윤성우의_열혈_cpp_프로그래밍</a><br>]]></description><link>resource\language\c++\call-by-reference.html</link><guid isPermaLink="false">resource/Language/C++/Call-by-reference.md</guid><pubDate>Sat, 22 Mar 2025 07:31:43 GMT</pubDate></item><item><title><![CDATA[const]]></title><description><![CDATA[<a class="tag" href="?query=tag:language/cpp" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#language/cpp</a> <a class="tag" href="?query=tag:참고도서/윤성우의_열혈_cpp_프로그래밍" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/윤성우의_열혈_cpp_프로그래밍</a> 
 <br><br><a href=".?query=tag:language\cpp" class="tag" target="_blank" rel="noopener nofollow">#language/cpp</a> <br>constant<br><br>const는 대상을 상수화시키는 역할을 한다.<br>아래와 같이 사용될 수 있다.<br>
<br>변수의 상수화
<br>
const int num = 10;
//num = 20; -&gt; error : 변경 불가

<br>
<br>포인터의 상수화
<br>
<br>포인터 자체를 상수화
<br>
int * const ptr = &amp;val;
//ptr = &amp;val2; -&gt; error

<br>
<br>참조를 통해 값을 변경할 수 없음
<br>
const int *ptr = &amp;val;
//*ptr = 4; -&gt; error

<br>
<br><a data-href="클래스" href="resource\language\c++\클래스.html" class="internal-link" target="_self" rel="noopener nofollow">클래스</a>의 멤버함수를 const로 선언. const 함수는 아래의 특징을 가진다.
<br>
<br>함수 내부에서 멤버 변수의 값 변경 불가
<br>const 함수 내에서 const가 아닌 함수의 호출 제한
<br>
void constantFunc() const
{
	//memberVal = 100; -&gt; error
	//nonConstantFunc(); -&gt; error
}

<br>
<br>객체의 상수화. const로 선언된 객체는 const 멤버함수만 호출할 수 있다.
<br><br>참고자료<br><a href=".?query=tag:참고도서\윤성우의_열혈_cpp_프로그래밍" class="tag" target="_blank" rel="noopener nofollow">#참고도서/윤성우의_열혈_cpp_프로그래밍</a><br>]]></description><link>resource\language\c++\const.html</link><guid isPermaLink="false">resource/Language/C++/const.md</guid><pubDate>Sat, 22 Mar 2025 07:31:43 GMT</pubDate></item><item><title><![CDATA[explicit 키워드]]></title><description><![CDATA[<a class="tag" href="?query=tag:language/cpp" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#language/cpp</a> <a class="tag" href="?query=tag:참고도서/윤성우의_열혈_cpp_프로그래밍" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/윤성우의_열혈_cpp_프로그래밍</a> 
 <br><br><a href=".?query=tag:language\cpp" class="tag" target="_blank" rel="noopener nofollow">#language/cpp</a><br><br>C++ 언어에서는 대입 연산자를 사용하여 객체 간 복사를 할 수 있다. <a data-footref="1" href="about:blank#fn-1-0dd0c864fc857925" class="footnote-link" target="_self" rel="noopener nofollow">[1]</a><br>SoSimple sim2 = sim1;<br>이러한 구문은 아래와 같이 묵시적 변환되어 처리된다.<br>SoSimple sim2(sim1);<br>이러한 묵시적 변환은 객체 간 복사에서만 일어나지 않는다. 단순히 객체를 초기화할 때도 대입 연산자를 사용할 수 있으며, 묵시적 변환이 일어난다.<br>AAA obj = 3; // AAA obj(3); 으로 변환됨<br>explicit 키워드는 이러한 묵시적 변환을 막기 위해 사용된다. 복사 생성자에 explicit 키워드가 붙어있는 객체는 묵시적 변환이 허용되지 않아 대입 연산자를 사용하여 객체 간 복사 및 초기화를 할 수 없다.<br>
explicit SoSimple(const SoSimple &amp;copy) : num1(copy.num1), num2(copy.num2)
{
	//empty!!
}

<br><br>참고자료<br><a href=".?query=tag:참고도서\윤성우의_열혈_cpp_프로그래밍" class="tag" target="_blank" rel="noopener nofollow">#참고도서/윤성우의_열혈_cpp_프로그래밍</a><br><br><br>
<br>
<br><a data-href="복사 생성자" href="resource\language\c++\복사-생성자.html" class="internal-link" target="_self" rel="noopener nofollow">복사 생성자</a> 참고<a href="about:blank#fnref-1-0dd0c864fc857925" class="footnote-backref footnote-link" target="_self" rel="noopener nofollow">↩︎</a>
]]></description><link>resource\language\c++\explicit-키워드.html</link><guid isPermaLink="false">resource/Language/C++/explicit 키워드.md</guid><pubDate>Sat, 22 Mar 2025 07:31:43 GMT</pubDate></item><item><title><![CDATA[friend 선언]]></title><description><![CDATA[<a class="tag" href="?query=tag:language/cpp" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#language/cpp</a> <a class="tag" href="?query=tag:참고도서/윤성우의_열혈_cpp_프로그래밍" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/윤성우의_열혈_cpp_프로그래밍</a> 
 <br><br><a href=".?query=tag:language\cpp" class="tag" target="_blank" rel="noopener nofollow">#language/cpp</a> <br>friend<br><br>friend 선언은 다음의 기능을 하는 키워드이다.<br>A 클래스가 B 클래스를 대상으로 friend 선언을 하면, B 클래스는 A 클래스의 private 멤버에 직접 접근이 가능하다.
<br>단, A 클래스도 B 클래스의 private 멤버에 직접 접근이 가능하려면 B 클래스가 A 클래스를 대상으로 friend 선언을 해줘야 한다.<br>friend 키워드는 다음과 같이 사용된다.<br>
class Boy
{
	private :
		int height;
		friend class Girl; //Girl 객체를 friend로 선언
	public :
		Boy(int len) : height(len) {}
		. . . . .
};

<br>friend 키워드는 다음의 특징을 가진다.<br>
<br>friend 선언은 클래스 내 어디에든 위치할 수 있다.(private, public, protected 모두에 위치할 수 있다는 뜻.)
<br>다음의 구문은 아직 Girl 클래스가 선언되지 않은 상태에서도 정상적으로 컴파일 된다.
<br>friend class Girl;<br>
<br>왜냐하면 이 구문은 다음 두 가지 의미를 동시에 내포하기 떄문이다.

<br>Girl은 클래스의 이름이다.
<br>그리고 바로 그 Girl 클래스를 friend로 선언한다.


<br>
<br>friend 선언은 다음과 같이 클래스의 특정 멤버 함수에 한하여 사용될 수 있다.
<br>friend Point PointOP::PointAdd(const Point&amp;, const Point&amp;);<br>
<br>또한 friend 선언은 다음과 같이 일반 함수에 대해서도 사용할 수 있다.
<br>friend void ShowPointPos(const Point&amp;);<br>
<br>3번, 4번 케이스의 경우, friend 선언에 함수의 원형 선언이 포함되어 있으므로 friend 선언을 위해서 별도의 함수원형을 선언할 필요는 없다.
<br><br>참고자료<br><a href=".?query=tag:참고도서\윤성우의_열혈_cpp_프로그래밍" class="tag" target="_blank" rel="noopener nofollow">#참고도서/윤성우의_열혈_cpp_프로그래밍</a><br>]]></description><link>resource\language\c++\friend-선언.html</link><guid isPermaLink="false">resource/Language/C++/friend 선언.md</guid><pubDate>Sat, 22 Mar 2025 07:31:43 GMT</pubDate></item><item><title><![CDATA[mutable 키워드]]></title><description><![CDATA[<a class="tag" href="?query=tag:language/cpp" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#language/cpp</a> <a class="tag" href="?query=tag:참고도서/윤성우의_열혈_cpp_프로그래밍" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/윤성우의_열혈_cpp_프로그래밍</a> 
 <br><br><a href=".?query=tag:language\cpp" class="tag" target="_blank" rel="noopener nofollow">#language/cpp</a> <br>mutable<br><br>mutable은 다음의 의미를 가진 키워드이다.<br>const 함수 내에서의 값의 변경을 예외적으로 허용한다.<br>아래의 예제와 같이 사용할 수 있다.<br>
#include &lt;iostream&gt;
using namespace std;

class SoSimple
{
	private:
		int num1;
		mutable int num2;
	public :
		void CopyToNum2() const
		{
			num2 = num1;
		}
};

int main(void)
{
	SoSimple sm(1, 2);
	sm.CopyToNum2(); // const 함수에서 mutable 멤버변수를 변경하고 있다.

	return 0;
}

<br>과도한 mutable 사용은 함수의 const 선언을 의미없게 하므로 지양하여야 한다.<br><br>참고자료<br><a href=".?query=tag:참고도서\윤성우의_열혈_cpp_프로그래밍" class="tag" target="_blank" rel="noopener nofollow">#참고도서/윤성우의_열혈_cpp_프로그래밍</a><br>]]></description><link>resource\language\c++\mutable-키워드.html</link><guid isPermaLink="false">resource/Language/C++/mutable 키워드.md</guid><pubDate>Sat, 22 Mar 2025 07:31:44 GMT</pubDate></item><item><title><![CDATA[new & delete]]></title><description><![CDATA[<a class="tag" href="?query=tag:language/cpp" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#language/cpp</a> <a class="tag" href="?query=tag:참고도서/윤성우의_열혈_cpp_프로그래밍" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/윤성우의_열혈_cpp_프로그래밍</a> 
 <br><br><a href=".?query=tag:language\cpp" class="tag" target="_blank" rel="noopener nofollow">#language/cpp</a> <br>동적 메모리 할당<br><br>c++에서 동적 할당 기능을 가진 연산자이다. malloc, free와 비교할 때 아래의 이점을 가진다.<br><br>키워드 new의 사용방법<br><br>키워드 delete의 사용방법<br><br><br>참고자료<br><a href=".?query=tag:참고도서\윤성우의_열혈_cpp_프로그래밍" class="tag" target="_blank" rel="noopener nofollow">#참고도서/윤성우의_열혈_cpp_프로그래밍</a><br>]]></description><link>resource\language\c++\new-&amp;-delete.html</link><guid isPermaLink="false">resource/Language/C++/new &amp; delete.md</guid><pubDate>Sat, 22 Mar 2025 07:31:44 GMT</pubDate></item><item><title><![CDATA[static 키워드]]></title><description><![CDATA[<a class="tag" href="?query=tag:language/cpp" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#language/cpp</a> <a class="tag" href="?query=tag:참고도서/윤성우의_열혈_cpp_프로그래밍" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/윤성우의_열혈_cpp_프로그래밍</a> 
 <br><br><a href=".?query=tag:language\cpp" class="tag" target="_blank" rel="noopener nofollow">#language/cpp</a> <br>static<br><br>기존의 C 언어에서 static 키워드는 다음의 의미를 가진다.<br>
<br>전역 변수에 선언된 static의 의미 -&gt; 선언된 파일 내에서만 참조를 허용하겠다는 의미
<br>함수 내에 선언된 static의 의미 -&gt; 한번만 초기화되고, 지역변수와 달리 함수를 빠져나가도 소멸되지 않는다.
<br>C++에서 static 키워드는 추가적으로 다음의 의미를 가진다.<br>
<br>static 키워드가 멤버 변수에 붙은 경우

<br>static 멤버변수는 클래스 매개변수라고도 한다. 일반적인 멤버변수와 달리 클래스당 하나씩만 생성되기 때문이다.
<br>static 변수는 클래스의 객체가 생성되지 않아도 전역 변수와 같이 메모리 공간에 할당된다.
<br>만일 객체가 여러 개 생성된다면 여러 개의 객체가 하나의 static 변수를 공유한다.
<br>static 함수의 소멸 시점은 전역 변수와 동일하다.
<br>static 멤버변수는 적어도 한번은 초기화되어야 하며, 초기화는 생성자 내부가 아닌 곳에서 별도로 이루어져야 한다.
<br>static 멤버변수가 public으로 선언된 경우, 객체를 통하지 않아도 다음과 같이 접근이 가능하다.

<br>cout&lt;&lt;SoSimple::simObjcnt;




<br>static 멤버변수를 선언하는 예제코드<br>
class SoSimple
{
	private :
		static int simObjCnt; //static 멤버변수, 클래스 변수
	public :
		SoSimple()
		{
			simObjCnt++;
			cout&lt;&lt;simObjCnt&lt;&lt;"번째 SoSimple 객체"&lt;&lt;endl;
		}
};
int SoSimple::simObjCnt = 0; //static 멤버 변수의 초기화. static 멤버 변수는 반드시 단 한번은 초기화가 이루어져야 한다.

<br><img alt="static 멤버변수.png" src="lib\media\static-멤버변수.png"><br>
<br>
static 키워드가 멤버 함수에 붙은 경우

<br>선언된 클래스의 모든 객체가 공유한다.
<br>public으로 선언이 되면, 클래스의 이름을 이용해서 호출이 가능하다.
<br>객체의 멤버로 존재하는 것이 아니다.

<br>따라서 객체의 멤버변수에 접근할 수 없다.
<br>객체의 생성 이전에도 호출할 수 있다.
<br>-&gt; static 멤버함수 내에서는 static 멤버변수와 static 멤버함수만 호출이 가능하다.




<br>
const static 멤버의 경우

<br>클래스 내에 선언된 <a data-href="const" href="resource\language\c++\const.html" class="internal-link" target="_self" rel="noopener nofollow">const</a> 멤버변수의 경우, <a data-href="멤버 이니셜라이저" href="resource\language\c++\멤버-이니셜라이저.html" class="internal-link" target="_self" rel="noopener nofollow">멤버 이니셜라이저</a>의 도움을 받아 초기화해야 한다. 그러나 const static 멤버변수의 경우 다음과 같이 선언과 동시에 초기화할 수 있다.


<br>
#include &lt;iostream&gt;
using namespace std;

class countryArea
{
	public :
		const static int RUSSIA = 1707540;
		const static int CANADA = 998467;
		const static int CHINA  = 957290;
		const static int SOUTH_KOREA = 9922;
};

int main(void)
{
	cout&lt;&lt;"러시아 면적: "&lt;&lt;CountryArea::RUSSIA&lt;&lt;"km"&lt;&lt;endl;
	cout&lt;&lt;"캐나다 면적: "&lt;&lt;CountryArea::CANADA&lt;&lt;"km"&lt;&lt;endl;
	cout&lt;&lt;"중국 면적: "&lt;&lt;CountryArea::CHINA&lt;&lt;"km"&lt;&lt;endl;
	cout&lt;&lt;"한국 면적: "&lt;&lt;CountryArea::SOUTH_KOREA&lt;&lt;"km"&lt;&lt;endl;
}

<br><br>참고자료<br><a href=".?query=tag:참고도서\윤성우의_열혈_cpp_프로그래밍" class="tag" target="_blank" rel="noopener nofollow">#참고도서/윤성우의_열혈_cpp_프로그래밍</a><br>]]></description><link>resource\language\c++\static-키워드.html</link><guid isPermaLink="false">resource/Language/C++/static 키워드.md</guid><pubDate>Sat, 22 Mar 2025 07:31:44 GMT</pubDate><enclosure url="lib\media\static-멤버변수.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;lib\media\static-멤버변수.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[this]]></title><description><![CDATA[<a class="tag" href="?query=tag:language/cpp" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#language/cpp</a> <a class="tag" href="?query=tag:참고도서/윤성우의_열혈_cpp_프로그래밍" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/윤성우의_열혈_cpp_프로그래밍</a> 
 <br><br><a href=".?query=tag:language\cpp" class="tag" target="_blank" rel="noopener nofollow">#language/cpp</a><br><br>멤버함수 내에서는 this라는 이름의 포인터를 사용할 수 있는데, 이는 객체 자신을 가리키는 용도로 사용되는 포인터이다. this 포인터는 그 주소 값과 자료형이 정해져 있지 않으며 객체 스스로가 저장되어 있는 주소를 가리킨다.<br>this 포인터는 주로 멤버 변수의 이름과 멤버 함수의 지역 변수의 이름이 같을 때, 이 둘을 구별하기 위해 사용된다. 아래의 예제를 참고하자.<br>
class ThisClass
{
	private : 
		int num; //멤버 변수와
	public : 
		void ThisFunc(int num) //멤버 함수의 매개변수의 이름이 같다.
		{
			this-&gt;num = 207; //this 포인터는 함수의 매개변수를 가리키지 않으므로 이를 이용하여 구별이 가능하다.
			num = 105;
		}
	. . . .
};

<br>이러한 this 포인터의 특징을 사용하면 멤버 변수와 멤버 함수(주로 getter 또는 setter)의 매개변수, 지역변수의 이름을 다르게 지을 필요가 없다.<br>
#include &lt;iostream&gt;

using namespace std;

class TwoNumber
{
	private :
		int num1;
		int num2;
	public :
		TwoNumber(int num1, int num2)
		{
			this-&gt;num1 = num1;
			this-&gt;num2 = num2;
		}
		//TwoNumber(int num1, int num2) : num1(num1), num2(num2) {}
		void ShowTwoNumber()
		{
			cout&lt;&lt;this-&gt;num1&lt;&lt;endl;
			cout&lt;&lt;this-&gt;num2&lt;&lt;endl;
		}
};

int main(void)
{
	TwoNumber two(2, 4);
	two.ShowTwoNumber();

	return (0);
}

<br>또한, this 포인터를 사용하여 객체 자신을 참조자를 반환하는 구분을 작성할 수 있다. 이러한 참조자를 Self-Reference라 한다.<br>
#include &lt;iostream&gt;

using namespace std;

class SelfRef
{
	private :
		int num;
	public :
		SelfRef(int n) : num(n)
		{
			cout&lt;&lt;"객체생성"&lt;&lt;endl;
		}
		SelfRef &amp;Adder(int n)
		{
			num += n;
			return *this;
		}
		SelfRef &amp;ShowTwoNumber()
		{
			cout&lt;&lt;num&lt;&lt;endl;
			return *this;
		}
};

int main(void)
{
	SelfRef obj(3);
	SelfRef &amp;ref = obj.Adder(2);
	
	obj.ShowTwoNumber();
	ref.ShowTwoNumber();
	ref.Adder(1).ShowTwoNumber().Adder(2).ShowTwoNumber();

	return (0);
}

<br><br>참고자료<br><a href=".?query=tag:참고도서\윤성우의_열혈_cpp_프로그래밍" class="tag" target="_blank" rel="noopener nofollow">#참고도서/윤성우의_열혈_cpp_프로그래밍</a><br>]]></description><link>resource\language\c++\this.html</link><guid isPermaLink="false">resource/Language/C++/this.md</guid><pubDate>Sat, 22 Mar 2025 07:31:44 GMT</pubDate></item><item><title><![CDATA[virtual 키워드]]></title><description><![CDATA[<a class="tag" href="?query=tag:language/cpp" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#language/cpp</a> <a class="tag" href="?query=tag:참고도서/윤성우의_열혈_cpp_프로그래밍" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/윤성우의_열혈_cpp_프로그래밍</a> 
 <br><br><a href=".?query=tag:language\cpp" class="tag" target="_blank" rel="noopener nofollow">#language/cpp</a> <br>virtual<br><br>virtual 키워드는 다음의 용도를 가지는 키워드이다.<br>
<br><a data-href="가상 함수" href="resource\language\c++\가상-함수.html" class="internal-link" target="_self" rel="noopener nofollow">가상 함수</a>의 생성
<br><a data-href="가상 소멸자" href="resource\language\c++\가상-소멸자.html" class="internal-link" target="_self" rel="noopener nofollow">가상 소멸자</a>의 생성
<br><a data-href="가상 상속" href="resource\language\c++\가상-상속.html" class="internal-link" target="_self" rel="noopener nofollow">가상 상속</a>을 선언한다.
<br><br>참고자료<br><a href=".?query=tag:참고도서\윤성우의_열혈_cpp_프로그래밍" class="tag" target="_blank" rel="noopener nofollow">#참고도서/윤성우의_열혈_cpp_프로그래밍</a><br>]]></description><link>resource\language\c++\virtual-키워드.html</link><guid isPermaLink="false">resource/Language/C++/virtual 키워드.md</guid><pubDate>Sat, 22 Mar 2025 07:31:44 GMT</pubDate></item><item><title><![CDATA[envsubst]]></title><description><![CDATA[<a class="tag" href="?query=tag:linux/cmd" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#linux/cmd</a> 
 <br><br><a href=".?query=tag:linux\cmd" class="tag" target="_blank" rel="noopener nofollow">#linux/cmd</a><br>환경변수 삽입<br><br>envsubst는 환경 변수 값을 텍스트에 치환(substitute)하는 데 사용하는 유용한 도구입니다. 일반적으로 쉘 스크립트에서 템플릿 파일을 처리하거나 환경 변수 기반 설정 파일을 생성할 때 사용됩니다. envsubst는 GNU gettext 패키지에 포함되어 있으며, 특히 bash 환경에서 자주 사용됩니다.<br><br>bash<br>코드 복사<br>envsubst &lt; input_template_file &gt; output_file<br>위 명령은 input_template_file 내의 ${VARIABLE} 형식의 환경 변수를 실제 값으로 치환한 결과를 output_file에 저장합니다.<br><br><br>
<br>
전체 환경 변수 치환 환경 변수를 정의하고 이를 치환:
bash
코드 복사
export VAR1="Hello" export VAR2="World" echo '${VAR1} ${VAR2}' | envsubst
출력:
코드 복사
Hello World

<br>
특정 변수만 치환 envsubst에 $VARIABLE 목록을 지정하면 해당 변수들만 치환됩니다.
bash
코드 복사
export VAR1="Hello" export VAR2="World" echo '${VAR1} ${VAR2}' | envsubst '${VAR1}'
출력:
bash
코드 복사
Hello ${VAR2}

<br>
파일을 템플릿으로 사용 템플릿 파일을 작성하고 환경 변수를 치환:
템플릿 파일 (example.txt):
bash
코드 복사
Hello, ${NAME}! Welcome to ${PLACE}.
스크립트:
bash
코드 복사
export NAME="Alice" export PLACE="Wonderland" envsubst &lt; example.txt &gt; output.txt cat output.txt
출력 (output.txt):
css
코드 복사
Hello, Alice! Welcome to Wonderland.

<br>
명령과 조합 다른 명령과 조합하여 동적으로 내용을 생성:
bash
코드 복사
export USER="John" echo "User: ${USER}, Date: $(date)" | envsubst
출력:
yaml
코드 복사
User: John, Date: Thu Nov 21 12:00:00 2024

<br><br><br>
<br>변수 형식: envsubst는 ${VARIABLE} 또는 $VARIABLE 형식의 변수를 인식합니다. 단, ${} 형태를 사용하는 것이 더 안전합니다.<br>

<br>미정의 변수 처리: 환경 변수가 정의되지 않은 경우, 변수가 그대로 출력됩니다.<br>

<br>특정 변수가 없을 경우 디폴트 값 사용: 치환 전에 변수를 기본값으로 설정하면 활용도가 높아집니다.
  bash
  코드 복사
  export NAME=${NAME:-DefaultName} echo "Hello, ${NAME}" | envsubst<br>

<br><br>Linux에서 envsubst는 gettext 패키지에 포함되어 있으므로 다음 명령으로 설치할 수 있습니다:<br>
<br>Ubuntu/Debian:
  bash
  코드 복사
  sudo apt-get install gettext<br>

<br>CentOS/RHEL:
  bash
  코드 복사
  sudo yum install gettext<br>

<br>envsubst는 환경 변수 기반 설정을 쉽게 관리하도록 돕는 매우 간단하면서도 강력한 도구입니다. 🛠️<br>주의 : 이 명령어는 이미지 빌드 타임에는 환경 변수를 제대로 읽지 못한다. 따라서 반드시 Dockerfile의 RUN이 아니라 ENTRYPOINT로 넘겨서 실행시켜야 한다.]]></description><link>resource\linux\cmd\envsubst.html</link><guid isPermaLink="false">resource/Linux/cmd/envsubst.md</guid><pubDate>Sat, 22 Mar 2025 07:31:44 GMT</pubDate></item><item><title><![CDATA[ssh]]></title><description><![CDATA[<a class="tag" href="?query=tag:linux/cmd" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#linux/cmd</a> 
 <br><br><a href=".?query=tag:linux\cmd" class="tag" target="_blank" rel="noopener nofollow">#linux/cmd</a><br>Secured SHell<br><br>ssh는 원격으로 다른 환경에 연결하기 위한 도구이다.<br>
본 문서는 일단 ssh에 대해 깊게 다루기보다는 기본적인 사용법만 숙지하는 것을 목표로 한다.<br><br>
<br>연결하는 측에서는 ssh 클라이언트를 설치한다. apt install openssh-client
<br>연결을 지원하는 측에서는 ssh 서버를 설치한다. apt install openssh-server
<br>서버 측에서 /etc/ssh/sshd_config(= ssh 서버의 옵션 파일) 파일을 용도에 맞게 수정한다

<br>주의 : 설정 파일을 수정한 후에는 systemctl restart sshd를 통해 서버를 재시작해야 함


<br><br>
<br>클라이언트 측에서 다음의 명령어를 실행한다. 

<br>ssh -p &lt;연결에_사용할_port&gt; &lt;계정_id&gt;@&lt;서버의_ip주소&gt;
<br>ssh 서버 측에서 default port인 22번 포트를 사용할 경우 -p 옵션은 불필요하다.


<br>문제가 발생하면 ~/.ssh/known_host의 내용을 초기화해볼 것
<br>서버 측에서 연결을 위해 계정의 비밀번호를 요구한다(Permission denied가 뜨는 경우 서버 측의 PasswordAuthentication 옵션을 확인하자).
<br><br>
<br>클라이언트 측에서 다음의 명령어를 실행해 ssh 키 한 쌍을 생성한다. 

<br>ssh-keygen -t rsa -b 4096 -C "comment"
<br>-t rsa : rsa 알고리즘으로 키를 생성
<br>-b 4096 : 4096 비트 길이의 키를 생성
<br>-C "comment" : 키에 대한 코멘트를 입력 (보통 이메일 주소를 입력)
<br>생성된 키는 ~/.ssh/id_rsa, id_rsa_pub의 형태로 저장된다.


<br>1의 명령어를 입력하면 다음과 같은 질문이 나온다.

<br>파일 이름: 기본 경로인 ~/.ssh/id_rsa를 그대로 사용하려면 Enter 입력
<br>패스프레이즈: 비밀번호를 입력하여 추가 보안을 설정할 수 있음. 비밀번호 없이 진행하려면 Enter 입력


<br>ssh 키 중 공개키는 서버의 ~/.ssh/authorized_keys 파일에 등록하고, private 키는 클라이언트 측에서 지니고 있다 연결에 사용해야 한다.
<br>공개 키를 클라이언트 측에서 서버의 ~/.ssh/authorized_keys 파일에 등록하려면 서버에 연결된 상태에서 아래의 명령어를 사용한다.

<br>ssh-copy-id -p &lt;port&gt; &lt;user&gt;@remote-server-ip


<br>서버 측에서 PasswordAuthentication 옵션을 no, PubkeyAuthentication 옵션을 yes로 설정한다.
<br><br>
<br>vscode의 remote developement을 설치한다.
<br>f1 -&gt; Remote-SSH: Connect to Host... -&gt; Add New SHH Host... 실행
<br>ssh -p &lt;port&gt; &lt;계정&gt;@&lt;ip 주소&gt; 입력
<br>SSH configuration file을 저장할 장소 선택(~/.ssh/config가 일반적이다.)
<br>연결 완료
<br>향후 연결을 더 편하게 하고 싶으면 4의 configuration file을 아래와 같이 수정할 수 있다.<br>Host [연결 시 ip 주소 대신 사용하는 단축키를 설정]
HostName [연결 대상 ip 주소]
User [연결에 사용할 계정]
Port [연결 대상 port. 서버가 default port인 22번 포트를 사용하면 필요 없음]
IdentityFile [인증에 사용할 ssh private key 경로. 공개 키 인증을 하지 않는다면 필요 없다]
]]></description><link>resource\linux\cmd\ssh.html</link><guid isPermaLink="false">resource/Linux/cmd/ssh.md</guid><pubDate>Fri, 28 Feb 2025 09:51:15 GMT</pubDate></item><item><title><![CDATA[모듈러 산술]]></title><description><![CDATA[<a class="tag" href="?query=tag:math/number_theory" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#math/number_theory</a> 
 <br><br><a href=".?query=tag:math\number_theory" class="tag" target="_blank" rel="noopener nofollow">#math/number_theory</a><br>modular arithmetic<br><br><br>정수론에서 모듈러 산술 또는 합동 산술은 정수의 합과 곱을 어떤 주어진 수의 나머지에 대하여 정의하는 방법이다.<br><br>모듈러 연산에는 다음과 같은 성질들이 존재한다.<br>
<br>덧셈 : (A + B) mod C = (A mod C + B mod C) mod C
<br>뺄셈 : (A - B) mod C = (A mod C - B mod C) mod C
<br>곱셈 : (A  B) mod C = (A mod C  B mod C) mod C
<br>거듭제곱 : (A^B) mod C = ((A mod C)^B) mod C
<br>프로그래밍에서 종종 매우 큰 수를 처리하게 되는데, 모듈러 거듭제곱 연산의 최적화를 통해 큰 수를 효율적으로 계산할 수 있다.]]></description><link>resource\mathmetic\모듈러-산술.html</link><guid isPermaLink="false">resource/Mathmetic/모듈러 산술.md</guid><pubDate>Thu, 06 Mar 2025 04:19:27 GMT</pubDate></item><item><title><![CDATA[게이트웨이]]></title><description><![CDATA[<a class="tag" href="?query=tag:network" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#network</a> <a class="tag" href="?query=tag:참고도서/그림으로_이해하는_네트워크_용어" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/그림으로_이해하는_네트워크_용어</a> 
 <br><br><a href=".?query=tag:network" class="tag" target="_blank" rel="noopener nofollow">#network</a> <br>gateway<br><br>서로 다른 두 개의 네트워크를 연결하여 서로 통신하기 위해 필요한 기기나 시스템. <a data-href="OSI 참조 모델" href="resource\network\기초-개념\osi-참조-모델.html" class="internal-link" target="_self" rel="noopener nofollow">OSI 참조 모델</a>의 전체 계층을 인식하여 통신 매체나 전송 방식 등의 차이를 흡수하고 이기종 간에 접속할 수 있도록 한다.<br>게이트웨이는 전용 기기인 경우도 있고 컴퓨터 상 동작하는 소프트웨어인 경우도 있다.<br>보통은 <a data-href="라우터" href="resource\network\기초-개념\라우터.html" class="internal-link" target="_self" rel="noopener nofollow">라우터</a>가 게이트웨이 역할을 맡으며, 이 경우 LAN에서 외부 네트워크에 엑세스할 떄의 출입구라는 의미를 가진다. 표준으로 사용되는 게이트웨이를 디폴트 게이트웨이라 하며, LAN 밖으로 송신되는 패킷은 일단 이 디폴트 게이트웨이로 전송된 후에 외부 네트워크로 전송된다.<br><br>참고자료<br><a href=".?query=tag:참고도서\그림으로_이해하는_네트워크_용어" class="tag" target="_blank" rel="noopener nofollow">#참고도서/그림으로_이해하는_네트워크_용어</a><br>]]></description><link>resource\network\기초-개념\게이트웨이.html</link><guid isPermaLink="false">resource/Network/기초 개념/게이트웨이.md</guid><pubDate>Sat, 22 Mar 2025 07:31:44 GMT</pubDate></item><item><title><![CDATA[공인 IP 주소]]></title><description><![CDATA[<a class="tag" href="?query=tag:network" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#network</a> <a class="tag" href="?query=tag:참고도서/그림으로_이해하는_네트워크_용어" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/그림으로_이해하는_네트워크_용어</a> <a class="tag" href="?query=tag:참고도서/후니의_쉽게_쓴_시스코_네트워킹" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/후니의_쉽게_쓴_시스코_네트워킹</a> 
 <br><br><a href=".?query=tag:network" class="tag" target="_blank" rel="noopener nofollow">#network</a> <br>public IP address<br><br>컴퓨터는 <a data-href="IP 주소" href="resource\network\기초-개념\ip-주소.html" class="internal-link" target="_self" rel="noopener nofollow">IP 주소</a>를 통해 서로를 식별하므로, 각각의 IP 주소는 중복되지 않고 고유해야 한다.<br>전 세계에서 유일한 번호라는 것을 보장하는 IP 주소를 공인 IP 주소라 한다.<br>공인 IP 주소는 개인이 마음대로 할당할 수 없으며, 나라마다 이를 위한 전문 기관이 있고, 기관의 관리하에 할당받게 되어 있다.<br>IP 주소는 32비트의 정수로 표현하기 때문에 중복되지 않는 번호의 수가 유한하다. 따라서 LAN의 내부와 같이 제한된 범위 안에서는 별도로 <a data-href="사설 IP 주소" href="resource\network\기초-개념\사설-ip-주소.html" class="internal-link" target="_self" rel="noopener nofollow">사설 IP 주소</a>를 할당하여 사용하는 것이 일반적이다.<br>공인 IP 주소는 네트워크 규격에 의해 다섯 클래스로 나누어진다. 각각의 클래스에서 사용할 수 있는 IP 주소는 다음과 같이 정해져 있다.<br>
<br>클래스 A : 첫 번째 옥텟이 1 ~ 126으로 시작하는 네트워크. 이진법으로 나타내면 아래와 같다.
<br>0nnnnnnn.hhhhhhhh.hhhhhhhh.hhhhhhhh
0 : 클래스 A에서 첫번째 비트는 무조건 0으로 시작함.
n : 첫번째 옥텟을 사용하여 네트워크 주소를 나타냄
h : 나머지는 호스트 주소

디폴트 서브넷 마스크는 255.0.0.0
<br>
<br>클래스 B : 첫 번째 옥텟이 128 ~ 191로 시작하는 네트워크. 이진법으로 나타내면 아래와 같다.
<br>10nnnnnn.nnnnnnnn.hhhhhhhh.hhhhhhhh
10 : 클래스 A에서 첫번째 비트는 무조건 1, 두번째 비트는 0이다.
n : 첫번째, 두번째 옥텟을 사용하여 네트워크 주소를 나타냄
h : 나머지는 호스트 주소

디폴트 서브넷 마스크는 255.255.0.0
<br>
<br>클래스 C : 첫 번째 옥텟이 192 ~ 223로 시작하는 네트워크. 이진법으로 나타내면 아래와 같다.
<br>110nnnnn.nnnnnnnn.nnnnnnnn.hhhhhhhh
10 : 클래스 A에서 첫번째와 두번째 비트는 무조건 1, 세번째 비트는 0이다.
n : 첫번째, 두번째, 세번째 옥텟을 사용하여 네트워크 주소를 나타냄
h : 나머지는 호스트 주소

디폴트 서브넷 마스크는 255.255.255.0
<br>
<br>클래스 D : 첫 번째 옥텟이 224 ~ 239로 시작하는 네트워크. 멀티캐스트용 주소.
<br>클래스 E : 첫 번째 옥텟이 240 ~ 255로 시작하는 네트워크. 연구용 주소.
<br><br>참고자료<br><a href=".?query=tag:참고도서\그림으로_이해하는_네트워크_용어" class="tag" target="_blank" rel="noopener nofollow">#참고도서/그림으로_이해하는_네트워크_용어</a><br>
<a href=".?query=tag:참고도서\후니의_쉽게_쓴_시스코_네트워킹" class="tag" target="_blank" rel="noopener nofollow">#참고도서/후니의_쉽게_쓴_시스코_네트워킹</a><br>]]></description><link>resource\network\기초-개념\공인-ip-주소.html</link><guid isPermaLink="false">resource/Network/기초 개념/공인 IP 주소.md</guid><pubDate>Sat, 22 Mar 2025 07:31:44 GMT</pubDate></item><item><title><![CDATA[네트워크 토폴로지]]></title><description><![CDATA[<a class="tag" href="?query=tag:network" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#network</a> <a class="tag" href="?query=tag:참고도서/그림으로_이해하는_네트워크_용어" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/그림으로_이해하는_네트워크_용어</a> 
 <br><br><a href=".?query=tag:network" class="tag" target="_blank" rel="noopener nofollow">#network</a> <br>Network Topology<br><br>컴퓨터를 네트워크에 연결할 때의 형태를 의미한다.<br>대표적인 네트워크 토폴로지는 아래의 세가지이다.<br><br><br>참고자료<br><a href=".?query=tag:참고도서\그림으로_이해하는_네트워크_용어" class="tag" target="_blank" rel="noopener nofollow">#참고도서/그림으로_이해하는_네트워크_용어</a><br>]]></description><link>resource\network\기초-개념\네트워크-토폴로지.html</link><guid isPermaLink="false">resource/Network/기초 개념/네트워크 토폴로지.md</guid><pubDate>Sat, 22 Mar 2025 07:31:44 GMT</pubDate></item><item><title><![CDATA[네트워크 프로토콜]]></title><description><![CDATA[<a class="tag" href="?query=tag:network" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#network</a> <a class="tag" href="?query=tag:참고도서/그림으로_이해하는_네트워크_용어" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/그림으로_이해하는_네트워크_용어</a> 
 <br><br><a href=".?query=tag:network" class="tag" target="_blank" rel="noopener nofollow">#network</a> <br>네트워크를 통해 컴퓨터끼리 정보를 주고받는 절차를 칭한다.<br><br>같은 언어를 가진 사람끼리만 소통할 수 있는 것처럼, 서로 다른 pc가 통신하기 위해선 통신하기 위한 절차를 규정해야 한다. 이러한 절차를 네트워크 프로토콜이라 한다.<br><br>참고자료<br><a href=".?query=tag:참고도서\그림으로_이해하는_네트워크_용어" class="tag" target="_blank" rel="noopener nofollow">#참고도서/그림으로_이해하는_네트워크_용어</a><br>]]></description><link>resource\network\기초-개념\네트워크-프로토콜.html</link><guid isPermaLink="false">resource/Network/기초 개념/네트워크 프로토콜.md</guid><pubDate>Sat, 22 Mar 2025 07:31:44 GMT</pubDate></item><item><title><![CDATA[동적 라우팅]]></title><description><![CDATA[<a class="tag" href="?query=tag:network" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#network</a> 
 <br><br><a href=".?query=tag:network" class="tag" target="_blank" rel="noopener nofollow">#network</a> <br>dynamic routing<br><br>라우터가 주변의 라우터와 교류하여 목적지에 도달하기 위한 최적의 경로를 스스로 탐색하는 방식. 탐색된 경로는 라우팅 테이블에 저장된다.<br>네트워크 환경의 변화에 지속적으로 대응할 수 있다는 장점이 있지만, 경로 정보를 수집하고 관리하는 작업이 추가로 필요하기 때문에 네트워크에 부하를 가하여 성능에 부정적인 영향을 끼친다.<br><br>참고자료<br><a data-tooltip-position="top" aria-label="https://terms.naver.com/entry.naver?docId=2271886&amp;cid=51207&amp;categoryId=51207" rel="noopener nofollow" class="external-link" href="https://terms.naver.com/entry.naver?docId=2271886&amp;cid=51207&amp;categoryId=51207" target="_blank">네이버 지식백과</a><br>]]></description><link>resource\network\기초-개념\동적-라우팅.html</link><guid isPermaLink="false">resource/Network/기초 개념/동적 라우팅.md</guid><pubDate>Sat, 22 Mar 2025 07:31:44 GMT</pubDate></item><item><title><![CDATA[라우터]]></title><description><![CDATA[<a class="tag" href="?query=tag:network" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#network</a> <a class="tag" href="?query=tag:참고도서/그림으로_이해하는_네트워크_용어" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/그림으로_이해하는_네트워크_용어</a> 
 <br><br><a href=".?query=tag:network" class="tag" target="_blank" rel="noopener nofollow">#network</a> <br>router<br><br><a data-href="OSI 참조 모델" href="resource\network\기초-개념\osi-참조-모델.html" class="internal-link" target="_self" rel="noopener nofollow">OSI 참조 모델</a> 3계층(네트워크 계층)의 중계 기능을 제공하는 장치.<br>
LAN과 LAN, LAN과 인터넷처럼 서로 다른 네트워크를 상호 연결하기 위해 사용한다.<br>라우터는 네트워크 프로토콜 수준에서 경로 정보(라우팅 테이블)를 관리한다. 그리고 이 경로 정보를 기반으로 수신지의 네트워크로 통신 데이터를 중계한다.<br>라우터가 수신받은 패킷을 아래의 규칙에 따라 송신한다.<br>
<br>만약 수신한 패킷의 목적지가 LAN 내부라면 외부로 송신하지 않고 그대로 전달한다.
<br>수신한 패킷의 목적지가 다른 네트워크라면 해당 네트워크를 담당하는 라우터에 전송을 의뢰한다.
<br>목적지 네트워크가 먼 곳에 있어서 직접 주고받을 수 없는 경우에는 좀 더 가까운 라우터에 전송한다.
<br><br>참고자료<br><a href=".?query=tag:참고도서\그림으로_이해하는_네트워크_용어" class="tag" target="_blank" rel="noopener nofollow">#참고도서/그림으로_이해하는_네트워크_용어</a><br>]]></description><link>resource\network\기초-개념\라우터.html</link><guid isPermaLink="false">resource/Network/기초 개념/라우터.md</guid><pubDate>Sat, 22 Mar 2025 07:31:44 GMT</pubDate></item><item><title><![CDATA[라우팅]]></title><description><![CDATA[<a class="tag" href="?query=tag:network" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#network</a> 
 <br><br><a href=".?query=tag:network" class="tag" target="_blank" rel="noopener nofollow">#network</a> <br>routing<br><br>전달받은 패킷을 어느 출력 경로를 통해 다음 호스트로 전달해야 가장 최적일지 결정하는 것.<br>최적의 기준은 상황마다 다를 수 있다. 단순히 빠른 경로가 최적의 경로일 수 있고, 다소 느리더라도 보안성이 높은 경로가 최적의 경로일 수 있다. 따라서 주어진 상황에 따라 다른 정책을 사용해야 한다.<br>라우팅은 <a data-href="정적 라우팅" href="resource\network\기초-개념\정적-라우팅.html" class="internal-link" target="_self" rel="noopener nofollow">정적 라우팅</a>과 <a data-href="동적 라우팅" href="resource\network\기초-개념\동적-라우팅.html" class="internal-link" target="_self" rel="noopener nofollow">동적 라우팅</a>으로 나눌 수 있다.<br><br>참고자료<br><a data-tooltip-position="top" aria-label="https://terms.naver.com/entry.naver?docId=2271886&amp;cid=51207&amp;categoryId=51207" rel="noopener nofollow" class="external-link" href="https://terms.naver.com/entry.naver?docId=2271886&amp;cid=51207&amp;categoryId=51207" target="_blank">네이버 지식백과</a><br>]]></description><link>resource\network\기초-개념\라우팅.html</link><guid isPermaLink="false">resource/Network/기초 개념/라우팅.md</guid><pubDate>Sat, 22 Mar 2025 07:31:44 GMT</pubDate></item><item><title><![CDATA[리피터]]></title><description><![CDATA[<a class="tag" href="?query=tag:network" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#network</a> <a class="tag" href="?query=tag:참고도서/그림으로_이해하는_네트워크_용어" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/그림으로_이해하는_네트워크_용어</a> 
 <br><br><a href=".?query=tag:network" class="tag" target="_blank" rel="noopener nofollow">#network</a> <br>repeater<br><br><a data-href="OSI 참조 모델" href="resource\network\기초-개념\osi-참조-모델.html" class="internal-link" target="_self" rel="noopener nofollow">OSI 참조 모델</a> 1계층(물리 계층)의 중계 기능을 제공하는 장치이다.<br>네트워크는 LAN 케이블에 전기 신호를 보내서 통신 데이터를 전송한다. 그러나 케이블이 길어지면 그 안에 흐르는 전기 신호가 감쇠하여 결국 해석할 수 없는 신호가 된다. 리피터는 이렇게 감쇠한 신호를 다시 정렬하고 증폭하여 송출함으로서 LAN의 총 연장 거리를 늘릴 수 있도록 한다.<br><a data-href="이더넷" href="resource\network\기초-개념\이더넷.html" class="internal-link" target="_self" rel="noopener nofollow">이더넷</a>에서는 동일한 경로에 리피터를 네 개 까지 사용하여 총 연장 거기를 늘릴 수 있다. 상한이 정해져 있는 이유는 몇 단계씩 리피터를 경유하면 신호가 왜곡되어 해석할 수 없게 되고, 총 연장 거리가 너무 길어지면 콜리전(신호 충돌) 감지가 잘 동작하지 않기 때문이다.<br>리피터를 여러 개 묶어서 멀티 포트로 사용하는 것을 <a data-href="허브" href="resource\network\기초-개념\허브.html" class="internal-link" target="_self" rel="noopener nofollow">허브</a>라고 한다.<br><br>참고자료<br><a href=".?query=tag:참고도서\그림으로_이해하는_네트워크_용어" class="tag" target="_blank" rel="noopener nofollow">#참고도서/그림으로_이해하는_네트워크_용어</a><br>]]></description><link>resource\network\기초-개념\리피터.html</link><guid isPermaLink="false">resource/Network/기초 개념/리피터.md</guid><pubDate>Sat, 22 Mar 2025 07:31:44 GMT</pubDate></item><item><title><![CDATA[멀티캐스트]]></title><description><![CDATA[<a class="tag" href="?query=tag:network" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#network</a> <a class="tag" href="?query=tag:참고도서/후니의_쉽게_쓴_시스코_네트워킹" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/후니의_쉽게_쓴_시스코_네트워킹</a> 
 <br><br><a href=".?query=tag:network" class="tag" target="_blank" rel="noopener nofollow">#network</a> <br>Multicast<br><br>LAN을 구성하는 구성원 중 특정 그룹에만 송신할 수 있는 기능. <a data-href="유니캐스트" href="resource\network\기초-개념\유니캐스트.html" class="internal-link" target="_self" rel="noopener nofollow">유니캐스트</a>와 <a data-href="브로드캐스트" href="resource\network\기초-개념\브로드캐스트.html" class="internal-link" target="_self" rel="noopener nofollow">브로드캐스트</a>의 장점을 합쳤다고 볼 수 있다.<br>만약 100개의 pc 중 50개의 pc에만 메시지를 전달하는 상황이라 가정할 때, 유니캐스트는 메시지를 50번 송신해야 한다는 단점이 있고, 브로드캐스트는 나머지 50개의 pc에도 불필요하게 메시지를 송신해야 한다는 단점이 있다. 멀티캐스트를 사용하면 1번의 송신으로 지정된 pc들에게만 메시지를 보낼 수 있다. <br>단, 멀티캐스트는 <a data-href="스위칭 허브" href="resource\network\기초-개념\스위칭-허브.html" class="internal-link" target="_self" rel="noopener nofollow">스위칭 허브</a>나 <a data-href="라우터" href="resource\network\기초-개념\라우터.html" class="internal-link" target="_self" rel="noopener nofollow">라우터</a>가 멀티캐스트를 지원해야 사용할 수 있다는 제약이 있다. 스위칭 허브나 라우터가 멀티캐스트를 지원하지 않을 경우, 멀티캐스트를 브로드캐스트와 같이 취급한다.<br><br>참고자료<br><a href=".?query=tag:참고도서\후니의_쉽게_쓴_시스코_네트워킹" class="tag" target="_blank" rel="noopener nofollow">#참고도서/후니의_쉽게_쓴_시스코_네트워킹</a><br>]]></description><link>resource\network\기초-개념\멀티캐스트.html</link><guid isPermaLink="false">resource/Network/기초 개념/멀티캐스트.md</guid><pubDate>Sat, 22 Mar 2025 07:31:44 GMT</pubDate></item><item><title><![CDATA[브로드캐스트]]></title><description><![CDATA[<a class="tag" href="?query=tag:network" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#network</a> <a class="tag" href="?query=tag:참고도서/후니의_쉽게_쓴_시스코_네트워킹" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/후니의_쉽게_쓴_시스코_네트워킹</a> 
 <br><br><a href=".?query=tag:network" class="tag" target="_blank" rel="noopener nofollow">#network</a> <br>Broadcast<br><br>LAN의 모든 네트워크 장비에게 보내는 통신. 브로드캐스트를 수신한 <a data-href="NIC" href="resource\network\기초-개념\nic.html" class="internal-link" target="_self" rel="noopener nofollow">NIC</a>는 무조건 패킷을 cpu로 올린다. 따라서 브로드캐스트가 잦은 네트워크 환경은 pc 성능을 떨어뜨린다.<br><br>참고자료<br><a href=".?query=tag:참고도서\후니의_쉽게_쓴_시스코_네트워킹" class="tag" target="_blank" rel="noopener nofollow">#참고도서/후니의_쉽게_쓴_시스코_네트워킹</a><br>]]></description><link>resource\network\기초-개념\브로드캐스트.html</link><guid isPermaLink="false">resource/Network/기초 개념/브로드캐스트.md</guid><pubDate>Sat, 22 Mar 2025 07:31:44 GMT</pubDate></item><item><title><![CDATA[브로드캐스트 도메인]]></title><description><![CDATA[<a class="tag" href="?query=tag:network" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#network</a> <a class="tag" href="?query=tag:참고도서/후니의_쉽게_쓴_시스코_네트워킹" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/후니의_쉽게_쓴_시스코_네트워킹</a> 
 <br><br><a href=".?query=tag:network" class="tag" target="_blank" rel="noopener nofollow">#network</a> <br>broadcast domain<br><br><a data-href="브로드캐스트" href="resource\network\기초-개념\브로드캐스트.html" class="internal-link" target="_self" rel="noopener nofollow">브로드캐스트</a> 시 메시지를 수신하는 영역을 일컫는다.<br><a data-href="라우터" href="resource\network\기초-개념\라우터.html" class="internal-link" target="_self" rel="noopener nofollow">라우터</a>는 브로드캐스트를 차단하는 특성이 있다.<br>브로드캐스트 도메인이 너무 크면 컴퓨터가 과도하게 많은 브로드캐스트를 수신하여 성능이 저하되기 때문에, 라우터를 이용하여 브로드캐스트 영역을 적절한 크기로 분할한다.<br><br>참고자료<br><a href=".?query=tag:참고도서\후니의_쉽게_쓴_시스코_네트워킹" class="tag" target="_blank" rel="noopener nofollow">#참고도서/후니의_쉽게_쓴_시스코_네트워킹</a><br>]]></description><link>resource\network\기초-개념\브로드캐스트-도메인.html</link><guid isPermaLink="false">resource/Network/기초 개념/브로드캐스트 도메인.md</guid><pubDate>Sat, 22 Mar 2025 07:31:44 GMT</pubDate></item><item><title><![CDATA[브리지]]></title><description><![CDATA[<a class="tag" href="?query=tag:network" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#network</a> <a class="tag" href="?query=tag:참고도서/그림으로_이해하는_네트워크_용어" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/그림으로_이해하는_네트워크_용어</a> 
 <br><br><a href=".?query=tag:network" class="tag" target="_blank" rel="noopener nofollow">#network</a> <br>bridge<br><br><a data-href="OSI 참조 모델" href="resource\network\기초-개념\osi-참조-모델.html" class="internal-link" target="_self" rel="noopener nofollow">OSI 참조 모델</a> 2계층(데이터 링크 계층)의 중계 기능을 제공하는 장치.<br>브리지는 그 이름처럼 다리를 의미하며 서로 다른 세그먼트 사이를 연결하는 역할을 한다. 세그먼트란 네트워크 상의 단일 기기로부터 송출된 패킷이 무조건 도달할 수 있는 범위를 말한다. <br>브리지는 수신된 패킷을 검사하여 발신지와 수신지의 <a data-href="MAC 주소" href="resource\network\기초-개념\mac-주소.html" class="internal-link" target="_self" rel="noopener nofollow">MAC 주소</a>를 기억한다. 이를 바탕으로 주소 테이블을 작성하여 이후에 중계되는 세그먼트 중 어디에 수신지 주소가 있는지 파악한다.<br>주소 테이블에 수신 패킷의 수신지가 있으면 브리지는 주소가 속해 있는 세그먼트에만 패킷을 전달한다. 이렇게 네트워크 상의 패킷 흐름을 제어하여 네트워크 효율을 높일 수 있다.<br>브리지는 전송된 패킷을 중계하고 재송출하므로, 라피터와 마찬가지로 LAN의 총 연장 거리를 늘릴 수 있다. 또한, 브리지는 불필요한 패킷을 다른 세그먼트로 전달하는 일도 없기 때문에 콜리전 감지에 대한 문제도 발생하지 않고, <a data-href="리피터" href="resource\network\기초-개념\리피터.html" class="internal-link" target="_self" rel="noopener nofollow">리피터</a>에서 발생하던 다단 접속의 제한도 없다.<br>브리지를 여러 개 묶어서 멀티 포트화한 것을 <a data-href="스위칭 허브" href="resource\network\기초-개념\스위칭-허브.html" class="internal-link" target="_self" rel="noopener nofollow">스위칭 허브</a>라고 한다.<br><br>참고자료<br><a href=".?query=tag:참고도서\그림으로_이해하는_네트워크_용어" class="tag" target="_blank" rel="noopener nofollow">#참고도서/그림으로_이해하는_네트워크_용어</a><br>]]></description><link>resource\network\기초-개념\브리지.html</link><guid isPermaLink="false">resource/Network/기초 개념/브리지.md</guid><pubDate>Sat, 22 Mar 2025 07:31:44 GMT</pubDate></item><item><title><![CDATA[사설 IP 주소]]></title><description><![CDATA[<a class="tag" href="?query=tag:network" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#network</a> <a class="tag" href="?query=tag:참고도서/그림으로_이해하는_네트워크_용어" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/그림으로_이해하는_네트워크_용어</a> 
 <br><br><a href=".?query=tag:network" class="tag" target="_blank" rel="noopener nofollow">#network</a> <br>private IP address<br><br><a data-href="IP 주소" href="resource\network\기초-개념\ip-주소.html" class="internal-link" target="_self" rel="noopener nofollow">IP 주소</a>는 32비트 정수로 표현하기 때문에 중복되지 않는 번호의 수는 한정되어 있다.<br>
따라서 전 세계의 모든 컴퓨터에 개별 IP를 부여하는 것은 현실적으로 가능하지 않다.<br>그렇기 때문에 IP 주소는 전 세계에서 유일한 번호가 보장되는 <a data-href="공인 IP 주소" href="resource\network\기초-개념\공인-ip-주소.html" class="internal-link" target="_self" rel="noopener nofollow">공인 IP 주소</a>와 제한된 범위 안에서 사용하는 사설 IP 주소로 나뉜다. <br>LAN처럼 제한된 작은 범위의 네트워크에서는 사설 IP 주소를 할당하는 것이 일반적이다.<br>사설 IP 주소는 지정된 범위 안에서만 유효하며, 공용 공간인 외부 세계와 통신하려면 NAT나 IP 마스커레이드 같은 수단을 사용해 주소를 변환해야 한다.<br>사설 IP 주소는 네트워크 규격에 의해 세 클래스로 나누어진다. 각각의 클래스에서 사용할 수 있는 IP 주소는 다음과 같이 정해져 있다.<br><br><br>참고자료<br><a href=".?query=tag:참고도서\그림으로_이해하는_네트워크_용어" class="tag" target="_blank" rel="noopener nofollow">#참고도서/그림으로_이해하는_네트워크_용어</a><br>]]></description><link>resource\network\기초-개념\사설-ip-주소.html</link><guid isPermaLink="false">resource/Network/기초 개념/사설 IP 주소.md</guid><pubDate>Fri, 28 Feb 2025 14:17:29 GMT</pubDate></item><item><title><![CDATA[서브넷 마스크]]></title><description><![CDATA[<a class="tag" href="?query=tag:network" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#network</a> <a class="tag" href="?query=tag:참고도서/그림으로_이해하는_네트워크_용어" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/그림으로_이해하는_네트워크_용어</a> 
 <br><br><a href=".?query=tag:network" class="tag" target="_blank" rel="noopener nofollow">#network</a> <br>subnet mask<br><br>대규모 네트워크의 관리를 용이하게 하기 위해 작은 단위의 네트워크로 분할할 수 있다. 이것을 서브넷(subnet)이라 한다.<br>서브넷 마스크는 이러한 서브넷을 표현하기 위한 값으로, <a data-href="IP 주소" href="resource\network\기초-개념\ip-주소.html" class="internal-link" target="_self" rel="noopener nofollow">IP 주소</a>의 앞에서부터 몇 비트까지 네트워크 주소로 사용할지 정의하기 위해 사용한다. 서브넷 마스크에 의해 호스트 주소 부분 중 몇 개의 비트를 네트워크 주소로 재정의하여, 단일 네트워크를 서브넷으로 구분할 수 있다.<br>ex) 172.16.0.0의 네트워크 주소 부분이 16비트일 때, 호스트 부분 중 8비트를 재정의하여 256개의 서브넷으로 분할할 수 있다.<br>172.16.0.0을 이진법으로 표현했을 때 서브넷 마스크의 적용

10101100.00010000.00000000.00000000
nnnnnnnn.nnnnnnnn.ssssssss.hhhhhhhh

n : 네트워크 주소 부분
s : 서브넷으로 재정의된 부분
h : 호스트 부분
<br><br>참고자료<br><a href=".?query=tag:참고도서\그림으로_이해하는_네트워크_용어" class="tag" target="_blank" rel="noopener nofollow">#참고도서/그림으로_이해하는_네트워크_용어</a><br>]]></description><link>resource\network\기초-개념\서브넷-마스크.html</link><guid isPermaLink="false">resource/Network/기초 개념/서브넷 마스크.md</guid><pubDate>Sat, 22 Mar 2025 07:31:45 GMT</pubDate></item><item><title><![CDATA[스위칭 허브]]></title><description><![CDATA[<a class="tag" href="?query=tag:network" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#network</a> <a class="tag" href="?query=tag:참고도서/그림으로_이해하는_네트워크_용어" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/그림으로_이해하는_네트워크_용어</a> 
 <br><br><a href=".?query=tag:network" class="tag" target="_blank" rel="noopener nofollow">#network</a> <br>switching hub<br><br>스위칭 기능을 가진 허브로, 일반적인 허브와 마찬가지로 여러 개의 LAN 케이블을 연결하기 위한 집선 장치다. 스위칭 기능은 허브가 가진 여러 포트 중에 실제로 통신이 발생한 포트만 연결하여 다른 포트에는 불필요한 패킷을 전송하지 않도록 한 것이다.<br>리피터의 집합체인 허브와 달리 스위칭 허브는 <a data-href="브리지" href="resource\network\기초-개념\브리지.html" class="internal-link" target="_self" rel="noopener nofollow">브리지</a>를 멀티 포트화한 것으로, 멀티 포트 브리지라고도 불린다. 수신 패킷을 모든 포트에 전송하는 리피터 허브와 달리 스위칭 허브는 실체로 통신을 실시하는 포트에만 패킷을 보낸다. 따라서 다른 포트는 동시에 다른 통신을 할 수 있다. 이처럼 패킷 충돌을 억제하기 때문에 네트워크 효율성을 향상시킬 수 있다. 또한 브리지의 특성을 계승하기 때문에 계단식 접속에 대한 제한도 없다.<br>스위칭 허브는 패킷을 수신했을 때 그 패킷을 보낸 포트와 패킷에 기록된 수신지의 <a data-href="MAC 주소" href="resource\network\기초-개념\mac-주소.html" class="internal-link" target="_self" rel="noopener nofollow">MAC 주소</a>를 연결한 테이블을 만든다. 이 테이블을 가지고 어떤 포트에 어떤 MAC 주소를 가진 기기가 접속되어 있는지 관리하여 포트 분배를 실시한다.<br><br>참고자료<br><a href=".?query=tag:참고도서\그림으로_이해하는_네트워크_용어" class="tag" target="_blank" rel="noopener nofollow">#참고도서/그림으로_이해하는_네트워크_용어</a><br>]]></description><link>resource\network\기초-개념\스위칭-허브.html</link><guid isPermaLink="false">resource/Network/기초 개념/스위칭 허브.md</guid><pubDate>Sat, 22 Mar 2025 07:31:45 GMT</pubDate></item><item><title><![CDATA[스타형 LAN]]></title><description><![CDATA[<a class="tag" href="?query=tag:network" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#network</a> <a class="tag" href="?query=tag:참고도서/그림으로_이해하는_네트워크_용어" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/그림으로_이해하는_네트워크_용어</a> 
 <br><br><a href=".?query=tag:network" class="tag" target="_blank" rel="noopener nofollow">#network</a> <br><br><a data-href="네트워크 토폴로지" href="resource\network\기초-개념\네트워크-토폴로지.html" class="internal-link" target="_self" rel="noopener nofollow">네트워크 토폴로지</a>의 하나로, 허브라는 집선 장치를 중심으로 각 컴퓨터를 연결하는 방식을 스타형 LAN이라고 한다. <a data-href="허브" href="resource\network\기초-개념\허브.html" class="internal-link" target="_self" rel="noopener nofollow">허브</a>를 중심으로 해서 선이 별 모양으로 퍼져나가기 때문에 이런 이름이 붙었다.<br>스타형 LAN은 아래와 같은 특징을 같는다.<br>
<br>허브가 통신을 중개하는 역할을 하므로 네트워크에 접속된 컴퓨터가 고장 나도 다른 컴퓨터에 영향을 미치지 않는다.
<br>하지만 허브가 고장난 경우에는 중앙의 통신 경로가 차단되므로 네트워크 전체가 통신 불능 상태가 된다.
<br>배선의 자유도가 높다.
<br>허브끼리 서로 연결하여 계층 구조를 만들 수 있다.
<br><br>참고자료<br><a href=".?query=tag:참고도서\그림으로_이해하는_네트워크_용어" class="tag" target="_blank" rel="noopener nofollow">#참고도서/그림으로_이해하는_네트워크_용어</a><br>]]></description><link>resource\network\기초-개념\스타형-lan.html</link><guid isPermaLink="false">resource/Network/기초 개념/스타형 LAN.md</guid><pubDate>Sat, 22 Mar 2025 07:31:45 GMT</pubDate></item><item><title><![CDATA[유니캐스트]]></title><description><![CDATA[<a class="tag" href="?query=tag:network" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#network</a> <a class="tag" href="?query=tag:참고도서/후니의_쉽게_쓴_시스코_네트워킹" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/후니의_쉽게_쓴_시스코_네트워킹</a> 
 <br><br><a href=".?query=tag:network" class="tag" target="_blank" rel="noopener nofollow">#network</a> <br>Unicast<br><br>정보를 받을 대상을 지정하여 송신하는 방식. 수신하는 측은 지정된 대상과 자신의 <a data-href="MAC 주소" href="resource\network\기초-개념\mac-주소.html" class="internal-link" target="_self" rel="noopener nofollow">MAC 주소</a>가 일치할 때만 패킷을 cpu로 전달한다. 자신이 지정된 대상이 아닐 시 패킷을 폐기하므로 컴퓨터 성능에 영향을 끼치지 않는다.<br><br>참고자료<br><a href=".?query=tag:참고도서\후니의_쉽게_쓴_시스코_네트워킹" class="tag" target="_blank" rel="noopener nofollow">#참고도서/후니의_쉽게_쓴_시스코_네트워킹</a><br>]]></description><link>resource\network\기초-개념\유니캐스트.html</link><guid isPermaLink="false">resource/Network/기초 개념/유니캐스트.md</guid><pubDate>Sat, 22 Mar 2025 07:31:45 GMT</pubDate></item><item><title><![CDATA[이더넷]]></title><description><![CDATA[<a class="tag" href="?query=tag:network" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#network</a> <a class="tag" href="?query=tag:참고도서/그림으로_이해하는_네트워크_용어" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/그림으로_이해하는_네트워크_용어</a> 
 <br><br><a href=".?query=tag:network" class="tag" target="_blank" rel="noopener nofollow">#network</a> <br>이더넷(Ethernet)은 미국 제록스(Xerox) 사 팔로 알토 연구소(Palo Alto Research Center)의 로버트 맷칼프가 발명한 네트워크 규격이다.<br><br>현재 <a data-href="LAN" href="resource\network\기초-개념\lan.html" class="internal-link" target="_self" rel="noopener nofollow">LAN</a> 환경에서 통용되는 네트워크 규격이다. 스타형 LAN, 버스형 LAN에서 주로 사용된다.<br>이더넷은 아래와 같은 특성을 가진다.<br>
<br>매체 사용 감지 Carrier Sense : 네트워크의 통신 상태를 감지하여, 다른 pc가 송신하지 않을 경우에 한해 데이터를 송신한다.
<br>CSMA/CD Carrier Sense Multriple Access/Collision Detection : 부득이하게 동시에 전송하여 패킷 충돌이 발생하면 임의의 시간 동안 대기 후 재전송한다.
<br><br>참고자료<br><a href=".?query=tag:참고도서\그림으로_이해하는_네트워크_용어" class="tag" target="_blank" rel="noopener nofollow">#참고도서/그림으로_이해하는_네트워크_용어</a><br>]]></description><link>resource\network\기초-개념\이더넷.html</link><guid isPermaLink="false">resource/Network/기초 개념/이더넷.md</guid><pubDate>Sat, 22 Mar 2025 07:31:45 GMT</pubDate></item><item><title><![CDATA[정적 라우팅]]></title><description><![CDATA[<a class="tag" href="?query=tag:network" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#network</a> 
 <br><br><a href=".?query=tag:network" class="tag" target="_blank" rel="noopener nofollow">#network</a> <br>Static Routing<br><br>송수신 호스트 사이에서 패킷 전송이 이루어지기 전에 경로 정보를 라우터에 미리 저장하여 중개하는 방식.<br>패킷을 중개하기 위한 최적의 경로 정보는 개별 라우터별로 저장하여 관리하는데, 운용 중인 네트워크 구성에 변화가 생기면 이에 적절하게 대처할 수 없다는 문제점이 있다. 즉, 라우터에 보관된 경로 정보가 고정되어 변화된 정보를 갱신하기가 용이하지 않으며, 특히 네트워크 내부의 혼잡도를 반영할 수 없다.<br>단, 동적 라우팅보다 비용이 적다는 장점이 있다. 따라서 동적 라우팅이 필요 없는 작은 규모의 LAN에서 사용될 수 있다.<br>디폴트 라우팅 default routing : 목적지에 상관없이 무조건 지정된 네트워크로 패킷을 전송한다. 주로 네트워크가 일직선으로 구성되어 있거나, 다음 라우터에 목적지까지 가는 데 필요한 경로 정보가 저장되어 있을 때 유용하다.<br><br>참고자료<br><a data-tooltip-position="top" aria-label="https://terms.naver.com/entry.naver?docId=2271886&amp;cid=51207&amp;categoryId=51207" rel="noopener nofollow" class="external-link" href="https://terms.naver.com/entry.naver?docId=2271886&amp;cid=51207&amp;categoryId=51207" target="_blank">네이버 지식백과</a><br>]]></description><link>resource\network\기초-개념\정적-라우팅.html</link><guid isPermaLink="false">resource/Network/기초 개념/정적 라우팅.md</guid><pubDate>Sat, 22 Mar 2025 07:31:45 GMT</pubDate></item><item><title><![CDATA[콜리전 도메인]]></title><description><![CDATA[<a class="tag" href="?query=tag:network" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#network</a> <a class="tag" href="?query=tag:참고도서/후니의_쉽게_쓴_시스코_네트워킹" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/후니의_쉽게_쓴_시스코_네트워킹</a> <a class="tag" href="?query=tag:참고링크/후니의_IT_블로그" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고링크/후니의_IT_블로그</a> 
 <br><br><a href=".?query=tag:network" class="tag" target="_blank" rel="noopener nofollow">#network</a> <br>collision domain<br><br>메시지 전송 시 충돌이 일어나는 영역을 일컫는다.<br><a data-href="허브" href="resource\network\기초-개념\허브.html" class="internal-link" target="_self" rel="noopener nofollow">허브</a>를 이용하여 LAN들을 연결하는 경우, 콜리전 도메인이 늘어난다.<br><a data-href="브리지" href="resource\network\기초-개념\브리지.html" class="internal-link" target="_self" rel="noopener nofollow">브리지</a>, <a data-href="스위칭 허브" href="resource\network\기초-개념\스위칭-허브.html" class="internal-link" target="_self" rel="noopener nofollow">스위칭 허브</a>를 이용하여, 콜리전 도메인을 분할할 수 있다.<br><br>참고자료<br><a href=".?query=tag:참고도서\후니의_쉽게_쓴_시스코_네트워킹" class="tag" target="_blank" rel="noopener nofollow">#참고도서/후니의_쉽게_쓴_시스코_네트워킹</a><br>
<a href=".?query=tag:참고링크\후니의_IT_블로그" class="tag" target="_blank" rel="noopener nofollow">#참고링크/후니의_IT_블로그</a><br>]]></description><link>resource\network\기초-개념\콜리전-도메인.html</link><guid isPermaLink="false">resource/Network/기초 개념/콜리전 도메인.md</guid><pubDate>Sat, 22 Mar 2025 07:31:45 GMT</pubDate></item><item><title><![CDATA[패킷]]></title><description><![CDATA[<a class="tag" href="?query=tag:network" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#network</a> <a class="tag" href="?query=tag:참고도서/그림으로_이해하는_네트워크_용어" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/그림으로_이해하는_네트워크_용어</a> 
 <br><br><a href=".?query=tag:network" class="tag" target="_blank" rel="noopener nofollow">#network</a> <br>packet은 소포라는 의미이다.<br><br>패킷이란 컴퓨터 통신에서 작게 분할된 통신 데이터의 단위를 말한다.<br>큰 데이터가 분할되지 않고 네트워크로 전송되면 데이터가 회선을 점유하여 다른 기기가 전혀 통신할 수 없는 문제가 일어난다. 예를 들어, 1000BASE-T 규격의 이더넷이 1초간 전송할 수 있는 양은 1G 비트까지이므로, 5G 비트 파일을 전송하면 다른 pc는 5초간 회선을 사용할 수 없게 된다.<br>따라서, 패킷이라는 작은 단위로 데이터를 분할해 회선을 점유하는 시간을 최소화함으로서 다른 pc와 회선을 공유한다.<br>패킷에는 목적지까지 무사히 도착하기 위해 다음과 같은 속성 정보가 포함되어 있다.<br>
<br>송신지와 수신지의 ip 주소
<br>패킷이 사용하는 네트워크 프로토콜 정보
<br><br>참고자료<br><a href=".?query=tag:참고도서\그림으로_이해하는_네트워크_용어" class="tag" target="_blank" rel="noopener nofollow">#참고도서/그림으로_이해하는_네트워크_용어</a><br>]]></description><link>resource\network\기초-개념\패킷.html</link><guid isPermaLink="false">resource/Network/기초 개념/패킷.md</guid><pubDate>Sat, 22 Mar 2025 07:31:45 GMT</pubDate></item><item><title><![CDATA[허브]]></title><description><![CDATA[<a class="tag" href="?query=tag:network" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#network</a> <a class="tag" href="?query=tag:참고도서/그림으로_이해하는_네트워크_용어" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/그림으로_이해하는_네트워크_용어</a> 
 <br><br><a href=".?query=tag:network" class="tag" target="_blank" rel="noopener nofollow">#network</a> <br>hub<br><br>허브는 여러 개의 LAN 케이블을 연결하는 집선 장치이다. 주로 <a data-href="스타형 LAN" href="resource\network\기초-개념\스타형-lan.html" class="internal-link" target="_self" rel="noopener nofollow">스타형 LAN</a>을 구성하는 데 사용한다.<br>허브에는 여러 개의 포트가 있으며, 각 포트는 LAN 케이블을 통해 컴퓨터와 1대1로 연결할 수 있다.<br><a data-href="리피터" href="resource\network\기초-개념\리피터.html" class="internal-link" target="_self" rel="noopener nofollow">리피터</a>와 마찬가지로, 입력된 것을 단순히 증폭하여 연결된 모든 포트로 송출한다. 이 때문에 멀티 포트 리피터, 리피터 허브라 부르기도 한다.<br><br>참고자료<br><a href=".?query=tag:참고도서\그림으로_이해하는_네트워크_용어" class="tag" target="_blank" rel="noopener nofollow">#참고도서/그림으로_이해하는_네트워크_용어</a><br>]]></description><link>resource\network\기초-개념\허브.html</link><guid isPermaLink="false">resource/Network/기초 개념/허브.md</guid><pubDate>Sat, 22 Mar 2025 07:31:45 GMT</pubDate></item><item><title><![CDATA[IP]]></title><description><![CDATA[<a class="tag" href="?query=tag:network" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#network</a> <a class="tag" href="?query=tag:참고도서/그림으로_이해하는_네트워크_용어" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/그림으로_이해하는_네트워크_용어</a> 
 <br><br><a href=".?query=tag:network" class="tag" target="_blank" rel="noopener nofollow">#network</a> <br>Internet Protocol<br><br><a data-href="OSI 참조 모델" href="resource\network\기초-개념\osi-참조-모델.html" class="internal-link" target="_self" rel="noopener nofollow">OSI 참조 모델</a>의 3계층인 네트워크 계층에서 사용되는 <a data-href="네트워크 프로토콜" href="resource\network\기초-개념\네트워크-프로토콜.html" class="internal-link" target="_self" rel="noopener nofollow">네트워크 프로토콜</a>로, 네트워크 상의 기기에 주소를 할당하거나 해당 주소로 패킷을 전송하는 역할을 수행한다.<br>IP는 전송 데이터인 <a data-href="패킷" href="resource\network\기초-개념\패킷.html" class="internal-link" target="_self" rel="noopener nofollow">패킷</a>을 TCP나 UDP 같은 상위 계층에서 수신한 뒤, IP 헤더라는 정보를 추가하여 네트워크에 전송한다. IP 헤더는 송신지와 수신지의 <a data-href="IP 주소" href="resource\network\기초-개념\ip-주소.html" class="internal-link" target="_self" rel="noopener nofollow">IP 주소</a>를 비롯한 정보가 모여 있다.<br>또한, IP에는 경로를 선택하는 방법도 정의되어 있어 이를 통해 여러 네트워크를 넘나드는 통신이 가능하다. 예를 들어, LAN과 외부 네트워크를 연결하는 기기인 <a data-href="라우터" href="resource\network\기초-개념\라우터.html" class="internal-link" target="_self" rel="noopener nofollow">라우터</a>가 IP 경로 선택(<a data-href="라우팅" href="resource\network\기초-개념\라우팅.html" class="internal-link" target="_self" rel="noopener nofollow">라우팅</a>)을 지원한다.<br><br>참고자료<br><a href=".?query=tag:참고도서\그림으로_이해하는_네트워크_용어" class="tag" target="_blank" rel="noopener nofollow">#참고도서/그림으로_이해하는_네트워크_용어</a><br>]]></description><link>resource\network\기초-개념\ip.html</link><guid isPermaLink="false">resource/Network/기초 개념/IP.md</guid><pubDate>Sat, 22 Mar 2025 07:31:45 GMT</pubDate></item><item><title><![CDATA[IP 주소]]></title><description><![CDATA[<a class="tag" href="?query=tag:network" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#network</a> <a class="tag" href="?query=tag:참고도서/그림으로_이해하는_네트워크_용어" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/그림으로_이해하는_네트워크_용어</a> 
 <br><br><a href=".?query=tag:network" class="tag" target="_blank" rel="noopener nofollow">#network</a> <br>IP address<br><br>인터넷과 같이 <a data-href="IP" href="resource\network\기초-개념\ip.html" class="internal-link" target="_self" rel="noopener nofollow">IP</a>를 기반으로 하는 네트워크에서 각 컴퓨터 한 대마다 할당된 식별 번호이다. 현재는 32비트의 숫자로 표현하는 IPv4(Internet Protocol version 4)가 일반적이다. 다만 숫자 그대로는 이해하기 어렵기 떄문에 8비트씩 네 개로 분할하고 각각을 10진수로 표기해 192.168.0.1과 같이 표현한다.<br>IP 주소의 내용은 네트워크별로 나누어지는 네트워크 주소 부분과 그 네트워크 내에서 컴퓨터를 식별하기 위한 호스트 주소 부분을 조합하여 구성된다. 같은 네트워크 안에서 정상적으로 통신하기 위해선 네트워크 주소는 같고 호스트 주소는 달라야 한다.<br>호스트 주소 부분의 모든 비트가 0이라면 특정 호스트가 아니라 네트워크 그 자체를 나타낸다.<br>
모든 비트가 1이라면 특정 호스트가 아니라 브로드캐스팅을 나타낸다.<br>IP 주소를 구성하는 비트 수에 따라 IPv4 와 IPv6로 분류할 수 있다.<br>
또한 모든 네트워크에서 통용되는 <a data-href="공인 IP 주소" href="resource\network\기초-개념\공인-ip-주소.html" class="internal-link" target="_self" rel="noopener nofollow">공인 IP 주소</a>와 제한된 범위에서만 통용되는 <a data-href="사설 IP 주소" href="resource\network\기초-개념\사설-ip-주소.html" class="internal-link" target="_self" rel="noopener nofollow">사설 IP 주소</a>로 나눌 수 있다.<br><br>참고자료<br><a href=".?query=tag:참고도서\그림으로_이해하는_네트워크_용어" class="tag" target="_blank" rel="noopener nofollow">#참고도서/그림으로_이해하는_네트워크_용어</a><br>]]></description><link>resource\network\기초-개념\ip-주소.html</link><guid isPermaLink="false">resource/Network/기초 개념/IP 주소.md</guid><pubDate>Sat, 22 Mar 2025 07:31:45 GMT</pubDate></item><item><title><![CDATA[LAN]]></title><description><![CDATA[<a class="tag" href="?query=tag:network" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#network</a> <a class="tag" href="?query=tag:참고도서/그림으로_이해하는_네트워크_용어" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/그림으로_이해하는_네트워크_용어</a> 
 <br><br><a href=".?query=tag:network" class="tag" target="_blank" rel="noopener nofollow">#network</a> <br>LAN은 Local Area network(근거리 통신망)의 약어이다<br><br>회사나 건물처럼 비교적 좁은 범위 내의 컴퓨터를 연결하여 네트워크를 구성한 것.<br>LAN은 <a data-tooltip-position="top" aria-label="네트워크 토폴로지" data-href="네트워크 토폴로지" href="resource\network\기초-개념\네트워크-토폴로지.html" class="internal-link" target="_self" rel="noopener nofollow">연결 형태</a>에 따라 스타형, 버스형, 링형으로 나눌 수 있다.<br>
LAN의 통신을 제어하는 방법에는 이더넷, FDDI, 토근 링 등이 있다.<br>현재는 <a data-href="이더넷" href="resource\network\기초-개념\이더넷.html" class="internal-link" target="_self" rel="noopener nofollow">이더넷</a>에 의한 <a data-href="스타형 LAN" href="resource\network\기초-개념\스타형-lan.html" class="internal-link" target="_self" rel="noopener nofollow">스타형 LAN</a>이 주류를 이루고 있다.<br>컴퓨터는 LAN, 즉 네트워크가 구성된 환경에서만 다른 컴퓨터와 데이터를 주고 받을 수 있다. 따라서 가정, 회사 등 컴퓨터를 여러 대 사용하는 환경에서는 대부분 LAN을 구축한다.<br><br>참고자료<br><a href=".?query=tag:참고도서\그림으로_이해하는_네트워크_용어" class="tag" target="_blank" rel="noopener nofollow">#참고도서/그림으로_이해하는_네트워크_용어</a><br>]]></description><link>resource\network\기초-개념\lan.html</link><guid isPermaLink="false">resource/Network/기초 개념/LAN.md</guid><pubDate>Fri, 28 Feb 2025 14:17:31 GMT</pubDate></item><item><title><![CDATA[MAC 주소]]></title><description><![CDATA[<a class="tag" href="?query=tag:network" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#network</a> <a class="tag" href="?query=tag:참고도서/그림으로_이해하는_네트워크_용어" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/그림으로_이해하는_네트워크_용어</a> 
 <br><br><a href=".?query=tag:network" class="tag" target="_blank" rel="noopener nofollow">#network</a> <br>Media Access Control address<br><br><a data-href="NIC" href="resource\network\기초-개념\nic.html" class="internal-link" target="_self" rel="noopener nofollow">NIC</a> 별로 할당된 고유 번호로, 이더넷은 반드시 개별 NIC에 대해 48비트의 번호가 붙어 있다. 이더넷에서는 네트워크에 존재하는 노드를 모두 식별할 수 있어야 하므로 기기마다 고유 번호를 할당해 이를 바탕으로 데이터를 송수신한다.<br>MAC 주소는 물리적으로 정의된 주소로 사용자가 변경할 수 없다.<br>MAC 주소의 앞자리 24비트는 제조사의 식별 번호이며, 중복되지 않고 고유한 값이다.<br>
뒷자리 24비트는 제조사가 자사 제품에 할당하는 고유 번호로, 역시 반드시 고유한 값을 사용한다.<br>
즉 모든 MAC 주소는 중복되지 않으며 고유함을 보장받는다.<br><a data-href="OSI 참조 모델" href="resource\network\기초-개념\osi-참조-모델.html" class="internal-link" target="_self" rel="noopener nofollow">OSI 참조 모델</a>의 데이터 링크 계층에서 동작하는 <a data-href="브리지" href="resource\network\기초-개념\브리지.html" class="internal-link" target="_self" rel="noopener nofollow">브리지</a>와 <a data-href="스위칭 허브" href="resource\network\기초-개념\스위칭-허브.html" class="internal-link" target="_self" rel="noopener nofollow">스위칭 허브</a>는 이 MAC 주소를 기반으로 노드를 식별하고 패킷을 중계한다.<br><br>참고자료<br><a href=".?query=tag:참고도서\그림으로_이해하는_네트워크_용어" class="tag" target="_blank" rel="noopener nofollow">#참고도서/그림으로_이해하는_네트워크_용어</a><br>]]></description><link>resource\network\기초-개념\mac-주소.html</link><guid isPermaLink="false">resource/Network/기초 개념/MAC 주소.md</guid><pubDate>Sat, 22 Mar 2025 07:31:45 GMT</pubDate></item><item><title><![CDATA[NIC]]></title><description><![CDATA[<a class="tag" href="?query=tag:network" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#network</a> <a class="tag" href="?query=tag:참고도서/그림으로_이해하는_네트워크_용어" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/그림으로_이해하는_네트워크_용어</a> 
 <br><br><a href=".?query=tag:network" class="tag" target="_blank" rel="noopener nofollow">#network</a> <br>Network Interface Card<br><br>컴퓨터에 네트워크를 연결하기 위한 확장카드.<br>NIC는 네트워크의 인터페이스이며 물리적인 네트워크와의 접점이다. 컴퓨터의 데이터를 전기 신호로 변환하여 케이블에 흘려보내거나, 그 반대의 역할을 수행한다.<br>흔히 우리가 아는 LAN 케이블 또한 컴퓨터의 NIC가 있는 곳에 연결된다.<br>모든 NIC는 물리적인 주소(<a data-href="MAC 주소" href="resource\network\기초-개념\mac-주소.html" class="internal-link" target="_self" rel="noopener nofollow">MAC 주소</a>)를 가진다.<br><br>참고자료<br><a href=".?query=tag:참고도서\그림으로_이해하는_네트워크_용어" class="tag" target="_blank" rel="noopener nofollow">#참고도서/그림으로_이해하는_네트워크_용어</a><br>]]></description><link>resource\network\기초-개념\nic.html</link><guid isPermaLink="false">resource/Network/기초 개념/NIC.md</guid><pubDate>Sat, 22 Mar 2025 07:31:45 GMT</pubDate></item><item><title><![CDATA[OSI 참조 모델]]></title><description><![CDATA[<a class="tag" href="?query=tag:network" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#network</a> <a class="tag" href="?query=tag:참고도서/그림으로_이해하는_네트워크_용어" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/그림으로_이해하는_네트워크_용어</a> <a class="tag" href="?query=tag:참고도서/후니의_쉽게_쓴_시스코_네트워킹" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/후니의_쉽게_쓴_시스코_네트워킹</a> 
 <br><br><a href=".?query=tag:network" class="tag" target="_blank" rel="noopener nofollow">#network</a> <br>OSI 참조 모델은 네트워크의 기본 구조를 일곱 개 계층으로 나누어 표준화한 것이다.<br><br>네트워크에서는 다른 기종 간에도 문제없이 데이터를 송수신할 수 있도록 상호 호환성을 구현하는 것이 중요하다. 또한 기존의 네트워크 기능을 확장해야 할 필요도 있다.<br>이와 같은 상호 호환성과 확장성을 위해 네트워크의 기본 구조는 일곱 개의 층으로 나뉘어져 관리되고 있다. 이 계층 구조를 OSI 참조 모델 혹은 OSI 계층 모델이라고 한다.<br>각 계층이 담당하는 역할은 아래와 같다.<br><br>송신 측은 응용 계층에서 물리 계층까지 순서대로 데이터를 가공하여 보내고, 수신하는 곳은 받은 데이터를 역순으로 가공하여 이를 복원한다.<br><br>참고자료<br><a href=".?query=tag:참고도서\그림으로_이해하는_네트워크_용어" class="tag" target="_blank" rel="noopener nofollow">#참고도서/그림으로_이해하는_네트워크_용어</a><br>
<a href=".?query=tag:참고도서\후니의_쉽게_쓴_시스코_네트워킹" class="tag" target="_blank" rel="noopener nofollow">#참고도서/후니의_쉽게_쓴_시스코_네트워킹</a><br>]]></description><link>resource\network\기초-개념\osi-참조-모델.html</link><guid isPermaLink="false">resource/Network/기초 개념/OSI 참조 모델.md</guid><pubDate>Sat, 22 Mar 2025 07:31:45 GMT</pubDate></item><item><title><![CDATA[TCP]]></title><description><![CDATA[<a class="tag" href="?query=tag:network" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#network</a> <a class="tag" href="?query=tag:참고도서/그림으로_이해하는_네트워크_용어" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/그림으로_이해하는_네트워크_용어</a> 
 <br><br><a href=".?query=tag:network" class="tag" target="_blank" rel="noopener nofollow">#network</a> <br>Transmission Control Protocol<br><br><a data-href="OSI 참조 모델" href="resource\network\기초-개념\osi-참조-모델.html" class="internal-link" target="_self" rel="noopener nofollow">OSI 참조 모델</a>의 4계층인 전송 계층에서 사용되는 네트워크 프로토콜로, 신뢰성이 높은 데이터 통신을 보장한다. 신뢰성이 높다는 것은 데이터의 손실 없이 확실하게 상대에게 전송한다는 의미이다.<br>TCP는 5계층(세션 계층) 이상의 프로토콜에서 통신 데이터를 수신하여 <a data-href="패킷" href="resource\network\기초-개념\패킷.html" class="internal-link" target="_self" rel="noopener nofollow">패킷</a>으로 분할한다. 그리고 이 패킷을 3계층(네트워크 계층)의 <a data-href="IP" href="resource\network\기초-개념\ip.html" class="internal-link" target="_self" rel="noopener nofollow">IP</a>에게 전달하여 상대방에게 송신한다.<br>패킷을 전송하는 IP는 패킷이 순서대로 도착하는 것을 보장하지 않아, 네트워크의 혼잡 상황에 따라 패킷의 손실이나 지연에 의해 순서가 뒤바뀌는 일이 발생할 수 있다. 이에 대응하여 데이터 통신이 신뢰성을 가질 수 있도록 TCP는 다음의 방법들을 사용한다.<br>
<br>송신 측에서 통신 데이터를 패킷으로 분할할 때 분할 순으로 시퀀스 번호를 부여한다.
<br>수신 측에서 이 번호를 확인하고 필요에 따라 순서를 정렬하여 패킷의 순서가 올바른지 확인한다.
<br>수신 측에서 수신했다는 것을 알리는 패킷(ACK 패킷)을 송신 측에 전송한다.
<br>송신 측에선 일정 시간 이상 수신 측에서 응답을 보내지 않을 경우 패킷을 재전송하여 손실을 방지한다.
<br><br>참고자료<br><a href=".?query=tag:참고도서\그림으로_이해하는_네트워크_용어" class="tag" target="_blank" rel="noopener nofollow">#참고도서/그림으로_이해하는_네트워크_용어</a><br>]]></description><link>resource\network\기초-개념\tcp.html</link><guid isPermaLink="false">resource/Network/기초 개념/TCP.md</guid><pubDate>Sat, 22 Mar 2025 07:31:45 GMT</pubDate></item><item><title><![CDATA[TCP IP]]></title><description><![CDATA[<a class="tag" href="?query=tag:network" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#network</a> <a class="tag" href="?query=tag:참고도서/그림으로_이해하는_네트워크_용어" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/그림으로_이해하는_네트워크_용어</a> 
 <br><br><a href=".?query=tag:network" class="tag" target="_blank" rel="noopener nofollow">#network</a> <br>TCP/IP는 인터넷에서 표준으로 사용하는 네트워크 프로토콜이다.<br><br><a data-href="OSI 참조 모델" href="resource\network\기초-개념\osi-참조-모델.html" class="internal-link" target="_self" rel="noopener nofollow">OSI 참조 모델</a> 3계층(네트워크 계층)의 IP를 비롯한 여러 프로토콜의 집합체의 총칭. TCP/IP는 주로 4계층(전송 계층)에 위치하는 TCP와 조합하여 구성된다. 예를 들어 인터넷의 대표적인 서비스인 WWW의 HTTP 등은 이 프로토콜을 기반으로 하여 움직이고 있다.<br>이 프로토콜을 사용하여 전송되는 데이터는 <a data-href="패킷" href="resource\network\기초-개념\패킷.html" class="internal-link" target="_self" rel="noopener nofollow">패킷</a>이라는 단위로 나누어져 통신한다. 각각의 패킷에는 목적지의 IP 주소가 포함되어 있어 네트워크를 통해 상대에게 도달할 수 있다.<br>하위 계층인 <a data-href="IP" href="resource\network\기초-개념\ip.html" class="internal-link" target="_self" rel="noopener nofollow">IP</a>는 네트워크 각 기기의 주소를 할당하거나 해당 주소를 기반으로 패킷으로 전송하는 역할을 한다.<br>상위 계층인 <a data-href="TCP" href="resource\network\기초-개념\tcp.html" class="internal-link" target="_self" rel="noopener nofollow">TCP</a>는 패킷의 수신 확인을 실시하며 올바른 순서로 패킷이 전달되도록 보장한다.<br>
단 TCP는 상당히 무거운 프로토콜이므로, 상황에 따라 신뢰성보다 빠른 처리속도를 중시하는 <a data-href="UDP" href="resource\network\기초-개념\udp.html" class="internal-link" target="_self" rel="noopener nofollow">UDP</a>를 사용할 수도 있다.<br><br>참고자료<br><a href=".?query=tag:참고도서\그림으로_이해하는_네트워크_용어" class="tag" target="_blank" rel="noopener nofollow">#참고도서/그림으로_이해하는_네트워크_용어</a><br>]]></description><link>resource\network\기초-개념\tcp-ip.html</link><guid isPermaLink="false">resource/Network/기초 개념/TCP IP.md</guid><pubDate>Sat, 22 Mar 2025 07:31:45 GMT</pubDate></item><item><title><![CDATA[UDP]]></title><description><![CDATA[<a class="tag" href="?query=tag:network" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#network</a> <a class="tag" href="?query=tag:참고도서/그림으로_이해하는_네트워크_용어" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/그림으로_이해하는_네트워크_용어</a> 
 <br><br><a href=".?query=tag:network" class="tag" target="_blank" rel="noopener nofollow">#network</a> <br>User Datagram Protocol<br><br><a data-href="OSI 참조 모델" href="resource\network\기초-개념\osi-참조-모델.html" class="internal-link" target="_self" rel="noopener nofollow">OSI 참조 모델</a>의 4계층(전송 계층)에서 사용하는 네트워크 프로토콜이며, 연결이 없는 형태(데이터그램)의 통신 기능을 제공한다. 연결이 없는 형태란 지금부터 정보를 보낸다고 상대방에게 통지하지 않고 보내는 전송 방법을 의미한다. 따라서 통신의 신뢰성은 낮지만 속도가 빠른 것이 특징이다.<br>UDP는 3계층(네트워크 계층)의 <a data-href="IP" href="resource\network\기초-개념\ip.html" class="internal-link" target="_self" rel="noopener nofollow">IP</a>를 5계층(세션 계층) 이상의 프로토콜에서 직접 사용할 수 있도록 중개 역할을 한다고 볼 수 있다. <a data-href="패킷" href="resource\network\기초-개념\패킷.html" class="internal-link" target="_self" rel="noopener nofollow">패킷</a>을 분할하여 전송만 하기 때문에 실제로 수신 측에서 아무것도 받지 못할 수도 있다.<br>이러한 특성을 감안하여 작은 사이즈의 패킷을 주고받기만 하면 되는 응용프로그램(ex. DNS, DHCP)이나 시간적 연속성이 중요한 응용프로그램(ex. 음성 전화, 동영상 배포)에서 사용한다.<br><br>참고자료<br><a href=".?query=tag:참고도서\그림으로_이해하는_네트워크_용어" class="tag" target="_blank" rel="noopener nofollow">#참고도서/그림으로_이해하는_네트워크_용어</a><br>]]></description><link>resource\network\기초-개념\udp.html</link><guid isPermaLink="false">resource/Network/기초 개념/UDP.md</guid><pubDate>Sat, 22 Mar 2025 07:31:45 GMT</pubDate></item><item><title><![CDATA[WAN]]></title><description><![CDATA[<a class="tag" href="?query=tag:network" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#network</a> <a class="tag" href="?query=tag:참고도서/그림으로_이해하는_네트워크_용어" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/그림으로_이해하는_네트워크_용어</a> 
 <br><br><a href=".?query=tag:network" class="tag" target="_blank" rel="noopener nofollow">#network</a> <br>WAN은 Wide Area Network(광역 통신망)의 약어이다<br><br>서로 멀리 떨어져 있는 컴퓨터나 LAN 사이를 연결한 네트워크.<br>아래의 방법들로 WAN을 구축할 수 있다.<br>
<br>거점 사이를 전용선으로 연결한다. 비용이 많이 든다.
<br>필요할 때만 공중 회선을 경유해 전화 접속으로 연결한다. 통신 시간에 따라 비용이 변동된다.
<br>VPN을 사용해 인터넷에 가상의 전용선 공간을 만들고 거점 사이를 연결한다. 비용은 저렴하지만 보안적인 측면에서 주의가 필요하다.
<br><br>참고자료<br><a href=".?query=tag:참고도서\그림으로_이해하는_네트워크_용어" class="tag" target="_blank" rel="noopener nofollow">#참고도서/그림으로_이해하는_네트워크_용어</a><br>]]></description><link>resource\network\기초-개념\wan.html</link><guid isPermaLink="false">resource/Network/기초 개념/WAN.md</guid><pubDate>Fri, 28 Feb 2025 14:17:34 GMT</pubDate></item><item><title><![CDATA[네트워크 바이트 순서]]></title><description><![CDATA[<a class="tag" href="?query=tag:network" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#network</a> <a class="tag" href="?query=tag:language/c" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#language/c</a> <a class="tag" href="?query=tag:socket_programming" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#socket_programming</a> <a class="tag" href="?query=tag:참고도서/윤성우의_열혈_TCP_IP_소켓_프로그래밍" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/윤성우의_열혈_TCP_IP_소켓_프로그래밍</a> 
 <br><br><a href=".?query=tag:network" class="tag" target="_blank" rel="noopener nofollow">#network</a> <a href=".?query=tag:language\c" class="tag" target="_blank" rel="noopener nofollow">#language/c</a> <a href=".?query=tag:socket_programming" class="tag" target="_blank" rel="noopener nofollow">#socket_programming</a><br>network byte order<br><br>CPU가 어떤 <a data-href="호스트 바이트 순서" href="resource\network\소켓-프로그래밍(리눅스)\호스트-바이트-순서.html" class="internal-link" target="_self" rel="noopener nofollow">호스트 바이트 순서</a>를 따르냐에 따라 데이터를 방식이 다르다.<br>
만약 빅 엔디안을 채택하는 시스템이 아무런 조치 없이 리틀 엔디안 시스템에 데이터를 송신한다면 데이터를 거꾸로 읽게 되어 문제가 발생할 것이다.<br>이러한 문제를 해결하기 위하여 네트워크를 통하여 데이터를 전송할 때에는 빅 엔디안 방식으로 기준을 통일하여 데이터를 전송하기로 약속하였으며, 이 약속을 가리켜 네트워크 바이트 순서(Network Byte Order)라 한다.<br><br>참고자료<br><a href=".?query=tag:참고도서\윤성우의_열혈_TCP_IP_소켓_프로그래밍" class="tag" target="_blank" rel="noopener nofollow">#참고도서/윤성우의_열혈_TCP_IP_소켓_프로그래밍</a><br>]]></description><link>resource\network\소켓-프로그래밍(리눅스)\네트워크-바이트-순서.html</link><guid isPermaLink="false">resource/Network/소켓 프로그래밍(리눅스)/네트워크 바이트 순서.md</guid><pubDate>Sat, 22 Mar 2025 07:31:45 GMT</pubDate></item><item><title><![CDATA[다중 접속 서버]]></title><description><![CDATA[<a class="tag" href="?query=tag:network" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#network</a> <a class="tag" href="?query=tag:language/c" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#language/c</a> <a class="tag" href="?query=tag:socket_programming" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#socket_programming</a> <a class="tag" href="?query=tag:참고도서/윤성우의_열혈_TCP_IP_소켓_프로그래밍" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/윤성우의_열혈_TCP_IP_소켓_프로그래밍</a> 
 <br><br><a href=".?query=tag:network" class="tag" target="_blank" rel="noopener nofollow">#network</a> <a href=".?query=tag:language\c" class="tag" target="_blank" rel="noopener nofollow">#language/c</a> <a href=".?query=tag:socket_programming" class="tag" target="_blank" rel="noopener nofollow">#socket_programming</a><br>multi user server<br><br>서버는 꺼지지 않고 무한히 클라이언트의 요청에 응답해야 한다.<br>이러한 특성 때문에 서버를 이루는 코드는 일반적으로 무한 루프를 포함한다.<br>
그리고 그 무한 루프는 대충 아래와 같은 구조를 띈다.<br>
새로운 클라이언트의 연결을 수락(accept()) -&gt; 클라이언트로부터 요청이 있는지 체크(read()) -&gt; 응답(write()) -&gt; 반복...

<br>문제는 accept(), read(), write() 모두 blocking 될 수 있는 함수라는 것이다.<br>accept()는 클라이언트의 연결 요청이 없을 경우 새로운 요청이 도착할 때까지 대기한다.<br>
read()의 경우 버퍼에 읽을 데이터가 없을 때 새로운 데이터가 도착할 때까지 대기한다.<br>
write()의 경우 버퍼에 데이터를 작성할 공간이 없을 때 작성할 공간이 생길 때까지 대기한다.<br>문제는 서버에서 이러한 blocking이 발생할 경우 다음 로직의 실행에 지연이 발생하기 때문에 여러 개의 클라이언트의 요청을 동시에 처리하는 것이 아닌 순차적으로 처리하게 된다는 문제점이 있다.<br>
새로운 클라이언트의 연결을 수락하기 위해 accept()에서 대기 -&gt; 클라이언트로부터 요청을 받기 위해 read()에서 대기 -&gt; 응답을 위해 write()에서 대기(다만 write()에서 대기가 발생하는 경우는 드물다) -&gt; 반복...

<br>이러한 문제점을 해결하여(즉, blocking으로부터 발생하는 지연을 최대한 없애버림으로서) 접속하고 있는 클라이언트에게 동시에 서비스를 제공하는 서버를 다중 접속 서버라 칭한다.<br>다중 접속 서버는 다음의 수단을 사용하여 구현할 수 있다.<br>
<br><a data-href="멀티 프로세스 기반 서버" href="resource\network\소켓-프로그래밍(리눅스)\멀티-프로세스-기반-서버.html" class="internal-link" target="_self" rel="noopener nofollow">멀티 프로세스 기반 서버</a>
<br><a data-href="멀티 쓰레딩 기반 서버" href="resource\network\소켓-프로그래밍(리눅스)\멀티-쓰레딩-기반-서버.html" class="internal-link" target="_self" rel="noopener nofollow">멀티 쓰레딩 기반 서버</a>
<br><a data-href="멀티 플렉싱 기반 서버" href="resource\network\소켓-프로그래밍(리눅스)\멀티-플렉싱-기반-서버.html" class="internal-link" target="_self" rel="noopener nofollow">멀티 플렉싱 기반 서버</a>
<br><a data-href="fcntl" href="fcntl" class="internal-link" target="_self" rel="noopener nofollow">fcntl</a>이나 <a data-href="set_socket" href="set_socket" class="internal-link" target="_self" rel="noopener nofollow">set_socket</a> 등의 시스템 콜을 사용하여 소켓이 가리키는 fd가 non-blocking으로 동작하도록 설정한다.
<br>위의 방법 중 4번은 <a data-href="시스템 콜" href="시스템 콜" class="internal-link" target="_self" rel="noopener nofollow">시스템 콜</a>을 호출하는 빈도가 매우 증가하여 성능 상의 불이익이 있으므로 사용하지 않는 것이 좋다.<br><br><img alt="다중 접속 서버 구현 방식.jpg" src="lib\media\다중-접속-서버-구현-방식.jpg"><br>
<a data-tooltip-position="top" aria-label="https://velog.io/@appti/%EB%8B%A4%EC%A4%91-%EC%A0%91%EC%86%8D-%EC%84%9C%EB%B2%84-%EA%B5%AC%ED%98%84-%EB%B0%A9%EC%8B%9D" rel="noopener nofollow" class="external-link" href="https://velog.io/@appti/%EB%8B%A4%EC%A4%91-%EC%A0%91%EC%86%8D-%EC%84%9C%EB%B2%84-%EA%B5%AC%ED%98%84-%EB%B0%A9%EC%8B%9D" target="_blank">원본 링크</a><br><br><br>참고자료<br><a href=".?query=tag:참고도서\윤성우의_열혈_TCP_IP_소켓_프로그래밍" class="tag" target="_blank" rel="noopener nofollow">#참고도서/윤성우의_열혈_TCP_IP_소켓_프로그래밍</a> <br>]]></description><link>resource\network\소켓-프로그래밍(리눅스)\다중-접속-서버.html</link><guid isPermaLink="false">resource/Network/소켓 프로그래밍(리눅스)/다중 접속 서버.md</guid><pubDate>Sat, 22 Mar 2025 07:31:46 GMT</pubDate><enclosure url="lib\media\다중-접속-서버-구현-방식.jpg" length="0" type="image/jpeg"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;lib\media\다중-접속-서버-구현-방식.jpg&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[멀티 쓰레딩 기반 서버]]></title><description><![CDATA[<a class="tag" href="?query=tag:socket_programming" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#socket_programming</a> <a class="tag" href="?query=tag:network" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#network</a> <a class="tag" href="?query=tag:server" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#server</a> <a class="tag" href="?query=tag:참고도서/윤성우의_열혈_TCP_IP_소켓_프로그래밍" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/윤성우의_열혈_TCP_IP_소켓_프로그래밍</a> 
 <br><br><a href=".?query=tag:socket_programming" class="tag" target="_blank" rel="noopener nofollow">#socket_programming</a> <a href=".?query=tag:network" class="tag" target="_blank" rel="noopener nofollow">#network</a> <a href=".?query=tag:server" class="tag" target="_blank" rel="noopener nofollow">#server</a> <br>**<br><br><br>참고자료<br><a href=".?query=tag:참고도서\윤성우의_열혈_TCP_IP_소켓_프로그래밍" class="tag" target="_blank" rel="noopener nofollow">#참고도서/윤성우의_열혈_TCP_IP_소켓_프로그래밍</a> <br>]]></description><link>resource\network\소켓-프로그래밍(리눅스)\멀티-쓰레딩-기반-서버.html</link><guid isPermaLink="false">resource/Network/소켓 프로그래밍(리눅스)/멀티 쓰레딩 기반 서버.md</guid><pubDate>Sat, 22 Mar 2025 07:31:46 GMT</pubDate></item><item><title><![CDATA[멀티 프로세스 기반 서버]]></title><description><![CDATA[<a class="tag" href="?query=tag:socket_programming" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#socket_programming</a> <a class="tag" href="?query=tag:network" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#network</a> <a class="tag" href="?query=tag:server" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#server</a> <a class="tag" href="?query=tag:참고도서/윤성우의_열혈_TCP_IP_소켓_프로그래밍" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/윤성우의_열혈_TCP_IP_소켓_프로그래밍</a> 
 <br><br><a href=".?query=tag:socket_programming" class="tag" target="_blank" rel="noopener nofollow">#socket_programming</a> <a href=".?query=tag:network" class="tag" target="_blank" rel="noopener nofollow">#network</a> <a href=".?query=tag:server" class="tag" target="_blank" rel="noopener nofollow">#server</a> <br>multi process server<br><br>멀티 프로세스 기반 서버는 다음과 같은 과정을 통해 non-blocking한(즉, <a data-href="다중 접속 서버" href="resource\network\소켓-프로그래밍(리눅스)\다중-접속-서버.html" class="internal-link" target="_self" rel="noopener nofollow">다중 접속 서버</a>를) 구현한다.<br>
<br>서버(부모 프로세스)는 accept 함수 호출을 통해서 연결 요청을 수락한다.
<br>이때 얻게 되는 소켓의 파일 디스크립터를 자식 프로세스를 생성해서 넘겨준다.
<br>자식 프로세스는 전달받은 파일 디스크립터를 바탕으로 서비스를 제공한다.
<br>부모 프로세스는 1의 과정을 되풀이하며 지속적으로 클라이언트의 연결 요청을 수락한다. 이후 반복.
<br>
// echo_mpserv.c

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;unistd.h&gt;
#include &lt;signal.h&gt;
#include &lt;sys/wait.h&gt;
#include &lt;arpa/inet.h&gt;
#include &lt;sys/socket.h&gt;

#define BUF_SIZE 30

void error_handling(char *message);
void read_childproc(int sig);

int main(int argc, char *argv[])
{
	if (argc != 2) {
		printf("Usage : %s &lt;port&gt;\n", argv[0]);
		exit(1);
	}
	
	int serv_sock, clnt_sock;
	struct sockaddr_in serv_adr, clnt_adr;

	pid_t pid;
	struct sigaction act;
	socklen_t adr_sz;
	int str_len, state;
	char buf[BUF_SIZE];

	// SIGCHLD가 발생하면 좀비를 회수하도록 처리한다.
	act.sa_handler = read_childproc;
	sigemptyset(&amp;act.sa_mask);
	act.sa_flags = 0;
	state = sigaction(SIGCHLD, &amp;act, 0);

	// tcp 서버 소켓을 만든다.
	serv_sock = socket(PF_INET, SOCK_STREAM, 0);
	memset(&amp;serv_adr, 0, sizeof(serv_adr));
	serv_adr.sin_family = AF_INET;
	serv_adr.sin_addr.s_addr = htonl(INADDR_ANY);
	serv_adr.sin_port = htons(atoi(argv[1]));
	
	if (bind(serv_sock, (struct sockaddr *)&amp;serv_adr, sizeof(serv_adr)) == -1)
		error_handling("bind() error");
	if (listen(serv_sock, 5) == -1)
		error_handling("listen() error");

	while (1)
	{
		// 클라이언트의 연결 요청을 수락한다.
		adr_sz = sizeof(clnt_adr);
		clnt_sock = accept(serv_sock, (struct sockaddr *)&amp;clnt_adr, &amp;adr_sz);
		if (clnt_sock == -1)
			continue ;
		else
			puts("new client connected...");

		// fork()하여 자식 프로세스에게 클라이언트에게 서비스 제공하는 작업을 전담한다.
		// 이때, 자식 프로세스는 부모 프로세스의 메모리 공간을 복사하여 생성되므로 별도의 전달 작업
		// 없이 클라이언트와 연결된 소켓을 사용할 수 있다.
		pid = fork();
		if (pid == -1)
		{
			close(clnt_sock);
			continue;
		}
		if (pid == 0)
		{
			close(serv_sock);
			while ((str_len = read(clnt_sock, buf, BUF_SIZE)) != 0)
				write(clnt_sock, buf, str_len);

			close(clnt_sock);
			puts("client disconnected...");

			return (0);
		}
		else
			close(clnt_sock);
	}
	close(serv_sock);
	return (0);
}

void read_childproc(int sig)
{
	sig = 0;
	
	pid_t pid;
	int status;
	pid = waitpid(-1, &amp;status, WNOHANG);
	printf("removed proc id: %d \n", pid);
}

void error_handling(char *message)
{
	fputs(message, stderr);
	fputc('\n', stderr);
	exit(1);
}

<br><br>멀티 프로세스 기반으로 서버를 작성하면 기능 별로 코드를 분할하기 용이하다. 특히 데이터를 송신하는 부분과 데이터를 수신하는 부분을 분할하여 작성하면 코드의 가독성이 크게 증대된다.<br>입출력 루틴 분할의 또 다른 장점은, 데이터 송수신이 잦은 프로그램의 성능향상을 들 수 있다.<br><img alt="tcp 입출력 루틴 분할.png" src="lib\media\tcp-입출력-루틴-분할.png" style="width: 600px; max-width: 100%;"><br>위 그림의 왼쪽은 이전 에코 클라이언트의 데이터 송수신 방식을, 그리고 오른쪽은 입출력 루틴을 분리시킨 에코 클라이언트의 데이터 송수신 방식을 보여준다. 일단 서버에서의 차이는 없다. 차이가 나는 부분은 클라이언트 영역이다. 입출력 루틴이 분리된 클라이언트는 데이터의 수신 여부에 상관없이 데이터 전송이 가능하기 떄문에 연속해서 데이터의 전송이 가능하다. 따라서 동일한 시간 내에서의 데이터 송수신 분량이 상대적으로 많을 수밖에 없다. 그리고 이러한 성능적 차이는 데이터의 전송 속도가 느린 환경에서 더 확실히 드러난다.<br>
// echo_mpclient.c

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;unistd.h&gt;
#include &lt;arpa/inet.h&gt;
#include &lt;sys/socket.h&gt;

#define BUF_SIZE 30

void error_handling(char *message);
void read_routine(int sock, char *buf);
void write_routine(int sock, char *buf);

int main(int argc, char *argv[])
{
	// 인자 개수 체크
	if (argc != 3)
	{
		printf("Usage : %s &lt;IP&gt; &lt;port&gt;\n", argv[0]);
		exit(1);
	}
	
	int sock;
	pid_t pid;
	char buf[BUF_SIZE];
	struct sockaddr_in serv_adr;

	// 소켓을 만들어 서버에 접속
	sock = socket(PF_INET, SOCK_STREAM, 0);
	memset(&amp;serv_adr, 0, sizeof(serv_adr));
	serv_adr.sin_family = AF_INET;
	serv_adr.sin_addr.s_addr = inet_addr(argv[1]);
	serv_adr.sin_port = htons(atoi(argv[2]));

	if (connect(sock, (struct sockaddr *)&amp;serv_adr, sizeof(serv_adr)) == -1)
		error_handling("connect() error!");

	// 입력 루틴과 출력 루틴을 분할
	// 입력은 부모에서, 출력은 자식에서 실행한다.
	pid = fork();
	if (pid == 0)
		write_routine(sock, buf);
	else
		read_routine(sock, buf);

	close(sock);
	return (0);
}

// 입력 루틴 : 서버에서 연결을 끊을 때까지 전달받은 명령을 표준 출력으로 보낸다.
void read_routine(int sock, char *buf)
{
	while (1)
	{
		int str_len = read(sock, buf, BUF_SIZE);
		if (str_len == 0)
			return ;

		buf[str_len] = 0;
		printf("Message from server: %s", buf);
	}
}

// 출력 루틴 : 표준 입력으로부터 입력받아 서버에 보낸다.
// q 또는 Q라는 입력을 받으면 shutdown 시스템콜을 사용하여
// write 버퍼를 닫는 동시에 서버에 EOF를 보낸다.
// 서버 측은 EOF를 전달받으면 close()를 통하여 클라이언트와의 연결을 끊는다고 기대할 수 있다.
// 그러면 부모에서 동작하고 있는 read_routine에서도 read()가 0을 반환함을 통해
// 연결이 끊겼음을 인지한다.
void write_routine(int sock, char *buf)
{
	while (1)
	{
		fgets(buf, BUF_SIZE, stdin);
		if (!strcmp(buf, "q\n") || !strcmp(buf, "Q\n"))
		{
			shutdown(sock, SHUT_WR);
			// 연결이 끊기면 바로 return 하므로 별도로 좀비를 회수할 필요가 없다.
			return ;
		}
		write(sock, buf, strlen(buf));
	}
}

void error_handling(char *message)
{
	fputs(message, stderr);
	fputc('\n', stderr);
	exit(1);
}

<br><br>참고자료<br><a href=".?query=tag:참고도서\윤성우의_열혈_TCP_IP_소켓_프로그래밍" class="tag" target="_blank" rel="noopener nofollow">#참고도서/윤성우의_열혈_TCP_IP_소켓_프로그래밍</a> <br>]]></description><link>resource\network\소켓-프로그래밍(리눅스)\멀티-프로세스-기반-서버.html</link><guid isPermaLink="false">resource/Network/소켓 프로그래밍(리눅스)/멀티 프로세스 기반 서버.md</guid><pubDate>Sat, 22 Mar 2025 07:31:46 GMT</pubDate><enclosure url="lib\media\tcp-입출력-루틴-분할.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;lib\media\tcp-입출력-루틴-분할.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[멀티 플렉싱 기반 서버]]></title><description><![CDATA[<a class="tag" href="?query=tag:socket_programming" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#socket_programming</a> <a class="tag" href="?query=tag:network" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#network</a> <a class="tag" href="?query=tag:server" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#server</a> <a class="tag" href="?query=tag:참고도서/윤성우의_열혈_TCP_IP_소켓_프로그래밍" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/윤성우의_열혈_TCP_IP_소켓_프로그래밍</a> 
 <br><br><a href=".?query=tag:socket_programming" class="tag" target="_blank" rel="noopener nofollow">#socket_programming</a> <a href=".?query=tag:network" class="tag" target="_blank" rel="noopener nofollow">#network</a> <a href=".?query=tag:server" class="tag" target="_blank" rel="noopener nofollow">#server</a> <br>multiplexing server<br><br>멀티 플렉싱이란 <a data-href="다중 접속 서버" href="resource\network\소켓-프로그래밍(리눅스)\다중-접속-서버.html" class="internal-link" target="_self" rel="noopener nofollow">다중 접속 서버</a>를 구현하는 방법 중의 하나이다.<br>
멀티 플렉싱의 원리를 거칠게 설명하면 아래와 같다.<br>
<br>서버가 소켓을 열고 <a data-href="listen" href="resource\network\소켓-프로그래밍(리눅스)\listen.html" class="internal-link" target="_self" rel="noopener nofollow">listen</a>한다.
<br>여러 클라이언트가 서버에 연결 요청을 한다.
<br>서버는 요청한 모든 클라이언트와의 연결을 수락하고, 연결된 소켓을 별도의 관리 테이블에 저장한다.
<br>서버는 내부적으로 연결된 소켓에서 발생하는 이벤트를 무한 반복문을 통해 감시한다.

<br>이 때의 이벤트는, 클라이언트에서 데이터를 소켓에 전송해 커널 영역에 데이터가 세팅되어 서버와 연결된 소켓이 read가 가능해진 상태가 되는 이벤트를 의미한다.
<br>서버는 <a data-href="select" href="resource\network\소켓-프로그래밍(리눅스)\select.html" class="internal-link" target="_self" rel="noopener nofollow">select</a> 등의 시스템 콜을 사용하여 이벤트를 감지한다.


<br>클라이언트가 연결된 소켓에게 데이터를 전송한다.

<br>데이터가 커널 영역에 저장되어 read 호출이 가능해지면 이벤트가 발생한다.
<br>서버는 계속 무한 반복문을 통해 이벤트를 감시한다.


<br>서버에서 무한 루프를 통해 관리 테이블에 저장한 소켓의 이벤트를 감시하다가, 이벤트가 발생한 것을 감지하고 클라이언트의 요청을 처리한다.
<br>서버에서 요청을 처리한 이후 클라이언트와 연결된 소켓을 해당 클라이언트에게 응답을 반환한다.
<br>이후 멀티 플렉싱에 관련된 자세한 기술은 <a data-href="select" href="resource\network\소켓-프로그래밍(리눅스)\select.html" class="internal-link" target="_self" rel="noopener nofollow">select</a> 문서를 참고하자.<br><br>참고자료<br><a href=".?query=tag:참고도서\윤성우의_열혈_TCP_IP_소켓_프로그래밍" class="tag" target="_blank" rel="noopener nofollow">#참고도서/윤성우의_열혈_TCP_IP_소켓_프로그래밍</a> <br>]]></description><link>resource\network\소켓-프로그래밍(리눅스)\멀티-플렉싱-기반-서버.html</link><guid isPermaLink="false">resource/Network/소켓 프로그래밍(리눅스)/멀티 플렉싱 기반 서버.md</guid><pubDate>Sat, 22 Mar 2025 07:31:46 GMT</pubDate></item><item><title><![CDATA[소켓의 타입]]></title><description><![CDATA[<a class="tag" href="?query=tag:network" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#network</a> <a class="tag" href="?query=tag:language/c" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#language/c</a> <a class="tag" href="?query=tag:socket_programming" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#socket_programming</a> <a class="tag" href="?query=tag:linux" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#linux</a> <a class="tag" href="?query=tag:참고도서/윤성우의_열혈_TCP_IP_소켓_프로그래밍" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/윤성우의_열혈_TCP_IP_소켓_프로그래밍</a> 
 <br><br><a href=".?query=tag:network" class="tag" target="_blank" rel="noopener nofollow">#network</a> <a href=".?query=tag:language\c" class="tag" target="_blank" rel="noopener nofollow">#language/c</a> <a href=".?query=tag:socket_programming" class="tag" target="_blank" rel="noopener nofollow">#socket_programming</a> <a href=".?query=tag:linux" class="tag" target="_blank" rel="noopener nofollow">#linux</a><br>type<br><br><a data-tooltip-position="top" aria-label="socket" data-href="socket" href="resource\network\소켓-프로그래밍(리눅스)\socket.html" class="internal-link" target="_self" rel="noopener nofollow">소켓</a>의 <a data-href="프로토콜 체계" href="resource\network\소켓-프로그래밍(리눅스)\프로토콜-체계.html" class="internal-link" target="_self" rel="noopener nofollow">프로토콜 체계</a>를 결정한 후에는, 해당 프로토콜 체계 내에서 어떠한 방식으로 데이터를 전송할 것인지 결정해야 한다. 예를 들어서 PF_INET에 해당하는 프로토콜 체계에는 둘 이상의 데이터 전송방식이 존재한다.<br><br><br>연결 지향형 소켓은 TCP 방식으로 연결을 지원하며 특징은 아래와 같다.<br>
<br>중간에 데이터가 소멸되지 않고 목적지로 전송된다.
<br>전송 순서대로 데이터가 수신된다.
<br>전송되는 데이터의 경계(Boundary)가 존재하지 않는다(중요)
<br>소켓 대 소켓의 연결은 반드시 1대 1이어야 한다.
<br>1, 2번의 특성은 우리가 익히 알던 TCP의 특성이다. 그리고 4번은 그리 이해하기 어렵지 않다. 그러므로 3번에 대해 좀 더 자세히 알아보자.<br>데이터를 송수신하는 소켓은 내부적으로 버퍼(buffer), 쉽게 말해서 바이트 배열을 지니고 있다. 그리고 소켓을 통해 전송되는 데이터는 일단 이 배열에 저장된다. 때문에 데이터가 수신되었다고 해서 바로 read()를 통해 호출해야 하는 것은 아니다. 버퍼의 용량을 초과하지 않는 한, 여러 번에 걸쳐 데이터가 채워진 후에 한 번의 read() 호출을 통해서 데이터 전부를 읽어 들일수도 있고, 반대로 한번의 write() 호출로 전송된 데이터를 여러 번의 read() 호출을 통해 읽어들일 수도 있다. 즉, read()의 호출횟수와 write() 함수의 호출횟수는 연결지향형 소켓의 경우 큰 의미를 갖지 못한다. 때문에 연결지향형 소켓은 데이터의 경계가 존재하지 않는다고 말하는 것이다.<br><br>
<br>전송된 순서에 상관없이 가장 빠른 전송을 지향한다.
<br>전송된 데이터는 손실의 우려가 있고, 파손의 우려가 있다.
<br>전송되는 데이터의 경계(Boundary)가 존재한다.
<br>한 번에 전송할 수 있는 데이터의 크기가 제한된다.
<br>연결이라는 개념이 존재하지 않는다.
<br>마찬가지로 1, 2번의 특성은 우리가 익히 알던 UDP의 그것이다. 3,4 번은 연결지향형 소켓과 반대의 특성을 지니고 있다. 전송되는 데이터의 경계가 존재한다는 것은 아래와 같은 의미를 가진다.<br>
<br>연결지향형 소켓의 경우, 첫 번째 write()로 50 byte의 데이터를 송신하고 두 번째 write()로 50 byte의 데이터를 송신한 후에, 한 번에 read()만으로 100 byte의 데이터를 한꺼번에 수신할 수 있다.
<br>반면에, 비연결지향형 소켓의 경우 두 번의 read()를 사용하여 데이터를 50 byte 씩 나눠서 수신해야 한다. 데이터의 경계가 정해져 있기 때문이다.
<br>4, 5번 특성에 대해서는 차후 부연한다.<br><br><a data-href="socket" href="resource\network\소켓-프로그래밍(리눅스)\socket.html" class="internal-link" target="_self" rel="noopener nofollow">socket</a> 시스템콜에는 protocol이라는 세번째 인자가 존재한다.<br>
첫번째 인자로 <a data-href="프로토콜 체계" href="resource\network\소켓-프로그래밍(리눅스)\프로토콜-체계.html" class="internal-link" target="_self" rel="noopener nofollow">프로토콜 체계</a>를 정의하고, 두번째 인자로 <a data-href="소켓의 타입" href="resource\network\소켓-프로그래밍(리눅스)\소켓의-타입.html" class="internal-link" target="_self" rel="noopener nofollow">소켓의 타입</a>을 지정하였으므로 이미 프로토콜 결정에 충분한 정보를 전달하였다고 판단할 수 있다. 하지만 다음과 같은 상황 때문에 세번째 인자는 필요하다.<br>하나의 프로토콜 체계 안에 데이터의 전송방식이 동일한 프로토콜이 둘 이상 존재하는 경우<br>예를 들어 첫번째 인자로 PF_INET을 넘기고, 두번째 인자로 SOCK_STREAM을 넘기는 것은 다음을 의미한다.<br>IPv4 인터넷 프로토콜 체계에서 동작하는 연결지향형 데이터 전송 소켓<br>위 조건을 충족하는 프로토콜은 IPPROTO_TCP 하나이기 때문에 세번째 인자로 0을 전달하여도 정상적으로 소켓은 생성된다. 하지만 좀 더 명시적으로 코드를 작성하고 싶다면 아래와 같이 작성하면 된다. 아래와 같이 생성되는 소켓을 가리켜 TCP 소켓이라 한다.<br>int tcp_socket = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP);
<br>UDP 소켓은 아래와 같은 정의를 가지고 있다.<br>IPv4 인터넷 프로토콜 체계에서 동작하는 비 연결지향형 데이터 전송 소켓<br>위 조건을 만족하는 프로토콜은 IPPROTO_UDP 하나이기 때문에 세번째 인자로 0을 전달하여도 되고, 명시적으로 인자를 전달하여도 된다.<br>int udp_socket = socket(PF_INET , SOCK_DGRAM, IPPROTO_UDP);
<br><br>참고자료<br><a href=".?query=tag:참고도서\윤성우의_열혈_TCP_IP_소켓_프로그래밍" class="tag" target="_blank" rel="noopener nofollow">#참고도서/윤성우의_열혈_TCP_IP_소켓_프로그래밍</a><br>]]></description><link>resource\network\소켓-프로그래밍(리눅스)\소켓의-타입.html</link><guid isPermaLink="false">resource/Network/소켓 프로그래밍(리눅스)/소켓의 타입.md</guid><pubDate>Sat, 22 Mar 2025 07:31:46 GMT</pubDate></item><item><title><![CDATA[프로토콜 체계]]></title><description><![CDATA[<a class="tag" href="?query=tag:network" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#network</a> <a class="tag" href="?query=tag:language/c" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#language/c</a> <a class="tag" href="?query=tag:socket_programming" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#socket_programming</a> <a class="tag" href="?query=tag:linux" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#linux</a> <a class="tag" href="?query=tag:참고도서/윤성우의_열혈_TCP_IP_소켓_프로그래밍" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/윤성우의_열혈_TCP_IP_소켓_프로그래밍</a> 
 <br><br><a href=".?query=tag:network" class="tag" target="_blank" rel="noopener nofollow">#network</a> <a href=".?query=tag:language\c" class="tag" target="_blank" rel="noopener nofollow">#language/c</a> <a href=".?query=tag:socket_programming" class="tag" target="_blank" rel="noopener nofollow">#socket_programming</a> <a href=".?query=tag:linux" class="tag" target="_blank" rel="noopener nofollow">#linux</a><br>Protocol Family<br><br><a data-tooltip-position="top" aria-label="socket" data-href="socket" href="resource\network\소켓-프로그래밍(리눅스)\socket.html" class="internal-link" target="_self" rel="noopener nofollow">소켓</a>이 사용할 프로토콜의 부류정보를 가리켜 '프로토콜 체계'라 하며, 프로토콜 체계의 종류는 다음과 같다.<br><br>주로 PF_INET에 해당하는 IPv4 인터넷 프로토콜 체계가 주로 사용되는 프로토콜 체계이며, 그 외 체계는 중요도가 떨어지거나 아직 보편화 되지 않은 프로토콜이다.<br><br>참고자료<br><a href=".?query=tag:참고도서\윤성우의_열혈_TCP_IP_소켓_프로그래밍" class="tag" target="_blank" rel="noopener nofollow">#참고도서/윤성우의_열혈_TCP_IP_소켓_프로그래밍</a><br>]]></description><link>resource\network\소켓-프로그래밍(리눅스)\프로토콜-체계.html</link><guid isPermaLink="false">resource/Network/소켓 프로그래밍(리눅스)/프로토콜 체계.md</guid><pubDate>Sat, 22 Mar 2025 07:31:46 GMT</pubDate></item><item><title><![CDATA[호스트 바이트 순서]]></title><description><![CDATA[<a class="tag" href="?query=tag:computer_science" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#computer_science</a> <a class="tag" href="?query=tag:참고도서/윤성우의_열혈_TCP_IP_소켓_프로그래밍" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/윤성우의_열혈_TCP_IP_소켓_프로그래밍</a> 
 <br><br><a href=".?query=tag:computer_science" class="tag" target="_blank" rel="noopener nofollow">#computer_science</a><br>Host Bye Order<br><br>호스트 바이트 순서란 CPU의 데이터 저장 방식을 의미한다.<br>
CPU의 데이터를 저장하는 방식은 아래의 두가지로 나뉜다.<br><br>다음은 각 저장방식에서 0x20번지를 시작으로 4바이트 int형 정수 0x12345678을 저장하는 예시이다.<br><br><br><br><br>인텔과 AMD  계열의 CPU는 모두 리틀 엔디안을 기준으로 정렬한다.<br><br>참고자료<br><a href=".?query=tag:참고도서\윤성우의_열혈_TCP_IP_소켓_프로그래밍" class="tag" target="_blank" rel="noopener nofollow">#참고도서/윤성우의_열혈_TCP_IP_소켓_프로그래밍</a><br>]]></description><link>resource\network\소켓-프로그래밍(리눅스)\호스트-바이트-순서.html</link><guid isPermaLink="false">resource/Network/소켓 프로그래밍(리눅스)/호스트 바이트 순서.md</guid><pubDate>Sat, 22 Mar 2025 07:31:46 GMT</pubDate></item><item><title><![CDATA[accept]]></title><description><![CDATA[<a class="tag" href="?query=tag:network" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#network</a> <a class="tag" href="?query=tag:language/c" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#language/c</a> <a class="tag" href="?query=tag:socket_programming" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#socket_programming</a> <a class="tag" href="?query=tag:linux/system_call" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#linux/system_call</a> <a class="tag" href="?query=tag:참고도서/윤성우의_열혈_TCP_IP_소켓_프로그래밍" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/윤성우의_열혈_TCP_IP_소켓_프로그래밍</a> 
 <br><br><a href=".?query=tag:network" class="tag" target="_blank" rel="noopener nofollow">#network</a> <a href=".?query=tag:language\c" class="tag" target="_blank" rel="noopener nofollow">#language/c</a> <a href=".?query=tag:socket_programming" class="tag" target="_blank" rel="noopener nofollow">#socket_programming</a> <a href=".?query=tag:linux\system_call" class="tag" target="_blank" rel="noopener nofollow">#linux/system_call</a><br>클라이언트의 연결 요청 수락<br><br><a data-href="listen" href="resource\network\소켓-프로그래밍(리눅스)\listen.html" class="internal-link" target="_self" rel="noopener nofollow">listen</a>의 호출 이후에 클라이언트의 연결 요청이 들어왔다면, 들어온 순서대로 연결 요청을 수락해야 한다.<br>
listen을 통해 생성된 서버 소켓은 오로지 연결 요청만을 전담하여 수신하는 소켓이므로, 클라이언트와 데이터를 주고 받기 위해서는 별도의 연결 소켓이 필요하다. 이를 위해 accept를 사용한다.<br><img alt="accept의 기능.png" src="lib\media\accept의-기능.png"><br>accept을 사용하면 연결 요청 대기 큐에서 연결 요청 하나를 꺼내, 해당 클라이언트와의 통신을 위한 소켓을 생성 후 연결한 후에 해당 소켓의 파일 디스크립터를 반환한다.<br>#include &lt;sys/socket.h&gt;

int accept(int sock, struct sockaddr *addr, socklen_t *addrlen);
<br>
<br>sock : 서버 소켓의 파일 디스크립터 전달
<br>addr : 연결 요청한 클라이언트의 주소 정보를 담을 변수의 주소 값 전달. 함수 호출이 완료되면 인자로 전달된 주소의 변수에는 클라이언트의 주소 정보가 채워진다.
<br>addrlen : 두 번째 매개변수 addr에 전달된 주소의 변수 크기를 바이트 단위로 전달. 단, 크기 정보를 변수에 저장한 다음에 변수의 주소 값을 전달한다. 그리고 함수 호출이 완료되면 크기정보로 채워져 있던 변수에는 클라이언트의 주소 정보 길이가 바이트 단위로 계산되어 채워진다.
<br>
<br>성공 시 생성된 소켓의 파일 디스크립터, 실패 시 -1 반환
<br><br>참고자료<br><a href=".?query=tag:참고도서\윤성우의_열혈_TCP_IP_소켓_프로그래밍" class="tag" target="_blank" rel="noopener nofollow">#참고도서/윤성우의_열혈_TCP_IP_소켓_프로그래밍</a><br>]]></description><link>resource\network\소켓-프로그래밍(리눅스)\accept.html</link><guid isPermaLink="false">resource/Network/소켓 프로그래밍(리눅스)/accept.md</guid><pubDate>Sat, 22 Mar 2025 07:31:46 GMT</pubDate><enclosure url="lib\media\accept의-기능.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;lib\media\accept의-기능.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[bind]]></title><description><![CDATA[<a class="tag" href="?query=tag:network" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#network</a> <a class="tag" href="?query=tag:language/c" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#language/c</a> <a class="tag" href="?query=tag:socket_programming" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#socket_programming</a> <a class="tag" href="?query=tag:linux/system_call" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#linux/system_call</a> <a class="tag" href="?query=tag:참고도서/윤성우의_열혈_TCP_IP_소켓_프로그래밍" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/윤성우의_열혈_TCP_IP_소켓_프로그래밍</a> 
 <br><br><a href=".?query=tag:network" class="tag" target="_blank" rel="noopener nofollow">#network</a> <a href=".?query=tag:language\c" class="tag" target="_blank" rel="noopener nofollow">#language/c</a> <a href=".?query=tag:socket_programming" class="tag" target="_blank" rel="noopener nofollow">#socket_programming</a> <a href=".?query=tag:linux\system_call" class="tag" target="_blank" rel="noopener nofollow">#linux/system_call</a><br>소켓에 인터넷 주소를 할당<br><br>#include &lt;sys/socket.h&gt;

int bind(int sockfd, struct sockaddr *myaddr, socklen_t addrlen);
<br>
<br>sockfd : 주소 정보를(IP와 PORT를) 할당할 소켓의 파일 디스크립터
<br>myaddr : 할당하고자 하는 주소 정보를 지니는 구조체 변수의 주소 값.
<br>addrlen : 두 번째 인자로 전달된 구조체 변수의 길이 정보.
<br>
<br>반환값 : 성공 시 0, 실패 시 -1 반환
<br>bind()를 통해 IP 주소와 PORT 번호를 얻은 소켓은 해당 포트로 전송되는 모든 데이터를 수신하게 된다.<br>특이 사항으로 <a data-tooltip-position="top" aria-label="sockaddr_in > ^917553" data-href="sockaddr_in#^917553" href="resource\network\소켓-프로그래밍(리눅스)\sockaddr_in.html#^917553" class="internal-link" target="_self" rel="noopener nofollow">sockaddr</a> 구조체는 매우 사용하기 불편하므로 보통 <a data-href="sockaddr_in" href="resource\network\소켓-프로그래밍(리눅스)\sockaddr_in.html" class="internal-link" target="_self" rel="noopener nofollow">sockaddr_in</a> 타입 변수의 주소를 형변환으로 변환시켜 사용한다.<br><br>참고자료<br><a href=".?query=tag:참고도서\윤성우의_열혈_TCP_IP_소켓_프로그래밍" class="tag" target="_blank" rel="noopener nofollow">#참고도서/윤성우의_열혈_TCP_IP_소켓_프로그래밍</a><br>]]></description><link>resource\network\소켓-프로그래밍(리눅스)\bind.html</link><guid isPermaLink="false">resource/Network/소켓 프로그래밍(리눅스)/bind.md</guid><pubDate>Sat, 22 Mar 2025 07:31:46 GMT</pubDate></item><item><title><![CDATA[connect]]></title><description><![CDATA[<a class="tag" href="?query=tag:network" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#network</a> <a class="tag" href="?query=tag:language/c" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#language/c</a> <a class="tag" href="?query=tag:socket_programming" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#socket_programming</a> <a class="tag" href="?query=tag:linux/system_call" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#linux/system_call</a> <a class="tag" href="?query=tag:참고도서/윤성우의_열혈_TCP_IP_소켓_프로그래밍" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/윤성우의_열혈_TCP_IP_소켓_프로그래밍</a> 
 <br><br><a href=".?query=tag:network" class="tag" target="_blank" rel="noopener nofollow">#network</a> <a href=".?query=tag:language\c" class="tag" target="_blank" rel="noopener nofollow">#language/c</a> <a href=".?query=tag:socket_programming" class="tag" target="_blank" rel="noopener nofollow">#socket_programming</a> <a href=".?query=tag:linux\system_call" class="tag" target="_blank" rel="noopener nofollow">#linux/system_call</a><br>연결 요청<br><br>클라이언트는 아래의 시스템 콜을 통해 서버에 연결 요청을 송신한다.<br>#include &lt;sys/socket.h&gt;

int connect(int sock, struct sockaddr *servaddr, socklen_t addrlen);
<br>
<br>sock : 클라이언트 소켓의 파일 디스크립터 전달
<br>servaddr : 연결요청 할 서버의 주소 정보를 담은 변수의 주소 값 전달
<br>addrlen : 두 번째 매개변수 servaddr에 전달된 주소의 변수 크기를 바이트 단위로 전달
<br>
<br>반환값 : 성공 시 0, 실패 시 -1 반환
<br>클라이언트에 의해서 connect 함수가 호출되면 다음 둘 중 한가지 상황이 되어야 함수가 반환된다(함수 호출이 완료된다).<br>
<br>서버에 의해 연결 요청이 접수됨.
<br>네트워크 단절 등 오류 상황이 발생해서 연결 요청이 중단되었다.
<br>여기서 주의할 사실은 위에서 말하는 연결 요청의 접수는 서버의 accept 호출을 의미하는 것이 아니라는 점이다. 이는 클라이언트의 연결 요청 정보가 서버의 연결 요청 대기 큐에 등록된 상황을 의미하는 것이다. 때문에 connect 함수가 반환했더라도 당장에 서비스가 이뤄지지 않을 수도 있음을 기억해야 한다.<br>

클라이언트 소켓이 서버 소켓과 다른 점은 <a data-href="bind" href="resource\network\소켓-프로그래밍(리눅스)\bind.html" class="internal-link" target="_self" rel="noopener nofollow">bind</a>를 통해 주소 정보를 등록하지 않는다는 점이다.<br>
하지만 네트워크를 통해 데이터를 송수신하려면 클라이언트 소켓에도 주소 정보가 등록이 되어야 한다.<br>
클라이언트 소켓의 주소 정보 등록은 connect가 호출될 때 커널에 의해 자동으로 이루어진다.<br>
IP는 컴퓨터(호스트)에 할당된 IP로, PORT는 비어있는 포트 중 하나를 임의로 선택해 할당한다.
<br><br>참고자료<br><a href=".?query=tag:참고도서\윤성우의_열혈_TCP_IP_소켓_프로그래밍" class="tag" target="_blank" rel="noopener nofollow">#참고도서/윤성우의_열혈_TCP_IP_소켓_프로그래밍</a><br>]]></description><link>resource\network\소켓-프로그래밍(리눅스)\connect.html</link><guid isPermaLink="false">resource/Network/소켓 프로그래밍(리눅스)/connect.md</guid><pubDate>Sat, 22 Mar 2025 07:31:46 GMT</pubDate></item><item><title><![CDATA[Half-close]]></title><description><![CDATA[<a class="tag" href="?query=tag:network" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#network</a> <a class="tag" href="?query=tag:language/c" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#language/c</a> <a class="tag" href="?query=tag:socket_programming" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#socket_programming</a> <a class="tag" href="?query=tag:linux" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#linux</a> <a class="tag" href="?query=tag:참고도서/윤성우의_열혈_TCP_IP_소켓_프로그래밍" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/윤성우의_열혈_TCP_IP_소켓_프로그래밍</a> 
 <br><br><a href=".?query=tag:network" class="tag" target="_blank" rel="noopener nofollow">#network</a> <a href=".?query=tag:language\c" class="tag" target="_blank" rel="noopener nofollow">#language/c</a> <a href=".?query=tag:socket_programming" class="tag" target="_blank" rel="noopener nofollow">#socket_programming</a> <a href=".?query=tag:linux" class="tag" target="_blank" rel="noopener nofollow">#linux</a><br>스트림의 절반만 닫는다<br><br>파일 및 표준 입출력, 그리고 현재 다루고 있는 네트워크 프로그램밍에서 흔히 등장하는 개념인 스트림은 물의 흐름을 의미한다. 그런데 물의 흐름은 한쪽 방향으로만 형성된다. 마찬가지로 소켓의 스트림 역시 한쪽 방향으로만 데이터의 이동이 가능하기 때문에 양방향 통신을 위해서는 다음 그림에서 보이듯이 두 개의 스트림이 필요하다.<br><img alt="소켓을 기반으로 생성되는 두 개의 스트림.png" src="lib\media\소켓을-기반으로-생성되는-두-개의-스트림.png" style="width: 600px; max-width: 100%;"><br>한 소켓의 입력 스트림은 맞은편  소켓의 출력 스트림으로 이어진다.<br>이번 문서에서 다루는 Half-close는 한 번에 두 개의 스트림을 모두 끊어버리는 게 아닌, 이 중 하나의 스트림만 끊는 것이다. 리눅스의 close()는 두 스트림을 동시에 끊어버리기 때문에 <a data-href="shutdown" href="resource\network\소켓-프로그래밍(리눅스)\shutdown.html" class="internal-link" target="_self" rel="noopener nofollow">shutdown</a>이라는 별도의 시스템콜을 사용해야 한다.<br><br><br><img alt="일방적 연결종료.png" src="lib\media\일방적-연결종료.png"><br>close를 사용하면 출력 버퍼에 남아있는 데이터는 모두 전송하지만, 입력 버퍼를 사용해서는 어떠한 데이터도 수신할 수 없게 된다. 따라서 일방적으로 close를 사용하면 상대가 송신한 데이터를 수신하지 못하고 연결을 종료하는 경우가 발생하게 된다.<br>이와 같은 문제의 해결을 위해 사용되는 방법은 보통 다음과 같다.<br>
<br>특정 문자를 통신 종료의 신호로 삼아 해당 문자를 수신하기 전에는 close하지 않는다.
<br>충분히 여유를 종료한다.
<br>하지만 위의 방법은 근본적으로 문제를 해결할 수 없다. 1의 경우 텍스트만을 주고 받는 간단한 케이스의 경우 텍스트를 작성하는 사람이 해당 규칙을 인지하고 있으므로 어느정도 유효하지만, 파일 송수신을 하는 경우 해당 파일에 종료를 의미하는 문자가 포함되어 있을 수 있어 중간에 연결이 갑작스럽게 끊길 수 있다.<br>두번째 방법의 경우, 어느 정도의 시간만큼 대기해야 안전하게 종료할 수 있는지에 대한 기준이 불명확하다.<br>이러한 문제의 해결을 위해서 데이터의 송수신에 사용되는 데이터의 일부만 종료(Half-close)하는 방법이 제공되는 것이다.<br><br>다음과 같은 상황이 있다고 가정하자.<br>

<br>서버는 클라이언트에게 파일을 보낸다.
<br>클라이언트는 파일을 '완전히' 수신한 후 서버 측으로 스스로의 상태를 보고하는 메시지를 보낸다.

<br>여기서 문제가 되는 것은 2번 과정이다. 만약에 1번 과정만 존재했다면 서버 측에서 파일 전송을 완료하고 close를 사용하면 문제가 해결되었을 것이다. 앞서 언급했지만 close를 사용해도 출력버퍼에 남아있는 데이터의 전송은 보장받기 때문이다. 클라이언트는 소켓이 닫히면서 eof를 전송받아 연결이 종료되었음을 인지할 수 있다.<br>하지만 1번 과정 이후의 프로세스가 남아 있으므로, 서버 측은 close를 사용할 수 없다. 클라이언트 측은 eof를 받지 못하므로 파일의 전송이 끝났다는 것을 인지하지 못해 2번 과정으로 넘어갈 수 없다.<br>그러면 다음과 같은 해결책을 제안할 수 있다.<br>서버와 클라이언트 사이에 파일의 끝을 의미하는 문자를 하나 약속한다.<br>하지만 상술했듯이, 위 방법은 유효하지 않은 방법이다. 약속으로 정해진 문자와 일치하는 데이터가 파일 중간에 존재할 수도 있기 때문이다. 근본적으로 이러한 문제를 해결하는 half-close를 해결할 수 있는 방법은 half-close를 사용하는 것이다.<br>위의 예시로 언급한 상황의 경우, 아래와 같은 프로세스로 문제를 해결할 수 있다.<br>

<br>서버는 클라이언트에게 파일을 보낸다.
<br>파일을 완전히 보내면 서버 측에서 <a data-href="shutdown" href="resource\network\소켓-프로그래밍(리눅스)\shutdown.html" class="internal-link" target="_self" rel="noopener nofollow">shutdown</a>을 사용해 출력 버퍼만을 닫는다.
<br>서버 측의 출력 버퍼는 클라이언트의 입력 버퍼와 연결되어 있으므로 클라이언트는 eof를 수신한다.
<br>클라이언트는 파일 전송이 끝났음을 인지하고 서버에게 스스로의 상태를 보고하는 메시지를 보낸다.
<br>서버 측은 출력 버퍼만 닫혀있고 입력 버퍼는 열려있으므로 클라이언트의 보고를 수신할 수 있다.
<br>모든 프로세스가 종료되었으므로 연결을 완전히 끊는다.

<br>위 예시 말고도 소켓의 일부만 닫는다는 개념은 다양한 상황에 유용하게 사용할 수 있다.<br><img alt="파일 전송 데이터 흐름도.png" src="lib\media\파일-전송-데이터-흐름도.png"><br><br><a data-href="shutdown" href="resource\network\소켓-프로그래밍(리눅스)\shutdown.html" class="internal-link" target="_self" rel="noopener nofollow">shutdown</a>에 SHUT_RDWT를 전달하면 입력 버퍼와 출력 버퍼를 모두 닫을 수 있다.<br>
이 점은 close를 사용했을 때와 동일하므로, SHUT_RDWT 인자로 shutdown을 사용하면 close를 대체할 수 있다는 오해를 부를 수 있다는 생각이 든다.<br>shutdown은 소켓의 버퍼만을 닫을 뿐, 리소스는 해제하지 않는다. 따라서 shutdown으로 입출력 버퍼를 모두 닫아도 버퍼와 관계없는 동작은 실행이 가능하다.<br>반면에 close는 소켓의 리소스를 완전히 해제하므로 close 이후에는 어떠한 조작도 할 수 없다.<br>그러므로 shutdown으로 입출력 버퍼를 모두 닫았더라도 차후 close를 사용해 소켓의 리소스를 완전히 해제해주어야 한다.<br><br>참고자료<br><a href=".?query=tag:참고도서\윤성우의_열혈_TCP_IP_소켓_프로그래밍" class="tag" target="_blank" rel="noopener nofollow">#참고도서/윤성우의_열혈_TCP_IP_소켓_프로그래밍</a><br>]]></description><link>resource\network\소켓-프로그래밍(리눅스)\half-close.html</link><guid isPermaLink="false">resource/Network/소켓 프로그래밍(리눅스)/Half-close.md</guid><pubDate>Sat, 22 Mar 2025 07:31:46 GMT</pubDate><enclosure url="lib\media\소켓을-기반으로-생성되는-두-개의-스트림.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;lib\media\소켓을-기반으로-생성되는-두-개의-스트림.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[htons]]></title><description><![CDATA[<a class="tag" href="?query=tag:network" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#network</a> <a class="tag" href="?query=tag:language/c" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#language/c</a> <a class="tag" href="?query=tag:socket_programming" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#socket_programming</a> <a class="tag" href="?query=tag:linux" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#linux</a> <a class="tag" href="?query=tag:참고도서/윤성우의_열혈_TCP_IP_소켓_프로그래밍" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/윤성우의_열혈_TCP_IP_소켓_프로그래밍</a> 
 <br><br><a href=".?query=tag:network" class="tag" target="_blank" rel="noopener nofollow">#network</a> <a href=".?query=tag:language\c" class="tag" target="_blank" rel="noopener nofollow">#language/c</a> <a href=".?query=tag:socket_programming" class="tag" target="_blank" rel="noopener nofollow">#socket_programming</a> <a href=".?query=tag:linux" class="tag" target="_blank" rel="noopener nofollow">#linux</a><br>htons는 <a data-tooltip-position="top" aria-label="호스트 바이트 순서" data-href="호스트 바이트 순서" href="resource\network\소켓-프로그래밍(리눅스)\호스트-바이트-순서.html" class="internal-link" target="_self" rel="noopener nofollow">host network byte order</a> to <a data-tooltip-position="top" aria-label="네트워크 바이트 순서" data-href="네트워크 바이트 순서" href="resource\network\소켓-프로그래밍(리눅스)\네트워크-바이트-순서.html" class="internal-link" target="_self" rel="noopener nofollow">network byte order</a> - short variable의 약자이다.<br><br><a data-href="sockaddr_in" href="resource\network\소켓-프로그래밍(리눅스)\sockaddr_in.html" class="internal-link" target="_self" rel="noopener nofollow">sockaddr_in</a>에 port 번호를 저장할 때에는 <a data-href="네트워크 바이트 순서" href="resource\network\소켓-프로그래밍(리눅스)\네트워크-바이트-순서.html" class="internal-link" target="_self" rel="noopener nofollow">네트워크 바이트 순서</a>로 저장해야 한다. htons는 port 번호의 바이트 순서 변환(Endian Conversions)을 지원한다.<br>
/* 기능 : port 번호의 바이트 순서 변환
*  매개인자 : port 번호
*  반환값 : 빅 엔디안으로 변환된 port 번호
*/
unsigned short htons(unsigned short);

<br>htons의 형제격으로 아래의 함수들이 있다. 자주 쓰이지는 않지만 참고하자.<br>
// network byte order to host byte order - short variable
unsigned short ntohs(unsigned short);
// host byte order to network byte order - long variable
unsigned long  htonl(unsigned long);
// network byte order to host byte order - long variable
unsigned long  ntohl(unsigned long);

<br><br>참고자료<br><a href=".?query=tag:참고도서\윤성우의_열혈_TCP_IP_소켓_프로그래밍" class="tag" target="_blank" rel="noopener nofollow">#참고도서/윤성우의_열혈_TCP_IP_소켓_프로그래밍</a><br>]]></description><link>resource\network\소켓-프로그래밍(리눅스)\htons.html</link><guid isPermaLink="false">resource/Network/소켓 프로그래밍(리눅스)/htons.md</guid><pubDate>Sat, 22 Mar 2025 07:31:46 GMT</pubDate></item><item><title><![CDATA[INADDR_ANY]]></title><description><![CDATA[<a class="tag" href="?query=tag:network" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#network</a> <a class="tag" href="?query=tag:language/c" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#language/c</a> <a class="tag" href="?query=tag:socket_programming" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#socket_programming</a> <a class="tag" href="?query=tag:linux" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#linux</a> <a class="tag" href="?query=tag:참고도서/윤성우의_열혈_TCP_IP_소켓_프로그래밍" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/윤성우의_열혈_TCP_IP_소켓_프로그래밍</a> 
 <br><br><a href=".?query=tag:network" class="tag" target="_blank" rel="noopener nofollow">#network</a> <a href=".?query=tag:language\c" class="tag" target="_blank" rel="noopener nofollow">#language/c</a> <a href=".?query=tag:socket_programming" class="tag" target="_blank" rel="noopener nofollow">#socket_programming</a> <a href=".?query=tag:linux" class="tag" target="_blank" rel="noopener nofollow">#linux</a><br>자기 자신의 IP 주소를 나타내는 상수<br><br>자기 자신의 IP 주소를 나타내는 32비트 정수형 상수이다. 서버 프로그램의 경우 이 상수를 사용하면 별도의 IP 주소를 입력하지 않아도 되서 편리하다. 주로 <a data-tooltip-position="top" aria-label="htons > ^84391e" data-href="htons#^84391e" href="resource\network\소켓-프로그래밍(리눅스)\htons.html#^84391e" class="internal-link" target="_self" rel="noopener nofollow">htonl</a>을 사용하여 <a data-href="네트워크 바이트 순서" href="resource\network\소켓-프로그래밍(리눅스)\네트워크-바이트-순서.html" class="internal-link" target="_self" rel="noopener nofollow">네트워크 바이트 순서</a>로 변환한 후 <a data-tooltip-position="top" aria-label="sockaddr_in > ^d7a9de" data-href="sockaddr_in#^d7a9de" href="resource\network\소켓-프로그래밍(리눅스)\sockaddr_in.html#^d7a9de" class="internal-link" target="_self" rel="noopener nofollow">sockaddr_in의 sin_addr</a>로 전달하는데 사용한다.<br>#include &lt;netinet/in.h&gt;

struct sockaddr_in addr;
addr.sin_addr.s_addr = htonl(INADDR_ANY);
<br>

서버 소켓은 생성 시 자신이 속한 컴퓨터의 IP 주소로 초기화가 이뤄져야 한다.<br>
즉 초기화할 IP 주소가 뻔하므로 시스템 콜이 이러한 작업을 처리하면 편리할 것 같다는 생각이 든다.<br>
그러나 IP 주소는 컴퓨터에 장착되어 있는 NIC(랜카드)의 개수만큼 부여가 가능하므로 하나의 컴퓨터가 복수의 IP를 보유할 수 있다. 그러므로 이러한 경우에는 서버 소켓이라 할지라도 어느 IP 주소로 들어오는(어느 NIC로 들어오는) 데이터를 수신할지 결정해야 한다.<br>
때문에 서버 소켓의 초기화 과정에서 IP 주소 정보를 요구하는 것이다. 반면 NIC가 하나뿐인 컴퓨터라면 주저 없이 INADDR_ANY를 사용해서 초기화하는 것이 편리하다.
<br><br>참고자료<br><a href=".?query=tag:참고도서\윤성우의_열혈_TCP_IP_소켓_프로그래밍" class="tag" target="_blank" rel="noopener nofollow">#참고도서/윤성우의_열혈_TCP_IP_소켓_프로그래밍</a><br>]]></description><link>resource\network\소켓-프로그래밍(리눅스)\inaddr_any.html</link><guid isPermaLink="false">resource/Network/소켓 프로그래밍(리눅스)/INADDR_ANY.md</guid><pubDate>Sat, 22 Mar 2025 07:31:46 GMT</pubDate></item><item><title><![CDATA[inet_addr]]></title><description><![CDATA[<a class="tag" href="?query=tag:network" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#network</a> <a class="tag" href="?query=tag:language/c" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#language/c</a> <a class="tag" href="?query=tag:socket_programming" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#socket_programming</a> <a class="tag" href="?query=tag:linux" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#linux</a> <a class="tag" href="?query=tag:참고도서/윤성우의_열혈_TCP_IP_소켓_프로그래밍" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/윤성우의_열혈_TCP_IP_소켓_프로그래밍</a> 
 <br><br><a href=".?query=tag:network" class="tag" target="_blank" rel="noopener nofollow">#network</a> <a href=".?query=tag:language\c" class="tag" target="_blank" rel="noopener nofollow">#language/c</a> <a href=".?query=tag:socket_programming" class="tag" target="_blank" rel="noopener nofollow">#socket_programming</a> <a href=".?query=tag:linux" class="tag" target="_blank" rel="noopener nofollow">#linux</a><br>inet_addr<br><br><a data-tooltip-position="top" aria-label="sockaddr_in > ^d7a9de" data-href="sockaddr_in#^d7a9de" href="resource\network\소켓-프로그래밍(리눅스)\sockaddr_in.html#^d7a9de" class="internal-link" target="_self" rel="noopener nofollow">sockaddr_in</a>의 멤버 sin_addr에는 32비트 정수형으로 ip 주소를 저장해야 한다.  inet_addr은 aaa.bbb.ccc.ddd 꼴의 문자열로 표현된 ip 주소를  32비트 정수로 변환하는 번거로운 작업을 수행한다. 또한, 변환 과정에서 <a data-href="네트워크 바이트 순서" href="resource\network\소켓-프로그래밍(리눅스)\네트워크-바이트-순서.html" class="internal-link" target="_self" rel="noopener nofollow">네트워크 바이트 순서</a>로의 변환도 동시에 지원한다.<br>#include &lt;arpa/inet.h&gt;

/* 입력값 : 문자열로 표현된 ip 주소
*  반환값 : 성공 시 빅엔디안으로 변환된 32비트 정수 값, 실해 시 INADDR_NONE 반환
*/
in_addr_t inet_addr(const char *string);
<br>비슷한 기능을 수행하는 함수로 <a data-href="inet_aton" href="resource\network\소켓-프로그래밍(리눅스)\inet_aton.html" class="internal-link" target="_self" rel="noopener nofollow">inet_aton</a>이 있다.<br>
만약 네트워크 바이트 순서로 정렬된 32비트 정수로부터 문자열 형태로 표현된 ip 주소를 얻고 싶다면 <a data-href="inet_ntoa" href="resource\network\소켓-프로그래밍(리눅스)\inet_ntoa.html" class="internal-link" target="_self" rel="noopener nofollow">inet_ntoa</a>를 사용하면 된다.<br><br>참고자료<br><a href=".?query=tag:참고도서\윤성우의_열혈_TCP_IP_소켓_프로그래밍" class="tag" target="_blank" rel="noopener nofollow">#참고도서/윤성우의_열혈_TCP_IP_소켓_프로그래밍</a><br>]]></description><link>resource\network\소켓-프로그래밍(리눅스)\inet_addr.html</link><guid isPermaLink="false">resource/Network/소켓 프로그래밍(리눅스)/inet_addr.md</guid><pubDate>Sat, 22 Mar 2025 07:31:46 GMT</pubDate></item><item><title><![CDATA[inet_aton]]></title><description><![CDATA[<a class="tag" href="?query=tag:network" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#network</a> <a class="tag" href="?query=tag:language/c" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#language/c</a> <a class="tag" href="?query=tag:socket_programming" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#socket_programming</a> <a class="tag" href="?query=tag:linux" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#linux</a> <a class="tag" href="?query=tag:참고도서/윤성우의_열혈_TCP_IP_소켓_프로그래밍" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/윤성우의_열혈_TCP_IP_소켓_프로그래밍</a> 
 <br><br><a href=".?query=tag:network" class="tag" target="_blank" rel="noopener nofollow">#network</a> <a href=".?query=tag:language\c" class="tag" target="_blank" rel="noopener nofollow">#language/c</a> <a href=".?query=tag:socket_programming" class="tag" target="_blank" rel="noopener nofollow">#socket_programming</a> <a href=".?query=tag:linux" class="tag" target="_blank" rel="noopener nofollow">#linux</a><br>inet_aton<br><br>inet_aton은 <a data-href="inet_addr" href="resource\network\소켓-프로그래밍(리눅스)\inet_addr.html" class="internal-link" target="_self" rel="noopener nofollow">inet_addr</a>과 동일한 기능을 수행한다. 차이점은 변환된 ip 주소를 반환하지 않고 두 번째 인자로 전달받은 in_addr 구조체에 저장한다는 점이다.<br>#include &lt;arpa/inet.h&gt;

// 성공 시 1(true) 실패 시 0(false) 반환
int inet_aton(const char *string, struct in_addr *addr);
<br><br>참고자료<br><a href=".?query=tag:참고도서\윤성우의_열혈_TCP_IP_소켓_프로그래밍" class="tag" target="_blank" rel="noopener nofollow">#참고도서/윤성우의_열혈_TCP_IP_소켓_프로그래밍</a><br>]]></description><link>resource\network\소켓-프로그래밍(리눅스)\inet_aton.html</link><guid isPermaLink="false">resource/Network/소켓 프로그래밍(리눅스)/inet_aton.md</guid><pubDate>Sat, 22 Mar 2025 07:31:46 GMT</pubDate></item><item><title><![CDATA[inet_ntoa]]></title><description><![CDATA[<a class="tag" href="?query=tag:network" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#network</a> <a class="tag" href="?query=tag:language/c" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#language/c</a> <a class="tag" href="?query=tag:socket_programming" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#socket_programming</a> <a class="tag" href="?query=tag:linux" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#linux</a> <a class="tag" href="?query=tag:참고도서/윤성우의_열혈_TCP_IP_소켓_프로그래밍" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/윤성우의_열혈_TCP_IP_소켓_프로그래밍</a> 
 <br><br><a href=".?query=tag:network" class="tag" target="_blank" rel="noopener nofollow">#network</a> <a href=".?query=tag:language\c" class="tag" target="_blank" rel="noopener nofollow">#language/c</a> <a href=".?query=tag:socket_programming" class="tag" target="_blank" rel="noopener nofollow">#socket_programming</a> <a href=".?query=tag:linux" class="tag" target="_blank" rel="noopener nofollow">#linux</a><br>inet_ntoa<br><br><a data-href="inet_addr" href="resource\network\소켓-프로그래밍(리눅스)\inet_addr.html" class="internal-link" target="_self" rel="noopener nofollow">inet_addr</a>, <a data-href="inet_aton" href="resource\network\소켓-프로그래밍(리눅스)\inet_aton.html" class="internal-link" target="_self" rel="noopener nofollow">inet_aton</a>의 반대 기능을 하는 함수이다.<br>
네트워크 바이트 순서로 정렬된 32비트 정수를 입력하면 문자열 형태로 표현된 ip 주소를 반환한다.<br>#include &lt;arpa/inet.h&gt;

//성공 시 변환된 문자열의 주소 값, 실패 시 -1 반환
char *inet_ntoa(struct in_addr adr);
<br>참고로 inet_ntoa가 반환하는 메모리 주소는 inet_ntoa에 내부적으로 할당된 메모리 공간이다. inet_ntoa가 재호출되면 이전에 할당한 메모리 주소를 지우고 새로운 메모리 주소를 할당하기 때문에, inet_ntoa가 반환한 문자열 정보를 다른 문자열 공간에 복사해 두는 것이 좋다.<br><br>참고자료<br><a href=".?query=tag:참고도서\윤성우의_열혈_TCP_IP_소켓_프로그래밍" class="tag" target="_blank" rel="noopener nofollow">#참고도서/윤성우의_열혈_TCP_IP_소켓_프로그래밍</a><br>]]></description><link>resource\network\소켓-프로그래밍(리눅스)\inet_ntoa.html</link><guid isPermaLink="false">resource/Network/소켓 프로그래밍(리눅스)/inet_ntoa.md</guid><pubDate>Sat, 22 Mar 2025 07:31:46 GMT</pubDate></item><item><title><![CDATA[listen]]></title><description><![CDATA[<a class="tag" href="?query=tag:network" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#network</a> <a class="tag" href="?query=tag:language/c" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#language/c</a> <a class="tag" href="?query=tag:socket_programming" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#socket_programming</a> <a class="tag" href="?query=tag:linux/system_call" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#linux/system_call</a> <a class="tag" href="?query=tag:참고도서/윤성우의_열혈_TCP_IP_소켓_프로그래밍" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/윤성우의_열혈_TCP_IP_소켓_프로그래밍</a> 
 <br><br><a href=".?query=tag:network" class="tag" target="_blank" rel="noopener nofollow">#network</a> <a href=".?query=tag:language\c" class="tag" target="_blank" rel="noopener nofollow">#language/c</a> <a href=".?query=tag:socket_programming" class="tag" target="_blank" rel="noopener nofollow">#socket_programming</a> <a href=".?query=tag:linux\system_call" class="tag" target="_blank" rel="noopener nofollow">#linux/system_call</a><br>연결 요청 대기 상태로의 진입<br><br><a data-href="bind" href="resource\network\소켓-프로그래밍(리눅스)\bind.html" class="internal-link" target="_self" rel="noopener nofollow">bind</a>의 함수호출을 통해서 소켓에 주소까지 할당했다면, 이번에는 listen의 호출을 통해서 연결 요청 대기 상태로 진입해야 한다. 그리고 listen 함수가 호출되어야 클라이언트가 연결요청을 할 수 있는 상태가 된다. 즉, listen 함수가 호출되어야 클라이언트는 연결요청을 위해서 connect 함수를 호출할 수 있다(이전에 connect 함수가 호출되면 오류 발생).<br>#include &lt;sys/socket.h&gt;

int listen(int sock, int backlog);
<br>
<br>sock : 연결 요청 대기 상태에 두고자 하는 소켓의 파일 디스크립터 전달, 이 함수의 인자로 전달된 디스크립터의 소켓이 서버 소켓(리스닝 소켓)이 된다.
<br>backlog : 연결 요청 대기 큐(Queue)의 크기 정보 전달. 5가 전달되면 큐의 크기가 5가 되어 클라이언트의 연결 요청을  5개까지 대기시킬 수 있다.
<br>반환값: 정상적으로 처리에 성공하면 0, 아니면 -1을 반환한다.
<br><br><img alt="연결 요청 대기 큐.png" src="lib\media\연결-요청-대기-큐.png"><br>그렇다면 연결 요청 대기 상태란 무엇인가?<br>
클라이언트의 연결 요청도 인터넷을 통해서 흘러 들어오는 일종의 데이터 전송이기 때문에, 이것을 받아들이려면 소켓이 하나 있어야 한다. 서버 소켓의 역할이 이것이다. 서버 소켓은 클라이언트의 연결 요청을 전담하여 수신한다.<br>
listen 함수가 호출되면 서버 소켓이 만들어지고, listen 함수의 두 번째 인자로 전달되는 정수의 크기에 해당하는 대기실이 만들어진다. 이 대기실을 가리켜 연결요청 대기 큐라 한다. 서버 소켓은 클라이언트로부터 받은 연결 요청을 연결요청 대기 큐에 저장한다.<br>
서버 소켓과 연결 요청 대기 큐가 완전히 준비되어서 클라이언트의 연결요청을 받아들일 수 있는 상태를 가리켜 연결 요청 대기 상태라 한다.<br>
listen의 두 번째 인자로 전달될 적절한 인자의 값은 서버의 성격마다 다르지만, 웹 서버와 같이 잦은 연결 요청을 받는 서버의 경우에는 최소 15 이상을 전달해야 한다. 참고로 연결 요청 대기 큐의 크기는 어디까지나 실험적 결과에 의존해서 결정하게 된다.
<br><br>참고자료<br><a href=".?query=tag:참고도서\윤성우의_열혈_TCP_IP_소켓_프로그래밍" class="tag" target="_blank" rel="noopener nofollow">#참고도서/윤성우의_열혈_TCP_IP_소켓_프로그래밍</a><br>]]></description><link>resource\network\소켓-프로그래밍(리눅스)\listen.html</link><guid isPermaLink="false">resource/Network/소켓 프로그래밍(리눅스)/listen.md</guid><pubDate>Sat, 22 Mar 2025 07:31:47 GMT</pubDate><enclosure url="lib\media\연결-요청-대기-큐.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;lib\media\연결-요청-대기-큐.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[select]]></title><description><![CDATA[<a class="tag" href="?query=tag:network" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#network</a> <a class="tag" href="?query=tag:language/c" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#language/c</a> <a class="tag" href="?query=tag:socket_programming" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#socket_programming</a> <a class="tag" href="?query=tag:linux/system_call" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#linux/system_call</a> <a class="tag" href="?query=tag:참고도서/윤성우의_열혈_TCP_IP_소켓_프로그래밍" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/윤성우의_열혈_TCP_IP_소켓_프로그래밍</a> 
 <br><br><a href=".?query=tag:network" class="tag" target="_blank" rel="noopener nofollow">#network</a> <a href=".?query=tag:language\c" class="tag" target="_blank" rel="noopener nofollow">#language/c</a> <a href=".?query=tag:socket_programming" class="tag" target="_blank" rel="noopener nofollow">#socket_programming</a> <a href=".?query=tag:linux\system_call" class="tag" target="_blank" rel="noopener nofollow">#linux/system_call</a><br>select<br><br>select 함수를 이용하는 것이 멀티 플렉싱 서버의 구현에 있어서 가장 대표적인 방법이다. 그리고 윈도우에서도 이와 동일한 이름으로 동일한 기능을 제공하는 함수가 있기 때문에 이식성에 있어서도 좋은 점수를 줄 수 있다.<br><br>select 함수를 사용하면 하나의 구조체에 여러 개의 파일 디스크립터를 모아놓고 동시에 이들을 관찰할 수 있다. 이때 관찰할 수 있는 항목은 다음과 같다. <br>
<br>수신한 데이터를 가지고 있는 소켓이 존재하는가?
<br>블로킹되지 않고 데이터의 전송이 가능한 소켓은 무엇인가?
<br>예외상황이 발생한 소켓은 무엇인가?
<br>

관찰항목 각각을 가리켜 이벤트라 하고, 관찰 항목에 속하는 상황이 발생했을 때, '이벤트(event)가 발생했다'라고 표현한다. 이는 매우 일반적인 표현이기 때문에 여러분도 이 표현에 익숙해질 필요가 있다.
<br><br>select 함수의 호출 순서를 전체적으로 정리하면 아래와 같다.<br>
<br>파일 디스크립터의 설정
<br>검사의 범위 설정
<br>타임아웃의 설정
<br>select 함수의 호출
<br>호출 결과 확인
<br><br>select 함수를 사용하면 여러 개의 파일 디스크립터를 동시에 관찰할 수 있다.<br>
파일 디스크립터의 관찰은 소켓의 관찰로 해석할 수 있다.<br>그렇다면 먼저 관찰하고자 하는 파일 디스크립터를 모아야 한다.<br>
모을 때도, 관찰항목(수신, 전송, 예외)에 따라 모아야 한다.<br>
즉, 바로 <a data-tooltip-position="top" aria-label="select > ^9974c7" data-href="select#^9974c7" href="resource\network\소켓-프로그래밍(리눅스)\select.html#^9974c7" class="internal-link" target="_self" rel="noopener nofollow">위</a>에서 언급한 세가지 관찰 항목별로 구분해서 세 묶음으로 모아야 한다.<br>파일 디스크립터를 세 묶음으로 모을 때 사용되는 것이 fd_set형 변수이다. 즉, 다음 그림에서 보이듯이 0과 1로 표현되는, 비트 단위로 이뤄진 배열이라고 생각한다.<br>fd의 값에 대응되는 위치의 비트가 0으로 설정되어 있으면 해당 파일 디스크립터가 관찰 대상이 아님을 의미한다.<br>
반대로, 비트가 1로 설정되어 있으면 해당 파일 디스크립터가 관찰 대상임을 의미한다.<br>fd_set형 변수의 조작은 비트 단위로 이뤄지기 때문에 직접 값을 등록하는 일은 매우 번거롭다. 따라서 일반적으로 아래의 매크로 함수를 통해서 조작한다.<br>
#include &lt;sys/select.h&gt;

// 주소형으로 전달된 fd_set형 변수의 모든 비트를 0으로 초기화한다.
FD_ZERO(fd_set *fdset)

// 매개변수 fdset으로 전달된 주소의 변수에
// 매개변수 fd로 전달된 파일 디스크립터 정보를 등록한다.
FD_SET(int fd, fd_set *fdset)

// 매개변수 fdset으로 전달된 주소의 변수에서 매개변수 fd로 전달된
// 파일 디스크립터 정보를 삭제한다.
FD_CLR(int fd, fd_set *fdset)

// 매개변수 fdset으로 전달된 주소의 변수에 매개변수 fd로 전달된
// 파일 디스크립터 정보가 있으면 양수를 반환한다.
FD_ISSET(int fd, fd_set *fdset)

<br><br>이 단락의 내용을 이해하려면 먼저 select 함수의 형태를 알아야 한다.<br>
#include &lt;sys/select.h&gt;
#include &lt;sys/time.h&gt;

int select(int maxfd, fd_set *readset, fd_set *writeset, \
	fd_set *exceptset, const struct timeval *timeout);

<br>
<br>maxfd : 검사 대상이 되는 파일 디스크립터의 수
<br>readset : fd_set형 변수에 '수신된 데이터의 존재 여부'에 관심 있는 파일 디스크립터 정보를 모두 등록해서 그 변수의 주소 값을 전달한다.
<br>writeset : fd_set형 변수에 '블로킹 없는 데이터 전송의 기능여부'에 관심 있는 파일 디스크립터 정보를 모두 등록해서 그 변수의 주소 값을 전달한다.
<br>exceptset : fd_set형 변수에 '예외 상황의 발생여부'에 관심이 있는 파일 디스크립터 정보를 모두 등록해서 그 변수의 주소 값을 전달한다.
<br>timeout : select 함수 호출 이후에 무한정 블로킹 상태에 빠지지 않도록 타임아웃(time-out)을 설정하기 위한 인자를 전달한다.
<br>반환 값 : 오류 발생 시에는 -1이 반환되고, 타임 아웃에 의한 반환 시에는 0이 반환된다. 그리고 반환 대상으로 등록된 파일 디스크립터에 해당 관심에 관련된 변화가 발생하면 0보다 큰 값이 반환되는데, 이 값은 변화가 발생한 파일 디스크립터의 수를 의미한다.
<br>위 내용에 좀 더 살을 덧붙여보자.<br>먼저, 검사 대상이 되는 파일 디스크립터의 수를 첫번째 인자로 넘겨야 한다. 결론부터 말하자면, 여태까지 생성된 서버 소켓, 클라이언트 소켓을 가리키는 fd 중 가장 큰 값 + 1을 전달하면 된다. fd는 일반적으로 생성될 때마다 값이 1씩 늘어나기 때문에, 소켓을 하나 생성할 때마다 select에 전달할 값을 갱신하게 될 것이다.<br>select는 0 ~ 첫번째 인자 - 1의 범위에 존재하는 fd에 event가 발생했는지 감시한다. 만약 event가 발생한 fd가 2 ~ 4번째 인자로 받은 fd_set에 포함되어 있으면 해당하는 fd_set에 그 내용을 기록한다.<br>select가 호출되었을 때 아무런 이벤트가 발생하지 않았으면, 이벤트가 발생할 때까지 감시 대상을 지속적으로 감시하면서 block 상태에 머무른다.<br>
만약 select가 무한정 대기 상태에 빠지는 것을 원치 않는다면, 5번째 인자로 전달되는 timeval 구조체 변수를 전달하여 얼마만큼의 시간이 지나면 block에서 빠져나오도록 설정할 수 있다. 이러한 시간 제한을 걸기를 원하지 않는다면 NULL을 전달하면 된다.<br>
struct timeval
{
	long tv_sec; // seconds
	long tv_usec; // microseconds
}

<br><br>select 함수는 변화가 생긴 fd의 수를 반환하므로, 양수를 반환한다면 감시 대상에 변화가 생겼다고 해석할 수 있다. 그러면 불특정 다수의 감시 대상 중 정확히 어떤 fd에 변화가 생겼는지 확인할 수 있을까?<br>select 함수호출이 완료되고 나면, select 함수의 인자로 전달된 fd_set형 변수에는 변화가 생긴다. 모든 비트가 0으로 변경되지만, 변화가 발생한 파일 디스크립터에 해당하는 비트만 그대로 1로 남아있게 된다. 때문에 여전히 1로 남아있는 위치의 파일 디스크립터에서 변화가 발생했다고 판단할 수 있다.<br><br>// select.c

#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;
#include &lt;sys/time.h&gt;
#include &lt;sys/select.h&gt;

#define BUF_SIZE 30

int main(int argc, char *argv[])
{
	fd_set reads, temps;
	int result, str_len;
	char buf[BUF_SIZE];
	struct timeval timeout;

	FD_ZERO(&amp;reads);
	// 0(표준 입력)을 감시 대상으로 삼는다.
	FD_SET(0, &amp;reads); // 0 is standard input(console)

	// timeout은 이 위치가 아닌 아래의 while 문 안에서 실행해야 한다.
	// select 함수가 호출될 때마다 5번째 인자로 전달된 timeval 구조체의 멤버들이 0으로 초기화되어버리기 때문이다.
	/*
	timeout.tv_sec = 5;
	timeout.tv_usec = 5000;
	*/

	while (1)
	{
		// select에 temps를 전달하는 이유는 select가 전달받은 fd_set의 비트를 변경하기 때문이다.
		temps = reads;
		// select가 블록하는 시간 5초
		timeout.tv_sec = 5;
		timeout.tv_usec = 0;
		result = select(1, &amp;temps, 0, 0, &amp;timeout);
		if (result == -1)
		{
			puts("select() error!");
			break ;
		}
		else if (result == 0)
		{
			puts("Time-out!");
		}
		else
		{
			// 변화가 발생한 fd가 0인가?
			if (FD_ISSET(0, &amp;temps))
			{
				// 표준 입력으로 입력받은 내용을 표준 출력으로 보낸다.
				str_len = read(0, buf, BUF_SIZE);
				buf[str_len] = 0;
				printf("message from console : %s", buf);
			}
		}
	}
	return (0);
}

<br>
// echo_selectserv.c

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;unistd.h&gt;
#include &lt;arpa/inet.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;sys/time.h&gt;
#include &lt;sys/select.h&gt;

#define BUF_SIZE 100

void error_handling(char *buf);

int main(int argc, char *argv[])
{
	// 필요한 변수 설정
	int serv_sock, clnt_sock;
	struct sockaddr_in serv_adr, clnt_adr;
	struct timeval timeout;
	fd_set reads, cpy_reads;

	socklen_t adr_sz;
	int fd_max, str_len, fd_num;
	char buf[BUF_SIZE];

	// 필요한 port 번호를 전달받지 못했다 -&gt; error
	if (argc !=2)
	{
		printf("Usage : %s &lt;port&gt;\n", argv[0]);
		exit(1);
	}

	// 서버 소켓의 주소 정보 설정
	serv_sock = socket(PF_INET, SOCK_STREAM, 0);
	memset(&amp;serv_adr, 0, sizeof(serv_adr));
	serv_adr.sin_family = AF_INET;
	serv_adr.sin_addr.s_addr(htonl(INADDR_ANY));
	serv_adr.sin_port = htons(atoi(argv[1]));

	if (bind(serv_sock, (struct sockaddr *)&amp;serv_adr, sizeof(serv_adr)) == -1)
		error_handling("bind() error");
	if (listen(serv_sock, 5) == -1)
		error_handling("listen() error");

	// 서버 소켓을 fd_set에 저장
	FD_ZERO(&amp;reads);
	FD_SET(serv_sock, &amp;reads);
	fd_max = serv_sock;

	while (1)
	{
		// select의 블록 시간 == 5초
		cpy_reads = reads;
		timeout.tv_sec = 5;
		timeout.tv_usec = 5000;

		if ((fd_num = select(fd_max + 1, &amp;cpy_reads, 0, 0, &amp;timeout)) == -1)
			break ;
		if (fd_num == 0)
			continue ;

		for (int i = 0; i &lt; fd_max + 1; i++)
		{
			// 이벤트가 발생한 fd인가?
			if (FD_ISSET(i, &amp;cpy_reads))
			{
				// 이벤트가 발생한 소켓이 서버 소켓일 때
				// 서버 소켓에 전달되는 클라이언트의 연결 요청도 엄연한 입력이다.
				// 서버 소켓에 read 이벤트가 발생하면 클라이언트로부터 접속 요청을 받았다고 간주할 수 있다.
				// 그러므로 새로운 클라이언트와 연결하는 절차를 진행한다.
				if (i == serv_sock) // connection request!
				{
					adr_sz = sizeof(clnt_adr);
					clnt_sock = accept(serv_sock, (struct sockaddr *)&amp;clnt_adr, &amp;adr_sz);
					FD_SET(clnt_sock, &amp;reads);
					if (fd_max &lt; clnt_sock)
						fd_max = clnt_sock;
					printf("connected client: %d \n", clnt_sock);
				}
				else // read message!
				{
					str_len = read(i, buf, BUF_SIZE);
					// 소켓이 close될때 연결된 소켓이 있으면 해당 소켓에 eof를 전달한다.
					// eof를 받으면 read는 0을 반환한다.
					// 따라서 read가 0을 반환하면 접속이 끊겼다고 간주한다.
					if (str_len == 0) // close request!
					{
						FD_CLR(i, &amp;reads);
						close(i);
						printf("closed client: %d \n", i);
					}
					// 메세지를 수신받은 경우 echo한다.
					else
					{
						write(i, buf, str_len); // echo!
					}
				}
			}
		}
	}
	close(serv_sock);
	return (0);
}

void error_handling(char *buf)
{
	fputs(buf, stderr);
	fputc('\n', stderr);
	exit(1);
}

<br><br>참고자료<br><a href=".?query=tag:참고도서\윤성우의_열혈_TCP_IP_소켓_프로그래밍" class="tag" target="_blank" rel="noopener nofollow">#참고도서/윤성우의_열혈_TCP_IP_소켓_프로그래밍</a> <br>]]></description><link>resource\network\소켓-프로그래밍(리눅스)\select.html</link><guid isPermaLink="false">resource/Network/소켓 프로그래밍(리눅스)/select.md</guid><pubDate>Sat, 22 Mar 2025 07:31:47 GMT</pubDate></item><item><title><![CDATA[shutdown]]></title><description><![CDATA[<a class="tag" href="?query=tag:network" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#network</a> <a class="tag" href="?query=tag:language/c" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#language/c</a> <a class="tag" href="?query=tag:socket_programming" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#socket_programming</a> <a class="tag" href="?query=tag:linux/system_call" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#linux/system_call</a> <a class="tag" href="?query=tag:참고도서/윤성우의_열혈_TCP_IP_소켓_프로그래밍" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/윤성우의_열혈_TCP_IP_소켓_프로그래밍</a> 
 <br><br><a href=".?query=tag:network" class="tag" target="_blank" rel="noopener nofollow">#network</a> <a href=".?query=tag:language\c" class="tag" target="_blank" rel="noopener nofollow">#language/c</a> <a href=".?query=tag:socket_programming" class="tag" target="_blank" rel="noopener nofollow">#socket_programming</a> <a href=".?query=tag:linux\system_call" class="tag" target="_blank" rel="noopener nofollow">#linux/system_call</a><br>shutdown<br><br>shutdown은 <a data-href="Half-close" href="resource\network\소켓-프로그래밍(리눅스)\half-close.html" class="internal-link" target="_self" rel="noopener nofollow">Half-close</a>를 구현하기 위하여 사용되는 시스템 콜로, 소켓이 보유하고 있는 두 개의 스트림 중 한 스트림만을 끊는 기능을 가지고 있다.<br>#include &lt;sys/socket.h&gt;

/*
* sock : 종료할 소켓의 파일 디스크립터 전달
* howto : 종료방법에 대한 정보 전달
* 반환값 : 성공 시 0, 실패 시 -1 반환
*/
int shutdown(int sock, int howto); 
<br><br>shutdown의 두 번째 인자로 SHUT_RD가 전달되면 입력 스트림이 종료되어 더 이상 데이터를 수신할 수 없는 상태가 된다. 데이터가 입력버퍼에 전달되더라도 그냥 지워져 버릴 뿐만 아니라 입력 관련 함수의 호출도 더 이상 허용되지 않는다.<br>SHUT_WR이 두 번째 인자로 전달되면 출력 스트림이 종료되어 더 이상의 데이터 전송이 불가능해진다. 단, 출력 버퍼에 전송되지 못한 상태로 남아있는 데이터가 존재하면 해당 데이터는 목적지로 전송된다.<br>SHUT_RDWR을 사용하면 입출력 스트림이 모두 종료된다.<br><br>참고자료<br><a href=".?query=tag:참고도서\윤성우의_열혈_TCP_IP_소켓_프로그래밍" class="tag" target="_blank" rel="noopener nofollow">#참고도서/윤성우의_열혈_TCP_IP_소켓_프로그래밍</a><br>]]></description><link>resource\network\소켓-프로그래밍(리눅스)\shutdown.html</link><guid isPermaLink="false">resource/Network/소켓 프로그래밍(리눅스)/shutdown.md</guid><pubDate>Sat, 22 Mar 2025 07:31:47 GMT</pubDate></item><item><title><![CDATA[sockaddr_in]]></title><description><![CDATA[<a class="tag" href="?query=tag:network" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#network</a> <a class="tag" href="?query=tag:language/c" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#language/c</a> <a class="tag" href="?query=tag:socket_programming" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#socket_programming</a> <a class="tag" href="?query=tag:linux" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#linux</a> <a class="tag" href="?query=tag:참고도서/윤성우의_열혈_TCP_IP_소켓_프로그래밍" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/윤성우의_열혈_TCP_IP_소켓_프로그래밍</a> 
 <br><br><a href=".?query=tag:network" class="tag" target="_blank" rel="noopener nofollow">#network</a> <a href=".?query=tag:language\c" class="tag" target="_blank" rel="noopener nofollow">#language/c</a> <a href=".?query=tag:socket_programming" class="tag" target="_blank" rel="noopener nofollow">#socket_programming</a> <a href=".?query=tag:linux" class="tag" target="_blank" rel="noopener nofollow">#linux</a><br>주소 정보의 표현<br><br>sockaddr_in  구조체는 아래의 형태를 가지며, <a data-href="bind" href="resource\network\소켓-프로그래밍(리눅스)\bind.html" class="internal-link" target="_self" rel="noopener nofollow">bind</a>에 주소 정보를 전달하는 용도로 사용된다.<br>struct sockaddr_in
{
	sa_family_t    sin_family;
	uint16_t       sin_port;
	struct in_addr sin_addr;
	char           sin_zero[8];
}
<br>struct in_addr
{
	in_addr_t      s_addr; //32비트 IPv4 인터넷 주소
}
<br><br>uint8_t와 같은 POSIX(Portable Operating System Interpace) 자료형을 사용하는 이유는 어떠한 경우에도 고정된 바이트 자료형임을 보장받기 위해서이다.<br><br>sin_family에는 아래의 표를 참조하여 프로토콜이 사용하는 주소체계를 저장한다.<br><br><br>16비트 port 번호를 저장한다. 단, <a data-href="htons" href="resource\network\소켓-프로그래밍(리눅스)\htons.html" class="internal-link" target="_self" rel="noopener nofollow">htons</a>를 사용하여 <a data-href="네트워크 바이트 순서" href="resource\network\소켓-프로그래밍(리눅스)\네트워크-바이트-순서.html" class="internal-link" target="_self" rel="noopener nofollow">네트워크 바이트 순서</a>로 저장해야 한다.<br><br>32비트 IP주소 정보를 저장한다. 이 역시 <a data-href="inet_addr" href="resource\network\소켓-프로그래밍(리눅스)\inet_addr.html" class="internal-link" target="_self" rel="noopener nofollow">inet_addr</a> 또는 <a data-href="inet_aton" href="resource\network\소켓-프로그래밍(리눅스)\inet_aton.html" class="internal-link" target="_self" rel="noopener nofollow">inet_aton</a>을 사용하여 <a data-href="네트워크 바이트 순서" href="resource\network\소켓-프로그래밍(리눅스)\네트워크-바이트-순서.html" class="internal-link" target="_self" rel="noopener nofollow">네트워크 바이트 순서</a>로 저장해야 한다. 이 멤버를 정확히 파악하기 위해서는 구조체 in_addr도 함께 살펴봐야 한다. 그런데 구조체 in_addr의 유일한 멤버가 unit32_t로 선언되어 있으니, 간단히 32비트 정수자료형으로 인식해도 괜찮다.<br><br>아무런 의미를 가지지 않는다. 단순히 구조체 sockaddr_in의 크기를 구조체 sockaddr와 일치시키기 위해 삽입된 멤버이다. 그러나 반드시 0으로 채워야 한다. 만약에 0으로 채우지 않으면 원하는 결과를 얻지 못한다. sockaddr에 대해서는 후술한다.<br><br>sockaddr은 아래와 같은 형태의 구조체이다.<br>
struct sockaddr
{
	sa_family_t sin_family;  // 주소체계(Address Family)
	// 주소정보. IP 주소와 PORT 번호를 형식에 맞게 입력하고 남은 공간은 0으로 채워야한다.
	char        sa_data[14];
}

<br>sockaddr_in은 <a data-href="bind" href="resource\network\소켓-프로그래밍(리눅스)\bind.html" class="internal-link" target="_self" rel="noopener nofollow">bind</a>에 전달하기 위한 구조체라고 설명하였지만, 본래 bind()에는 sockaddr 구조체를 전달하여야 한다. 그러나 sockaddr은 sa_data에 IP 주소와 port 번호를 bit 단위로 조작하여 넣어야 하기 때문에 매우 불편하다. 따라서 sockaddr_in에서 sa_data를 sin_port(포트), sin_addr(IP 주소), sin_zero(남은 공간을 0으로 채움)의 형태로 나누어 입력할 수 있도록 고친 후, 형변환을 사용하여 아래와 같이 sockaddr 구조체의 주소형으로 변환하여 넘긴다. sockaddr_in에 sin_zero가 들어가는 이유도 구조체의 크기가 동일해야 주소를 통해 접근했을 때 sockaddr과 동일한 효과를 얻을 수 있기 때문이다.<br>if (bind(serv_scok, (struct sockaddr *)&amp;serv_addr, sizeof(serv_addr)) == -1)
	error_handling("bind() error");
<br><br>참고자료<br><a href=".?query=tag:참고도서\윤성우의_열혈_TCP_IP_소켓_프로그래밍" class="tag" target="_blank" rel="noopener nofollow">#참고도서/윤성우의_열혈_TCP_IP_소켓_프로그래밍</a><br>]]></description><link>resource\network\소켓-프로그래밍(리눅스)\sockaddr_in.html</link><guid isPermaLink="false">resource/Network/소켓 프로그래밍(리눅스)/sockaddr_in.md</guid><pubDate>Sat, 22 Mar 2025 07:31:47 GMT</pubDate></item><item><title><![CDATA[socket]]></title><description><![CDATA[<a class="tag" href="?query=tag:network" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#network</a> <a class="tag" href="?query=tag:language/c" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#language/c</a> <a class="tag" href="?query=tag:socket_programming" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#socket_programming</a> <a class="tag" href="?query=tag:linux/system_call" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#linux/system_call</a> <a class="tag" href="?query=tag:참고도서/윤성우의_열혈_TCP_IP_소켓_프로그래밍" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/윤성우의_열혈_TCP_IP_소켓_프로그래밍</a> 
 <br><br><a href=".?query=tag:network" class="tag" target="_blank" rel="noopener nofollow">#network</a> <a href=".?query=tag:language\c" class="tag" target="_blank" rel="noopener nofollow">#language/c</a> <a href=".?query=tag:socket_programming" class="tag" target="_blank" rel="noopener nofollow">#socket_programming</a> <a href=".?query=tag:linux\system_call" class="tag" target="_blank" rel="noopener nofollow">#linux/system_call</a><br>socket<br><br>#include &lt;sys/socket.h&gt;

int socket(int domain, int type, int protocol);
<br>
<br>domain : 소켓이 사용할 <a data-tooltip-position="top" aria-label="프로토콜 체계" data-href="프로토콜 체계" href="resource\network\소켓-프로그래밍(리눅스)\프로토콜-체계.html" class="internal-link" target="_self" rel="noopener nofollow">프로토콜 체계(protocol family)</a> 정보 전달
<br>type : <a data-tooltip-position="top" aria-label="소켓의 타입" data-href="소켓의 타입" href="resource\network\소켓-프로그래밍(리눅스)\소켓의-타입.html" class="internal-link" target="_self" rel="noopener nofollow">소켓의 데이터 전송방식</a>에 대한 정보 전달
<br>protocol : 두 컴퓨터 간 통신에 사용되는 프로토콜 정보 전달
<br>
<br>반환값 : 성공 시 생성된 소켓을 가리키는 파일 디스크립터, 실패 시 -1 반환
<br>3개의 인자에 어떠한 값을 전달하냐의 따라 소켓의 특성이 달라진다.<br><br><br>참고자료<br><a href=".?query=tag:참고도서\윤성우의_열혈_TCP_IP_소켓_프로그래밍" class="tag" target="_blank" rel="noopener nofollow">#참고도서/윤성우의_열혈_TCP_IP_소켓_프로그래밍</a><br>]]></description><link>resource\network\소켓-프로그래밍(리눅스)\socket.html</link><guid isPermaLink="false">resource/Network/소켓 프로그래밍(리눅스)/socket.md</guid><pubDate>Sat, 22 Mar 2025 07:31:47 GMT</pubDate></item><item><title><![CDATA[TCP 소켓]]></title><description><![CDATA[<a class="tag" href="?query=tag:network" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#network</a> <a class="tag" href="?query=tag:language/c" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#language/c</a> <a class="tag" href="?query=tag:socket_programming" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#socket_programming</a> <a class="tag" href="?query=tag:linux" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#linux</a> <a class="tag" href="?query=tag:참고도서/윤성우의_열혈_TCP_IP_소켓_프로그래밍" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/윤성우의_열혈_TCP_IP_소켓_프로그래밍</a> 
 <br><br><a href=".?query=tag:network" class="tag" target="_blank" rel="noopener nofollow">#network</a> <a href=".?query=tag:language\c" class="tag" target="_blank" rel="noopener nofollow">#language/c</a> <a href=".?query=tag:socket_programming" class="tag" target="_blank" rel="noopener nofollow">#socket_programming</a> <a href=".?query=tag:linux" class="tag" target="_blank" rel="noopener nofollow">#linux</a><br>tcp socket<br><br><br><a data-href="소켓의 타입" href="resource\network\소켓-프로그래밍(리눅스)\소켓의-타입.html" class="internal-link" target="_self" rel="noopener nofollow">소켓의 타입</a>에서 설명하였듯이, <a data-href="TCP" href="resource\network\기초-개념\tcp.html" class="internal-link" target="_self" rel="noopener nofollow">TCP</a> 소켓에는 데이터의 경계라는 개념이 존재하지 않는다. 데이터의 경계가 존재하지 않는다는 것은 TCP 프로토콜이 자의적으로 다음의 동작을 수행할 수 있음을 의미한다.<br>
<br>한 번에 대량의 데이터를 write() 할 때, 여러 개의 작은 단위로 쪼개 나누어 송신할 수 있다.
<br>여러 번 소량의 데이터를 write() 할 때, 하나의 큰 단위로 합쳐 한 번에 송신할 수 있다.
<br>이것이 가능한 이유는 read(), write()가 호출되는 즉시 데이터가 송수신되는 것이 아니기 때문이다. TCP 소켓에는 입출력 버퍼가 존재하며, 소켓을 대상으로 read(), write()가 호출되면 아래와 같이 동작한다.<br>
<br>write()의 경우 : 데이터를 출력 버퍼로 전달 후, 상황에 맞게 적절히(한번에 보내든 나눠서 보내든) 데이터를 상대방의 입력 버퍼로 전송한다.
<br>read()의 경우 : 입력 버퍼에 저장된 데이터를 읽어들인다.
<br><img alt="tcp 소켓의 입출력 버퍼.png" src="lib\media\tcp-소켓의-입출력-버퍼.png"><br>또한 TCP 소켓의 입출력 버퍼는 아래와 같은 특성을 지닌다.<br>
<br>입출력 버퍼는 TCP 소켓 각각에 대해 별도로 존재한다.
<br>입출력 버퍼는 소켓 생성 시 자동으로 생성한다.
<br>소켓을 닫아도 출력 버퍼에 남아있는 데이터는 계속해서 전송이 이뤄진다.
<br>소켓을 닫으면 입력 버퍼에 남아있는 데이터는 소멸되어 버린다.
<br><br><br>입출력 버퍼의 존재를 알았으니, 다음과 같은 상황을 가정해볼 수 있다.<br>클라이언트의 입력 버퍼의 크기보다 큰 데이터를 서버 측에서 전송하였다.<br>만약 위와 같은 상황이 발생한다면 버퍼 크기의 초과분만큼 데이터가 손실되는 문제가 발생할 것이다.<br>
이러한 문제를 해결하기 위해 TCP에는 슬라이딩 윈도우 프로토콜이 존재한다. 이 프로토콜은 데이터의 흐름을 제어하여 데이터가 버퍼의 크기를 초과하여 송신되지 않도록 한다.<br>슬라이딩 윈도우 프로토콜에 입각하여, 양측 소켓은 아래와 같이 현재 버퍼에 얼마만큼의 데이터를 더 저장할 수 있는 지에 관한 메세지를 주고받으며 송수신한다.<br>
<br>
소켓 A : 50 byte까지는 수용할 수 있다.

<br>
소켓 B : 확인

<br>
소켓 A : 방금 20 byte를 비워 70 byte까지는 수용할 수 있다.

<br>
소켓 B : 확인

<br>
write()가 반환되는 시점<br>
write()가 반환되는 시점은 상대 호스트로 데이터의 전송이 완료되는 시점이 아닌, 전송할 데이터가 출력버퍼로 이동이 완료되는 시점이다. 그러나 TCP의 경우는 출력 버퍼로 이동된 데이터의 전송을 보장하기 때문에 write()의 데이터 전송이 완료되어야 반환이 된다.라고 표현한다.<br>
따라서 이 표현에 대한 정확한 이해가 필요하다.
<br><br>Three-way handshaking은 tcp 소켓이 상대 소켓과 연결하는 방식을 의미하며, 연결 설정 과정에서 총 3번의 메세지를 주고 받아 이러한 이름이 붙었다.<br><img alt="tcp 소켓의 연결 설정 과정.png" src="lib\media\tcp-소켓의-연결-설정-과정.png" style="width: 300px; max-width: 100%;"><br>소켓은 전 이중(Full-duplex) 방식으로 동작하므로 양방향으로 데이터를 주고받을 수 있다. 따라서 데이터 송수신에 앞서 준비과정이 필요하다. 먼저 연결 요청을 하는 호스트 A가 호스트 B에게 다음 메세지를 전달하고 있다.<br>[SYN] SEQ: 1000, ACK: -<br>SYN은 Synchroniztion의 줄임 말로써, 데이터 송수신에 앞서 전송되는 동기화 메세지라는 의미를 담고 있다.<br>
SEQ는 Sequence의 줄임말이다. 소켓 프로그래밍과 TCP/IP 프로토콜에서 SEQ는 데이터 패킷의 순서를 나타내는 데 사용된다.<br>
ACK는 Acknowledgment의 줄임 말로써, 데이터를 성공적으로 수신했음을 송신자에게 알리는 메세지를 의미한다. 위 메세지는 처음으로 보내는 메세지이므로 ACK 메세지가 비어있는 상태이다.<br>
SYN과 ACK를 묶어 보내는 형식의 메세지를 SYN+ACK 메세지라고 한다.<br>위 예시의 세 메세지는 각각 다음과 같은 의미를 가지고 있다.<br>[SYN] SEQ: 1000, ACK: -<br>내가 지금 보내는 패킷에 1000이라는 번호를 부여한다.<br>[SYN+ACK] SEQ: 2000, ACK: 1001<br>내가 지금 보내는 패킷에 2000이라는 번호를 부여한다. 응답 시 다음 번엔 1001번(방금 보낸 패킷에 1을 더한 값) 패킷을 송신하라<br>[SYN] SEQ: 1001, ACK: 2001<br>내가 지금 보내는 패킷에 1001이라는 번호를 부여한다. 응답 시 다음 번엔 2001번(방금 보낸 패킷에 1을 더한 값) 패킷을 송신하라<br>위의 메세지를 성공적으로 주고받으면 소켓들은 성공적으로 연결 설정을 마치게 된다.<br>
패킷에 번호를 부여하고, 이 번호 정보를 상대방에게 알리는 이유는 데이터의 손실을 막기 위해서이다.<br><br><img alt="tcp 소켓의 데이터 송신 오류.png" src="lib\media\tcp-소켓의-데이터-송신-오류.png" style="width: 600px; max-width: 100%;"><br>데이터를 송수신할 시에는 Three-way handshaking 때와 마찬가지로 SEQ과 ACK를 주고받는다. 단, SYN+ACK의 형태로 보내지는 않으며, 송신하는 측은 SEQ, 수신하는 측은 ACK를 보낸다.<br>응답하는 쪽은 다음의 공식을 기준으로 ACK 메시지를 전송한다.<br>ACK 번호 -&gt; SEQ 번호 + 전송받은 바이트 크기 + 1<br>마지막에 1을 더한 이유는 Three-way handshaking에도 보았듯이, 다음 번에 전달할 SEQ의 번호를 알리기 위함이다.<br>데이터의 손실에 대한 재전송을 위해서, TCP 소켓은 ACK 응답을 요구하는 패킷 전송 시에 타이머를 동작시킨다. 그리고 해당 타이머가 Time-out! 되었을 때 패킷을 재전송한다.<br><br>연결을 끊을 때, 한 쪽이 일방적으로 연결을 끊어버리면, 상대방이 데이터가 남아있을 때 문제가 되기 때문에 상호간에 연결 종료의 합의과정을 거치게 된다. 이를  Four-way handshaking이라 한다.<br><img alt="tcp 소켓의 연결종료 과정.png" src="lib\media\tcp-소켓의-연결종료-과정.png" style="width: 600px; max-width: 100%;"><br>소켓 A가 종료 메시지를 소켓 B에게 전달하고, 소켓 B는 해당 메시지의 수신을 소켓 A에게 알린다.<br>
그리고 이어서 소켓 B가 종료 메시지를 소켓 A에게 전달하고, 소켓 A는 해당 메시지의 수신을 소켓 B에게 알리며 종료의 과정을 마치게 된다. 위 그림에서 패킷 안에 삽입되어 있는 FIN은 종료를 알리는 메시지를 뜻한다.<br>
즉, 상호간에 FIN 메시지를 한번씩 주고 받고서 연결이 종료되는데, 이 과정이 네 단계에 걸쳐서 진행되기 때문에 이를 가리켜 Four-way handshaking이라고 한다.<br><br>참고자료<br><a href=".?query=tag:참고도서\윤성우의_열혈_TCP_IP_소켓_프로그래밍" class="tag" target="_blank" rel="noopener nofollow">#참고도서/윤성우의_열혈_TCP_IP_소켓_프로그래밍</a><br>]]></description><link>resource\network\소켓-프로그래밍(리눅스)\tcp-소켓.html</link><guid isPermaLink="false">resource/Network/소켓 프로그래밍(리눅스)/TCP 소켓.md</guid><pubDate>Sat, 22 Mar 2025 07:31:47 GMT</pubDate><enclosure url="lib\media\tcp-소켓의-입출력-버퍼.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;lib\media\tcp-소켓의-입출력-버퍼.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[단방향 암호화]]></title><description><![CDATA[<a class="tag" href="?query=tag:security" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#security</a> <a class="tag" href="?query=tag:cryptograph" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#cryptograph</a> <a class="tag" href="?query=tag:참고링크/생활코딩" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고링크/생활코딩</a> 
 <br><br><a href=".?query=tag:security" class="tag" target="_blank" rel="noopener nofollow">#security</a> <a href=".?query=tag:cryptograph" class="tag" target="_blank" rel="noopener nofollow">#cryptograph</a><br>hash<br><br><br>단방향 암호화는 암호화만 지원하고 복호화는 지원하지 않는 암호화 방식을 일컫는다.<br>
다른 말로 hash(다지다)라고도 하는데, 무언가를 다지면 원형을 알아볼 수 없는 것을 암호화에 빗댄 것이다.<br>단방향 암호화는 무결성 특성을 극대화하는 방식이다.<br>복호화를 할 수 없는데 어떻게 원본과 암호화된 내용이 동일함을 확인할 수 있을까? 다음과 같은 상황을 가정해보자.<br>A라는 사람이 B라는 사람에게 특정한 파일을 전송받기로 했다. A는 B를 신뢰하지만, 전송되는 과정에서 파일이 조작되었을 가능성을 배제할 수 없다.<br>따라서 B는 A에게 파일을 전송하는 동시에 파일에 hash 알고리즘을 적용하여 얻은 문자열을 같이 보낸다. md5를 이용하여 hash 했다고 가정하자.<br>A는 파일을 전송받은 후, 해당 파일을 md5로 hash한 뒤 그 값을 B가 보낸 문자열과 비교한다. 문자열이 같다면 B가 보낸 파일과 A가 보낸 파일이 동일함을 알 수 있다.<br>hash는 또한 다음과 같은 목적을 위해 사용된다.<br>
<br>무결성 검증 Verifying the integrity of messages and files
<br>전자 서명을 하는 경우 Signature generation and verification
<br>파일 또는 데이터의 신뢰할만한 식별자가 필요할 때 File or data identifier
<br>사용자의 비밀번호를 서버에 안전하게 저장할 때 Password verification
<br>암호 화폐 채굴 시 작업 증명을 위하여 Proof-of-work
<br><br>참고자료<br><a href=".?query=tag:참고링크\생활코딩" class="tag" target="_blank" rel="noopener nofollow">#참고링크/생활코딩</a> <br>]]></description><link>resource\security\암호학\단방향-암호화.html</link><guid isPermaLink="false">resource/Security/암호학/단방향 암호화.md</guid><pubDate>Thu, 13 Feb 2025 02:35:03 GMT</pubDate></item><item><title><![CDATA[암호학]]></title><description><![CDATA[<a class="tag" href="?query=tag:security" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#security</a> <a class="tag" href="?query=tag:cryptograph" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#cryptograph</a> <a class="tag" href="?query=tag:참고링크/생활코딩" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고링크/생활코딩</a> 
 <br><br><a href=".?query=tag:security" class="tag" target="_blank" rel="noopener nofollow">#security</a> <a href=".?query=tag:cryptograph" class="tag" target="_blank" rel="noopener nofollow">#cryptograph</a><br>cryptograph<br><br><br>감추어진 정보가 조작되지 않고 허가된 사람에게만 공개되도록 하는 방법을 암호학 cryptograph라고 한다.<br>암호는 다음의 3가지 원칙을 지켜야 한다.<br>
<br>기밀성 Confidentiality : 암호화된 내용이 무엇인지 알 수 없어야 한다.
<br>무결성 Integrity : 암호화된 내용이 원본과 동일함을 보장하여야 한다.
<br>인증 authentication : 권한이 있는 자만 암호화된 내용에 접근할 수 있어야 한다.
<br>보호되고 있지 않은 데이터를 평문 plain text라고 한다.<br>
암호화된 내용을 암호문 cipher text라고 한다.<br>평문을 암호화하여 암호문으로 만들기 위하여 암호 알고리즘 cryptography algorithm을 사용한다.<br>평문을 암호문으로 만드는 과정을 암호화 encryption이라고 한다.<br>
암호문을 평문으로 만드는 과정을 복호화 decryption이라고 한다.<br>예전에는 암호 알고리즘 자체를 비밀로 하여 기밀성을 지켰지만, 요즘에는 트렌드가 바뀌어 암호 알고리즘을 공개하여 성능을 검증받는다. 대신 암호 알고리즘이 비밀 정보를 사용하도록 하고, 이 비밀 정보가 없으면 복호화 할 수 없도록 한다. 이 비밀 정보를 키 key라고 한다.<br>암호화에는 <a data-href="양방향 암호화" href="resource\security\암호학\양방향-암호화.html" class="internal-link" target="_self" rel="noopener nofollow">양방향 암호화</a> 방식과 <a data-href="단방향 암호화" href="resource\security\암호학\단방향-암호화.html" class="internal-link" target="_self" rel="noopener nofollow">단방향 암호화</a> 방식이 있다.<br>양방향 암호화 방식은 암호화와 복호화를 모두 지원한다.<br>
양방향 암호화 방식은 대칭키 방식과 비대칭키 방식으로 나뉜다.<br>
대칭키 방식은 암호화와 복호화에 모두 같은 키를 사용한다. 대표적으로 AES, Twofish 같은 알고리즘이 있다.<br>
비대칭키 방식은 암호화와 복호화에 각자 다른 키를 사용한다. 대표적으로 RSA 같은 것들이 있다.<br>반면에 단방향 암호화 방식은 암호화만 지원한다.<br>
대표적으로 md5, sha 같은 것들이 있다.<br><br>참고자료<br><a href=".?query=tag:참고링크\생활코딩" class="tag" target="_blank" rel="noopener nofollow">#참고링크/생활코딩</a><br>]]></description><link>resource\security\암호학\암호학.html</link><guid isPermaLink="false">resource/Security/암호학/암호학.md</guid><pubDate>Mon, 20 Jan 2025 08:13:08 GMT</pubDate></item><item><title><![CDATA[양방향 암호화]]></title><description><![CDATA[<a class="tag" href="?query=tag:security" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#security</a> <a class="tag" href="?query=tag:cryptograph" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#cryptograph</a> <a class="tag" href="?query=tag:참고링크/생활코딩" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고링크/생활코딩</a> 
 <br><br><a href=".?query=tag:security" class="tag" target="_blank" rel="noopener nofollow">#security</a> <a href=".?query=tag:cryptograph" class="tag" target="_blank" rel="noopener nofollow">#cryptograph</a> <br>__<br><br><br><br>대칭키 방식이란 하나의 키를 암호화와 복호화 모두에 사용하는 방식을 말한다.<br><br>B가 A에게 특정 자료를 암호화하여 전송한다고 가정할 때, A가 자료를 복호화하여 열람하기 위해서는 암호화된 자료와 키를 둘 다 보내야만 한다. 만약에 전송 중 자료를 갈취당한다면 키 또한 같이 갈취당했을 것이므로 아주 쉽게 보안이 뚫리게 된다.<br>그러므로 대칭키 방식은 자료를 암호화하여 자기 혼자만 볼 때는 유효할 수 있으나, 타인과 그 자료를 공유해야 하는 상황에서는 부적합하다.<br><br><br><br>비대칭키 또는 공개키 방식은 2개의 키를 사용하여 암호화와 복호화에 사용되는 키를 달리 하는 방식을 말한다. 이때 이 2개의 키를 각각 공개키 public key와 비공개키 private key라고 한다.<br>만약 암호화에 공개키를 사용했다면 복호화를 위해서는 무조건 비공개키를 사용해야만 한다.<br>
반대로 암호화에 비공개키를 사용했다면 복호화를 위해 무조건 공개키를 사용해야만 한다.<br>위의 절에서 대칭키 방식의 한계를 보았다. 비대칭키 방식은 다음과 같이 이러한 한계를 극복할 수 있다.<br>마찬가지로 B가 A에게 어떠한 자료를 공유하고자 하는 가정을 가정해보자. 쉬운 이해를 위해, 전송되는 모든 것은 크래커에게 갈취당한다는 극단적인 가정을 추가해보자. 다음과 같은 절차를 거친다.<br>
<br>A가 공개키와 비공개키를 만든다. 그리고 공개키만 B에게 보낸다.
<br>B는 공개키를 이용하여 자료를 암호화하여 A에게 보낸다.
<br>크래커는 공개키와 공개키로 암호화된 자료를 갈취하였다.
<br>하지만 A는 비공개키는 자신만이 보유하고 어딘가로 전송한 적이 없으므로 자료는 A, B, 크래커 중 A만이 복호화할 수 있다. 
<br><br><br>전자서명이란 어떠한 내용이 특정인에 의하여 작성되었다는 것을 보증하기 위한 보안적 장치이다. 비대칭키를 사용하면 다음과 같이 전자서명을 구현할 수 있다.<br>
<br>A가 자신의 공개 키를 웹상에 공개한다. 그리고 B에게 자료를 보낼 때 원문과 원문을 비공개키로 암호화한 암호문을 같이 보낸다. 이때, 암호문이 전자서명에 해당한다.
<br>이때 크래커는 B에게 혼선을 주고자 조작된 자료와 위조한 전자서명을 B에게 보낸다. B는 받은 2개의 자료 중 어느 것이 A가 보낸 것인지 검증해야 한다.
<br>웹상에 공개된 공개 키로 두 개의 전자 서명을 모두 복호화한다. 이때, 원문과 복호화한 전자서명이 일치하는 자료가 A가 보낸 것이라고 B는 확신할 수 있다.
<br><br>참고자료<br><a href=".?query=tag:참고링크\생활코딩" class="tag" target="_blank" rel="noopener nofollow">#참고링크/생활코딩</a> <br>]]></description><link>resource\security\암호학\양방향-암호화.html</link><guid isPermaLink="false">resource/Security/암호학/양방향 암호화.md</guid><pubDate>Mon, 20 Jan 2025 08:53:27 GMT</pubDate></item><item><title><![CDATA[그리드]]></title><description><![CDATA[<a class="tag" href="?query=tag:language/css" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#language/css</a> <a class="tag" href="?query=tag:web" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#web</a> <a class="tag" href="?query=tag:참고링크/생활코딩" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고링크/생활코딩</a> 
 <br><br><a href=".?query=tag:language\css" class="tag" target="_blank" rel="noopener nofollow">#language/css</a> <a href=".?query=tag:web" class="tag" target="_blank" rel="noopener nofollow">#web</a><br>grid<br><br><br>참고자료<br><a href=".?query=tag:참고링크\생활코딩" class="tag" target="_blank" rel="noopener nofollow">#참고링크/생활코딩</a> <br>]]></description><link>resource\web\css\그리드.html</link><guid isPermaLink="false">resource/Web/CSS/그리드.md</guid><pubDate>Wed, 22 Jan 2025 02:43:16 GMT</pubDate></item><item><title><![CDATA[CSS 선택자]]></title><description><![CDATA[<a class="tag" href="?query=tag:web" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#web</a> <a class="tag" href="?query=tag:language/css" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#language/css</a> <a class="tag" href="?query=tag:참고도서/모던_웹_디자인을_위한_HTML5_CSS3_입문" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/모던_웹_디자인을_위한_HTML5_CSS3_입문</a> 
 <br><br><a href=".?query=tag:web" class="tag" target="_blank" rel="noopener nofollow">#web</a> <a href=".?query=tag:language\css" class="tag" target="_blank" rel="noopener nofollow">#language/css</a><br>**<br><br><br>CSS3 선택자는 특정한 HTML 태그를 선택할 때 사용하는 기능이다.<br>선택자를 사용해 특정한 HTML 태그를 선택하면 해당 태그에 우리가 원하는 스타일 또는 기능을 적용할 수 있다.<br>선택자는 다음과 같이 사용된다.<br>
h1{color:read;}

<br>위 예제에서 각각의 요소는<br>
<br>h1 : 선택자
<br>color : 스타일 속성
<br>red : 스타일 값
<br>에 해당한다.<br>이러한 코드를 CSS 블록이라고 부르며 style 태그 내부에 입력해 사용한다. 이때 style 태그 내부에 입력되는 코드를 스타일시트라고 부른다.<br>
&lt;!--stylesheet.html--&gt;

&lt;!DOCTYPE html&gt;
&lt;html&gt;
	&lt;head&gt;
		&lt;title&gt;CSS Selector Basic&lt;/title&gt;
		&lt;style&gt;
			h1 {
				color: red;
				background-color: orange;
			}
		&lt;/style&gt;
	&lt;/head&gt;
	&lt;body&gt;
		&lt;h1&gt;CSS Selector Basic&lt;/h1&gt;
	&lt;/body&gt;
&lt;/html&gt;

<br>CSS3 선택자는 다양한 종류로 이루어져 있다.<br><br><br>HTML 문서 안의 모든 태그를 선택할 때는 전체 선택자를 사용한다.<br><br>전체 선택자는 모든 웹 페이지에서 빠지지 않고 사용하는 선택자이다.<br>
아래의 코드는 전체 선택자를 사용해 모든 태그의 color 속성에 red 키워드를 적용한다.<br>
&lt;!--select_all.html--&gt;

&lt;!DOCTYPE html&gt;
&lt;html&gt;
	&lt;head&gt;
		&lt;title&gt;CSS3 Selector Basic Page&lt;/title&gt;
		&lt;style&gt;
			/* 모든 태그의 color 속성에 red 키워드를 적용한다. */
			* { color: red; }
		&lt;/style&gt;
	&lt;/head&gt;
	&lt;body&gt;
		&lt;h1&gt;Lorem ipsum&lt;/h1&gt;
		&lt;p&gt;lorem ipsum dolor sit amet, consectetur adipscing elit.&lt;/p&gt;
	&lt;/body&gt;
&lt;/html&gt;

<br><br>일반적으로 전체 선택자를 사용하면 body 태그 내부에 있는 요소에만 스타일 속성이 적용되는 것처럼 보인다. 그래서 전체 선택자가 body 태그 내부에 있는 모든 요소를 선택한다고 생각하기 쉽다.<br>하지만 전체 선택자를 사용하면 html 태그를 포함해 head 태그, title 태그, style 태그까지 선택한다. 다음 예제는 jQuery를 사용해 전체 선택자로 선택된 모든 태그에 스타일을 적용하는 코드이다.<br>
&lt;!--select_all_range.html--&gt;
&lt;!--왜 안되는 지 모르겠다--&gt;

&lt;!DOCTYPE html&gt;
&lt;html&gt;
	&lt;head&gt;
		&lt;title&gt;CSS3 Selector Basic Page&lt;/title&gt;
		&lt;script src="http://code.jquery.com/jquery-1.11.1.js"&gt;&lt;/script&gt;
		&lt;script&gt;
			/* 웹페이지가 모두 준비되면 */
			$(document).ready(function () {
			/* 모든 태그의 border 속성에 Spx solid black을 적용한다 */
			$('*').css('border', 'Spx solid black');
			});
		&lt;/script&gt;
	&lt;/head&gt;
	&lt;body&gt;
		&lt;h1&gt;Lorem ipsum&lt;/h1&gt;
		&lt;p&gt;Lorem ipsum dolor sit amet, consectetur adipiscing elit.&lt;/p&gt;
	&lt;/body&gt;
&lt;/html&gt;


<br><br>태그 선택자는 HTML 페이지 내부에서 특정 종류의 태그를 모두 선택할 때 사용하는 선택자이다.<br><br>태그 선택자는 아래의 코드처럼 사용한다. 다음 코드는 h1 태그의 color 속성에 red 키워드를 적용하고 p 태그의 color 속성에 blue 키워드를 적용한다.<br>
&lt;!--select_tag.html--&gt;

&lt;!DOCTYPE html&gt;
&lt;html&gt;
	&lt;head&gt;
		&lt;title&gt;CSS3 Select Basic Page&lt;/title&gt;
		&lt;style&gt;
			/* h1 태그의 color 속성에 red 키워드를 적용한다. */
			h1 { color: red; }

			/* p 태그의 color 속성에 blue 키워드를 적용한다. */
			p { color: blue; }
		&lt;/style&gt;
	&lt;/head&gt;
	&lt;body&gt;
		&lt;h1&gt;Lorem ipsum dolor amet&lt;/h1&gt;
		&lt;p&gt;Lorem ipsum dolor sit amet, consectetur adipiscing elit.&lt;/p&gt;
		&lt;p&gt;Nunc nisl turpis, aliquet et gravida non, facilisis a sem.&lt;/p&gt;
	&lt;/body&gt;
&lt;/html&gt;

<br>그리고 다음과 같이 여러 개의 선택자를 한꺼번에 선택해서 스타일 속성을 적용할 때는 쉼표를 사용한다.<br>여러 개의 태그 선택자를 쉼표로 연결해 margin 속성과 padding 속성을 적용한다.<br>
&lt;style&gt;
	body, p, h1, h2, h3, h4, h5, h6 { margin: 0; padding: 0; }
&lt;/style&gt;

<br><br>아이디 선택자는 특정한 id 속성을 가지고 있는 태그를 선택할 때 사용하는 선택자이다.<br><br>웹 표준에 id 속성은 웹 페이지 내부에서 중복되면 안된다라는 규정이 있으므로 아이디 선택자는 특정한 하나의 태그를 선택할 때 사용한다.<br>일반적으로 아래의 코드처럼 공간 분할 태그에 id 속성을 적용하고 레이아웃을 구성한다.<br>
&lt;!--select_id.html--&gt;

&lt;!DOCTYPE html&gt;
&lt;html&gt;
	&lt;head&gt;
		&lt;title&gt;CSS3 Selector Basic Page&lt;/title&gt;
		&lt;style&gt;
			/* id 속성값으로 header를 가지는 태그의 스타일을 지정한다. */
			#header {
				width: 800px; margin: 0 auto;
				background: red;
			}
			#wrap {
				width: 800px; margin: 0 auto;
				overflow: hidden;
			}
			#aside {
				width: 200px; float: left;
				background: blue;
			}
			#content {
				width: 600px; float: left;
				background: green;
			}
		&lt;/style&gt;
	&lt;/head&gt;
	&lt;body&gt;
		&lt;div id="header"&gt;
			&lt;h1&gt;Header&lt;/h1&gt;
		&lt;/div&gt;
		&lt;div id="wrap"&gt;
			&lt;div id="aside"&gt;
				&lt;h1&gt;Aside&lt;/h1&gt;
			&lt;/div&gt;
			&lt;div id="content"&gt;
				&lt;h1&gt;Content&lt;/h1&gt;
			&lt;/div&gt;
		&lt;/div&gt;
	&lt;/body&gt;
&lt;/html&gt;

<br><br>클래스 선택자는 특정한 클래스를 가지고 있는 태그를 선택할 때 사용하는 선택자이다.<br><br>
&lt;!--select_class.html--&gt;

&lt;!DOCTYPE html&gt;
&lt;html&gt;
	&lt;head&gt;
		&lt;title&gt;CSS3 Selector Basic&lt;/title&gt;
		&lt;style&gt;
			/* class 속성값으로 select를 가지는 태그의 color 속성에 red 키워드를 적용한다 */
			.select { color: red; }
		&lt;/style&gt;
	&lt;/head&gt;
	&lt;body&gt;
		&lt;ul&gt;
			&lt;li class="select"&gt;Lorem ipsum&lt;/li&gt;
			&lt;li&gt;Lorem ipsum&lt;/li&gt;
			&lt;li class="select"&gt;Lorem ipsum&lt;/li&gt;
			&lt;li&gt;Lorem ipsum&lt;/li&gt;
		&lt;/ul&gt;
	&lt;/body&gt;
&lt;/html&gt;

<br><br>class 속성은 아래처럼 공백으로 구분해서 여러 클래스를 사용할 수 있다. 따라서 아래의 코드의 h1 태그는 .item, .header CSS 블록이 같이 적용된다.<br>
&lt;h1 class="item header"&gt;Lorem ipsum&lt;/h1&gt;

<br><br>id 속성은 웹 페이지 내부에서 중복되지 않으므로 상관없지만 class 속성은 중복될 수 있다. 만약 class 속성이 서로 다른 태그에 사용된다면 태그 선택자와 클래스 선택자를 함께 사용해서 더 정확하게 클래스를 선택한다.<br>
&lt;!--select_tag_class.html--&gt;

&lt;!DOCTYPE html&gt;
&lt;html&gt;
	&lt;head&gt;
		&lt;title&gt;CSS3 Selector Basic&lt;/title&gt;
		&lt;style&gt;
			/* li 태그 중 class 속성값으로 select를 가지는 태그의 color 속성을 red 키워드를 적용한다. */
			li.select { color: red; }
		&lt;/style&gt;
	&lt;/head&gt;
	&lt;body&gt;
		&lt;h1 class="select"&gt;Lorem ipsum&lt;/h1&gt;
		&lt;ul&gt;
			&lt;li class="select"&gt;Lorem ipsum&lt;/li&gt;
			&lt;li&gt;Lorem ipsum&lt;/li&gt;
			&lt;li&gt;Lorem ipsum&lt;/li&gt;
			&lt;li&gt;Lorem ipsum&lt;/li&gt;
		&lt;/ul&gt;
	&lt;/body&gt;
&lt;/html&gt;

<br><br>속성 선택자를 사용하면 특정 속성을 가진 HTML 태그를 선택할 수 있다.<br>
속성 선택자는 지금까지 배운 다른 선택자와 함께 사용하는 선택자이다. <br>속성 선택자는 기본 속성 선택자와 문자열 속성 선택자로 나눌 수 있으며 기본 속성 선택자는 많이 사용하지만 문자열 속성 선택자는 특별한 경우에만 사용한다.<br><br>기본 속성 선택자는 다음의 표와 같은 형태이다. 지금까지 배운 선택자 뒤에 대괄호([])를 사용해 속성과 값을 입력한다.<br><br><br>input 태그는 type 속성을 입력하지 않으면 자동으로 text 속성값을 적용한다. 하지만 CSS는  HTML 태그가 기본으로 무엇을 출력하는지는 관심이 없기 때문에 코드에 명시적으로 속성값을 text라고 작성한 태그에만 스타일을 적용한다는 점에 유의하자.<br><br>문자열 속성 선택자는 태그에 지정한 속성의 특정 문자열을 확인한다.<br><br>
위 표를 보면 선택자[속성~=값]과 선택자[속성|=값]의 설명이 같다. 하이픈(-)이 들어간 단어의 구분 방법이 다르다. 예를 들러 ko-kr 글자를 다음과 같이 인식한다.
<br><br>문자열 속성 선택자는 거의 사용하지 않지만 파일 형태에 따라 스타일을 적용할 때 가끔 사용한다.<br>
&lt;!--select_string-attribute.html--&gt;

&lt;!DOCTYPE html&gt;
&lt;html&gt;
	&lt;head&gt;
		&lt;title&gt;CSS3 Selector Basic&lt;/title&gt;
		&lt;style&gt;
			/* img 태그 중에서 src 속성값이 png로 끝나는 태그의
			border 속성에 3px solid red를 적용한다 */
			img[src$=png] { border: 3px solid red; }

			/* img 태그 중에서 src 속성값이 jpg로 끝나는 태그의
			border 속성에 3px solid green를 적용한다 */
			img[src$=jpg] { border: 3px solid green; }

			/* img 태그 중에서 src 속성값이 gif로 끝나는 태그의
			border 속성에 3px solid blue를 적용한다 */
			img[src$=png] { border: 3px solid blue; }
		&lt;/style&gt;
	&lt;/head&gt;
	&lt;body&gt;
		&lt;img src="jajq.png" width="200" height="250" /&gt;
		&lt;img src="node.jpg" width="200" height="250" /&gt;
		&lt;img src="ux.gif" width="200" height="250" /&gt;
	&lt;/body&gt;
&lt;/html&gt;

<br>문자열 속성 선택자는 복잡한 CSS 프레임워크를 만들 때나 사용하는 선택자이므로, 나중에 정말 필요한 경우에만 찾아봐도 늦지 않다.<br><br>후손 선택자는 특정한 태그 아래에 있는 <a data-tooltip-position="top" aria-label="HTML 태그, 요소 그리고 속성 > ^b1cf89" data-href="HTML 태그, 요소 그리고 속성#^b1cf89" href="resource\web\html\html-태그,-요소-그리고-속성.html#^b1cf89" class="internal-link" target="_self" rel="noopener nofollow">후손</a>을 선택할 때 사용하는 선택자이다.<br><br>
&lt;!--select_grandchild.html--&gt;

&lt;!DOCTYPE html&gt;
&lt;html&gt;
	&lt;head&gt;
		&lt;title&gt;CSS3 Selector Basic&lt;/title&gt;
		&lt;style&gt;
			/* id 속성값으로 header를 가지는 태그의 후손 위치에 있는 h1 태그의
			   color 속성에 red 키워드를 적용한다. */
			#header h1 { color: red; }
			/* id 속성값으로 section를 가지는 태그의 후손 위치에 있는 h1 태그의
			   color 속성에 orange 키워드를 적용한다. */
			#section h1 { color: orange; }
		&lt;/style&gt;
	&lt;/head&gt;
	&lt;body&gt;
		&lt;div id="header"&gt;
			&lt;h1 class="title"&gt;Lorem ipsum&lt;/h1&gt;
			&lt;div id="nav"&gt;
				&lt;h1&gt;Navigation&lt;/h1&gt;
			&lt;/div&gt;
		&lt;/div&gt;
		&lt;div id="section"&gt;
			&lt;h1 class="title"&gt;Lorem ipsum&lt;/h1&gt;
			&lt;p&gt;Lorem ipsum dolor sit amet, consectetur adipiscing elit.&lt;/p&gt;
		&lt;/div&gt;
	&lt;/body&gt;
&lt;/html&gt;

<br><br>여러 개의 선택자를 함께 사용할 때 후손 선택자를 다음과 같이 사용하는 경우가 있다.<br>
&lt;style&gt;
	/* id 속성값이 header인 태그의 후손 위치에 있는 h1 태그와 h2 태그의 color 속성에 red 키워드를 적용한다. */
	#header h1, h2 {color: red; }
&lt;/style&gt;

<br>위 예제의 선택자는 #header 태그의 후손에 위치하는 h1 태그를 선택하고 일반적인 h2 태그를 선택한다.<br>
만약 #header 태그의 후손에 위치하는 h1 태그와 #header 태그의 후손에 위치하는 h2 태그를 선택하고 싶다면 아래의 코드처럼 사용해야 한다.<br>
&lt;style&gt;
	/* id 속성값이 header인 태그의 후손 위치에 있는 h1 태그와
	   id 속성값이 header인 태그의 후손 위치에 있는 h2 태그의
	   color 속성에 red 키워드를 적용한다. */
	#header h1, #header h2 { color: red; }
&lt;\style&gt;

<br><br>자손 선택자는 특정 태그 아래에 있는 <a data-tooltip-position="top" aria-label="HTML 태그, 요소 그리고 속성 > ^b1cf89" data-href="HTML 태그, 요소 그리고 속성#^b1cf89" href="resource\web\html\html-태그,-요소-그리고-속성.html#^b1cf89" class="internal-link" target="_self" rel="noopener nofollow">자손</a>을 선택할 때 사용하는 선택자이다.<br><br>아래의 예제는 위에서 살펴본 body 태그와 구성이 같지만 #nav 태그 아래에 있는 h1 태그에는 스타일이 적용되지 않는다.<br>
&lt;!--select_child.html--&gt;

&lt;!DOCTYPE html&gt;
&lt;html&gt;
	&lt;head&gt;
		&lt;title&gt;CSS3 Selector Basic&lt;/title&gt;
		&lt;style&gt;
			/* id 속성값으로 header를 가지는 태그의 후손 위치에 있는 h1 태그의
			   color 속성에 red 키워드를 적용한다. */
			#header &gt; h1 { color: red; }
			/* id 속성값으로 section를 가지는 태그의 후손 위치에 있는 h1 태그의
			   color 속성에 orange 키워드를 적용한다. */
			#section &gt; h1 { color: orange; }
		&lt;/style&gt;
	&lt;/head&gt;
	&lt;body&gt;
		&lt;div id="header"&gt;
			&lt;h1 class="title"&gt;Lorem ipsum&lt;/h1&gt;
			&lt;div id="nav"&gt;
				&lt;h1&gt;Navigation&lt;/h1&gt;
			&lt;/div&gt;
		&lt;/div&gt;
		&lt;div id="section"&gt;
			&lt;h1 class="title"&gt;Lorem ipsum&lt;/h1&gt;
			&lt;p&gt;Lorem ipsum dolor sit amet, consectetur adipiscing elit.&lt;/p&gt;
		&lt;/div&gt;
	&lt;/body&gt;
&lt;/html&gt;

<br><br>table 태그의 요소를 선택할 때는 자손 선택자를 사용하는 것이 좋지 않다.<br>
&lt;!--select_child_with_table.html--&gt;

&lt;!DOCTYPE html&gt;
&lt;html&gt;
	&lt;head&gt;
		&lt;title&gt;CSS3 Selector Basic&lt;/title&gt;
		&lt;style&gt;
			/* table 태그 아래의 tr 태그 아래 th 태그의 color 속성에 red 키워드를 적용한다. */
			table &gt; tr &gt; th {
				color: red;
			}
		&lt;/style&gt;
	&lt;/head&gt;
	&lt;body&gt;
		&lt;table border="1"&gt;
			&lt;tr&gt;
				&lt;th&gt;Name&lt;/th&gt;
				&lt;th&gt;Region&lt;/th&gt;
			&lt;/tr&gt;
			&lt;tr&gt;
				&lt;td&gt;윤인성&lt;/td&gt;
				&lt;td&gt;서울특별시 강서구 내발산동&lt;/td&gt;
			&lt;/tr&gt;
		&lt;/table&gt;
	&lt;/body&gt;
&lt;/html&gt;

<br>대부분 th 태그에 빨간색이 적용되는 것을 예상할 것이다. 하지만 실제로는 스타일 속성이 적용되지 않는다.<br>이 문제는 요소 검사를 사용해 HTML 페이지의 계층 구조를 살펴보면 원인을 알 수 있다. table 태그에 tbody 태그가 자동으로 추가되어 있을 것이다. 이렇게 웹 브라우저가 자동으로 tbody 태그를 추가하므로 스타일 속성이 적용되지 않는 것이다.<br>따라서 table &gt; tbody &gt; tr &gt; th 선택자를 사용해야 색상을 적용할 수 있다. 소스 코드와 실행 결과가 달라 혼동되므로 table 선택자에 스타일을 적용할 때는 자손 선택자를 사용하지 않도록 하자.<br><br><a data-tooltip-position="top" aria-label="HTML 태그, 요소 그리고 속성 > ^a63bb2" data-href="HTML 태그, 요소 그리고 속성#^a63bb2" href="resource\web\html\html-태그,-요소-그리고-속성.html#^a63bb2" class="internal-link" target="_self" rel="noopener nofollow">동위</a> 선택자는 동위 관계에서 뒤에 위치한 태그를 선택할 때 사용하는 선택자이다.<br><br>
&lt;!--select_brother.html--&gt;

&lt;!DOCTYPE html&gt;
&lt;html&gt;
	&lt;head&gt;
		&lt;title&gt;CSS3 Selector Basic&lt;/title&gt;
		&lt;style&gt;
			/* h1 태그 바로 뒤에 위치하는 h2 태그의 color 속성에 red 키워드를 적용한다. */
			h1 + h2 { color: red; }
			/* h1 태그 뒤에 위치하는 h2 태그의 background-color 속성에 orange 키워드를 적용한다. */
			h1 ~ h2 { background-color: orange; }
		&lt;/style&gt;
	&lt;/head&gt;
	&lt;body&gt;
		&lt;h1&gt;Header - 1&lt;/h1&gt;
		&lt;h2&gt;Header - 2&lt;/h2&gt;
		&lt;h2&gt;Header - 2&lt;/h2&gt;
		&lt;h2&gt;Header - 2&lt;/h2&gt;
		&lt;h2&gt;Header - 2&lt;/h2&gt;
	&lt;/body&gt;
&lt;/html&gt;

<br>동위 선택자는 CSS3 애니메이션을 사용해 동적으로 움직이는 레이아웃을 구성할 때 사용된다.<br><br>반응 선택자는 사용자의 반응으로 생성되는 특정한 상태를 선택하는 선택자이다. 사용자가 마우스를 특정한 태그 위에 올리면 hover 상태가 적용되고 클릭하면 active 상태가 적용된다.<br><br>
&lt;!--select_reactor.html--&gt;

&lt;!DOCTYPE html&gt;
&lt;html&gt;
	&lt;head&gt;
		&lt;title&gt;CSS3 Selector Basic&lt;/title&gt;
		&lt;style&gt;
			/* h1 태그에 마우스를 올릴 경우에
			   color 속성에 red 키워드를 적용한다. */
			h1:hover { color: red; }
			/* h1 태그를 마우스로 클릭할 때
			   color 속성에 blue 키워드를 적용한다. */
			h1:active { color: blue; }
		&lt;/style&gt;
	&lt;/head&gt;
	&lt;body&gt;
		&lt;h1&gt;User Action Selector&lt;/h1&gt;
	&lt;/body&gt;
&lt;/html&gt;

<br><br>상태 선택자는 입력 양식의 상태를 선택할 때 사용하는 선택자이다.<br><br>상태에 관해 좀 더 부연해보도록 하겠다.<br>checked 상태는 type 속성값이 checkbox 또는 radio인 input 태그가 선택된 상태를 의미한다.<br>focus 상태는 사용자가 초점을 맞추고 있는 입력 양식에 적용되는 상태이다. 참고로 웹페이지 하나당 하나의 input 태그에만 초점을 맞출 수 있다.<br>마지막으로 enabled 상태는 input 태그가 사용 가능한 상태를 나타내고 disabled 상태는 input 태그가 사용 불가능한 상태를 나타낸다.<br>
&lt;!--select_status.html--&gt;

&lt;!DOCTYPE html&gt;
&lt;html&gt;
	&lt;head&gt;
		&lt;title&gt;CSS3 Selector Basic&lt;/title&gt;
		&lt;style&gt;
			/* input 태그가 사용 가능할 경우에
			   background_color 속성에 white 키워드를 적용한다 */
			input:enabled { background-color: white; }
			/* input 태그가 사용 가능할 경우에
			   background_color 속성에 white 키워드를 적용한다 */
			input:disabled { background-color: gray; }
			/* input 태그가 사용 가능할 경우에
			   background_color 속성에 white 키워드를 적용한다 */
			input:focus { background-color: orange; }
		&lt;/style&gt;
	&lt;/head&gt;
	&lt;body&gt;
		&lt;h2&gt;Enabled&lt;/h2&gt;
		&lt;input /&gt;
		&lt;h2&gt;Disabled&lt;/h2&gt;
		&lt;input disabled="disabled" /&gt;
	&lt;/body&gt;
&lt;/html&gt;

<br>아래 예제는 상태 선택자를 복합적으로 적용시킨 예이다.<br>
&lt;!--select_status_brother.html--&gt;

&lt;!DOCTYPE html&gt;
&lt;html&gt;
	&lt;head&gt;
		&lt;title&gt;CSS3 Selector Basic&lt;/title&gt;
		&lt;style&gt;
			/* input 태그의 type 속성값이 checkbox인 태그가 체크되었을 때
			   바로 뒤에 위치하는 div 태그의 height 속성에 0픽셀을 적용한다 */
			input[type=checkout]:checked + div {
				height: 0px;
			}
			div {
				overflow: hidden;
				width: 650px; height: 300px;

				/* 변환 효과를 적용한다 */
				-ms-transition-duration: 1s;
				-webkit-transition-duration: 1s;
				-moz-transition-duration: 1s;
				-o-transition-duration: 1s;
				transition-duration: 1s;
			}
		&lt;/style&gt;
	&lt;/head&gt;
	&lt;body&gt;
		&lt;input type="checkbox" /&gt;
		&lt;div&gt;
			&lt;h1&gt;Lorem ipsum&lt;/h1&gt;
			&lt;p&gt;Lorem ipsum dolor sit amet, consectetur adipiscing elit.&lt;/p&gt;
		&lt;/div&gt;
	&lt;/body&gt;
&lt;/html&gt;

<br><br>구조 선택자는 CSS3부터 지원하는 선택자이다. 일반적으로 자손 선택자와 병행해서 많이 사용한다.<br><br>일반 구조 선택자는 특정한 위치에 있는 태그를 선택하는 선택자이다.<br><br>nth-child 선택자와 nth-last-child 선택자의 괄호 안에 수열을 넣으라는 말이 모호해보인다. 간단하게 다음 수열을 예시로 들어보겠다.<br>2n + 1<br>위 수열에 0부터 숫자를 하나씩 넣어보면 다음과 같은 수의 나열을 얻을 수 있다.<br>1, 3, 5, 7, 9 ...<br>따라서  :nth-child(2n+1) 선택자를 사용하면 첫 번째, 세 번째, 다섯 번째 등에 위치하는 태그를 선택한다.<br><br>형태 구조 선택자는 일반 구조 선택자와 비슷하지만 태그 형태를 구분한다.<br><br>
&lt;!--select_brother_struct.html--&gt;

&lt;!DOCTYPE html&gt;
&lt;html&gt;
	&lt;head&gt;
		&lt;title&gt;CSS3 Selector Basic Page&lt;/title&gt;
		&lt;style&gt;
			h1:first-of-type {color:red;}
			h2:first-of-type {color:red;}
			h3:first-of-type {color:red;}
		&lt;/style&gt;
	&lt;/head&gt;
	&lt;body&gt;
		&lt;h1&gt;Header - 1&lt;/h1&gt;
		&lt;h2&gt;Header - 2&lt;/h2&gt;
		&lt;h3&gt;Header - 3&lt;/h3&gt;
		&lt;h3&gt;Header - 3&lt;/h3&gt;
		&lt;h2&gt;Header - 2&lt;/h2&gt;
		&lt;h1&gt;Header - 1&lt;/h1&gt;
	&lt;/body&gt;
&lt;/html&gt;

<br>
&lt;!--select_brother_struct2.html--&gt;

&lt;!DOCTYPE html&gt;
&lt;html&gt;
	&lt;head&gt;
		&lt;title&gt;CSS3 Selector Basic Page&lt;/title&gt;
		&lt;style&gt;
			body &gt; *:first-of-type {color:red;}
		&lt;/style&gt;
	&lt;/head&gt;
	&lt;body&gt;
		&lt;h1&gt;Header - 1&lt;/h1&gt;
		&lt;h2&gt;Header - 2&lt;/h2&gt;
		&lt;h3&gt;Header - 3&lt;/h3&gt;
		&lt;h4&gt;Header - 4&lt;/h4&gt;
		&lt;h5&gt;Header - 5&lt;/h5&gt;
		&lt;h6&gt;Header - 6&lt;/h6&gt;
	&lt;/body&gt;
&lt;/html&gt;

<br><br>문자 가상 요소 선택자는 태그 내부 특정 조건의 문자를 선택하는 선택자이다. 문자 선택자는 가상 요소 선택자 Pseudo-Element Selector로 ::기호를 사용하는 것이 표준이지만 : 기호를 사용해도 정상 작동한다. 하지만 이 문서에서는 표준에 맞게 :: 기호를 사용한다.<br><br>시작 문자 선택자는 태그 내부의 첫 번째 글자와 첫 번째 줄을 선택할 때 사용하는 선택자이다.<br><br><br>전후 문자 선택자는 특정 태그의 전후에 위치하는 공간을 선택하는 선택자이다.<br><br>전후 문자 선택자에는 content 속성을 사용할 수 있다(다른 선택자에는 content 속성을 사용할 수 없다).<br>
&lt;!--select_front_back.html--&gt;

&lt;!DOCTYPE html&gt;
&lt;html&gt;
	&lt;head&gt;
		&lt;title&gt;CSS3 Selector Basic Page&lt;/title&gt;
		&lt;style&gt;
			p { counter-increment: rint; }
			p::before { content: counter(rint) "."; }
			p::after { content: " - " attr(data-page) " page"; }
			p::first-letter { font-size: 3em; }
		&lt;/style&gt;
	&lt;/head&gt;
	&lt;body&gt;
		&lt;h1&gt;Lorem ipsum dolor sit amet&lt;/h1&gt;
		&lt;p data-page="52"&gt;Lorem ipsum dolor sit amet, consectetur adipiscing elit.&lt;/p&gt;
		&lt;p data-page="273"&gt;Aenean ac erat et massa vehicula laoreet consequat et sem.&lt;/p&gt;
	&lt;/body&gt;
&lt;/html&gt;

<br>주의 깊게 살펴볼 부분은 ::first-letter 선택자를 사용해 첫 번째 글자를 선택했을 때 전후 문자 선택자로 생성한 글자도 스타일이 적용된다는 것이다.<br><br>웹 표준에 따르면 각각의 태그에 지정된 속성 의외의 것을 사용하면 안된다. 하지만 속성 앞에 문자열 data-를 붙이면 사용자 지정 속성으로 인정해준다.<br>위의 select_front_back.html 예제에서는 특정한 정보를 넣기 위해 사용자 지정 속성인 data-page 속성을 사용한다. 실제로 data-page 속성은 웹 표준에 존재하지 않고 임의로 지정한 것이다.<br>웹과 관련된 기술을 접할수록 사용자 지정 속성은 굉장히 많이 사용된다. 아래 예제는 모바일 애플리케이션을 쉽게 만들 수 있게 도와주는 jQuery Mobile 프레임워크를 사용한 코드이다. jQuery Mobile 프레임워크는 div 태그에 data-role 속성을 사용하면 레이아웃을 자동으로 구성해준다.<br>
&lt;!--jQuery_Mobile.html--&gt;

&lt;!DOCTYPE html&gt;
&lt;html&gt;
	&lt;head&gt;
		&lt;title&gt;--jQuery_Mobile&lt;/title&gt;
		&lt;meta name="viewport" content="width=device-width, initial-scale=1" /&gt;
		&lt;link rel="stylesheet"
		href="http://code.jquery.com/mobile/1.4.4/jquery.mobile-1.4.4.min.css" /&gt;
		&lt;script src="http://code.jquery.com/jquery-1.11.1.min.js"&gt;&lt;/script&gt;
		&lt;script src="http://code.jquery.com/mobile/1.4.4/jquery.mobile-1.4.4.min.js"&gt;&lt;/script&gt;
	&lt;/head&gt;
	&lt;body&gt;
		&lt;div data-role="page"&gt;
			&lt;div data-role="header" data-theme="b"&gt;
				&lt;h1&gt;HTML5&lt;/h1&gt;
			&lt;/div&gt;
			&lt;div data-role="content"&gt;
				&lt;ul data-role="listview"&gt;
					&lt;li data-role="list-divider"&gt;HTML5&lt;/li&gt;
					&lt;li&gt;Multimedia&lt;/li&gt;
					&lt;li&gt;Connectivity&lt;/li&gt;
					&lt;li&gt;Device Access&lt;/li&gt;
					&lt;li data-role="list-divider"&gt;CSS3&lt;/li&gt;
					&lt;li&gt;Animation&lt;/li&gt;
					&lt;li&gt;3d Transform&lt;/li&gt;
				&lt;/ul&gt;
			&lt;/div&gt;
		&lt;/div&gt;
	&lt;/body&gt;
&lt;/html&gt;

<br>위 예제를 실행하면 페이지가 자동으로 디자인되는 것을 볼 수 있다. 이런 프레임워크를 UI 프레임워크라고 하며 사용자 지정 속성을 굉장히 많이 활용한다.<br><br>반응 문자 선택자는 사용자가 문자와 반응해서 생기는 영역을 선택자이다.<br><br>
&lt;!--select_reacting_string.html--&gt;

&lt;!DOCTYPE html&gt;
&lt;html&gt;
	&lt;head&gt;
		&lt;title&gt;CSS3 Selector Basic Page&lt;/title&gt;
		&lt;style&gt;
			p::selection { background: black; color: red;}
		&lt;/style&gt;
	&lt;/head&gt;
	&lt;body&gt;
		&lt;h1&gt;Lorem ipsum dolor sit amet&lt;/h1&gt;
		&lt;p&gt;Lorem ipsum dolor sit amet, consectetur adipiscing elit.&lt;/p&gt;
		&lt;p&gt;Nunc nisl turpis, aliquet et gravida non, facilisis a sem.&lt;/p&gt;
	&lt;/body&gt;
&lt;/html&gt;

<br><br>링크 선택자는 href 속성을 가지고 있는 a 태그에 적용되는 선택자이다. 인터넷에서 한 번 다녀온 링크는 색이 변경되는 것을 볼 수 있는데, 링크 선택자는 한번 이상 다녀온 링크를 선택할 수 있는 선택자이다.<br><br>아래 예제는 링크 선택자와 문자 선택자를 함께 사용해 href 속성이 적용된 a 태크와 방문된 a 태그에 스타일을 적용한다.<br>
&lt;!--select_link.html--&gt;

&lt;!DOCTYPE html&gt;
&lt;html&gt;
	&lt;head&gt;
		&lt;title&gt;CSS3 Selector Basic&lt;/title&gt;
		&lt;style&gt;
			a { text-decoration: none; }
			a:visited { color: red; }

			/* href 속성을 가지고 있는 a 태그 뒤의 공간에
			"- (href 속성)"을 추가한다 */
			a:link::after { content: ' - ' attr(href); }
		&lt;/style&gt;
	&lt;/head&gt;
	&lt;body&gt;
		&lt;h1&gt;&lt;a&gt;Nothing&lt;/a&gt;&lt;/h1&gt;
		&lt;h1&gt;&lt;a href="http://hanbit.co.kr"&gt;Hanbit Media&lt;/a&gt;&lt;/h1&gt;
		&lt;h1&gt;&lt;a href="http://www.w3.org/"&gt;W3C&lt;/a&gt;&lt;/h1&gt;
		&lt;h1&gt;&lt;a href="https://github.com/"&gt;Github&lt;/a&gt;&lt;/h1&gt;
	&lt;/body&gt;
&lt;/html&gt;

<br><br>부정 선택자는 지금까지 배운 선택자를 모두 반대로 적용할 수 있게 만드는 선택자이다.<br><br>
&lt;!--select_not.html--&gt;

&lt;!DOCTYPE html&gt;
&lt;html&gt;
	&lt;head&gt;
		&lt;title&gt;CSS3 Selector Basic&lt;/title&gt;
		&lt;style&gt;
			/* input 태그 중에서 type 속성값이 password가 아닌 태그의
			   background 속성에 red 키워드를 적용한다 */
			input:not([type=password]) {
				background: red;
			}
		&lt;/style&gt;
	&lt;/head&gt;
	&lt;body&gt;
		&lt;input type="password" /&gt;
		&lt;input type="text" /&gt;
		&lt;input type="password" /&gt;
		&lt;input type="text" /&gt;
	&lt;/body&gt;
&lt;/html&gt;

<br><br>참고자료<br><a href=".?query=tag:참고도서\모던_웹_디자인을_위한_HTML5_CSS3_입문" class="tag" target="_blank" rel="noopener nofollow">#참고도서/모던_웹_디자인을_위한_HTML5_CSS3_입문</a> <br>]]></description><link>resource\web\css\css-선택자.html</link><guid isPermaLink="false">resource/Web/CSS/CSS 선택자.md</guid><pubDate>Fri, 14 Feb 2025 05:47:26 GMT</pubDate></item><item><title><![CDATA[CSS3 스타일 속성 기본]]></title><description><![CDATA[<a class="tag" href="?query=tag:language/css" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#language/css</a> <a class="tag" href="?query=tag:web" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#web</a> <a class="tag" href="?query=tag:참고도서/모던_웹_디자인을_위한_HTML5_CSS3_입문" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/모던_웹_디자인을_위한_HTML5_CSS3_입문</a> 
 <br><br><a href=".?query=tag:language\css" class="tag" target="_blank" rel="noopener nofollow">#language/css</a> <a href=".?query=tag:web" class="tag" target="_blank" rel="noopener nofollow">#web</a> <br>visual studio에서 Ctrl + Spacebar로 스타일 속성 선택지를 확인할 수 있으므로 미련하게 꾸역꾸역 외우지 말자<br><br><br>스타일 속성은 아래의 코드처럼 입력한다. 이때 오른쪽에 입력하는 값은 특정한 단위를 갖는다. 이 절에서는 스타일시트에서 사용하는 단위를 알아본다.<br>
&lt;style&gt;
	h1 {
		margin: 10px;
		font-size: 200%;
		line-height: 2em;
	}
&lt;/style&gt;

<br><br>키워드는 CSS3에서 가장 쉽게 사용할 수 있는 단위이다. 각각의 스타일 속성에 따라 별도의 키워드가 존재한다.<br><br>크기 단위는 CSS3에서 가장 많이 사용하는 단위이다. CSS3에서 사용하는 크기 단위는 %, em, cm, mm, inch, px이다. 이중에서 자주 사용하는 크기 단위는 아래와 같다.<br><br>첫번째로 알아볼 단위는 퍼센트 단위이다. 퍼센트 단위는 기본 설정된 크기에서 상대적으로 크기를 지정한다. 100%가 초기에 설정된 크기이다.<br>
&lt;!--percent.html--&gt;

&lt;!DOCTYPE html&gt;
&lt;html&gt;
	&lt;head&gt;
		&lt;title&gt;CSS3 Style Property Basic&lt;/title&gt;
		&lt;style&gt;
			p:nth-child(1) { font-size: 0% }
			p:nth-child(2) { font-size: 100% }
			p:nth-child(3) { font-size: 150% }
			p:nth-child(4) { font-size: 200% }
		&lt;/style&gt;
	&lt;/head&gt;
	&lt;body&gt;
		&lt;p&gt;Lorem ipsum dolor sit amet, consectetur adipiscing elit.&lt;/p&gt;
		&lt;p&gt;Lorem ipsum dolor sit amet, consectetur adipiscing elit.&lt;/p&gt;
		&lt;p&gt;Lorem ipsum dolor sit amet, consectetur adipiscing elit.&lt;/p&gt;
		&lt;p&gt;Lorem ipsum dolor sit amet, consectetur adipiscing elit.&lt;/p&gt;
	&lt;/body&gt;
&lt;/html&gt;

<br>두번째로 알아볼 크기 단위는 em 단위이다. em 단위는 배수를 나타내는 단위이다. 1배=1em=100%이며 1.5배=1.5em=150%이다.<br>
&lt;!--percent.html--&gt;

&lt;!DOCTYPE html&gt;
&lt;html&gt;
	&lt;head&gt;
		&lt;title&gt;CSS3 Style Property Basic&lt;/title&gt;
		&lt;style&gt;
			p:nth-child(1) { font-size: 0.0em; }
			p:nth-child(2) { font-size: 1.0em; }
			p:nth-child(3) { font-size: 1.5em; }
			p:nth-child(4) { font-size: 2.0em; }
		&lt;/style&gt;
	&lt;/head&gt;
	&lt;body&gt;
		&lt;p&gt;Lorem ipsum dolor sit amet, consectetur adipiscing elit.&lt;/p&gt;
		&lt;p&gt;Lorem ipsum dolor sit amet, consectetur adipiscing elit.&lt;/p&gt;
		&lt;p&gt;Lorem ipsum dolor sit amet, consectetur adipiscing elit.&lt;/p&gt;
		&lt;p&gt;Lorem ipsum dolor sit amet, consectetur adipiscing elit.&lt;/p&gt;
	&lt;/body&gt;
&lt;/html&gt;
<br>% 단위와 em 단위는 모두 상대적으로 크기를 지정한다. 절대적으로 크기를 지정할 때는 px 단위를 사용한다. 참고로 p 태그의 기본 font-size 속성이 16픽셀이다.<br>
&lt;!--percent.html--&gt;

&lt;!DOCTYPE html&gt;
&lt;html&gt;
	&lt;head&gt;
		&lt;title&gt;CSS3 Style Property Basic&lt;/title&gt;
		&lt;style&gt;
			p:nth-child(1) { font-size: 0px; }
			p:nth-child(2) { font-size: 16px; }
			p:nth-child(3) { font-size: 24px; }
			p:nth-child(4) { font-size: 32px; }
		&lt;/style&gt;
	&lt;/head&gt;
	&lt;body&gt;
		&lt;p&gt;Lorem ipsum dolor sit amet, consectetur adipiscing elit.&lt;/p&gt;
		&lt;p&gt;Lorem ipsum dolor sit amet, consectetur adipiscing elit.&lt;/p&gt;
		&lt;p&gt;Lorem ipsum dolor sit amet, consectetur adipiscing elit.&lt;/p&gt;
		&lt;p&gt;Lorem ipsum dolor sit amet, consectetur adipiscing elit.&lt;/p&gt;
	&lt;/body&gt;
&lt;/html&gt;

<br><br>폰트 크기를 지정할 때는 크기 단위를 섞어서 사용하는 경우가 많다. 이번에는 크기 단위를 섞어서 사용하는 방법을 살펴보자.<br>아래의 코드는 절대 크기 단위와 상대 크기 단위를 섞어서 폰트 크기를 지정한다.<br>
&lt;!--combined.html--&gt;

&lt;!DOCTYPE html&gt;
&lt;html&gt;
	&lt;head&gt;
		&lt;title&gt;CSS3 property Basic&lt;/title&gt;
		&lt;style&gt;
			* { font-size:12px; }
			h1 { font-size:3.0em; }
			h2 { font-size:1.5em; }
		&lt;/style&gt;
	&lt;/head&gt;
	&lt;body&gt;
		&lt;h1&gt;Lorem ipsum dolor sit amet&lt;/h1&gt;
		&lt;h2&gt;consectetur adipiscing elit. Sed nec purus elit, nec cursus dolor.&lt;/h2&gt;
		&lt;p&gt;Lorem ipsum dolor sit amet, consectetur adipiscing elit. Sed nec purus elit.&lt;/p&gt;
	&lt;/body&gt;
&lt;/html&gt;

<br>전체 폰트 크기에 절대 크기를 지정하고 각각의 태그에 상대 크기를 지정하는 방법은 많이 사용되므로 기억하는 것이 좋다.<br><br>크기 단위 0을 입력하는 경우 단위를 입력하지 않아도 된다. 개발자의 취향에 따라서 0을 입력하는 경우에도 단위를 표기하는 경우가 있고 표기하지 않는 경우도 있다.<br><br>색상을 입력하는 가장 간단한 방법은 아래의 코드처럼 키워드를 입력하는 것이다.<br>
&lt;style&gt;
	h1 { background-color: red; }
	h2 { background-color: orange; }
	h3 { background-color: blue; }
	h4 { background-color: green; }
	h5 { background-color: brown; }
	h6 { background-color: purple; }
&lt;\style&gt;

<br>하지만 단어로 표현할 수 있는 색상은 제한되어 있으므로 더욱 다양한 색상 표현을 위해 아래의 표와 같은 색상 단위를 제공한다.<br><br>

RGBA와 HSLA의 A는 투명도를 의미하는 알파 값이다. 알파 값은 0.0부터 1.0 사이의 숫자를 입력한다. 0.0을 입력할 경우에는 완전히 투명한 상태를 나타내고 1.0을 입력할 경우에는 불투명한 상태를 나타낸다.
<br>rgb 단위는 red, green, blue의 조합을 사용하여 색상을 표현하는 단위이다.<br>
RGB 색상은 다음과 같이 사용한다. 각각의 숫자는 0부터 255까지 입력할 수 있다.<br>
&lt;style&gt;
	h1 { background-color: rgb(255,255,255); }
&lt;\style&gt;

<br>HEX 코드 단위는 RGB 색상 단위를 짧게 입력하는 방법이다. HEX 코드는 16진수로 RGB 색상 조합을 순서대로 입력한다.<br>
&lt;style&gt;
	h1 { background-color: #0094FF;}
&lt;\style&gt;

<br>HSL 색상은 색상 Hue, 채도 Saturation, 명도 Lightness를 사용한다.<br>
아래와 같이 입력한다.<br>
&lt;style&gt;
	h1 { background-color: hsl(33, 100%, 50%);}
&lt;\style&gt;

<br><br>CSS3에서 이미지 파일이나 폰트 파일을 불러올 때는 URL 단위를 사용한다. 간단히 아래의 예제를 통해서 URL 단위의 사용법에 대해서 알아보자.<br>
&lt;!--url.html--&gt;

&lt;!DOCTYPE html&gt;
&lt;html&gt;
	&lt;head&gt;
		&lt;title&gt;CSS3 property Basic&lt;/title&gt;
		&lt;style&gt;
			body {
				background-image: url('Desert.jpg');
			}
		&lt;/style&gt;
	&lt;/head&gt;
	&lt;body&gt;
		&lt;h1&gt;Lorem ipsum dolor amet.&lt;/h1&gt;
		&lt;p&gt;Lorem ipsum dolor sit amet, consectetur adipiscing elit.&lt;/p&gt;
	&lt;/body&gt;
&lt;/html&gt;

<br>url() 함수 내부에 경로를 입력하면 된다. URL 경로를 입력할 때는 아래처럼 복잡한 경로를 사용할 수 있다.<br>
/* 현재 폴더의 Desert.jpg */
background-image: url('Desert.jpg');

/* 현재 폴더 내부의 Other 폴더의 Desert.jpg */
background-image: url('Other/Desert.jpg');

/* 루트 폴더의 Desert.jpg */
/* 루트 폴더의 개념은 서버를 알아야 한다 */
background-image: url('/Desert.jpg');

<br><br>가시 속성은 태그가 화면에 보이는 방식을 지정하는 속성이다.<br><br>display 속성 중 주로 사용되는 속성으로는 다음이 있다.<br><br>다음은 위의 표 중 none 키워드를 사용한 예제이다. 다른 키워드를 사용할 땐 display의 키워드를 변경해주면 된다.<br>
&lt;!--none.html--&gt;

&lt;!DOCTYPE html&gt;
&lt;html&gt;
	&lt;head&gt;
		&lt;title&gt;CSS3 Style Property Basic&lt;/title&gt;
		&lt;style&gt;
			#box {
				display: none;
			}
		&lt;/style&gt;
	&lt;/head&gt;
	&lt;body&gt;
		&lt;span&gt;Dummy&lt;/span&gt;
		&lt;div id="box"&gt;
			&lt;span&gt;Lorem ipsum dolor sit amet, consectetur adipiscing elit.&lt;/span&gt;
		&lt;/div&gt;
		&lt;span&gt;Dummy&lt;/span&gt;
	&lt;/body&gt;
&lt;/html&gt;

<br>코드를 실행했을 때, 단순히 보기에는 inline 형식과 inline-block 형식 모두 동일하게 출력되는 듯 하다.<br>하지만 width 속성과 height 속성, maring 속성을 사용할 때 2가지 형식의 차이를 확인할 수 있다.<br>
&lt;!--inline.html--&gt;

&lt;!DOCTYPE html&gt;
&lt;html&gt;
	&lt;head&gt;
		&lt;title&gt;CSS3 Style Property Basic&lt;/title&gt;
		&lt;style&gt;
			#box {
				display: inline;

				background-color: red;
				width: 300px; height: 50px;
				margin: 10px;
			}
		&lt;/style&gt;
	&lt;/head&gt;
	&lt;body&gt;
		&lt;span&gt;Dummy&lt;/span&gt;
		&lt;div id="box"&gt;
			&lt;span&gt;Lorem ipsum dolor sit amet, consectetur adipiscing elit.&lt;/span&gt;
		&lt;/div&gt;
		&lt;span&gt;Dummy&lt;/span&gt;
	&lt;/body&gt;
&lt;/html&gt;

<br>
&lt;!--inline-block.html--&gt;

&lt;!DOCTYPE html&gt;
&lt;html&gt;
	&lt;head&gt;
		&lt;title&gt;CSS3 Style Property Basic&lt;/title&gt;
		&lt;style&gt;
			#box {
				display: inline-block;

				background-color: red;
				width: 300px; height: 50px;
				margin: 10px;
			}
		&lt;/style&gt;
	&lt;/head&gt;
	&lt;body&gt;
		&lt;span&gt;Dummy&lt;/span&gt;
		&lt;div id="box"&gt;
			&lt;span&gt;Lorem ipsum dolor sit amet, consectetur adipiscing elit.&lt;/span&gt;
		&lt;/div&gt;
		&lt;span&gt;Dummy&lt;/span&gt;
	&lt;/body&gt;
&lt;/html&gt;

<br>inline 키워드를 적용한 코드는 width 속성과 height 속성이 적용되지 않는다. 또한 margin 속성이 div 태그의 좌우로만 지정된다.<br>반면에 inline-block 키워드를 적용하면 width 속성과 height 속성을 적용할 수 있다. 또한 margin 속성이 상하좌우로 적용된다. 이러한 특징은 block 키워드와 동일하다.<br><br>visiblity 속성은 대상을 보이거나 보이지 않게 지정하는 스타일 속성이다. visibility 속성에는 다음과 같은 키워드들을 사용한다.<br><br>위 절에서 살펴본 display 속성의 none 키워드도 대상을 화면에서 보이지 않게 만든다. 따라서 display 속성의 none 키워드와 visibility 속성의 hidden 키워드의 차이를 아는 것이 중요하다.<br>none 키워드를 사용하면 해당 블록이 완전히 사라지지만, hidden 키워드를 사용하면 해당 블록의 공간 자체는 남아있고 내용물만 보이지 않게 된다는 차이점이 있다.<br>

visibility의 다른 키워드인 hidden도 table에 적용하는 것이 가능하다. 하지만 hidden은 내용물을 보이지 않게 할 뿐 표의 공간 자체는 남아있는 반면, collapse 속성은 none과 같이 표 자체를 없애버린다는 차이점이 있다.
<br>
&lt;!--collapse.html--&gt;

&lt;!DOCTYPE html&gt;
&lt;html&gt;
	&lt;head&gt;
		&lt;title&gt;CSS3 Selector Basic Page&lt;/title&gt;
		&lt;style&gt;
			table {
				visibility: collapse;
			}
		&lt;/style&gt;
	&lt;/head&gt;
	&lt;body&gt;
		&lt;p&gt;Lorem ipsum dolor sit amet, consectetur adipiscing elit.&lt;/p&gt;
		&lt;table&gt;
			&lt;tr&gt;&lt;td&gt;TEST&lt;/td&gt;&lt;td&gt;Test&lt;/td&gt;&lt;/tr&gt;
			&lt;tr&gt;&lt;td&gt;TEST&lt;/td&gt;&lt;td&gt;Test&lt;/td&gt;&lt;/tr&gt;
			&lt;tr&gt;&lt;td&gt;TEST&lt;/td&gt;&lt;td&gt;Test&lt;/td&gt;&lt;/tr&gt;
		&lt;/table&gt;
		&lt;p&gt;Lorem ipsum dolor sit amet, consectetur adipiscing elit.&lt;/p&gt;
	&lt;/body&gt;
&lt;/html&gt;

<br><br>opacity 속성은 태그의 투명도를 조절하는 스타일 속성이다. opacity 속성에는 0.0부터 1.0 사이의 숫자를 입력할 수 있으며 0.0은 완전히 투명한 상태를 나타내고 1.0은 완전히 불투명한 상태를 나타낸다.<br>예를 들어 아래처럼 0.2를 적용하면 약간 투명한 상태로 보인다.<br>
&lt;!--opacity.html--&gt;

&lt;!DOCTYPE html&gt;
&lt;html&gt;
	&lt;head&gt;
		&lt;title&gt;CSS3 Basic Page&lt;/title&gt;
		&lt;style&gt;
			#box {
				background-color: black;
				color: white;

				opacity: 0.2;
			}
		&lt;/style&gt;
	&lt;/head&gt;
	&lt;body&gt;
		&lt;div id="box"&gt;lorem ipsum dolor sit amet,
			consectetur adipiscing elit.
		&lt;/div&gt;
	&lt;/body&gt;
&lt;/html&gt;

<br><br>박스 속성은 웹 페이지의 레이아웃을 구성할 때 가장 중요한 스타일 속성이다. CSS는 다음과 같은 속성을 모두 합쳐 박스 속성이라고 이야기한다.<br>
<br>margin
<br>border
<br>padding
<br>height
<br>width
<br>테두리 border 속성은 내용이 많으므로 다음 절에서 다루도록 한다. 이 절에서는 width 속성, height 속성, margin 속성, padding 속성을 알아보도록 한다.<br><br>width 속성과 height 속성은 글자를 감싸는 영역의 크기를 지정하는 스타일 속성이다. <br>
&lt;!--width_height.html--&gt;

&lt;!DOCTYPE html&gt;
&lt;html&gt;
	&lt;head&gt;
		&lt;title&gt;CSS Property Basic&lt;/title&gt;
		&lt;style&gt;
			div {
				width: 100px; height: 100px;
				background-color: red;
			}
		&lt;/style&gt;
	&lt;/head&gt;
	&lt;body&gt;
		&lt;div&gt;&lt;/div&gt;
	&lt;/body&gt;
&lt;/html&gt;

<br>코드를 실행하면 div 태그의 너비와 높이가 100픽셀로 지정된다.<br><br>maring 속성은 마진의 너비를 지정하는 속성이고 padding 속성은 패딩의 너비를 지정하는 속성이다.<br>margin과 padding은 영역을 둘러싸는 추가적인 여백이라고 생각될 수 있다.<br>아래의 코드는 margin 속성에 10픽셀을 적용하고 padding 속성에 30픽셀을 적용한다.<br>
&lt;!--margin_padding.html--&gt;

&lt;!DOCTYPE html&gt;
&lt;html&gt;
	&lt;head&gt;
		&lt;title&gt;CSS Property Basic&lt;/title&gt;
		&lt;style&gt;
			div {
				width: 100px; height: 100px;
				background-color: red;

				border: 20px solid black;
				margin: 10px; padding: 30px;
			}
		&lt;/style&gt;
	&lt;/head&gt;
	&lt;body&gt;
		&lt;div&gt;&lt;/div&gt;
	&lt;/body&gt;
&lt;/html&gt;

<br>margin 속성을 사용할 떄 각각의 너비를 별도로 지정할 수 있다. 아래의 예제와 같이 순서대로 크기 단위를 띄워쓰기로 구분해 적용하면 된다.<br>
margin: 10px 20px 30px 40px;

<br>그리고 다음과 같이 margin과 padding 속성에 2개의 값을 적용하는 경우도 있다.<br>
이 경우 2개의 값은 각각 margin과 padding의 세로, 가로 값을 의미한다.<br>
&lt;style&gt;
	div {
		width: 100px; height: 100px;
		background-color: red;

		/* margin: 위아래 왼쪽오른쪽 */
		/* padding: 위아래 왼쪽오른쪽 */
		margin: 0 30px; padding: 0 30px;
	}
&lt;/style&gt;

<br><br>앞 절에서 width 속성과 height 속성은 글자를 감싸는 영역의 크기를 지정하는 스타일 속성이라고 이야기하였다. box-sizing 속성은 이러한 공식을 변경할 수 있는 CSS3 속성이다.<br>box-sizing 속성은 width 속성과 height 속성이 차지하는 범위를 지정한다. box-sizing 속성은 다음의 키워드들을 사용한다.<br>
<br>border-box
<br>content-box
<br>inherit
<br>initial
<br>
&lt;!--box-sizing.html--&gt;

&lt;!DOCTYPE html&gt;
&lt;html&gt;
	&lt;head&gt;
		&lt;title&gt;CSS3 Property Basic&lt;/title&gt;
		&lt;style&gt;
			div{
				margin: 10px; padding: 10px;
				width: 100px; height: 100px;
				border: 10px solid black;
			}

			div:first-child {
				background: red;
				box-sizing: content-box;
			}
			
			div:last-child {
				background: orange;
				box-sizing: border-box;
			}
		&lt;/style&gt;
	&lt;/head&gt;
	&lt;body&gt;
		&lt;div&gt;&lt;/div&gt;
		&lt;div&gt;&lt;/div&gt;
	&lt;/body&gt;
&lt;/html&gt;

<br>content-box 키워드는 기본으로 적용되는 키워드이다. content-box 키워드를 적용하면 width 속성과 height 속성이 글자가 들어가는 영역의 크기를 지정하게 만든다. 따라서 content-box의 너비와 높이는 다음과 같은 공식으로 표기할 수 있다.<br>박스 너비 = width 속성 + 2 x (margin 속성 + border 속성 + padding 속성)<br>
박스 높이 = width 속성 + 2 x (margin 속성 + border 속성 + padding 속성)<br>border-box 키워드는 width속성과 height 속성이 테두리를 포함한 영역의 크기를 지정하게 만든다. 따라서 생성되는 영역의 전체 너비와 높이는 다음과 같은 공식으로 표기할 수 있다.<br>박스 너비 = width 속성 + 2 x margin 속성<br>
박스 높이 = height 속성 + 2 x margin 속성<br><br>테두리 속성은 원래 박스 속성이다. 하지만 분량이 굉장히 많은 관계로 별도로 분류하였다.<br><br>이번 주제에서는 border-width 속성과 border-style 속성을 살펴본다.<br>우선 border-width 속성은 테두리의 너비를 지정하는 스타일 속성이다.<br>
border-style 속성은 테두리의 형태를 지정하는 속성이다.<br>아래의 예제를 보자.<br>
&lt;!--border_style.html--&gt;

&lt;!DOCTYPE html&gt;
&lt;html&gt;
	&lt;head&gt;
		&lt;title&gt;CSS3 Property Basic&lt;/title&gt;
		&lt;style&gt;
			.box {
				border-width: thick;
				border-style: dashed;
				border-color: black;
			}
		&lt;/style&gt;
	&lt;/head&gt;
	&lt;body&gt;
		&lt;div class="box"&gt;
			&lt;h1&gt;Lorem ipsum dolor amet&lt;/h1&gt;
		&lt;/div&gt;
	&lt;/body&gt;
&lt;/html&gt;

<br>위 코드를 실행하면 두꺼운 dashed 형태의 검정색 테두리가 형성된다.<br>위 코드를 한 줄로 입력하면 아래와 같이 입력할 수 있다.<br>
&lt;style&gt;
	.box {
		border: thick dashed black;
	}
&lt;/style&gt;

<br>border 속성은 margin 속성과 padding 속성처럼 left, top, right, bottom 부분의 값을 적용할 수 있다.<br>
&lt;style&gt;
	.box {
		border-left: thick dashed black;
	}
&lt;/style&gt;

<br><br>border-radius 속성은  css3에서 추가된 속성이다. border-radius 속성을 사용하면 테두리가 둥근 사각형 또는 원을 만들 수 있다.<br>
&lt;style&gt;
	.box {
		border: thick dashed black;
		border-radius: 20px;
	}
&lt;/style&gt;

<br>다음과 같은 기법들을 적용시킬 수도 있다.<br>
&lt;style&gt;
	.box {
		/*border-width: thick;
		border-style: dashed;
		border-color: black;*/

		/* 한 줄로 입력하려면
		border: thick dashed black;*/

		/* 둥근 모서리 만들기
		border: thick dashed black;
		border-radius: 20px; */

		/* 모서리 각각의 각을 다르게 하기 */
		border: thick dashed black;
		border-radius: 50px 40px 20px 10px;
	}
&lt;/style&gt;

<br><br>배경 속성은 특정 태그의 배경 이미지 또는 색상을 지정하는 스타일 속성이다.<br><br>background-image 속성은 배경에 넣을 그림을 지정하는 스타일 속성이다.<br>
background-image 속성에는 URL 단위 또는 그레이디언트를 입력한다.<br>이 절에서는 URL 단위에 대해서만 다루고 그레이디언트는 나중에 다루도록 한다.<br>
&lt;!--background_image.html--&gt;

&lt;!DOCTYPE html&gt;
&lt;html&gt;
	&lt;head&gt;
		&lt;title&gt;CSS3 property Basic&lt;/title&gt;
		&lt;style&gt;
			body {
				background-image: url('BackgroundFront.png');
			}
		&lt;/style&gt;
	&lt;/head&gt;
	&lt;body&gt;
		
	&lt;/body&gt;
&lt;/html&gt;

<br>위의 예제를 실행시키면 body 태그가 차지하는 영역에 (즉 화면 전체에) 배경 이미지를 적용할 수 있다.<br><br>그림 크기를 조절할 때는 background-size 속성을 사용한다. background-size 스타일 속성은 CSS3에서 추가된 속성이다.<br>background-size 속성에는 크기 단위 또는 키워드를 사용한다.<br>background-size 속성은 1개 또는 2개의 크기 단위를 적용하며 각각 너비와 높이를 의미한다.<br>
&lt;!--background_size.html--&gt;

&lt;!DOCTYPE html&gt;
&lt;html&gt;
	&lt;head&gt;
		&lt;title&gt;CSS3 property Basic&lt;/title&gt;
		&lt;style&gt;
			body {
				background-image: url('BackgroundFront.png');
				background-size: 100%;

				/* 두 번째 속성은 높이를 의미한다. 
				background-size: 100% 250px */
			}
		&lt;/style&gt;
	&lt;/head&gt;
	&lt;body&gt;
		
	&lt;/body&gt;
&lt;/html&gt;

<br><br>background-size 속성에는 contain 키워드와 cover 키워드를 적용할 수 있다.<br>background-size 속성에 contain 키워드를 적용하면 너비를 100%로 적용한 것과 같은 효과를 낸다.<br>
cover 키워드를 적용하면 높이를 100%로 적용한 것과 같은 효과를 낸다.<br><br>background의 높이를 100%보다 작게 주면 그림이 패턴을 이루어 여러 개 출력되는 것을 볼 수 있다. 이는 background-repeat 속성의 기본 키워드가 repeat이므로 나타나느니 형상이다. background-repeat 속성에는 다음의 종류가 있다.<br><br><br>background-attachment 속성은 배경 이미지를 어떠한 방식으로 화면에 붙일 것인지를 지정하는 스타일 속성이다.<br>background-attachment 속성의 기본 키워드는 scroll 키워드이다. scorll 키워드는 화면 스크롤에 따라 배경 이미지가 함께 이동함을 의미한다.<br>fixed 키워드를 사용하면 화면 스크롤 유무에 관계없이 화면에 배경 이미지가 고정된다.<br>
&lt;!--background_attachment.html--&gt;

&lt;!DOCTYPE html&gt;
&lt;html&gt;
	&lt;head&gt;
		&lt;title&gt;CSS3 Property Basic&lt;/title&gt;
		&lt;style&gt;
			body {
				background-color: #E7E7E8;
				background-image: url('BackgroundFront.png'), url('BackgroundBack.png');
				background-size: 100%;
				background-repeat: no-repeat;
				background-attachment: fixed;
			}
		&lt;/style&gt;
	&lt;/head&gt;
	&lt;body&gt;
		&lt;p&gt;very long text&lt;/p&gt;
	&lt;/body&gt;
&lt;/html&gt;

<br><br>background-position 속성에는 다음과 같은 형태로 값을 적용한다.<br>
<br>background-position: 키워드;
<br>background-position: X축 크기;
<br>background-position: X축 크기 Y축 크기;
<br>키워드를 사용하는 경우의 예시를 보자. 다음과 같이 코드를 실행하면 배경 이미지가 아래에 붙는다.<br>
&lt;style&gt;
	body {
		background-color: #E7E7E8;
		background-image: url('BackgroundFront.png'), url('BackgroundBack.png');
		background-size: 100%;
		background-repeat: no-repeat;
		background-attachment: fixed;
		background-position: bottom;
	}
&lt;/style&gt;

<br>2개의 값을 입력하면 각각 X축 위치와 Y축 위치를 적용한다. 다음의 코드는 X축 위치를 0픽셀로 적용하고 Y축 위치를 50%로 적용하는 코드이다.<br>
&lt;style&gt;
	body {
		background-color: #E7E7E8;
		background-image: url('BackgroundFront.png'), url('BackgroundBack.png');
		background-size: 100%;
		background-repeat: no-repeat;
		background-attachment: fixed;
		background-position: 0px 50%;
	}
&lt;/style&gt;

<br><br>지금까지 배운 모든 배경 속성은 background 속성 한 번에 사용할 수 있다.<br>
W3C 표준안은 background 속성에 다음 형태를 입력하라고 지정하고 있다.<br>&lt;final-bg-layer&gt; = &lt;bg-image&gt; || &lt;position&gt; [ / &lt;bg-size&gt; ]? || &lt;repeat-style&gt; || &lt;attachment&gt; || &lt;box&gt;{1,2} || &lt;'background_color'&gt;
<br>실제로는 아래와 같은 형식으로 입력한다.<br><br>폰트 속성은 글자와 관련된 스타일 속성을 의미한다.<br><br>
&lt;!--font-size.html--&gt;

&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
	&lt;title&gt;CSS3 Font Property&lt;/title&gt;
	&lt;style&gt;
		.a { font-size: 32px; }
		.b { font-size: 2em; }
		.c { font-size: large; }
		.d { font-size: small; }
	&lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
	&lt;h1&gt;Lorem imsum&lt;/h1&gt;
	&lt;p class="a"&gt;lorem ipsum&lt;/p&gt;
	&lt;p class="b"&gt;lorem ipsum&lt;/p&gt;
	&lt;p class="c"&gt;lorem ipsum&lt;/p&gt;
	&lt;p class="d"&gt;lorem ipsum&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;

<br><br>font_family 속성에는 사용자 컴퓨터에 설치된 폰트를 사용한다.<br>일반적으로 한 단어로 이루어진 폰트는 따옴표를 사용하지 않는다. 하지만 두 단어 이상으로 이루어지는 폰트는 따옴표를 반드시 사용해야 한다.<br>
&lt;!--font-size.html--&gt;

&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
	&lt;title&gt;CSS3 Font Property&lt;/title&gt;
	&lt;style&gt;
		.font_arial { font-family: Arial; }
		.font_roman { font-family: 'Times New Roman'; }
	&lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
	&lt;h1 class="font_arial"&gt;Lorem imsum&lt;/h1&gt;
	&lt;p class="font_roman"&gt;Lorem ipsum&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;

<br>폰트를 적용할 때는 주의할 점이 있다. 개발하고 있는 우리의 컴퓨터에는 설치되어 있지만 우리가 개발한 웹 페이지를 사용할 사용자에게는 폰트가 설치되어 있지 않을 수 있다.<br>일반적으로 이러한 문제를 예방하고자 font-family 속성을 여러 개 사용한다.<br>
&lt;!--font-size.html--&gt;

&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
	&lt;title&gt;CSS3 Font Property&lt;/title&gt;
	&lt;style&gt;
		.font_arial { font-family: '없는 폰트', Arial; }
		.font_roman { font-family: 'Times New Roman', Arial; }
	&lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
	&lt;h1 class="font_arial"&gt;Lorem imsum&lt;/h1&gt;
	&lt;p class="font_roman"&gt;Lorem ipsum&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;

<br>하지만 다국어 웹 페이지를 제공할 경우 사용자에게 무슨 폰트가 있는지 일일이 확인할 수 없다. 이러한 문제를 해결하고자 font-family 속성의 가장 마지막 폰트에는 Serif 폰트(명조체), Sans-serif 폰트(고딕체), Mono space 폰트(고정 폭 글꼴)을 적용한다.<br>이 폰트는 웹 브라우저에서 지정하는 generic-family 폰트라고 부른다.<br><br>font-style 속성과 font-weight 속성은 폰트의 기울기 또는 두께를 조정하는 스타일 속성이다.<br>font-style 속성에는 키워드만을 사용한다.<br>
font-weight 속성에는 단위 또는 키워드를 사용한다.<br>
&lt;!--font_style_weight.html--&gt;

&lt;!DOCTYPE html&gt;
&lt;head&gt;
	&lt;head&gt;
		&lt;title&gt;CSS3 Font Property&lt;/title&gt;
		&lt;style&gt;
			.font_big { font-size: 2em; }
			.font_italic { font-style: italic; }
			.fint_bold { font-weight: bold; }
		&lt;/style&gt;
	&lt;/head&gt;
	&lt;body&gt;
		&lt;p class="font_big font_italic font_bold"&gt;Lorem ipsum dolor amet&lt;/p&gt;
	&lt;/body&gt;
&lt;/head&gt;

<br>일반 폰트의 두꼐는 400이고 두꺼운 폰트의 두께는 700이다. 또한 두께를 지원하지 않는 폰트는 font-weight 속성을 사용해 두께를 조절할 수 없다.<br><br>line-height 속성은 글자의 높이를 지정한다. 현대의 HTML 페이지는 문서의 형태보다 애플리케이션의 형태로 사용하므로 글자의 높이를 지정하는 기능보다 글자를 수직 중앙 정렬할 때 사용한다.<br>CSS는 block 형식을 가지는 태그를 수직 정렬할 수 있는 스타일 속성이 없다. 따라서 대체 방안으로 line-height 속성을 사용한다.<br>
&lt;!--align_button.html--&gt;

&lt;!DOCTYPE html&gt;
&lt;html&gt;
	&lt;head&gt;
		&lt;title&gt;CSS3 Font Property&lt;/title&gt;
		&lt;style&gt;
			.font_big { font-size: 2em; }
			.font_italic { font-style: italic; }
			.font_bold { font-weight: bold; }
			.font_center { text-align: center; }

			.button {
				width: 150px;
				height: 70px;
				background-color: #FF6A00;
				border: 10px solid #FFFFFF;
				border-radius: 30px;
				box-shadow: 5px 5px 5px #A9A9A9
			}

			.button &gt; a {
				display: block;
			}
		&lt;/style&gt;
	&lt;/head&gt;
	&lt;body&gt;
		&lt;div class="button"&gt;
			&lt;a href="#" class="font_big font_italic font_bold font_center"&gt;Click&lt;/a&gt;
		&lt;/div&gt;
	&lt;/body&gt;
&lt;/html&gt;

<br><br>text-align은 글자의 정렬을 조작하는 속성이다.<br>
&lt;!--text_align.html--&gt;

&lt;!DOCTYPE html&gt;
&lt;html&gt;
	&lt;head&gt;
		&lt;title&gt;CSS3 Font Property&lt;/title&gt;
		&lt;style&gt;
			.font_big { font-size: 2em; }
			.font_italic { font-style: italic; }
			.font_bold { font-weight: bold; }
			.font_center { text-align: center; }
			.font_right { text-align: right; }
		&lt;/style&gt;
	&lt;/head&gt;
	&lt;body&gt;
		&lt;p class="font_big font_italic font_bold font_center"&gt;Lorem ipsum dolor amet&lt;/p&gt;
		&lt;p class="font_bold font_right"&gt;2012.04.21&lt;/p&gt;
		&lt;p&gt;Lorem ipsum dolor sit amet, consectetur adipiscing elit.&lt;/p&gt;
	&lt;/body&gt;
&lt;/html&gt;

<br>

text-align은 span 태그를 대상으로 동작하지 않는다. 왜냐하면 너비가 없으므로 중앙이라는 개념이 존재하지 않기 때문이다. 마찬가지로 inline 형식의 태그는 text-align을 적용할 수 없다.
<br><br>text-decoration 속성은 링크의 밑줄을 지우는데 사용된다.<br>
&lt;!--text_decoration.html--&gt;

&lt;!DOCTYPE html&gt;
&lt;html&gt;
	&lt;head&gt;
		&lt;title&gt;CSS3 Font Property&lt;/title&gt;
		&lt;style&gt;
			a { text-decoration: none; }
		&lt;/style&gt;
	&lt;/head&gt;
	&lt;body&gt;
		&lt;h1&gt;
			&lt;a href="#"&gt;Lorem ipsum dolor amet&lt;/a&gt;
		&lt;/h1&gt;
	&lt;/body&gt;
&lt;/html&gt;

<br>text-decoration 속성으로는 밑줄만 제거되며 색상은 color 속성을 사용해 별도로 적용해야 한다.<br><br>프로그램을 개발할 때는 요소의 위치를 2가지 방법으로 설정한다.<br>
<br>절대 위치 좌표 : 요소의 X 좌표와 Y 좌표를 설정해 절대 위치를 지정한다.
<br>상대 위치 좌표 : 요소를 입력한 순서를 통해 상대적으로 위치를 지정한다.
<br>절대 위치 좌표는 드래그해서 만들 수 있으므로 상대 위치 좌표보다 개발하기 쉽다.<br>
하지만 상대 위치 좌표가 훨씬 많이 사용된다. 예를 들어 안드로이드폰은 다양한 회사에서 만드므로 화면의 해상도가 다양하다. 따라서 안드로이드는 상대 위치 좌표를 사용해 개발한다. HTML 페이지도 사용자가 다양한 화면 크기로 실행할 수 있으므로 상대 위치 좌표를 사용한다.<br>일반적으로 절대 위치 좌표는 특정 크기의 영역을 지정한 태그 내부에서만 사용한다.<br><br>HTML 태그의 위치 설정 방법을 변경할 때는 position 속성을 사용한다.<br>상대 위치 좌표를 사용할 때는 position 속성에 static 키워드 또는 relative 키워드를 적용한다. static 키워드를 적용하면 태그가 "위에서 아래로"와 "왼쪽에서 오른쪽으로" 순서에 맞게 배치된다(direction 속성을 사용해 "오른쪽에서 왼쪽"으로 변경할 수 있다.)<br>relative 키워드를 적용하면 static 키워드로 초기 위치가 지정된 상태에서 상하좌우로 이동할 수 있다. 반면에 절대 위치 좌표를 사용할 때는 position 속성에 absolute 키워드 또는 fixed 키워드를 적용한다.<br><br>
&lt;!--absolute.html--&gt;

&lt;!DOCTYPE html&gt;
&lt;html&gt;
	&lt;head&gt;
		&lt;title&gt;CSS3 Property Basic&lt;/title&gt;
		&lt;style&gt;
			.box {
				width: 100px; height: 100px;
				position: absolute;
			}
			.red { background-color: red; }
			.green { background-color: green; }
			.blue { background-color: blue; }
		&lt;/style&gt;
	&lt;/head&gt;
	&lt;body&gt;
		&lt;div class="box red"&gt;&lt;/div&gt;
		&lt;div class="box green"&gt;&lt;/div&gt;
		&lt;div class="box blue"&gt;&lt;/div&gt;
	&lt;/body&gt;
&lt;/html&gt;

<br>위 코드는 어떤 브라우저로 실행시키냐에 따라서 결과가 상이할 수 있다.<br>
모든 브라우저의 출력 방식을 통일하려면 아래와 같은 스타일 속성을 함께 사용해야 한다.<br>
<br>top
<br>left
<br>right
<br>bottom
<br>
&lt;!--absolute.html--&gt;

&lt;!DOCTYPE html&gt;
&lt;html&gt;
	&lt;head&gt;
		&lt;title&gt;CSS3 Property Basic&lt;/title&gt;
		&lt;style&gt;
			.box {
				width: 100px; height: 100px;
				position: absolute;
			}
			.red { background-color: red;
				left: 100px; top: 10px; }
			.green { background-color: green;
				left: 50px; top: 50px; }
			.blue { background-color: blue;
				left: 90px; top: 90px; }
		&lt;/style&gt;
	&lt;/head&gt;
	&lt;body&gt;
		&lt;div class="box red"&gt;&lt;/div&gt;
		&lt;div class="box green"&gt;&lt;/div&gt;
		&lt;div class="box blue"&gt;&lt;/div&gt;
	&lt;/body&gt;
&lt;/html&gt;

<br><br>위 예제에서는 뒤에 입력한 파란색 사각형이 위로 올라온다. 이러한 순서를 변경하고 싶을 때는 z-index 속성을 사용한다. z-index 속성에는 숫자를 적용하며 숫자가 클수록 앞에 위치한다.<br>아래의 코드는 각각의 태그의 z-index 속성에 100, 10, 1을 적용하였다.<br>
&lt;!--z-index.html--&gt;

&lt;!DOCTYPE html&gt;
&lt;html&gt;
	&lt;head&gt;
		&lt;title&gt;CSS3 Property Basic&lt;/title&gt;
		&lt;style&gt;
			.box {
				width: 100px; height: 100px;
				position: absolute;
			}
			.box:nth-child(1) { 
				background-color: red;
				left: 10px; top: 10px;
			
				z-index: 100;
			}
			.box:nth-child(2) { 
				background-color: green;
				left: 50px; top: 50px; 
			
				z-index: 10;
			}
			.box:nth-child(3) { 
				background-color: blue;
				left: 90px; top: 90px;
			
				z-index: 1;
			}
		&lt;/style&gt;
	&lt;/head&gt;
	&lt;body&gt;
		&lt;div class="box red"&gt;&lt;/div&gt;
		&lt;div class="box green"&gt;&lt;/div&gt;
		&lt;div class="box blue"&gt;&lt;/div&gt;
	&lt;/body&gt;
&lt;/html&gt;

<br>직전의 예제와 달리 빨간색 박스가 제일 앞쪽에 위치하는 것을 볼 수 있다.<br><br>position 속성에 absolute 키워드를 적용하면 부모 태그가 영역을 차지하지 않는다. 따라서 자손의 position 속성에 absolute 키워드를 적용할 경우는 부모 태그에 몇 가지 처리를 해야 한다.<br>이 문제를 해결할 때는 다음의 공식을 사용한다.<br>자손의 position 속성에 absolute 키워드를 적용하면 부모는 height 속성을 사용한다<br>이렇게 하면 부모 태그가 영역을 차지하게 만들 수 있다. 아래의 코드처럼 width 속성과 height 속성을 사용한다.<br>그리고 2번째 문제가 있다. 자손 요소들(박스들)이 부모의 위치를 기준으로 위치를 잡지 않는다는 것이다. 이 문제를 해결할 때는 다음의 방법을 사용한다.<br>자손의 position 속성에 absolute 키워드를 적용하면 부모의 position 속성에 relative 키워드를 적용한다.<br>이렇게 하면 자손 태그가 부모의 위치를 기준으로 절대 좌표를 설정한다. 이 공식에 따라서 div 태그에 position 속성을 사용한다.<br>
body &gt; div {
	width: 400px; height: 100px;
	border: 3px solid black;

	position: relative;
}

<br><br>overflow 속성은 내부의 요소가 부모의 범위를 벗어날 때 어떻게 처리할지 지정하는 속성이다.<br>
overflow 속성에는 아래의 표의 키워드를 사용한다.<br><br>다음과 같이 적용할 수 있다.<br>
body &gt; div {
	width: 400px; height: 100px;
	border: 3px solid black;

	position: relative;
	overflow: hidden;
}

<br>
body &gt; div {
	width: 400px; height: 100px;
	border: 3px solid black;

	position: relative;
	overflow: scroll;
}

<br>overflow 속성에 scroll 키워드를 적용하면 무조건 모든 축에 스크롤이 생성된다. 만약 특정한 방향으로만 스크롤을 생성할 때는 overflow-x 속성과 overflow-y 속성을 사용한다.<br>
```html

body &gt; div {
	width: 400px; height: 100px;
	border: 3px solid black;

	position: relative;
	overflow-y: scroll;
}

<br><br>float 속성에는 많은 키워드가 있지만 주로 아래의 키워드만 사용된다,.<br><br><br>float 속성은 부유하는 대상을 만들 때 사용하는 스타일 속성이다.<br>
&lt;!--float.html--&gt;

&lt;!DOCTYPE html&gt;
&lt;html&gt;
	&lt;head&gt;
		&lt;title&gt;Float Style Property&lt;/title&gt;
		&lt;style&gt;
			
		&lt;/style&gt;
	&lt;/head&gt;
	&lt;body&gt;
		&lt;img src="hanbit.jpg" /&gt;
		&lt;p&gt;Lorem ipsum dolor sit amet, consectetur adipiscing elit.&lt;/p&gt;
		&lt;p&gt;In hac habitasse platea dictumst. Donec lobortis angue a metus.&lt;/p&gt;
	&lt;/body&gt;
&lt;/html&gt;

<br>float의 개념을 이해하기 위해 먼저 위의 예제를 실행시켜보자. img 태그는 inline 형식의 태그이고 p태그는  block 형식의 태그이므로 그림과 글자가 분리되어 출력한다.<br>이제 float 속성을 적용시켜보자.<br>
&lt;style&gt;
	img {
		float: left;
	}
&lt;/style&gt;

<br>이미지가 글자 위에 부유하고 있는 모습을 볼 수 있을 것이다.<br><br>float 속성을 사용하면 태그를 수평으로 정렬할 수 있다. float 속성을 사용해 수평 정렬할 때는 주의할 점이 있으므로 아래처럼 div 태그에 각각의 태그를 구분할 수 있는 숫자를 입력한다.<br>
 &lt;!--body 태그 구성--&gt;

&lt;body&gt;
	&lt;div class="box"&gt;1&lt;/div&gt;
	&lt;div class="box"&gt;2&lt;/div&gt;
&lt;/body&gt;

<br>스타일시트에는 float 속성에 각각의 키워드를 적용한다.<br>
&lt;style&gt;
	.box {
		width: 100px; height: 100px;
		background-color: red;
		margin: 10px; padding: 10px;

		/* 태그를 왼쪽으로 붙인다. */
		float: left;
	}
&lt;/style&gt;

&lt;style&gt;
	.box {
		width: 100px; height: 100px;
		background-color: red;
		margin: 10px; padding: 10px;

		/* 태그를 오른쪽으로 붙인다. */
		float: right;
	}
&lt;/style&gt;

<br>첫번째 style 블록은 아래와 같은 결과를 뱉는다.<br>
| 1 2     |

<br>두번째 style 블록은 아래와 같은 결과를 뱉는다.<br>
|      1 2 |

<br><br>float 속성을 사용해 레이아웃을 구성할 때는 아래의 공식을 숙지하고 있어야 한다.<br>자손에 float 속성을 적용하면 부모의 overflow 속성에 hidden키워드를 적용한다<br>우선 아래처럼 레이아웃의 기본적인 틀을 입력한다.<br>
&lt;!--rayout.html--&gt;

&lt;!DOCTYPE html&gt;
&lt;html&gt;
	&lt;head&gt;
		&lt;title&gt;CSS3 Property Basic&lt;/title&gt;
		&lt;style&gt;

		&lt;/style&gt;
	&lt;/head&gt;
	&lt;body&gt;
		&lt;div id="header"&gt;&lt;h1&gt;Header&lt;/h1&gt;&lt;/div&gt;
		&lt;div id="navigation"&gt;&lt;h1&gt;Navigation&lt;/h1&gt;&lt;/div&gt;
		&lt;div id="wrap"&gt;
			&lt;div id="aside"&gt;
				&lt;h1&gt;Aside&lt;/h1&gt;
				&lt;p&gt;Lorem ipsum dolor sit amet, consectetur adipiscing elit.&lt;/p&gt;
			&lt;/div&gt;
			&lt;div id="section"&gt;
				&lt;h1&gt;Section&lt;/h1&gt;
				&lt;p&gt;Lorem ipsum dolor sit amet, consectetur adipiscing elit.&lt;/p&gt;
			&lt;/div&gt;
		&lt;/div&gt;
		&lt;div id="footer"&gt;&lt;h1&gt;Footer&lt;/h1&gt;&lt;/div&gt;
	&lt;/body&gt;
&lt;/html&gt;

<br>이제 스타일을 사용한다. 태그에 width 속성을 사용하고 margin-left, margin-right 속성에 auto 키워드를 적용하면 자동으로 중앙 정렬된다.<br>
&lt;style&gt;
	/* body 태그를 중앙 정렬한다 */
	body {
		width: 960px;
		margin: 0 auto;
	}
&lt;/style&gt;

<br>#wrap 태그 내부의 영역은 왼쪽과 오른쪽으로 구분되므로 아래처럼 입력한다.<br>
#aside와 #section 태그에 width 속성과 float 속성을 사용한다.<br>
&lt;style&gt;
	/* body 태그를 중앙 정렬한다 */
	body {
		width: 960px;
		margin: 0 auto;
	}
	#aside {
		width: 200px;
		float: left;
	}
	#section {
		width: 760px;
		float: left;
	}
&lt;/style&gt;

<br>여기까지 실습을 진행했을 때 문제가 하나 있다. footer 태그는 페이지의 가장 하단에 있어야 하는 데 section 블록 밑에 붙어있을 것이다.<br>이는 근본적으로 float 태그가 요소를 부유시키기 때문에 발생하는 일로, 이를 해결하기 위해서는 이 절 맨 처음 서술했던 거처럼 float 속성을 사용한 태그의 부모에 overflow 속성을 사용하고 hidden 키워드를 적용한다.<br>&lt;style&gt;
	/* body 태그를 중앙 정렬한다 */
	body {
		width: 960px;
		margin: 0 auto;
	}
	#aside {
		width: 200px;
		float: left;
	}
	#section {
		width: 760px;
		float: left;
	}
	#wrap { overflow: hidden; }
&lt;/style&gt;

<br><br>그림자 속성은 태그에 그림자를 부여해주는 스타일 속성이다.<br><br>text-shadow 속성은 글자에 그림자를 부여하는 스타일 속성이다. 아래의 그림의 형태로 값을 적용한다.<br>
text-shadow: &lt;오른쪽&gt; &lt;아래&gt; &lt;흐림도&gt; &lt;색상&gt;

<br>
&lt;!--text-shadow.html--&gt;

&lt;!DOCTYPE html&gt;
&lt;html&gt;
	&lt;head&gt;
		&lt;title&gt;CSS3 Property Basic&lt;/title&gt;
		&lt;style&gt;
			h1 {
				text-shadow: 5px 5px 5px black;
			}
		&lt;/style&gt;
	&lt;/head&gt;
	&lt;body&gt;
		&lt;h1&gt;Lorem ipsum dolor amet&lt;/h1&gt;
	&lt;/body&gt;
&lt;/html&gt;

<br><br>box-shadow 속성은 박스에 그림자를 부여하는 속성이다. 아래의 형태로 값을 적용한다.<br>
box-shadow: &lt;오른쪽&gt; &lt;아래&gt; &lt;흐림도&gt; &lt;색상&gt;

<br>
&lt;!--text-shadow.html--&gt;

&lt;!DOCTYPE html&gt;
&lt;html&gt;
	&lt;head&gt;
		&lt;title&gt;CSS3 Property Basic&lt;/title&gt;
		&lt;style&gt;
			div {
				border: 3px solid black;
				box-shadow: 10px 10px 30px black;
				text-shadow: 5px 5px 5px black;
			}
		&lt;/style&gt;
	&lt;/head&gt;
	&lt;body&gt;
		&lt;div&gt;
			&lt;h1&gt;Lorem ipsum dolor amet&lt;/h1&gt;
		&lt;/div&gt;
	&lt;/body&gt;
&lt;/html&gt;

<br><br>그림자 속성은 쉼표를 사용해 여러 개의 그림자 키워드를 사용할 수 있다.<br>
&lt;style&gt;
	div {
		border: 3px solid black;
		box-shadow: 10px 10px 10px black, 10px 10px 20px orange, 10px 10px 30px red;
		text-shadow: 10px 10px 10px black, 10px 10px 20px orange, 10px 10px 30px red;
	}
&lt;/style&gt;

<br><br><a data-tooltip-position="top" aria-label="https://css3generator.com/" rel="noopener nofollow" class="external-link" href="https://css3generator.com/" target="_blank">css3 생성기</a><br><br>벤더 프리픽스 Vender Prefix는 웹 브라우저 공급 업체에서 제공하며, 실험적인 기능이 필요할 때 사용한다.<br>
실험적인 기능은 웹 브라우저가 무턱대고 추가하기에는 무리가 있다.<br>하지만 다른 웹 브라우저를 이기려면 새로운 기능을 모두 제공해야 하므로 벤더 프리픽스를 사용해 지원한다. 아래는 벤더 프리픽스를 사용해 변환 효과를 적용하는 스타일 시트이다.<br>
&lt;!--bender-prefix.html--&gt;

&lt;style&gt;
	input[type=checkout]:checked + div {
		height: 0px;
	}

	div {
		overflow: hidden;
		width: 650px; height: 300px;

		/* 변환 효과를 적용한다 */
		-ms-transition-duration: 1s;
		-webkit-transition-duration: 1s;
		-moz-transition-duration: 1s;
		-o-transition-duration: 1s;
		transition-duration: 1s;
	}
&lt;/style&gt;

<br>위 예제에서 transition-duration 속성 앞에 붙어 있는 글자들이 벤더 프리픽스이다.<br><br>그레이디언트는 2가지 이상의 색상을 혼합해서 채색하는 기능이다.<br>CSS3에서 그레이디언트를 구현하기 위한 형식은 복잡하므로 다음과 같은 <a data-tooltip-position="top" aria-label="https://www.colorzilla.com/gradient-editor/" rel="noopener nofollow" class="external-link" href="https://www.colorzilla.com/gradient-editor/" target="_blank">자동화 도구</a>의 힘을 빌리는 것이 좋다.<br>
 &lt;!--gradient.html--&gt;

&lt;!DOCTYPE html&gt;
&lt;html&gt;
	&lt;head&gt;
		&lt;title&gt;CSS3 Style Property Basic&lt;/title&gt;
		&lt;style&gt;
			div {
				font-family: 'Times New Roman';
				height: 60px;
				line-height: 60px;
				text-align: center;

				/* Permalink - use to edit and share this gradient: https://colorzilla.com/gradient-editor/#1e5799+0,2989d8+50,207cca+51,7db9e8+100;Blue+Gloss+Default */
				background: linear-gradient(to bottom,  #1e5799 0%,#2989d8 50%,#207cca 51%,#7db9e8 100%); /* W3C, IE10+, FF16+, Chrome26+, Opera12+, Safari7+ */
			}
		&lt;/style&gt;
	&lt;/head&gt;
	&lt;body&gt;
		&lt;div&gt;
			&lt;h1&gt;CSS3 Gradient&lt;/h1&gt;
		&lt;/div&gt;
	&lt;/body&gt;
&lt;/html&gt;

<br>그레이디언트를 구현하기 위해 사용되는 linear-gradient() 함수는 아래와 같은 형식으로 입력한다.<br>
linear-gradient(&lt;각도&gt;, &lt;색상 블록 - 색상, 위치&gt;, &lt;색상 블록 - 색상, 위치&gt;)

<br><br>참고자료<br><a href=".?query=tag:참고도서\모던_웹_디자인을_위한_HTML5_CSS3_입문" class="tag" target="_blank" rel="noopener nofollow">#참고도서/모던_웹_디자인을_위한_HTML5_CSS3_입문</a> <br>]]></description><link>resource\web\css\css3-스타일-속성-기본.html</link><guid isPermaLink="false">resource/Web/CSS/CSS3 스타일 속성 기본.md</guid><pubDate>Tue, 21 Jan 2025 06:39:05 GMT</pubDate></item><item><title><![CDATA[HTML]]></title><description><![CDATA[<a class="tag" href="?query=tag:web" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#web</a> <a class="tag" href="?query=tag:network" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#network</a> <a class="tag" href="?query=tag:language/html" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#language/html</a> <a class="tag" href="?query=tag:참고도서/모던_웹_디자인을_위한_HTML5_CSS3_입문" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/모던_웹_디자인을_위한_HTML5_CSS3_입문</a> 
 <br><br><a href=".?query=tag:web" class="tag" target="_blank" rel="noopener nofollow">#web</a> <a href=".?query=tag:network" class="tag" target="_blank" rel="noopener nofollow">#network</a> <a href=".?query=tag:language\html" class="tag" target="_blank" rel="noopener nofollow">#language/html</a><br>hyper text markup language<br><br><br>현재의 HTML 표준은 HTML5이다. HTML5는 이전 표준과 비교하였을 때 아래와 같은 차별점을 가지고 있다.<br><br>동영상이나 음악을 재생할 수 있다.<br><br>하드웨어의 가속을 받아 2차원 그래픽과 3차원 그래픽을 구현할 수 있다.<br>2차원 그래픽의 구현을 위해 아래의 방법을 사용할 수 있다.<br>
<br>SVG 태그를 이용한 2차원 벡터 그래픽 구현
<br>자바스크립트 캔버스를 사용한 2차원 래스터 그래픽 구현
<br>3차원 그래픽을 구현하는 방법은 아래와 같다.<br>
<br>CSS3를 사용한 3차원 구현
<br>자바스크립트 WebGL을 사용한 3차원 구현
<br><br>서버와 소켓 통신을 할 수 있다.<br><br>장치에 접근하여 장치의 정보와 기능을 사용할 수 있다.<br>
예를 들어 스마트폰의 배터리 잔량과 같은 정보를 가져오거나 진동벨을 울릴 수 있다.<br><br>인터넷에 연결되지 않은 상태에서도 애플리케이션이 동작할 수 있다.<br><br>시멘틱 태그를 제공한다.<br>시멘틱 태그는 시멘틱 웹의 구현을 위해 존재한다.<br>
시멘틱 웹이란 검색 엔진 같은 프로그램이 정보의 의미를 분석하고 자료를 검색 및 처리하여 제공하는 지능형 웹을 의미한다.<br>
시멘틱 Sementic은 사전적으로 '의미론적인'이라는 뜻이다.
<br><br>CSS3 스타일 시트를 완벽하게 지원한다. CSS3 스타일시트를 통해 3차원 변환은 물론 애니메이션 효과를 적용할 수 있다.<br><br>추가 기능을 사용하여 웹의 성능을 극대화할 수 있다. 예를 들어 웹 워커를 사용하면 사용자의 화면이 멈추는 일 없이 연산을 처리할 수 있다.<br><br>HTML 5를 공부하려면 기본적으로 <a data-href="HTML 태그, 요소 그리고 속성" href="resource\web\html\html-태그,-요소-그리고-속성.html" class="internal-link" target="_self" rel="noopener nofollow">HTML 태그, 요소 그리고 속성</a>이라는 용어를 알아야한다.<br><br>HTML 페이지는 다음과 같은 방법을 사용해 주석을 입력한다.<br>
&lt;!-- 주석 --&gt;

<br><br>이제부터 HTML 페이지의 기본적인 구조를 알아보자. 모든 HTML5 페이지는 다음 코드에서 시작한다.<br>
&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
	&lt;title&gt;HTML5 Basic Page&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;/body&gt;
&lt;/html&gt;

<br><br>참고자료<br><a href=".?query=tag:참고도서\모던_웹_디자인을_위한_HTML5_CSS3_입문" class="tag" target="_blank" rel="noopener nofollow">#참고도서/모던_웹_디자인을_위한_HTML5_CSS3_입문</a> <br>]]></description><link>resource\web\html\html.html</link><guid isPermaLink="false">resource/Web/HTML/HTML.md</guid><pubDate>Sat, 22 Mar 2025 07:31:51 GMT</pubDate></item><item><title><![CDATA[HTML 태그, 요소 그리고 속성]]></title><description><![CDATA[<a class="tag" href="?query=tag:web" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#web</a> <a class="tag" href="?query=tag:language/html" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#language/html</a> <a class="tag" href="?query=tag:참고도서/모던_웹_디자인을_위한_HTML5_CSS3_입문" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/모던_웹_디자인을_위한_HTML5_CSS3_입문</a> 
 <br><br><a href=".?query=tag:web" class="tag" target="_blank" rel="noopener nofollow">#web</a> <a href=".?query=tag:language\html" class="tag" target="_blank" rel="noopener nofollow">#language/html</a><br>tag <br><br><br><a data-tooltip-position="top" aria-label="HTML" data-href="HTML" href="resource\web\html\html.html" class="internal-link" target="_self" rel="noopener nofollow">HTML5</a> 페이지는 사용자에게 보이는 뷰와 사용자에게 보이지 않는 코드로 나누어진다.<br>
지금부터 살펴볼 HTML 태그는 사용자에게 보이는 뷰를 만들 때 사용한다.<br>태그는 HTML 페이지에서 객체를 만들 때 사용한다. 그리고 태그를 사용해 만들어진 객체를 요소 Element라고 부른다.<br>
&lt;h1&gt;Hello TML5&lt;/h1&gt;

<br>HTML5은 위와 같이 시작 태그와 끝 태그를 별도로 입력하는 요소도 있지만 아래와 같이 시작 태그와 끝 태그를 함께 입력하는 요소도 존재한다.<br>
이렇게 단독으로 사용하는 태그는 HTML5 표기법과 XHTML5 표기법을 사용해 입력한다.<br>왼쪽이 HTML5, 오른쪽이 XHTML5 표기법이다.<br>
&lt;br&gt;&lt;br/&gt;

<br>어떠한 표기법을 사용해도 상관없지만 대부분의 개발자는 XHTML5 방법을 선호한다.<br>일부 태그는 태그 내부에 다른 태그를 넣을 수도 있다.<br>
&lt;article&gt;
	&lt;h1&gt;Article Header&lt;/h1&gt;
	&lt;p&gt;Lorem ipsum dolor sit amet.&lt;/p&gt;
&lt;/article&gt;

<br><br>상술했듯이, 일부 태그는 다른 태그 내부에 위치할수도 있다. 이 때, 어떤 태그의 한 단계 아래에 위치한 태그를 자손이라고 하고, 어떤 태그 하위에 위치한 모든 태그를 후손이라고 부른다.<br>
&lt;!--child_grandchild.html--&gt;

&lt;!DOCTYPE html&gt;

&lt;html&gt;
	&lt;head&gt;&lt;title&gt;chile, grandchild&lt;/title&gt;&lt;/head&gt;]
	&lt;body&gt;
		&lt;div&gt;
			&lt;h1&gt;CSS3 Selector Basic&lt;/h1&gt;
			&lt;h2&gt;Lorem ipsum&lt;/h2&gt;
			&lt;ul&gt;
				&lt;li&gt;universal selector&lt;/li&gt;
				&lt;li&gt;type selector&lt;/li&gt;
				&lt;li&gt;id &amp; class selector&lt;/li&gt;
			&lt;/ul&gt;
		&lt;/div&gt;
	&lt;/body&gt;
&lt;/html&gt;

<br><br>태그들이 같은 깊이에 위치할 경우 이를 동위 관계에 있다고 한다. 예를 들어, 아래의 코드에서 &lt;li&gt; 태그들은 모두 서로 동위 관계에 있다.<br>
&lt;body&gt;
	&lt;ul&gt;
		&lt;li&gt;CSS3 Selector Basic&lt;/li&gt;
		&lt;li&gt;CSS3 Selector Basic&lt;/li&gt;
		&lt;li&gt;CSS3 Selector Basic&lt;/li&gt;
		&lt;li&gt;CSS3 Selector Basic&lt;/li&gt;
		&lt;li&gt;CSS3 Selector Basic&lt;/li&gt;
	&lt;/ul&gt;
&lt;/body&gt;

<br><br>태그에 추가 정보를 부여할 때는 속성을 사용한다.<br>아래의 예시에서 title이 속성 이름, header가 속성 값, 그리고 이 둘을 통틀어서 속성 블록이라 한다.<br>
Hello HTML5는 내부 문자라고 한다.<br>
&lt;h1 title="header"&gt;Hello HTML5&lt;/h1&gt;

<br>내부 문자를 갖지 않는 태그도 아래와 같이 속성을 사용할 수 있다.<br>
&lt;img src="image.png"/&gt;

<br><br><br>
&lt;!DOCTYPE html&gt;

<br>모든 HTML 페이지의 첫 줄에 오는 태그이다. 웹 브라우저가 현재 웹 페이지가 HTML5 문서임을 인식하게 만들어준다.<br>W3C의 HTML5 명세에 따르면 모든 HTMl5 문서는 반드시 이 태그를 표기해야 한다.<br>
또한 반드시 문서의 가장 첫 번째 줄에 있어야 한다.<br><br>모든 HTML 페이지의 루트 요소이다.<br>
모든 HTML 페이지는 html 태그 내부에 작성할 수 있다.<br>
html 태그에는 lang 속성을 입력할 수 있다.<br>
&lt;html lang="ko"&gt;

<br>lang 속성에는 다음과 같은 속성 값이 올 수 있다.<br><br>lang 속성은 실제 웹 브라우저가 동작하는 데 어떠한 영향도 끼치지 않는다. 대신 구글과 같은 검색 엔진이 웹 페이지를 탐색할 때 해당 웹 페이지가 어떤 언어로 만들어져 있는지 쉽게 인식하게 만든다.<br>전 세게적인 데이터 네트워크 구축을 위해서는 lang 속성을 입력하는 것이 좋다.<br><br>body 태그는 사용자에게 보여지는 실제 부분이며, head 태그는 body 태그에서 필요한 스타일시트와 자바스크립트를 제공하는 데 사용한다.<br><br>head 태그 내부에는 다음 태그만 입력할 수 있다. 아래의 표 이외의 태그를 넣으면 웹 브라우저가 자동으로 해당 태그를 body 태그 내부로 옮긴다.<br><br><br><br>HTML5의 대표적인 글자 태그는 제목을 입력할 때 사용하는 제목 글자 태그이다.<br>
HTML5는 h1 ~ h6까지의 제목 글자 태그를 제공한다. h 뒤의 숫자는 글자의 크기 및 우선 순위를 나타낸다.<br>
&lt;!--header.html--&gt;

&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
	&lt;title&gt;HTML5 + CSS3 TEXT&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
	&lt;h1&gt;Header 1&lt;/h1&gt;
	&lt;h2&gt;Header 2&lt;/h2&gt;
	&lt;h3&gt;Header 3&lt;/h3&gt;
	&lt;h4&gt;Header 4&lt;/h4&gt;
	&lt;h5&gt;Header 5&lt;/h5&gt;
	&lt;h6&gt;Header 6&lt;/h6&gt;
&lt;/body&gt;
&lt;/html&gt;

<br><br>p 태그는 paragraph의 줄임말이다. paragraph는 단락을 의미하므로 p 태그를 사용하면 하나의 단락을 만들 수 있다.<br>
&lt;!--paragraph.html--&gt;

&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
	&lt;title&gt;HTML TEXT Basic Page&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
	&lt;h1&gt;Lorem ipsum&lt;/h1&gt;
	&lt;p&gt;Lorem ipsum dolor sit amet, consectetur adipiscing elit.&lt;/p&gt;
	&lt;p&gt;Nam commodo mi a lorem congue id rutrum leo venenatis.&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;

<br><br>&lt;br /&gt;와 같이 사용한다. 줄바꿈을 적용한다.<br><br>&lt;hr /&gt;과 같이 사용한다. 수평 줄을 그린다.<br>
&lt;!--paragraph.html--&gt;

&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
&lt;title&gt;HTML TEXT Basic Page&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
	&lt;h1&gt;Lorem ipsum&lt;/h1&gt;
	&lt;h2&gt;dodor sit amet&lt;/h2&gt;
	&lt;hr /&gt;
	&lt;p&gt;Lorem ipsum dolor sit amet, consectetur adipiscing elit.&lt;/p&gt;
	&lt;br /&gt;
	&lt;p&gt;Nam commodo mi a lorem congue id rutrum leo venenatis.&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;

<br><br>앵커 anchor 태그는 서로 다른 웹 페이지 사이를 이동하거나 웹 페이지 내부에서 특정한 위치로 이동할 때 사용되는 태그이다.<br>href 속성을 사용하여 이동하고자 하는 웹페이지를 정확히 지정해야 제대로 작동한다.<br>
&lt;!--anchor.html--&gt;

&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
	&lt;title&gt;HTML TEXT BASIC PAGE&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
	&lt;a href="http://hanbit.co.kr"&gt;Hanbit&lt;/a&gt;&lt;br /&gt;
	&lt;a href="https://github.com/"&gt;GitHub&lt;/a&gt;&lt;br /&gt;
&lt;/body&gt;
&lt;/html&gt;

<br><br>a 태그는 본래 가지고 있는 하이퍼링크 기능을 제거하고 사용하는 경우도 있다. 하지만 하이퍼링크 기능을 제거해도 웹 표준을 따르려면 a 태그에 href 속성을 반드시 입력해야 한다. 따라서 웹 표준을 지키면서 이동하지 않는 a 태그를 만들 때는 href속성에 #을 입력한다. 그리고 이를 빈 링크라고 부른다.<br>
&lt;a href="#"&gt;Empty link&lt;/a&gt;

<br><br>a 태그를 이용하면 현재 페이지 내부에서 원하는 장소로 이동할 수 있다. 이때는 원하는 장소에 id 속성을 부여해야 한다. 코드 2-8처럼 이동하기를 원하는 태그에 id 속성을 부여하고 a 태그의 href 속성에 #아이디 형태의 문자열을 입력한다.<br>
&lt;!--id.html--&gt;

&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;id.html&lt;/head&gt;
&lt;body&gt;
	&lt;a href="#alpha"&gt;Move to Alpha&lt;/a&gt;
	&lt;a href="#beta"&gt;Move tot Beta&lt;/a&gt;
	&lt;a href="#gamma"&gt;Move to Gamma&lt;/a&gt;
	&lt;hr /&gt;
	&lt;h1 id="alpha"&gt;Alpha&lt;/h1&gt;
	&lt;p&gt;Lorem ipsum dolor sit amet, consectetur adipiscing elit.&lt;/p&gt;
	&lt;h1 id="beta"&gt;Beta&lt;/h1&gt;
	&lt;h1 id="gamma"&gt;Gamma&lt;/h1&gt;
	&lt;p&gt;Nullam porta, felis sit amet porttitor vestibulum.&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;

<br>id 속성이 중복되면 먼저 나오는 태그로 이동한다. 하지만 id 속성을 중복해서 사용하는 것은 웹 표준에 어긋나는 행위이므로 지양해야 한다.<br><br>HTML5는 글자 형태 태그를 사용해 웹페이지의 글자와 형태에 의미를 부여한다. 각 글자에 형태 및 의미를 부여할 때는 아래의 표이 태그들을 사용한다.<br><br>
&lt;!--letter_type.html--&gt;

&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
	&lt;title&gt;HTML TXT Basic Page&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
	&lt;h1&gt;&lt;b&gt;Lorem ipsum dolor sit amet&lt;/b&gt;&lt;/h1&gt;
	&lt;h1&gt;&lt;i&gt;Lorem ipsum dolar sit amet&lt;/i&gt;&lt;/h1&gt;
	&lt;h1&gt;&lt;small&gt;Lorem ipsum dolar sit amet&lt;/small&gt;&lt;/h1&gt;
	&lt;h1&gt;&lt;sub&gt;Lorem ipsum dolar sit amet&lt;/sub&gt;&lt;/h1&gt;
	&lt;h1&gt;&lt;sup&gt;Lorem ipsum dolar sit amet&lt;/sup&gt;&lt;/h1&gt;
	&lt;h1&gt;&lt;ins&gt;Lorem ipsum dolar sit amet&lt;/ins&gt;&lt;/h1&gt;
	&lt;h1&gt;&lt;del&gt;Lorem ipsum dolar sit amet&lt;/del&gt;&lt;/h1&gt;
	&lt;hr /&gt;
	&lt;b&gt;Lorem ipsum dolor sit amet&lt;/b&gt;&lt;br /&gt;
	&lt;i&gt;Lorem ipsum dolor sit amet&lt;/i&gt;&lt;br /&gt;
	&lt;small&gt;Lorem ipsum dolor sit amet&lt;/small&gt;&lt;br /&gt;
	&lt;sub&gt;Lorem ipsum dolor sit amet&lt;/sub&gt;&lt;br /&gt;
	&lt;sup&gt;Lorem ipsum dolor sit amet&lt;/sup&gt;&lt;br /&gt;
	&lt;ins&gt;Lorem ipsum dolor sit amet&lt;/ins&gt;&lt;br /&gt;
	&lt;del&gt;Lorem ipsum dolor sit amet&lt;/del&gt;&lt;br /&gt;
&lt;/body&gt;
&lt;/html&gt;

<br>과거에는 이 절의 태그를 많이 사용하였다. 하지만 글자를 기울이거나 굵게 만드는 기능은 모두 스타일시트로 처리하므로 현대에는 잘 사용하지 않는다.<br><br>(생략)<br><br>대부분의 웹페이지에서 자주 사용되는 기능 중 하나는 메뉴 기능이다. 일반적으로 페이지를 이동할 때 사용되는 메뉴를 내비게이션 메뉴라고 한다.<br>내비게이션 메뉴를 만들 때는 아래의 목록 태그들을 활용한다.<br><br>ol 태그는 정렬된 목록 ordered list를 의미하고<br>
ul 태그는 정렬되지 않은 목록 unordered list를 의미한다.<br>
li 태그는 목록 요소 list item를 의미한다.<br>
&lt;!--basic_list.html--&gt;

&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;HTML Basic Page&lt;/head&gt;
&lt;body&gt;
	&lt;h1&gt;ol tag&lt;/h1&gt;
	&lt;ol&gt;
		&lt;li&gt;Facebook&gt;&lt;/li&gt;
		&lt;li&gt;Tweeter&gt;&lt;/li&gt;
		&lt;li&gt;Linked In&lt;/li&gt;
	&lt;/ol&gt;
	&lt;h1&gt;ul tag&lt;/h1&gt;
	&lt;ul&gt;
		&lt;li&gt;Facebook&lt;/li&gt;
		&lt;li&gt;Tweeter&gt;&lt;/li&gt;
		&lt;li&gt;Linked in&lt;/li&gt;
	&lt;/ul&gt;
&lt;/body&gt;
&lt;/html&gt;

<br><br>중첩해서 목록을 만들고 싶을 때는 li 태그 안에 목록 태그를 중첩해서 입력한다.<br>
&lt;!--list_in_list.html--&gt;

&lt;!DOCTYPE html&gt;
&lt;html&gt;
	&lt;body&gt;
	&lt;ul&gt;
		&lt;li&gt;HTML5
			&lt;ol&gt;
				&lt;li&gt;Multimedia Tag&lt;/li&gt;
				&lt;li&gt;Connectivity&lt;/li&gt;
				&lt;li&gt;Device Access&lt;/li&gt;
			&lt;/ol&gt;
		&lt;/li&gt;
		&lt;li&gt;CSS3
			&lt;ul&gt;
				&lt;li&gt;Animation&lt;/li&gt;
				&lt;li&gt;3D Transform&lt;/li&gt;
			&lt;/ul&gt;
		&lt;/li&gt;
	&lt;/ul&gt;
	&lt;/body&gt;
&lt;/html&gt;

<br><br>table 태그는 HTML 페이지에서 표를 만들 때 사용하는 태그이다. 과거에는 테이블 태그를 사용해 레이아웃을 구성하였다. 하지만 현대 웹 페이지의 대부분은 후술할 div 태그를 사용해 레이아웃을 구성하므로 사용 빈도가 굉장히 줄었다.<br>table 태그 안에 입력할 수 있는 태그는 많지만 실제로 많이 쓰이는 태그는 아래의 태그들이다.<br><br>
&lt;!--table.html--&gt;

&lt;!DOCTYPE html&gt;
&lt;html&gt;
	&lt;head&gt;HTML Basic Page&lt;/head&gt;
	&lt;body&gt;
		&lt;table border="1"&gt;
			&lt;tr&gt;
				&lt;th&gt;Header 1&lt;/th&gt;
				&lt;th&gt;Header 2&lt;/th&gt;
			&lt;/tr&gt;
			&lt;tr&gt;
				&lt;td&gt;Data 1&lt;/td&gt;
				&lt;td&gt;Data 1&lt;/td&gt;
			&lt;/tr&gt;
			&lt;tr&gt;
				&lt;td&gt;Data 2&lt;/td&gt;
				&lt;td&gt;Data 2&lt;/td&gt;
			&lt;/tr&gt;
	&lt;/body&gt;
&lt;/html&gt;

<br>table이 가질 수 있는 속성<br><br>th, td 태그가 가질 수 있는 속성<br><br>
&lt;!--table_attribute.html--&gt;

&lt;!DOCTYPE html&gt;
&lt;html&gt;
	&lt;head&gt;HTML Basic Page&lt;/head&gt;
	&lt;body&gt;
		&lt;table border="5"&gt;
			&lt;tr&gt;
				&lt;th colspan="3"&gt;Table Data&lt;/th&gt;
				&lt;th rowspan="3"&gt;Table Data&lt;/th&gt;
			&lt;/tr&gt;
			&lt;tr&gt;
				&lt;td&gt;Table Data&lt;/td&gt;
				&lt;td rowspan="2"&gt;imsTable Data&lt;/td&gt;
				&lt;td&gt;Table Data&lt;/td&gt;
			&lt;/tr&gt;
			&lt;tr&gt;
				&lt;td&gt;Table Data&lt;/td&gt;
				&lt;td&gt;Table Data&lt;/td&gt;
			&lt;/tr&gt;
		&lt;/table&gt;
	&lt;/body&gt;
&lt;/html&gt;

<br><br>이미지를 올리기 위해서는 &lt;img /&gt; 태그를 사용한다.<br>img 태그에서 가장 중요한 속성은 아래의 4가지 속성이다.<br><br>
&lt;!--img.html--&gt;

&lt;!DOCTYPE html&gt;
&lt;html&gt;
	&lt;head&gt;BASIC HTML Page&lt;/head&gt;
	&lt;body&gt;
		&lt;br /&gt;
		&lt;img src="images.jpeg" alt="netcat" width="300" /&gt;
		&lt;img src="Nothing" alt="그림이 존재하지 않습니다." width="300" /&gt;&lt;br /&gt;
	&lt;/body&gt;
&lt;/html&gt;

<br><br>오디오를 올리기 위해서는  &lt;audio /&gt; 태그를 사용한다.<br>아래의 속성들을 사용하여 구체적인 동작을 지정한다.<br><br>
&lt;!--audio.html--&gt;

&lt;!DOCTYPE html&gt;
&lt;html&gt;
	&lt;head&gt;BASIC HTML Page&lt;/head&gt;
	&lt;body&gt;
		&lt;br /&gt;
		&lt;audio src="audio.wav" controls="controls" &gt;&lt;/audio&gt;
	&lt;/body&gt;
&lt;/html&gt;

<br><br><a data-href="HTML" href="resource\web\html\html.html" class="internal-link" target="_self" rel="noopener nofollow">HTML</a> 문서에 나와있듯이 HTML 페이지의 표기법에는 XHTML 표기법과 HTML5 표기법이 있다.<br>방금의 예제와 같이 표기하는 방식이 XHTML5 표기법이다.<br>HTML5 표기법은 아래와 같이 작성한다.<br>
&lt;audio src="audio.wav" controls&gt;&lt;/audio&gt;

<br><br>웹 브라우저에 따라 위의 audio.html 예제가 실행되지 않을수도 있다.<br>
웹 브라우저마다 지원하는 음원 형식 포맷이 다르기 때문이다.<br>이러한 문제를 해결하기 위해 source 태그가 탄생하였다.<br>source 태그는 img 또는 video 안에 입력하는 태그이며 아래의 코드와 같이 사용한다.<br>
&lt;body&gt;
	&lt;audio controls="controls"&gt;
		&lt;source src="audio.mp3" type="audio/mp3" /&gt;
		&lt;source src="audio.ogg" type="audio/ogg" /&gt;
	&lt;/audio&gt;
&lt;/body&gt;

<br>mp3 파일과 ogg 파일을 사용하면 모든 브라우저에서 음악을 재생할 수 있다.<br><br>동영상을 재생하기 위해 video 태그를 사용하여야 한다.<br>video 태그에서 주로 사용되는 특성은 아래와 같다.<br><br>mp4 형식과 webm 형식을 사용하면 모든 브라우저에서 비디오를 재생할 수 있으므로 video, source 태그를 사용하여 아래와 같이 작성한다.<br>
&lt;!--video.html--&gt;

&lt;!DOCTYPE html&gt;
&lt;html&gt;
	&lt;head&gt;BASIC HTML Page&lt;/head&gt;
	&lt;body&gt;
		&lt;br /&gt;vi
		&lt;video controls="controls"&gt;
			&lt;source src="video.mp4" type="video/mp4" /&gt;
			&lt;source src="video.mp4" type="video/webm" /&gt;
		&lt;/video&gt;
	&lt;/body&gt;
&lt;/html&gt;

<br><br>(생략)<br><br>입력 양식은 사용자에게 입력받는 공간을 의미한다. 입력 양식 태그는 입력 양식을 만들 때 사용하는 태그이다.<br>사실 입력 양식을 제대로 다루려면 서버와 관련된 기술을 알아야 한다. 하지만 본문에서 참고한 자료는 입문용이므로 서버와 관련된 기술을 다룰 수 없다. 따라서 입력 양식과 관련된 기본적인 내용만 살펴본다.<br>입력 양식은 form 태그를 사용해 생성한다.<br>
입력 양식 안에는 input 태그를 입력한다.<br>
&lt;!--input.html--&gt;
&lt;!DOCTYPE html&gt;

&lt;html&gt;
&lt;head&gt;BASIC HTML Page&lt;/head&gt;
&lt;body&gt;
	&lt;br /&gt;
	&lt;form&gt;
		&lt;input type="text" name="search" /&gt;
		&lt;input type="submit" /&gt;
	&lt;/form&gt;
&lt;/body&gt;
&lt;/html&gt;

<br>form 태그의 속성 중 일반적으로 쓰이는 속성은 아래와 같다.<br><br>더 깊게 들어가면 클라이언트와 관련된 내용이 아니라 서버와 관련된 내용이므로 차후 보충하도록 하겠습니다.<br><br>input 태그는 방금 말했듯이 사용자로부터 정보를 입력받는 기능을 수행하는 태그이다. 방금 살펴보았던 것처럼 사용자에게 글자를 입력받는 것은 물론 비밀번호와 파일을 입력받을 수도 있다.<br>input 태그의 type 속성값을 지정하므로서 이러한 세부사항들을 설정할 수 있다.<br><br>다음과 같은 예제를 실행하여 결과를 확인해보자.<br>
&lt;!--input2.html--&gt;

&lt;!DOCTYPE html&gt;
&lt;html&gt;
	&lt;head&gt;Basic HTML Page&lt;/head&gt;
	&lt;body&gt;
		&lt;form&gt;
			&lt;input type="text" /&gt;&lt;br /&gt;
			&lt;input type="buttom" /&gt;&lt;br /&gt;
			&lt;input type="checkbox" /&gt;&lt;br /&gt;
			&lt;input type="file" /&gt;&lt;br /&gt;
			&lt;input type="hidden" /&gt;&lt;br /&gt;
			&lt;input type="image" /&gt;&lt;br /&gt;
			&lt;input type="password" /&gt;&lt;br /&gt;
			&lt;input type="radio" /&gt;&lt;br /&gt;
			&lt;input type="reset" /&gt;&lt;br /&gt;
			&lt;input type="submit" /&gt;&lt;br /&gt;
		&lt;/form&gt;
	&lt;/body&gt;
&lt;/html&gt;

<br><br>방금 전에 살펴본 input 태그는 HTML4에서 지원하던 input 태그이다. HTML5는 아래의 표의 type 속성값을 추가로 지원한다.<br><br>
&lt;!--input3.html--&gt;

&lt;!DOCTYPE html&gt;

&lt;html&gt;
&lt;head&gt;BASIC HTML Page&lt;/head&gt;
	&lt;body&gt;
		&lt;form&gt;
			&lt;input type="color" /&gt;&lt;br /&gt;
			&lt;input type="date" /&gt;&lt;br /&gt;
			&lt;input type="datetime" /&gt;&lt;br /&gt;
			&lt;input type="datetime-local" /&gt;&lt;br /&gt;
			&lt;input type="email" /&gt;&lt;br /&gt;
			&lt;input type="month" /&gt;&lt;br /&gt;
			&lt;input type="number" /&gt;&lt;br /&gt;
			&lt;input type="range" /&gt;&lt;br /&gt;
			&lt;input type="search" /&gt;&lt;br /&gt;
			&lt;input type="tel" /&gt;&lt;br /&gt;
			&lt;input type="time" /&gt;&lt;br /&gt;
			&lt;input type="url" /&gt;&lt;br /&gt;
			&lt;input type="week" /&gt;&lt;br /&gt;
		&lt;/form&gt;
	&lt;/body&gt;
&lt;/html&gt;

<br><br>input 양식이 아닌 입력 양식이 2개 있다. textarea 태그와 select 태그이다.<br>textarea 태그는 글상자를 통해 입력을 받게 해주는 태그이다.<br>
textarea 태그는 아래와 같이 사용한다.<br>
&lt;!--textarea.html--&gt;

&lt;!DOCTYPE html&gt;

&lt;html&gt;
	&lt;head&gt;&lt;title&gt;BASCI HTML PAGE&lt;/title&gt;&lt;/head&gt;
	&lt;body&gt;
		&lt;form&gt;
			&lt;textarea&gt;&lt;/textarea&gt;
		&lt;/form&gt;
	&lt;/body&gt;
&lt;/html&gt;

<br>아래의 속성들을 통해 글상자의 크기를 지정할 수 있다.<br><br>마지막으로 textarea 태그 안에 미리 글자를 입력하고 싶으면 아래처럼 태그 사이에 글자를 입력한다.<br>
&lt;!--만약 2줄을 열을 맞춰서 깔끔하게 입력하고 싶다면 아래와 같이 입력해야 한다--&gt;

&lt;body&gt;
	&lt;textarea&gt;글상자
글상자&lt;/textarea&gt;
&lt;/body&gt;

<br><br>select 태그는 여러 개의 목록에서 몇 가지를 선택할 수 있는 입력 양식 요소이다. select 태그를 사용할 때는 아래의 표의 태그는 함께 사용한다.<br><br>select 태그의 multiple 옵션을 체크하므로서 여러개의 선택 항목을 동시에 선택하도록 할 수 있다.<br>
&lt;!--select.html--&gt;

&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;&lt;title&gt;BASIC HTML PAGE&lt;/title&gt;&lt;/head&gt;
	&lt;body&gt;
		&lt;select&gt;
			&lt;option&gt;김밥&lt;/option&gt;
			&lt;option&gt;떡볶이&lt;/option&gt;
			&lt;option&gt;순대&lt;/option&gt;
			&lt;option&gt;오뎅&lt;/option&gt;
		&lt;/select&gt;
		&lt;br /&gt;
		&lt;select multiple="multiple"&gt;
			&lt;optgroup label="HTML5"&gt;
				&lt;option&gt;Multimedia Tag&lt;/option&gt;
				&lt;option&gt;Connectivity&lt;/option&gt;
				&lt;option&gt;Device Access&lt;/option&gt;
			&lt;/optgroup&gt;
			&lt;optgroup label="CSS3"&gt;
				&lt;option&gt;Animation&lt;/option&gt;
				&lt;option&gt;3D Transform&lt;/option&gt;
			&lt;/optgroup&gt;
		&lt;/select&gt;
	&lt;/body&gt;
&lt;/html&gt;

<br>하지만 select 태그는 결과물이 예쁘지 않고, 자바스크립트 등의 대체 수단이 존재하기 때문에 현재에는 거의 사용되지 않는다.<br><br>이 두 태그는 입력 양식을 입력 양식 폼에 넣어 정돈하기 위하여 사용된다.<br>
&lt;!--input_form.html--&gt;

&lt;!DOCTYPE html&gt;
&lt;html&gt;
	&lt;head&gt;&lt;title&gt;BASIC HTML PAGE&lt;/title&gt;&lt;/head&gt;
	&lt;body&gt;
		&lt;form&gt;
			&lt;fieldset&gt;
				&lt;legend&gt;입력 양식&lt;/legend&gt;
				&lt;table&gt;
					&lt;tr&gt;
						&lt;td&gt;&lt;label for="name"&gt;이름&lt;/label&gt;&lt;/td&gt;
						&lt;td&gt;&lt;input id="name" type="text" /&gt;&lt;/td&gt;
					&lt;/tr&gt;
					&lt;tr&gt;
						&lt;td&gt;&lt;label for="mail"&gt;이메일&lt;/label&gt;&lt;/td&gt;
						&lt;td&gt;&lt;input id="mail" type="email" /&gt;&lt;/td&gt;
					&lt;/tr&gt;
				&lt;/table&gt;
				&lt;input type="submit" /&gt;
			&lt;/fieldset&gt;
		&lt;/form&gt;
	&lt;/body&gt;
&lt;/html&gt;

<br><br>공간을 분할하는 이유는 공간을 분할해야 <a data-href="CSS" href="CSS" class="internal-link" target="_self" rel="noopener nofollow">CSS</a>를 사용해 우리가 원하는 레이아웃을 구성할 수 있기 때문이다.<br>대표적인 공간 분할 태그는 div 태그와 span 태그이다.<br><br>
&lt;!--div.html--&gt;

&lt;!DOCTYPE html&gt;
&lt;html&gt;
	&lt;head&gt;&lt;title&gt;basic html page&lt;/title&gt;&lt;/head&gt;
	&lt;body&gt;
		&lt;div&gt;Lorem ipsum&lt;/div&gt;
		&lt;div&gt;Lorem ipsum&lt;/div&gt;
		&lt;div&gt;Lorem ipsum&lt;/div&gt;
		&lt;div&gt;Lorem ipsum&lt;/div&gt;
		&lt;div&gt;Lorem ipsum&lt;/div&gt;
	&lt;/body&gt;
&lt;/html&gt;

<br>block 형식이란 차곡차곡 공간을 분할하는 형식을 말한다.<br>
따라서 글자가 웹 페이지의 너비만큼 차지하면서 쌓아 올려진다.<br>반면 inline 형식은 한 줄 안에 차례차례 위치하는 형식을 말한다.<br>
&lt;!--span.html--&gt;

&lt;!DOCTYPE html&gt;
&lt;html&gt;
	&lt;head&gt;&lt;title&gt;basic html page&lt;/title&gt;&lt;/head&gt;
	&lt;body&gt;
		&lt;span&gt;Lorem ipsum&lt;/span&gt;
		&lt;span&gt;Lorem ipsum&lt;/span&gt;
		&lt;span&gt;Lorem ipsum&lt;/span&gt;
		&lt;span&gt;Lorem ipsum&lt;/span&gt;
		&lt;span&gt;Lorem ipsum&lt;/span&gt;
	&lt;/body&gt;
&lt;/html&gt;

<br><br>div나 span 태그가 아니더라도 block 형식과 inline 형식 둘 중 하나에 속해 웹페이지의 공간을 차지한다.<br><br><br>사람은 눈으로 웹페이지의 레이아웃을 구분하므로 빠르게 구분할 수 있지만 컴퓨터는 그럴 수 없다.<br>따라서 기계적인 검색 엔진은 어떠한 태그가 어떠한 기능을 하는지 분별할 수 없고 웹 페이지에서 데이터를 효율적으로 추출할 수 없다. 이를 해결하고자 특정한 태그에 의미를 부여해 웹 페이지를 만드는 시도가 시작되었다. 이를 시멘틱 웹이라고 한다.<br>그리고 시멘틱 웹을 구현하려고 만들어지 태그가 바로 HTML5 시멘틱 구조 태크이다.<br><br>이 이외에도 많은 시멘틱 태그가 있지만 너무 많으므로 일단 생략한다.<br>시멘틱 태그는 모두 div 태그와 같은 기능을 수행하는 태그이다. 하지만 이전에 언급했던 것처럼 태그는 검색 엔진이나 그 이외의 기계적인 동작들이 웹 페이지를 쉽게 이해할 수 있게 하는 데 의미가 있다.<br>예를 들어 아래의 코드는 HTML5 이전의 레이아웃 구성 방식이다.<br>
&lt;!--non_sementic.html--&gt;

&lt;!DOCTYPE html&gt;
&lt;html&gt;
	&lt;head&gt;
		&lt;title&gt;non semantic&lt;/title&gt;
	&lt;/head&gt;
	&lt;body&gt;
		&lt;div&gt;
			&lt;h1&gt;HTML5 Header&lt;/h1&gt;
		&lt;/div&gt;
		&lt;div&gt;
			&lt;ul&gt;
				&lt;li&gt;&lt;a href="#"&gt;Menu - 1&lt;/a&gt;&lt;/li&gt;
				&lt;li&gt;&lt;a href="#"&gt;Menu - 2&lt;/a&gt;&lt;/li&gt;
				&lt;li&gt;&lt;a href="#"&gt;Menu - 2&lt;/a&gt;&lt;/li&gt;
			&lt;/ul&gt;
		&lt;/div&gt;
		&lt;div&gt;
			&lt;div&gt;
				&lt;h1&gt;Lorem ipsum dolor sit amet&lt;/h1&gt;
				&lt;p&gt;Lorem ipsum dolor sit amet, consectetur adipiscing elit.&lt;/p&gt;
			&lt;/div&gt;
			&lt;div&gt;
				&lt;h1&gt;Lorem ipsum dolor sit amet&lt;/h1&gt;
				&lt;p&gt;Lorem ipsum dolor sit amet, consectetur adipiscing elit.&lt;/p&gt;
			&lt;/div&gt;
		&lt;/div&gt;
		&lt;div&gt;
			&lt;span&gt;서울특별시 강서구 내발산동&lt;/span&gt;
		&lt;/div&gt;
	&lt;/body&gt;
&lt;/html&gt;

<br>
&lt;!--sementic.html--&gt;

&lt;!DOCTYPE html&gt;
&lt;html&gt;
	&lt;head&gt;
		&lt;title&gt;semantic&lt;/title&gt;
	&lt;/head&gt;
	&lt;body&gt;
		&lt;header&gt;
			&lt;h1&gt;HTML5 Header&lt;/h1&gt;
		&lt;/header&gt;
		&lt;nav&gt;
			&lt;ul&gt;
				&lt;li&gt;&lt;a href="#"&gt;Menu - 1&lt;/a&gt;&lt;/li&gt;
				&lt;li&gt;&lt;a href="#"&gt;Menu - 2&lt;/a&gt;&lt;/li&gt;
				&lt;li&gt;&lt;a href="#"&gt;Menu - 2&lt;/a&gt;&lt;/li&gt;
			&lt;/ul&gt;
		&lt;/nav&gt;
		&lt;section&gt;
			&lt;article&gt;
				&lt;h1&gt;Lorem ipsum dolor sit amet&lt;/h1&gt;
				&lt;p&gt;Lorem ipsum dolor sit amet, consectetur adipiscing elit.&lt;/p&gt;
			&lt;/article&gt;
			&lt;article&gt;
				&lt;h1&gt;Lorem ipsum dolor sit amet&lt;/h1&gt;
				&lt;p&gt;Lorem ipsum dolor sit amet, consectetur adipiscing elit.&lt;/p&gt;
			&lt;/article&gt;
		&lt;/section&gt;
		&lt;footer&gt;
			&lt;address&gt;서울특별시 강서구 내발산동&lt;/address&gt;
		&lt;/footer&gt;
	&lt;/body&gt;
&lt;/html&gt;

<br>사람의 눈으로 보아도 각 단락의 역할을 명확하게 구분할 수 있다.<br><br>참고자료<br><a href=".?query=tag:참고도서\모던_웹_디자인을_위한_HTML5_CSS3_입문" class="tag" target="_blank" rel="noopener nofollow">#참고도서/모던_웹_디자인을_위한_HTML5_CSS3_입문</a> <br>]]></description><link>resource\web\html\html-태그,-요소-그리고-속성.html</link><guid isPermaLink="false">resource/Web/HTML/HTML 태그, 요소 그리고 속성.md</guid><pubDate>Tue, 21 Jan 2025 06:14:53 GMT</pubDate></item><item><title><![CDATA[디스트럭처링]]></title><description><![CDATA[<a class="tag" href="?query=tag:language/JavaScript" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#language/JavaScript</a> <a class="tag" href="?query=tag:참고도서/모던_자바스크립트_핵심_가이드" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/모던_자바스크립트_핵심_가이드</a> 
 <br><br><a href=".?query=tag:language\JavaScript" class="tag" target="_blank" rel="noopener nofollow">#language/JavaScript</a> <br>destructuring 비구조화<br><br>디스트럭처링 할당 문법은 배열의 값 또는 객체의 속성을 풀어서 별개의 변수로 쓸 수 있게 해주는 자바스크립트 표현식이다.<br><br>
const person = {
	first: "Alberto",
	last: "Montalesi",
};

const {first, last} = person;

<br>디스트럭처링을 이용하여 person이 가진 속성에 접근함과 동시에 해당 속성 이름으로 변수 선언이 가능함을 알 수 있다.<br>변수의 이름을 객체의 속성과 동일하게 지정하는 데 그치지 않고, 다음과 같이 변수 이름을 바꿀 수도 있다.<br>
// person.links.social.facebook 프로퍼티를 찾아 fb라는 변수로 명명함
const {facebook: fb} = person.links.social;

console.log(fb);        // https://www.facebook.com/alberto.montalesi
console.log(facebook);  // ReferenceError: facebook is not defined

<br>다음과 같이 기본값을 전달할 수도 있다.<br>
// 변수를 fb로 다시 명명하고 기본값을 설정한다.
const {facebook: fb = "https://www.facebook.com"} = person.links.social;

<br><br>
const person = ["Alberto", "Montalesi", 25];
const [name, surname, age] = person;

<br>생성하려는 변수의 수가 배열의 수보다 적다면 오른쪽에서부터 남는 원소를 버린다.<br>나머지 모든 값을 얻고 싶다면 레스트 연산자 rest operator를 사용하면 된다.<br>
const person = ["Alberto", "Montalesi", "pizza", "ice cream", "cheese cake"];
// 레스트 연산자를 사용하여 나머지 값 전체를 얻는다.
const [name, surname, ...food] = person;
// ["pizza", "ice cream", "cheese cake"]
console.log(food);

<br>이 예에서 배열의 처음 두 값은 name과 surname에 할당되고 나머지 rest는 food 배열에 할당된다.<br><br>디스트럭처링 할당을 사용하면 변수의 값을 매우 쉽게 서로 교체할 수 있다.<br>
let hungry = "yes";
let full = "no";

[hungry, full] = [full, hungry];
// no, yes
console.log(hungry, full);

<br><br>참고자료<br><a href=".?query=tag:참고도서\모던_자바스크립트_핵심_가이드" class="tag" target="_blank" rel="noopener nofollow">#참고도서/모던_자바스크립트_핵심_가이드</a> <br>]]></description><link>resource\web\javascript\디스트럭처링.html</link><guid isPermaLink="false">resource/Web/JavaScript/디스트럭처링.md</guid><pubDate>Mon, 13 Jan 2025 06:56:28 GMT</pubDate></item><item><title><![CDATA[모듈]]></title><description><![CDATA[<a class="tag" href="?query=tag:language/JavaScript" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#language/JavaScript</a> <a class="tag" href="?query=tag:web" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#web</a> <a class="tag" href="?query=tag:참고도서/모던_자바스크립트_Deep_Dive" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/모던_자바스크립트_Deep_Dive</a> 
 <br><br><a href=".?query=tag:language\JavaScript" class="tag" target="_blank" rel="noopener nofollow">#language/JavaScript</a> <a href=".?query=tag:web" class="tag" target="_blank" rel="noopener nofollow">#web</a> <br>module<br><br><br>모듈 module이란 애플리케이션을 구성하는 개별적 요소로서 재사용 가능한 코드 조각을 말한다. 일반적으로 모듈은 기능을 기준으로 파일 단위로 분리한다. 이때 모듈이 성립하려면 모듈은 자신만의 파일 스코프(모듈 스코프)를 가질 수 있어야 한다.<br>자신만의 파일 스코프를 갖는 모듈의 자산(모듈에 포함되어 있는 변수, 함수, 객체 등)은 기본적으로 비공개 상태다. 다시 말해, 자신만의 파일 스코프를 갖는 모듈의 모든 자산은 캡슐화되어 다른 모듈에서 접근할 수 없다. 즉, 모듈은 개별적 존재로서 애플리케이션과 분리되어 존재한다.<br>하지만 애플리케이션과 완전히 분리되어 개별적으로 존재하는 모듈은 재사용이 불가능하므로 존재의 의미가 없다. 모듈은 애플리케이션이나 다른 모듈에 의해 재사용되어야 의미가 있다. 따라서 모듈은 공개가 필요한 자산에 한정하여 명시적으로 선택적 공개가 가능하다. 이를 export라 한다.<br>공개 export된 모듈의 자산은 다른 모듈에서 재사용할 수 있다. 이때 공개된 모듈의 자산을 사용하는 모듈을 모듈 사용자 module comsumer라 한다. 모듈 사용자는 모듈이 공개 export한 자산 중 일부 또는 전체를 선택해 자신의 스코프 내로 불러들여 재사용할 수 있다. 이를 import라 한다.<br>이처럼 모듈은 애플리케이션과 분리되어 개별적으로 존재하다가 필요에 따라 다른 모듈에 의해 재사용된다. 모듈은 기능별로 분리되어 개별적인 파일로 작성된다. 따라서 코드의 단위를 명확히 분리하여 애플리케이션을 구성할 수 있고, 재사용성이 좋아서 개발 효율성과 유지보수성을 높일 수 있다.<br><br>클라이어트 사이드 자바스크립트는 script 태그를 사용하여 외부의 자바스크립트 파일을 로드할 수 있지만 파일마다 독립적인 파일 스코프를 갖지 않는다.<br>다시 말해, 자바스크립트 파일을 여러 개의 파일로 분리하여 script 태그로 로드해도 분리된 자바스크립트 파일들은 결국 하나의 자바스크립트 파일 내에 있는 것처럼 동작한다. 즉, 모든 자바스크립트 파일은 하나의 전역을 공유한다. 따라서 분리된 자바스크립트 파일들의 전역 변수가 중복되는 등의 문제가 발생할 수 있다.<br>이것으로는 모듈을 구현할 수 있다.<br><br>자바스크립트 런타임 환경인  Node.js는 모듈 시스템의 사실상 표준 de taco standard인 CommonJS라는 모듈 시스템을 채택하여 이러한 문제를 해결하였다.<br>웹 브라우저 환경에 대해서는, ES6에서는 클라이언트 사이트 자바스크립트에서도 동작하는 모듈 기능을 추가했다.<br>ES6 모듈(앞으로 ESM이라 부른다)의 사용법은 간단하다. script 태그에 type="module" 어트리뷰트를 추가하면 로드된 자바스크립트 파일은 모듈로서 동작한다. 일반적인 자바스크립트 파일이 아닌 ESM임을 명확히 하기 위해 ESM의 파일 확장자는 mjs를 사용할 것을 권장한다.<br>
&lt;script type="module" src="app.mjs"&gt;&lt;/script&gt;

<br>ESM에는 클래스와 마찬가지로 기본적으로 strict.mode가 적용된다.<br><br>모듈 내부에서 선언한 식별자를 외부에 공개하여 다른 모듈들이 재사용할 수 있게 하려면 export 키워드를 사용한다.<br>export 키워드는 선언문 앞에 사용한다. 이로서 변수, 함수, 클래스 등 모든 식별자를 export할 수 있다.<br>
// 변수의 공개
export const pi = Math.PI;

// 함수의 공개
export function square(x) {
    return x * x;
}

// 클래스의 공개
export class Person {
    constructor(name) {
        this.name = name;
    }
}

/* 객체의 형태로 한 번에 export 할 수 있다.

const pi = Math.PI;

// 함수의 공개
function square(x) {
    return x * x;
}

// 클래스의 공개
class Person {
    constructor(name) {
        this.name = name;
    }
}

// 변수, 함수 클래스를 하나의 객체로 구성하여 공개
export { pi, square, Person };

*/

<br><br>다른 모듈에서 공개 export한 식별자를 자신의 모듈 스코프 내부로 로드하려면 import 키워드를 사용한다. 다른 모듈이 export한 식별자 이름으로 import해야 하며 ESM의 경우 파일 확장자를 생략할 수 없다.<br>
// import.mjs

import { pi, square, Person } from './export.mjs'

console.log(pi);
console.log(square);
console.log(new Person('Lee'));

<br>
&lt;!DOCTYPE html&gt;
&lt;html&gt;
    &lt;body&gt;
        &lt;script typ="module" src="./import.mjs"&gt;&lt;/script&gt;
    &lt;/body&gt;
&lt;/html&gt;

<br>위 예제의 import..mjs는 애플리케이션의 진입점 entry point이므로 반드시 script 태그로 로드해야 한다. 하지만 export.mjs는 import.mjs의 import 문에 의해 로드되는 의존성 dependency이다. 따라서 export.mjs는 script 태그로 로드하지 않아도 된다.<br>모듈이 export한 식별자 이름을 일일히 지정하지 않고 하나의 이름으로 한 번에 import할 수도 있다. 이때 import되는 식별자는 as 뒤에 지정한 객체에 프로퍼티로 할당된다.<br>
// 모듈이 export한 모든 식별자를 lib 객체의 프로퍼티로 모아 import한다.
import * as lib from './export.mjs'

console.log(lib.pi);
console.log(lib.square);
console.log(new lib.Person('Lee'));

<br>모듈이 export한 식별자 이름을 변경하여 import 할 수도 있다.<br>
// 모듈이 export한 식별자 이름을 변경하여 import한다.
import { pi as PI, square as sq, Person as P } from './export.mjs'

console.log(PI);
console.log(sq);
console.log(new P('Lee'));

<br>모듈에서 하나의 export한다면 default 키워드를 사용할 수 있다. default 키워드를 사용하는 경우 기본적으로 이름 없이 하나의 값을 export한다.<br>default 키워드를 사용하는 경우 var, let, const 키워드는 사용할 수 없다.<br>
// export.mjs

export default x =&gt; x * x;

<br>default 키워드와 함께 export한 모듈은 {} 없이 임의의 이름으로 import한다.<br>
import square from './export.mjs';

console.log(square(3)); // 9

<br><br>참고자료<br><a href=".?query=tag:참고도서\모던_자바스크립트_Deep_Dive" class="tag" target="_blank" rel="noopener nofollow">#참고도서/모던_자바스크립트_Deep_Dive</a> <br>]]></description><link>resource\web\javascript\모듈.html</link><guid isPermaLink="false">resource/Web/JavaScript/모듈.md</guid><pubDate>Sat, 18 Jan 2025 16:59:30 GMT</pubDate></item><item><title><![CDATA[제너레이터]]></title><description><![CDATA[<a class="tag" href="?query=tag:language/JavaScript" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#language/JavaScript</a> <a class="tag" href="?query=tag:web" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#web</a> <a class="tag" href="?query=tag:참고도서/모던_자바스크립트_Deep_Dive" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/모던_자바스크립트_Deep_Dive</a> 
 <br><br><a href=".?query=tag:language\JavaScript" class="tag" target="_blank" rel="noopener nofollow">#language/JavaScript</a> <a href=".?query=tag:web" class="tag" target="_blank" rel="noopener nofollow">#web</a> <br>generator<br><br><br>ES6에서 도입된 제너레이터 generator는 코드 블록의 실행을 일시 중지했다가 필요한 시점에 재개할 수 있는 특수한 함수이다. 제너레이터와 일반 함수의 차이는 다음과 같다.<br><br>일반 함수를 호출하면 제어권이 함수에게 넘어가고 함수 코드를 일괄 실행한다. 즉, 함수 호출자 caller는 함수를 호출한 이후 함수 실행을 제어할 수 없다. 제너레이터 함수는 함수 실행을 함수 호출자가 제어할 수 있다. 다시 말해, 함수 호출자가 함수 실행을 일시 중지시키거나 재개시킬 수 있다. 이는 함수의 제어권을 함수가 독점하는 것이 아니라 함수 호출자에게 양도 yield할 수 있다는 것을 의미한다.<br><br>일반 함수를 호출하면 매개변수를 통해 함수 외부에서 값을 주입받고 함수 코드를 일괄 실행하여 결과값을 함수 외부로 반환한다. 즉, 함수가 실행되고 있는 동안에는 함수 외부에서 함수 내부로 값을 전달하여 함수의 상태를 변경할 수 없다. 제너레이터 함수는 함수 호출자와 양방향으로 함수의 상태를 주고받을 수 있다. 다시 말해, 제너레이터 함수는 함수 호출자에게 상태를 전달할 수 있고 함수 호출자로부터 상태를 전달받을 수도 있다.<br><br>일반 함수를 호출하면 함수 코드를 일괄 실행하고 값을 반환한다. 제너레이터 함수를 호출하면 함수 코드를 실행하는 것이 아니라 이터러블이면서 동시에 이터레이터인 제너레이터 객체를 반환한다.<br><br>제너레이터 함수는 function * 키워드로 선언한다. 그리고 하나 이상의 yield 표현식을 포함한다. 이것을 제외하면 일반 함수를 정의하는 방법과 같다.<br>
// 제너레이터 함수 선언문
function* getDecFunc() {
    yield 1;
}

// 제너레이터 함수 표현식
const genExpFunc = function* () {
    yield 1;
};

// 제너레이터 메서드
const obj = {
    * genObjMethod() {
        yield 1;
    }
};

// 제너레이터 클래스 메서드
class MyClass {
    * genClsMethod() {
        yield 1;
    }
}

<br>애스터리스크(*)의 위치는 function 키워드와 함수 이름 사이라면 어디든지 상관없다. 다음 예제의 제너레이터 함수는 모두 유효하다. 하지만 일관성을 유지하기 위해 function 키워드 바로 뒤에 붙이는 것이 좋다.<br>제너레이터 함수는 화살표 함수로 정의할 수 없다.<br>
제너레이터 함수는 new 연산자와 함께 생성자 함수로 호출할 수 없다.<br><br>제너레이터 함수를 호출하면 일반 함수처럼 함수 코드 블록을 실행하는 것이 아니라 제너레이터 객체를 생성해 반환한다. 제너레이터 함수가 반환한 제널레이터 객체는 이터러블 iterable이면서 동시에 iterator다.<br>다시 말해, 제너레이터 객체는 Symbol.iterator를 상속받는 이터러블이면서 value, done 프로퍼티를 갖는 이터레이터 리절트 객체를 반환하는 next 메서드를 소유하는 이터레이터다. 제너레이터 객체는 next 메서드를 가지는 이터레이터이므로 Symbol.iterator 메서드를 호출해서 별도로 이터레이터를 생성할 필요가 없다.<br>
// 제네레이터 함수
function* getFunc() {
    yield 1;
    yield 2;
    yield 3;
}

// 제너레이터 객체를 호출하면 제너레이터 객체를 반환한다.
const generator = getFunc();

// 제너레이터 객체는 이터러블이면서 동시에 이터레이터다.
// 이터러블은 Symbol.iterator 메서드를 직접 구현하거나 프로토타입 체인을 통해 상속받은 객체다.
console.log(Symbol.iterator in generator);  // true
// 이터레이터는 next 메서드를 갖는다.
console.log('next' in generator);   // true

<br>제너레이터 객체는 next 메서드를 갖는 이터레이터이지만 이터레이터에는 없는  return, throw 메서드를 갖는다. 제너레이터 객체의 세 개의 메서드를 호출하면 다음과 같이 동작한다.<br>
<br>next 메서드를 호출하면 제너레이터 함수의 yield 표현식까지 코드 블록을 실행하고 yield된 값을 value 프로퍼티 값으로, false를 done 프로퍼티 값으로 갖는 이터레이터 리절트 객체를 반환한다. next 메서드를 반복 호출하여 제너레이터 함수가 끝까지 실행되면 next 메서드가 반환하는 이터레이터 함수의 반환값이 할당되고 done 프로퍼티에는 제너레이터 함수가 끝까지 실행되었을을 나타내는 true가 할당된다.
<br>return 메서드를 호출하면 인수로 전달받은 값을 value 프로퍼티 값으로, true를 done 프로퍼티 값으로 갖는 이터레이터 리절트 객체를 반환한다.
<br>throw 메서드를 호출하면 인수로 전달받은 에러를 발생시키고 undefined를 value 프로퍼티 값으로, true를 done 프로퍼티값으로 갖는 이터레이터 리절트 객체를 반환한다.
<br>
function* genFunc()
{
    try
    {
        yield 1;
        yield 2;
        yield 3;
    } catch (e)
    {
        console.error(e);
    }
}

const generator = genFunc();

console.log(generator.next());

console.log(generator.return('End!'));
//console.log(generator.throw('Error!'));

<br><br>제너레이터는 yield 키워드와 next 메서드를 통해 실행을 일시 중지했다가 필요한 시점에 다시 재개할 수 있다. 일반 함수는 호출 이후 제어권을 함수가 독점하지만 제너레이터는 함수 호출자에게 제어권을 양도 yield하여 필요한 시점에 함수 실행을 재개할 수 있다.<br>제너레이터 객체의 next 메서드를 호출하면 제너레이터 함수의 코드 블록을 실행한다.<br>단, 일반 함수처럼 한 번에 코드 블록의 모든 코드를 일괄 실행하는 것이 아니라 yield 표현식까지만 실행한다. yield 키워드는 제너레이터 함수의 실행을 일시 중지시키거나 yield 키워드 뒤에 오는 표현식의 평가 결과를 제너레이터 함수 호출자에게 반환한다.<br>
function* genFunc()
{
    yield 1;
    yield 2;
    yield 3;
}

const generator = genFunc();

for (let i = 0; i &lt; 4; i++)
{
    console.log(generator.next());
}

<br>이터레이터의 next 메서드와는 달리 제너레이터 객체의 next 메서드에는 인수를 전달할 수 있다. 제너레이터 객체의 next 메서드에 전달한 인수는 제너레이터 함수의 yield 표현식을 할당하는 변수에  할당된다. yield 표현식을 할당받는 변수에 yield 표현식의 평과 결과가 할당되지 않는 것에 주의해야 한다.<br>
function* genFunc()
{
    const x = yield 1;
    const y = yield (x + 10);

    return (x + y);
}

const generator = genFunc(0);

let res = generator.next();
console.log(res);

res = generator.next(10);
console.log(res);

res = generator.next(20);
console.log(res);

<br>이처럼 제너레이터 함수는 next 메서드와 yield 표현식을 통해 함수 호출자와 함수의 상태를 주고받을 수 있다. 함수 호출자는 next 메서드를 통해 yield 표현식까지 함수를 실행시켜 제너레이터 객체를 관리하는 상태(yield된 값)을 꺼내올 수 있고, next 메서드에 인수를 전달해서 제너레이터 객체에 상태(yield 표현식을 할당받는 변수)를 밀어넣을 수 있다.<br>이러한 제너레이터의 특성을 활용하면 비동기 처리를 동기 처리처럼 구현할 수 있다.<br><br><br>(생략)<br><br>제너레이터의 특성을 활용하여 프로미스의 후속 처리 메서드 then/catch/finally 없이 비동기 처리 결과를 반환하도록 구현할 수 있다.<br>
// node-fetch는 Node.js 환경에서 window.fetch 함수를 사용하기 위한 패키지이다.
// 브라우저 환경에 이 예제를 실행한다면 아래 코드는 필요없다.
// https://github.com/node-fetch/node-fetch
const fetch = require('node-fetch');

// 제너레이터 실행기
const async = generatorFunc =&gt; {
    const generator = generatorFunc();  // 2

    const onResolved = arg =&gt; {
        const result = generator.next(arg); // 5

        return result.done
            ? result.value  // 9
            : result.value.then(res =&gt; onResolved(res));    // 7
        };
    return onResolved;  // 3
};

(async(function* fetchTodo() {
    const url = 'https://jsonplaceholder.typicode.com/todos/1';

    const response = yield fetch(url);  // 6
    const todo = yield response.json(); // 8
    console.log(todo);
})());

<br>(예제에 대한 설명은 생략 - 너무 어려워요 차라리 <a data-href="async await" href="resource\web\javascript\async-await.html" class="internal-link" target="_self" rel="noopener nofollow">async await</a>을 참조합시다.)<br><br>참고자료<br><a href=".?query=tag:참고도서\모던_자바스크립트_Deep_Dive" class="tag" target="_blank" rel="noopener nofollow">#참고도서/모던_자바스크립트_Deep_Dive</a> <br>]]></description><link>resource\web\javascript\제너레이터.html</link><guid isPermaLink="false">resource/Web/JavaScript/제너레이터.md</guid><pubDate>Sat, 18 Jan 2025 15:32:55 GMT</pubDate></item><item><title><![CDATA[프로미스]]></title><description><![CDATA[<a class="tag" href="?query=tag:language/JavaScript" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#language/JavaScript</a> <a class="tag" href="?query=tag:web" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#web</a> <a class="tag" href="?query=tag:참고도서/모던_자바스크립트_Deep_Dive" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/모던_자바스크립트_Deep_Dive</a> 
 <br><br><a href=".?query=tag:language\JavaScript" class="tag" target="_blank" rel="noopener nofollow">#language/JavaScript</a> <a href=".?query=tag:web" class="tag" target="_blank" rel="noopener nofollow">#web</a> <br>Promise<br><br><br>자바스크립트는 비동기 처리를 위한 하나의 패턴으로 콜백 함수를 사용한다. 하지만 전통적인 콜백 패턴은 콜백 헬로 인해 가독성이 나쁘고 비동기 처리 중 발생한 에러의 처리가 곤란하여 여러 개의 비동기 처리를 한 번에 처리하는 데도 한계가 있다.<br>ES6에서는 비동기 처리를 위한 또 다른 패턴으로 프로미스 Promise를 도입했다. 프로미스는 전통적인 콜백 패턴이 가진 단점을 보완하며 비동기 처리 시점을 명확하게 표현할 수 있다는 장점이 있다.<br><br><br>다음과 같이 GET 요청을 위한 함수를 작성해 보자.<br>
// Get 요청을 위한 비동기 함수
const get = url =&gt; {
    const xhr = new XMLHttpRequest();
    xhr.open('GET', url);
    xhr.send();

    xhr.onload = () =&gt; {
        if (xhr.status === 200) {
            // 서버의 응답을 콘솔에 출력한다.
            console.log(JSON.parse(xhr.response));
        }
        else {
            console.error(`${xhr.status} ${xhr.statusText}`);
        }
    };
};

// id가 1인 post를 취득
get('https://jsonplaceholder.typicode.com/posts/1');

<br>위 예제의 get 함수는 서버의 응답 결과를 콘솔에 출력한다. get 함수가 서버의 응답 결과를 반환하게 하려면 어떻게 해야할지 생각해보자.<br>get 함수는 비동기 함수다. 비동기 함수란 함수 내부에 비동기로 동작하는 코드를 포함한 함수를 말한다. 비동기 함수를 호출하면 함수 내부의 비동기로 동작하는 코드가 완료되지 않았다 해도 기다리지 않고 즉시 종료된다. 즉, 비동기 함수 내부의 비동기로 동작하는 코드는 비동기 함수가 종료된 이후에 완료된다. 따라서 비동기 함수 내부의 비동기로 동작하는 코드에서 처리 결과를 외부로 반환하거나 상위 스코프의 변수에 할당하면 기대한 대로 동작하지 않는다.<br>get 함수가 비동기 함수인 이유는 get 함수 내부의 onload 이벤트 핸들러가 비동기로 동작하기 때문이다. get 함수를 호출하면 GET 요청을 전송하고 onload 이벤트 핸들러를 등록한 다음 undefined를 반환하고 즉시 종료된다. 즉, 비동기 함수인 get 함수 내부의 onload 이벤트 핸들러는 get 함수가 종료된 이후에 실행된다. <br>이처럼 비동기 함수는 비동기 처리 결과를 외부에 반환할 수 없고, 상위 스코프의 변수에 할당할 수도 없다. 따라서 비동기 함수의 처리 결과(서버의 응답 등)에 대한 후속 처리는 비동기 함수 내부에서 수행해야 한다. 이때 비동기 함수를 범용적으로 사용하기 위해 비동기 함수에 비동기 처리 결과에 대한 후속 처리를 수행하는 콜백 함수를 전달하는 것이 일반적이다. 필요에 따라 비동기 처리가 성공하면 호출될 콜백 함수와 비동기 처리가 실패하면 호출될 콜백 함수를 전달할 수 있다.<br>
// GET 요청을 위한 비동기 함수
const get = (url, successCallback, failureCallback) =&gt; {
    const xhr = new XMLHttpRequest();
    xhr.open('GET', url);
    xhr.send();

    xhr.onload = () =&gt; {
        if (xhr.status === 200)
        {
            // 서버의 응답을 콜백 함수에 인수로 전달하면서 호출되어 응답에 대한 후속 처리를 한다.
            successCallback(JSON.parse(xhr.response));
        }
        else
        {
            // 에러 정보를 콜백 함수에 인수로 전달하면서 호출하여 에러 처리를 한다.
            failureCallback(xhr.status);
        }
    };
};

// id가 1인 post를 취득
// 서버의 응답에 대한 후속 처리를 위한 콜백 함수를 비동기 함수인 get에 전달해야 한다.
get('https://jsonplaceholder.typicode.com/posts/1', console.log, console.error);

<br>이처럼 콜백 함수를 통해 비동기 처리 결과에 대한 후속 처리를 수행하는 비동기 함수가 비동기 처리 결과를 가지고 또다시 비동기 함수를 호출해야 한다면 콜백 함수 호출이 중첩되어 복잡도가 높아지는 현상이 발생하는데, 이를 콜백 헬 callback hell이라 한다.<br>
// GET 요청을 위한 비동기 함수
const get = (url, callback) =&gt; {
    const xhr = new XMLHttpRequest();
    xhr.open('GET', url);
    xhr.send();

    xhr.onload = () =&gt; {
        if (xhr.status === 200) {
            // 서버의 응답을 콜백 함수에 전달하면서 호출하여 응답에 대한 후속 처리를 한다.
            callback(JSON.parse(xhr.response));
        }
        else {
            console.error(`${xhr.status} ${xhr.statusText}`);
        }
    };
};

const url = 'https://jsonplaceholder.typicode.com';
get(`${url}/posts/1`, ({ userId }) =&gt; {
    console.log(userId); // 1
    // post의 userId를 사용하여 user 정보를 취득
    get(`${url}/users/${userId}`, userInfo =&gt; {
        console.log(userInfo);
    });
});

<br>위 예제를 보면 GET 요청을 통해 서버로부터 응답(id가 1인 post)을 취득하고 이 데이터를 사용하여 또다시 GET 요청을 한다. 콜백 헬은 가독성을 나쁘게 하며 실수를 유발하는 원인이 된다. 다음은 콜백 헬이 생기는 전형적인 사례다.<br>
get('/step1', a =&gt; {
	get(`/step2/${a}`, b =&gt; {
		get(`/step3/${b}`, c =&gt; {
			get(`/step4/${c}`, d =&gt; {
				console.log(d);
			})})})
})

<br><br>비동기 처리를 위한 콜백 패턴의 문제점 중에서 가장 심각한 것은 에러 처리가 곤란하다는 것이다.<br>
try {
 setTimeout(() =&gt; { throw new Error('Error!'); }, 1000);
} catch (e) {
	// 에러를 캐치하지 못한다
	console.error('캐치한 에러', e);
}

<br>setTimeout 함수의 콜백 함수가 실행될 때 setTimeout 함수는 이미 콜 스택에서 제거된 상태다. 이것은 setTimeout 함수의 콜백 함수를 호출한 것이 setTimeout 함수가 아니라는 것을 의미한다. setTimeout 함수의 콜백 함수의 호출자 caller가 setTimeout 함수라면 콜 스택의 현재 실행 중인 실행 컨텍스트가 콜백 함수의 실행 컨텍스트일 때 현재 실행 중인 실행 컨텍스트의 하위 실행 컨텍스트가 setTimeout 함수여야 한다.<br>에러는 호출자 caller 방향으로 전파된다. 즉, 콜 스택의 아래 방향(실행 중인 실행 컨텍스트가 푸시되기 직전에 푸시된 실행 컨텍스트 방향)으로 전파된다. 하지만 앞에서 살펴본 바와 같이 setTimeout 함수의 콜백 함수를 호출한 것은 setTimeout 함수가 아니다. 따라서 setTimeout 함수의 콜백 함수가 발생시킨 에러는 catch 블록에서 캐치되지 않는다.<br>지금까지 살펴본 비동기 처리를 위한 콜백 패턴은 콜백 헬이나 에러 처리가 곤란하다는 문제가 있다. 이를 극복하기 위해 ES6에서 프로미스 Promise가 도입되었다.<br><br>Promise 생성자 함수를 new 연산자와 함께 호출하면 Promise 객체를 생성한다. ES6에서 도입된 Promise는 호스트 객체가 아닌 ECMAScript 사양에 정의된 표준 빌트인 객체다.<br>Promise 생성자 함수는 비동기 처리를 수행할 콜백 함수를 인수로 전달받는데 이 콜백 함수는 resolve와 reject 함수를 인수로 전달받는다.<br>
// 프로미스 생성
const promise = new Promise((resolve, reject) =&gt; {
	// Promise 함수의 콜백 함수 내부에서 비동기 처리를 수행한다.
	if (/* 비동기 처리 성공*/ ) {
		resolve('result')
	}
	else {
		/* 비동기 처리 실패 */
		reject('failure reason');
	}
});

<br>Promise 생성자 함수가 인수로 전달받은 콜백 함수 내부에서 비동기 처리를 수행한다. 이때 비동기 처리가 성공하면 콜백 함수의 인수로 전달받은 resolve 함수를 호출하고, 비동기 처리가 실패하면 reject 함수를 호출한다.<br>
// GET 요청을 위한 비동기 함수
const promiseGet = url =&gt; {
    return new Promise((resolve, reject) =&gt; {
        const xhr = new XMLHttpRequest();
        xhr.open('GET', url);
        xhr.send();

        xhr.onload = () =&gt; {
            if (xhr.status === 200) {
                // 성공적으로 응답을 전달받으면 resolve 함수를 호출한다.
                resolve(JSON.parse(xhr.response));
            }
            else {
                // 에러 처리를 위해 reject 함수를 호출한다.
                reject(new Error(xhr.status));
            }
        };
    });
};

// promiseGet 함수는 프로미스를 반환한다.
promiseGet('https://jsonplaceholder.typicode.com/posts/1');

<br>비동기 함수인 promiseGet은 함수 내부에서 프로미스를 생성하고 반환한다. 비동기 처리는 Promise 생성자 함수가 인수로 전달받은 콜백 함수 내부에서 수행한다. 만약 비동기 처리가 성공하면 비동기 처리 결과를 resolve 함수에 인수로 전달하면서 호출하고, 비동기 처리가 실패하면 에러를 reject 함수에 인수로 전달하면서 호출한다.<br>프로미스는 다음과 같이 현재 비동기 처리가 어떻게 진행되고 있는지를 나타내는 상태 State 정보를 갖는다.<br><br>생성된 직후의 프로미스는 기본적으로 pending 상태다. 이후 비동기 처리가 수행되면 비동기 처리 결과에 따라 프로미스의 상태가 변경된다.<br>프로미스의 상태는 resolve 또는 reject 함수를 호출하는 것으로 결정된다.<br>fulfilled 또는 rejected 상태를 settled 상태라고 한다. settled 상태는 fulfilled 또는 rejected 상태와 상관없이 pending이 아닌 상태로 비동기 처리가 수행된 상태를 말한다.<br>프로미스는 pending -&gt; settled 로의 변화는 가능하지만 일단 settled 상태가 되면 더는 다른 상태로 변화할 수 없다.<br>프로미스는 비동기 처리 상태와 더불어 비동기 처리 결과도 상태로 갖는다. 아래의 프로미스를 개발자 도구에서 출력하면 대략 다음과 같은 출력을 볼 수 있다.<br>
// fulfilled된 프로미스
const fulfilled = new Promise(resolve =&gt; resolve(1));

// PromiseStatus: "fulfilled" -&gt; 비동기 처리 상태 정보
// PromiseValue: 1 -&gt; 비동기 처리 결과 정보

<br>reject에 함수에 값을 전달하여 호출해도 마찬가지로 PromiseValue 상태에 그 값을 저장한다.<br>즉 프로미스는 비동기 처리 상태와 처리 결과를 관리하는 객체다.<br><br>프로미스의 비동기 처리 상태가 변화하면 이에 따른 후속 처리를 해야 한다. 예를 들어, 프로미스가 fulfilled 상태가 되면 프로미스의 처리 결과를 가지고 무언가를 해야 하고, 프로미스가 rejected 상태가 되면 프로미스의 처리 결과(에러)를 가지고 에러 처리를 해야 한다. 이를 위해 프로미스는 후속 메서드 then, catch, finally를 제공한다.<br>프로미스의 비동기 처리 상태가 변화하면 후속 처리 메서드에 인수로 전달한 콜백 함수가 선택적으로 호출된다. 이때 후속 처리 메서드의 콜백 함수에 프로미스의 처리 결과가 인수로 전달된다.<br>모든 후속 처리 메서드는 프로미스를 반환하며, 비동기로 동작한다. 프로미스의 후속 처리 메서드는 다음과 같다.<br><br>then 메서드는 두 개의 콜백 함수를 인수로 전달받는다.<br>
<br>첫 번째 콜백 함수는 프로미스 fulfilled 상태가 되면 호출된다. 이 때 콜백 함수는 비동기 처리 결과를 인수로 전달받는다.
<br>두 번째 콜백 함수는 프로미스 rejected 상태가 되면 호출된다. 이때 콜백 함수는 프로미스의 에러를 인수로 전달받는다.
<br>즉, 첫 번째 콜백 함수는 비동기 처리가 성공했을 때 호출되는 성공 처리 콜백 함수이며, 두 번째 콜백 함수는 비동기 처리가 실패했을 때 호출되는 실패 처리 함수이다.<br>
// fulfilled
new Promise(resolve =&gt; resolve('fulfilled'))
	.then(v =&gt; console.log(v), e =&gt; console.error(e));  // fulfilled

// rejected
new Promise((_, reject) =&gt; reject(new Error('rejected')))
	.then(v =&gt; console.log(v), e =&gt; console.error(e));

<br>then 메서드는 언제나 프로미스를 반환한다. 만약 then 메서드의 콜백 함수가 프로미스를 반환하면 그 프로미스를 그대로 반환하고, 콜백 함수가 프로미스가 아닌 값을 반환하면 그 값을 암묵적으로 resolve 또는 reject하여 프로미스를 생성해 반환한다.<br>
콜백 함수의 내부에서 throw가 발생하여도 암묵적으로 reject하여 프로미스를 생성해 반환한다.
<br><br>catch 메서드는 한 개의 콜백 함수를 인수로 전달받는다.  catch 메서드의 콜백 함수는 프로미스가 rejected 상태인 경우만 호출된다.<br>
// rejected
new Promise((_, reject) =&gt; reject(new Error('rejected')))
	.catch(e =&gt; console.log(e));  // Error: rejected

<br>catch 메서드는 then(undefined, onRejected)과 동일하게 동작한다. 따라서 then 메서드와 마찬가지로 언제나 프로미스를 반환한다.<br>
// rejected
new Promise((_, reject) =&gt; reject(new Error('rejected')))
	.then(undefined, e =&gt; console.log(e));  // Error: rejected

<br>단, then 메서드의 두 번째 콜백 함수는 첫 번째 콜백 함수에서 발생한 에러를 캐치하지 못하고 코드가 복잡해져서 가독성이 좋지 않다.<br>catch 메서드를 모든 then 메서드를 호출한 이후에 호출하면 비동기 처리에서 발생한 에러(rejected 상태) 뿐만 아니라 then 메서드 내부에서 발생한 에러까지 모두 캐치할 수 있다.<br><br>finally 메서드는 한 개의 콜백 함수를 인수로 전달받는다. finallty 메서드의 콜백 함수는 프로미스의 성공 또는 실패와 상관없이 무조건 한 번 호출된다. finally 메서드는 프로미스의 상태와 상관없이 공통적으로 수행해야 할 처리 내용이 있을 때 유용하다. finally 메서드도 then/catch 메서드와 마찬가지로 언제나 프로미스를 반환한다.<br>finally로 전달하는 콜백함수는 어떠한 인수도 받지 않는다.<br>
new Promise(() =&gt; {})
	.finally(() =&gt; console.log('finally'));  // finally

<br>지금까지 배웠던 것을 조합하여 후속 처리를 구현한 예제이다.<br>
const PromiseGet = url =&gt; {
    return new Promise((resolve, reject) =&gt; {
        const xhr = new XMLHttpRequest();
        xhr.open('GET', url);
        xhr.send();

        xhr.onload = () =&gt; {
            if (xhr.status === 200) {
                // 성공적으로 응답을 전달받으면 resolve 함수를 호출한다.
                resolve(JSON.parse(xhr.response));
            }
            else {
                // 에러 처리를 위해 reject 함수를 호출한다.
                reject(new Error(xhr.status));
            }
        };
    });
};

// 프로미스의 후속 메서드 또한 프로미스를 반환하는 것을 이용하여
// 연달아 호출하는 것을 프로미스 체이닝 Promise Chaining이라고 한다.
promiseGet('https://jsonplaceholder.typicode.com/posts/1')
    .then(res =&gt; console.log(res))
    .catch(err =&gt; console.error(err))
    .finally(() =&gt; console.log('Bye!'));

<br><br>비동기 처리를 위한 콜백 패턴은 에러 처리가 곤란하다는 문제가 있다. 프로미스는 에러를 문제없이 처리할 수 있다.<br>방금의 예제의 비동기 함수 promiseGet은 프로미스를 반환한다. 비동기 처리 결과에 대한 후속 처리는 프로미스가 제공하는 후속 처리 메서드 then, catch, finally를 사용하여 수행한다. 비동기 처리에서 발생한 에러는 then 메서드의 두 번째 콜백 함수로 처리할 수 있다.<br>
const wrongUrl = 'https://jsonplaceholder.typicode.com/XXX/1';

// 부적적한 URL이 지정되었기 때문에 에러가 발생한다.
promiseGet(wrongUrl).then(
	res =&gt; console.log(res),
	err =&gt; console.error(err)
); // Error: 404

<br>단, catch 절에서 설명했듯이 에러를 처리할 때는 then보다 catch를 활용하는 것이 좋다.<br>
const wrongUrl = 'https://jsonplaceholder.typicode.com/XXX/1';

// 부적적한 URL이 지정되었기 때문에 에러가 발생한다.
promiseGet(wrongUrl).catch(
	err =&gt; console.error(err)
); // Error: 404

<br><br>콜백 헬에서 살펴보았듯이 비동기 처리를 위한 콜백 패턴은 콜백 헬이 발생하는 문제가 있다. 프로미스는 then, catch, finally 후속 처리 메서드를 통해 콜백 헬을 해결한다.<br>콜백 헬에서 살펴본 콜백 헬이 발생하는 예제를 프로미스를 통해 다시 구현해보자.<br>
const url = 'https://jsonplaceholder.typicode.com';

// id가 1인 post의 userId를 취득
promiseGet(`${url}/posts/1`)
	// 취득한 post의 userId로 user 정보를 취득
	.then(({ userId }) =&gt; promiseGet(`${url}/users/${userId}`))
	.then(userInfo =&gt; console.log(userInfo))
	.catch(err =&gt; console.error(err));

<br>위 예제에서 then -&gt; then -&gt; catch 순서로 후속 처리 메서드를 호출했다. then, catch, finally 후속 처리 메서드는 언제나 프로미스를 반환하므로 연속적으로 호출할 수 있다. 이를 프로미스 체이닝 Promise chaining이라고 한다.<br><a data-tooltip-position="top" aria-label="프로미스 > ^96e976" data-href="프로미스#^96e976" href="resource\web\javascript\프로미스.html#^96e976" class="internal-link" target="_self" rel="noopener nofollow">프로미스의 후속 처리 메서드</a>에서 살펴보았듯이 후속 처리 메서드의 콜백 함수는 프로미스의 비동기 처리 상태가 변경되면 선택적으로 호출된다. 위 예제에서 후속 처리 메서드의 콜백 함수는 다음과 같이 인수를 전달받으면서 호출된다.<br><br>프로미스는 프로미스 체이닝을 통해 비동기 처리 결과를 전달받아 후속 처리를 하므로 비동기 처리를 위한 콜백 패턴에서 발생하던 콜백 헬이 발생하지 않는다. 다만 프로미스도 콜백 패턴을 사용하므로 콜백 함수를 사용하지 않는 것은 아니다.<br>콜백 패턴은 가독성이 좋지 않다. 이 문제는 ES8에서 도입된 <a data-href="async await" href="resource\web\javascript\async-await.html" class="internal-link" target="_self" rel="noopener nofollow">async await</a>를 통해 해결할 수 있다. async/await를 사용하면 프로미스의 후속 처리 메서드 없이 마치 동기 처리처럼 프로미스가 처리 결과를 반환하도록 구현할 수 있다.<br>
const url = 'https://jsonplaceholder.typicode.com';

(async () =&gt; {
	// id가 1인 post의 userId를 취득
	const { userId } = await promiseGet(`${url}/posts/1`);

	// 취득한 post의 userId로 user 정보를 취득
	const userInfo = await promiseGet(`${url}/users/${userId}`);

	console.log(userInfo);
})();

<br>하지만 async/await도 프로미스를 기반으로 동작하므로 프로미스는 잘 이해하고 있어야 한다.<br><br>Promise는 주로 생성자 함수로 사용되지만 함수도 객체이므로 메서드를 가질 수 있다. Promise는 5가지 정적 메서드를 제공한다.<br><br>Promise.resolve와 Promise.reject 메서드는 이미 존재하는 값을 래핑하여 프로미스를 생성하기 위해 사용한다.<br>Promise.resolve 메서드는 인수로 전달받은 값을 resolve하는 프로미스를 생성한다.<br>
// 배열을 resolve하는 프로미스를 생성
const resolvePromise = Promise.resolve([1, 2, 3]);
resolvedPromise.then(console.log);   // [1, 2, 3]

<br>위 예제는 다음 예제와 동일하게 동작한다.<br>
const resolvedPromise = new Promise(resolve =&gt; resolve([1, 2, 3]));
resolvePromise.then(console.log);    // [1, 2, 3]

<br>Promise.reject 메서드는 인수로 전달받은 값을 reject하는 프로미스를 생성한다.<br>
// 배열을 reject하는 프로미스를 생성
const rejectedPromise = Promise.reject(new Error('Error!'));
rejectedPromise.catch(console.log);   // Error: Error!

<br>위 예제는 다음 예제와 동일하게 동작한다.<br>
const rejectedPromise = new Promise((_, reject) =&gt; reject(new Error('Error!')));
resolvePromise.catch(console.log);    // Error: Error!

<br><br>Promise.all 메서드는 여러 개의 비동기 처리를 모두 병렬 parellel 처리할 때 사용한다.<br>
const requestData1 = () =&gt; {
    return new Promise(resolve =&gt; setTimeout(() =&gt; resolve(1), 3000));
};
const requestData2 = () =&gt; {
    return new Promise(resolve =&gt; setTimeout(() =&gt; resolve(2), 2000));
};
const requestData3 = () =&gt; {
    return new Promise(resolve =&gt; setTimeout(() =&gt; resolve(3), 1000));
}

// 세 개의 비동기 처리를 순차적으로 처리
const res = [];
requestData1()
    .then(data =&gt; {
        res.push(data);
        return requestData2();
    })
    .then(data =&gt; {
        res.push(data);
        return requestData3();
    })
    .then(data =&gt; {
        res.push(data);
        console.log(res); // [1, 2, 3] =&gt; 약 6초 소요
    })
    .catch(console.error);

<br>위 예제는 세 개의 비동기 처리를 순차적으로 처리한다. 즉, 앞선 비동기 처리가 완료하면 다음 비동기 처리를 수행한다. 따라서 위 예제는 첫 번째 비동기 처리에 3초, 두 번째 비동기 처리에 2초, 세 번째 비동기 처리에 1초가 소요되어 총 6초 이상이 소요된다.<br>그런데 위 예제의 경우 세 개의 비동기 처리는 서로 의존하기 않고 개별적으로 수행된다. 즉, 앞선 비동기 처리 결과를 다음 비동기 처리가 사용하지 않는다. 따라서 위 예제의 경우 세 개의 비동기 처리를 순차적으로 처리할 필요가 없다.<br>Promise.all 메서드는 여러 개의 비동기 처리를 모두 병렬 처리할 때 사용한다. Promise.all 메서드를 사용해 세 개의 비동기 처리를 병렬로 처리해보자.<br>
// 세 개의 비동기 처리를 병렬로 처리
Promise.all([requestData1(), requestData2(), requestData3()])
    .then(console.log)  // [ 1, 2, 3 ] =&gt; 약 3초 소요
    .catch(console.error);

<br>Promise.all 메서드는 프로미스를 요소로 갖는 배열 등의 이터러블을 인수로 전달받는다. 그리고 전달받은 모든 프로미스가 모두 fulfilled 상태가 되면 모든 처리 결과를 배열에 저장해 새로운 프로미스를 반환한다.<br>이때 첫 번째 프로미스가 가장 나중에 fulfilled 상태가 되어도 Promise.all 메서드는 첫 번째 프로미스가 resolve한 처리 결과부터 차례대로 배열에 저장해 그 배열을 resolve하는 새로운 프로미스를 반환한다. 즉, 처리 순서가 보장된다.<br>Promise.all 메서드는 인수로 전달받은 배열의 프로미스가 하나라도 rejected 상태가 되면 나머지 프로미스가 fulfilled 상태가 되는 것을 기다리지 않고 즉시 종료한다.<br>
// 세 개의 비동기 처리를 병렬로 처리
Promise.all([
	new Promise((_, reject) =&gt; setTimeout(() =&gt; reject(new Error('Error 1')), 3000)),
	new Promise((_, reject) =&gt; setTimeout(() =&gt; reject(new Error('Error 2')), 2000)),
	new Promise((_, reject) =&gt; setTimeout(() =&gt; reject(new Error('Error 3')), 1000))
])
    .then(console.log)
    .catch(console.error);  // Error: Error 3

<br>Promise.all 메서드는 인수로 전달받은 이터러블의 요소가 프로미스가 아닌 경우 Promise.resolve 메서드를 통해 프로미스로 래핑한다.<br>
Promise.all([
	1, // -&gt; Promise.resolve(1)
	2, // -&gt; Promise.resolve(2)
	3, // -&gt; Promise.resolve(3)
])
	.then(console.log)  // [1, 2, 3]
	.catch(console.log);

<br>다음은 깃허브 아이디로 깃허브 사용자 이름을 취득하는 3개의 비동기 처리를 모두 병렬로 처리하는 예이다.<br>
// GET 요청을 위한 비동기 함수
const promiseGet = url =&gt; {
    return new Promise((resolve, reject) =&gt; {
        const xhr = new XMLHttpRequest();
        xhr.open('GET', url);
        xhr.send();
        xhr.onload = () =&gt; {
            if (xhr.status === 200)
            {
                // 성공적으로 응답을 전달받으면 resolve 함수를 호출한다.
                resolve(JSON.parse(xhr.response));
            }
            else
            {
                // 에러 처리를 위해 reject 함수를 호출한다.
                reject(new Error(xhr.status));
            }
        };
    });
};

const githubIds = ['jeresig', 'ahejlsberg', 'ungmo2'];

Promise.all(githubIds.map(id =&gt; promiseGet(`https://api.github.com/users/${id}`)))
    .then(users =&gt; users.map(user =&gt; user.name))
    .then(console.log)
    .catch(console.error);

<br><br>Promise.race 메서드는 Promise.all 메서드와 동일하게 프로미스를 요소로 갖는 배열 등의 이터러블을 인수로 전달받는다. Promise.race 메서드는 Promise.all 메서드처럼 모든 프로미스가 fulfilled 상태가 되는 것을 기다리는 것이 아니라 가장 먼저 fulfilled 상태가 된 프로미스의 처리 결과를 resolve하는 새로운 프로미스를 반환한다.<br>
Promise.race([
	new Promise(resolve =&gt; setTimeout(() =&gt; resolve(1), 3000)), // 1
	new Promise(resolve =&gt; setTimeout(() =&gt; resolve(2), 2000)), // 2
	new Promise(resolve =&gt; setTimeout(() =&gt; resolve(3), 1000)) // 3
])
	.then(console.log)  // 3
	.catch(console.log);

<br>프로미스가 rejected 상태가 되면 Promise.all 메서드와 동일하게 처리된다. 즉, Promise.race 메서드에 전달된 프로미스가 하나라도 rejected 상태가 되면 에러를 reject하는 새로운 프로미스를 즉시 반환한다.<br>
Promise.race([
    new Promise((_, reject) =&gt; setTimeout(() =&gt; reject(new Error('Error 1')), 3000)),
    new Promise((_, reject) =&gt; setTimeout(() =&gt; reject(new Error('Error 2')), 2000)),
    new Promise((_, reject) =&gt; setTimeout(() =&gt; reject(new Error('Error 3')), 1000)),
])
    .then(console.log)
    .catch(console.log);  // Error: Error 3

<br><br>Promise.allSettled 메서드는 프로미스를 요소로 갖는 배열 등의 이터러블을 인수로 전달받는다. 그리고 전달받은 프로미스가 모두 settled 상태(비동기 처리가 수행된 상태, 즉 fulfilled 또는 rejected 상태)가 되면 처리 결과를 배열로 반환한다.<br>
Promise.allSettled([
    new Promise(resolve =&gt; setTimeout(() =&gt; resolve(1), 2000)),
    new Promise((_, reject) =&gt; setTimeout(() =&gt; reject(new Error('Error!')), 1000))
]).then(console.log);

<br><br>다음 예제를 살펴보고 어떤 순서로 로그가 출력될지 생각해보자.<br>
setTimeout(() =&gt; console.log(1), 0);

Promise.resolve()
	.then(() =&gt; console.log(2))
	.then(() =&gt; console.log(3));

<br>프로미스의 후속 처리 메서드도 비동기로 동작하므로 1 -&gt; 2 -&gt; 3의 순으로 출력될 것처럼 보이지만 2 -&gt; 3 -&gt; 1의 순으로 출력된다. 그 이유는 프로미스의 후속 처리 메서드의 콜백 함수는 태스크 큐가 아니라 마이크로태스크 큐 microtask queue에 저장되기 때문이다.<br>마이크로태스크 큐는 태스크 큐와는 별도의 큐다. 마이크로태스크 큐에는 프로미스의 후속 처리 메서드의 콜백 함수가 일시 저장된다. 그 외에 비동기 함수의 콜백 함수나 이벤트 핸들러는 태스크 큐에 일시 저장된다.<br>콜백 함수나 이벤트 핸들러를 일시 저장한다는 점에서 태스크 큐와 동일하지만 마이크로태스크 큐는 태스크 큐보다 우선순위가 높다. 즉, 이벤트 루프는 콜 스택이 비면 먼저 마이크로태스크 큐에서 대기하고 있는 함수를 가져와 실행한다. 이후 마이크로태스크 큐가 비면 태스크 큐에서 대기하고 있는 함수를 가져와 실행한다.<br><br>참고자료<br><a href=".?query=tag:참고도서\모던_자바스크립트_Deep_Dive" class="tag" target="_blank" rel="noopener nofollow">#참고도서/모던_자바스크립트_Deep_Dive</a> <br>]]></description><link>resource\web\javascript\프로미스.html</link><guid isPermaLink="false">resource/Web/JavaScript/프로미스.md</guid><pubDate>Fri, 24 Jan 2025 03:48:44 GMT</pubDate></item><item><title><![CDATA[Ajax]]></title><description><![CDATA[<a class="tag" href="?query=tag:language/JavaScript" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#language/JavaScript</a> <a class="tag" href="?query=tag:web" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#web</a> <a class="tag" href="?query=tag:참고도서/모던_자바스크립트_Deep_Dive" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/모던_자바스크립트_Deep_Dive</a> 
 <br><br><a href=".?query=tag:language\JavaScript" class="tag" target="_blank" rel="noopener nofollow">#language/JavaScript</a> <a href=".?query=tag:web" class="tag" target="_blank" rel="noopener nofollow">#web</a> <br>Asynchronous JavaScript and XML<br><br><br>Ajax란 자바스크립트를 사용하여 브라우저가 서버에게 비동기 방식으로 데이터를 요청하고, 서버가 응답한 데이터를 수신하여 웹페이지를 동적으로 갱신하는 프로그래밍 방식을 말한다. Ajax는 브라우저에서 제공하는 Wep API인 <a data-href="XMLHttpRequest" href="resource\web\javascript\xmlhttprequest.html" class="internal-link" target="_self" rel="noopener nofollow">XMLHttpRequest</a> 객체를 기반으로 동작한다. XMLHttpRequest는 HTTp 비동기 통신을 위한 메서드와 프로퍼티를 제공한다.<br>이전의 웹페이지는 html 태그로 시작해서 html 태그로 끝나는 완전한 HTML을 서버로부터 전송받아 웹페이지 전체를 처음부터 다시 렌더링하는 방식으로 동작했다. 따라서 화면이 전환되면 서버로부터 새로운 HTML을 전송받아 웹페이지 전체를 처음부터 다시 렌더링했다.<br>이러한 전통적인 방식은 다음과 같은 단점이 있다.<br>
<br>이전 웹페이지와 차이가 없어서 변경할 필요가 없는 부분까지 포함된 완전한 HTML을 서버로부터 매번 다시 전송받기 때문에 불필요한 데이터 통신이 발생한다.
<br>변경할 필요가 없는 부분까지 처음부터 다시 렌더링한다. 이로 인해 화면 전환이 일어나면 화면이 순간적으로 깜빡이는 현상이 발생한다.
<br>클라이언트와 서버와의 통신이 동기 방식으로 동작하기 때문에 서버로부터 응답이 있을 때까지 다음 처리는 블로킹된다.
<br>Ajax의 등장은 이전의 전통적인 패러다임을 획기적으로 전환했다. 즉, 서버로부터 웹페이지의 변경에 필요한 데이터만 비동기 방식으로 전송받아 웹페이지를 변경할 필요가 없는 부분은 다시 렌더링하지 않고, 변경할 필요가 있는 부분만 한정적으로 렌더링하는 방식이 가능해진 것이다. 이를 통해 브라우저에서도 데스크톱 애플리케이션과 유사한 빠른 퍼포먼스와 부드러운 화면 전환이 가능해졌다.<br>Ajax는 전통적인 방식과 비교했을 때 다음과 같은 장점이 있다.<br>
<br>변경할 부분을 갱신하는 데 필요한 데이터만 전송받기 때문에 불필요한 데이터 통신이 발생하지 않는다.
<br>변경할 필요가 없는 부분은 다시 렌더링하지 않는다. 따라서 화면이 순간적으로 깜빡이는 현상이 발생하지 않는다.
<br>클라이언트와 서버와의 통신이 비동기 방식으로 동작하기 때문에 서버에게 요청을 보낸 이후 블로킹이 발생하지 않는다.
<br><br>참고자료<br><a href=".?query=tag:참고도서\모던_자바스크립트_Deep_Dive" class="tag" target="_blank" rel="noopener nofollow">#참고도서/모던_자바스크립트_Deep_Dive</a> <br>]]></description><link>resource\web\javascript\ajax.html</link><guid isPermaLink="false">resource/Web/JavaScript/Ajax.md</guid><pubDate>Thu, 16 Jan 2025 02:49:46 GMT</pubDate></item><item><title><![CDATA[async await]]></title><description><![CDATA[<a class="tag" href="?query=tag:language/JavaScript" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#language/JavaScript</a> <a class="tag" href="?query=tag:web" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#web</a> <a class="tag" href="?query=tag:참고도서/모던_자바스크립트_Deep_Dive" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/모던_자바스크립트_Deep_Dive</a> 
 <br><br><a href=".?query=tag:language\JavaScript" class="tag" target="_blank" rel="noopener nofollow">#language/JavaScript</a> <a href=".?query=tag:web" class="tag" target="_blank" rel="noopener nofollow">#web</a> <br>비동기 처리 끝판왕<br><br><br><a data-href="제너레이터" href="resource\web\javascript\제너레이터.html" class="internal-link" target="_self" rel="noopener nofollow">제너레이터</a>를 사용해서 비동기 처리를 동기 처리처럼 동작하도록 구현할 수 있지만 코드가 무척이나 장황해지고 가독성도 나쁘다. ES8에서는 제너레이터보다 간단하고 가독성 좋게 비동기 처리를 동기 처리처럼 동작하도록 구현할 수 있는 async/await가 도입되었다.<br>async/await는 <a data-href="프로미스" href="resource\web\javascript\프로미스.html" class="internal-link" target="_self" rel="noopener nofollow">프로미스</a>를 기반으로 동작한다. async/await를 사용하면 프로미스의 then/catch/finally 후속 처리 메서드에 콜백 함수를 전달해서 비동기 처리 결과를 후속 처리할 필요 없이 마치 동기 처리처럼 프로미스를 사용할 수 있다. 다시 말해, 프로미스가 후속 처리 메서드 없이 마치 동기 처리처럼 프로미스가 처리 결과를 반환하도록 구현할 수 있다.<br>
const fetch = require('node-fetch');

async function fetchTodo() {
    const url = 'https://jsonplaceholder.typicode.com/todos/1';

    const response = await fetch(url);
    const todo = await response.json();
    console.log(todo);
}

fetchTodo();

<br><br>await 키워드는 반드시 async 함수 내부에서 사용해야 한다. async 함수는 async 키워드를 사용해 정의하며 언제나 프로미스를 반환한다. async 함수가 명시적으로 프로미스를 반환하지 않더라도 async 함수는 암묵적으로 resolve하는 프로미스를 반환한다.<br>
// async 함수 선언문
async function foo(n) { return n; }
foo(1).then(v =&gt; console.log(v));   // 1

// async 함수 표현식
const bar = async function (n) { return n; };
bar(2).then(v =&gt; console.log(v));   // 2

// async 화살표 함수
const baz = async n =&gt; n;
baz(3).then(v =&gt; console.log(v));   // 3

// async 메서드
const obj = {
    async foo(n) { return n; }
};
obj.foo(4).then(v =&gt; console.log(v));   // 4

// async 클래스 메서드
class MyClass {
    async bar(n) { return; }
}

const myClass = new MyClass();
myClass.bar(5).then(v =&gt; console.log(v));   // 5

<br>클래스의 constructor 메서드는 async 메서드가 될 수 없다. 클래스의 constructor 메서드는 인스턴스를 반환해야 하지만 async 함수는 언제나 프로미스를 반환해야 한다.<br><br>await 키워드는 프로미스가 settled 상태(비동기 처리가 수행된 상태)가 될 때까지 대기하다가 settled 상태가 되면 프로미스가 resolve한 처리 결과를 반환한다. await 키워드는 반드시 프로미스 앞에서 사용해야 한다.<br>
const fetch = require('node-fetch');

const getGithubUserName = async id =&gt; {
    const res = await fetch(`https://api.github.com/users/${id}`);  // 1
    const { name } = await res.json();
    console.log(name);
};

getGithubUserName('ungmo2');

<br><br>비동기 처리를 위한 콜백 패턴의 단점 중 가장 심각한 것은 에러 처리가 곤란하다는 것이다.<br>async/await에서 에러 처리는 try ...catch문을 사용할 수 있다. 콜백 함수를 인수로 전달받는 비동기 함수와는 달리 프로미스를 반환하는 비동기 함수는 명시적으로 호출할 수 있기 때문에 호출자가 명확하다.<br>
const fetch = require('node-fetch');

const foo = async () =&gt; {
	try
	{
		const wrongUrl = 'https://wrong.url';
	
		const response = await fetch(wrongUrl);
		const data = await response.json();
		console.log(data);
	}
	catch (err)
	{
		// TypeError: Failed to fetch
		console.error(err);
	}
};

foo();

<br>async 함수 내에서 catch 문을 사용해서 에러 처리를 하지 않으면 async 함수는 발생한 에러를 reject하는 프로미스를 반환한다. 따라서 async 함수를 호출하고 Promise.prototype.catch 후속 처리 메서드를 사용해 에러를 캐치할 수도 있다.<br><br>참고자료<br><a href=".?query=tag:참고도서\모던_자바스크립트_Deep_Dive" class="tag" target="_blank" rel="noopener nofollow">#참고도서/모던_자바스크립트_Deep_Dive</a> <br>]]></description><link>resource\web\javascript\async-await.html</link><guid isPermaLink="false">resource/Web/JavaScript/async await.md</guid><pubDate>Fri, 24 Jan 2025 04:03:42 GMT</pubDate></item><item><title><![CDATA[fetch]]></title><description><![CDATA[<a class="tag" href="?query=tag:language/JavaScript" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#language/JavaScript</a> <a class="tag" href="?query=tag:web" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#web</a> <a class="tag" href="?query=tag:참고도서/모던_자바스크립트_Deep_Dive" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/모던_자바스크립트_Deep_Dive</a> 
 <br><br><a href=".?query=tag:language\JavaScript" class="tag" target="_blank" rel="noopener nofollow">#language/JavaScript</a> <a href=".?query=tag:web" class="tag" target="_blank" rel="noopener nofollow">#web</a> <br>neo XMLHttpRequest<br><br><br>fetch 함수는 <a data-href="XMLHttpRequest" href="resource\web\javascript\xmlhttprequest.html" class="internal-link" target="_self" rel="noopener nofollow">XMLHttpRequest</a> 객체와 마찬가지로 HTTP 요청 전송 기능을 제공하는 클라이언트 사이드 Web API이다. fetch 함수는 XMLHttpRequest 객체보다 사용법이 간단하고 프로미스를 지원하기 때문에 비동기 처리를 위한 콜백 패턴의 단점에서 자유롭다.<br>fetch 함수에는 HTTP 요청을 전송할 URL과 HTTP 요청 메서드, HTTP 요청 헤더, 페이로드 등을 설정한 객체를 전달한다.<br>
const promise = fetch(url [, options]);

<br>fetch 함수는 HTTP 응답을 나타내는 Response 객체를 래핑한 Promise 객체를 반환한다. fetch 함수로 GET 요청을 전송해 보자. fetch 함수에 첫 번째 인수로 HTTP 요청을 전송할 URL만 전달하면 GET 요청을 전송한다.<br>
fetch('https://jsonplaceholder.typicode.com/todos/1')
	.then(response =&gt; console.log(response));

<br>fetch 함수는 HTTP 응답을 나타내는 Response 객체를 래핑한 프로미스를 반환하므로 후속 처리 메서드 then을 통해 프로미스가 resolve한 Response 객체를 전달받을 수 있다. Response 객체는 HTTP 응답을 나타내는 다양한 프로퍼티를 제공한다.<br>Response.prototype에는 Response 객체에 포함되어 있는 HTTP 응답 몸체를 위한 다양한 메서드를 제공한다. 예를 들어, fetch 함수가 반환한 프로미스가 래핑하고 있는 MIME 타입이 application/json인 HTTP 응답 몸체를 취득하려면 Response.prototype.json 메서드를 사용한다. <br>Response.prototype.json 메서드는 Response 객체에서 HTTP 응답 몸체 response.body를 취득하여 역직렬화한다.<br>
fetch('https://jsonplaceholder.typicode.com/todos/1')
	// response는 HTTP 응답을 나타내는 Response 객체다.
	// json 메서드를 사용하여 Response 객체에서 HTTP 응답 몸체를 취득하여 역직렬화한다.
	.then(response =&gt; response.json())
	// json은 역직렬화된 HTTP 응답 몸체다.
	.then(json =&gt; console.log(json));

<br>fetch 함수를 통해 HTTP 요청을 전송해보자. fetch 함수에 첫 번째 인수로 HTTP 요청을 전송할 URL과 두 번째 인수로 HTTP 요청 메서드, HTTP 요청 헤더, 페이로드 등을 설정한 객체를 전달한다.<br>
const request = {
    get(url) {
        return fetch(url);
    },
    post(url, payload) {
        return fetch(url, {
            method: 'POST',
            headers: { 'content-Type': 'application/json' },
            body: JSON.stringify(payload)
        });
    },
    patch(url, payload) {
        return fetch(url, {
            method: 'PATCH',
            headers: { 'content-Type': 'application/json' },
            body: JSON.stringify(payload)
        });
    },
    delete(url) {
        return fetch(url, { method: 'DELETE' });
    }
}

// GET 요청
request.get('https://jsonplaceholder.typicode.com/todos/1')
    .then(response =&gt; response.json())
    .then(todos =&gt; console.log(todos))
    .catch(err =&gt; console.error(err));

// POST 요청
request.post('https://jsonplaceholder.typicode.com/todos', {
    userId: 1,
    title: 'JavaScript',
    completed: false
}).then(response =&gt; response.json())
    .then(todos =&gt; console.log(todos))
    .catch(err =&gt; console.error(err));

// PATCH 요청
request.post('https://jsonplaceholder.typicode.com/todos/1', {
    completed: true
}).then(response =&gt; response.json())
    .then(todos =&gt; console.log(todos))
    .catch(err =&gt; console.error(err));

// DELETE 요청
request.delete('https://jsonplaceholder.typicode.com/todos/1')
    .then(response =&gt; response.json())
    .then(todos =&gt; console.log(todos))
    .catch(err =&gt; console.error(err));

<br>더 자세한 내용은 <a data-tooltip-position="top" aria-label="https://developer.mozilla.org/ko/docs/Web/API/Fetch_API/Fetch%EC%9D%98_%EC%82%AC%EC%9A%A9%EB%B2%95" rel="noopener nofollow" class="external-link" href="https://developer.mozilla.org/ko/docs/Web/API/Fetch_API/Fetch%EC%9D%98_%EC%82%AC%EC%9A%A9%EB%B2%95" target="_blank">다음</a>을 참고하자.<br><br>참고자료<br><a href=".?query=tag:참고도서\모던_자바스크립트_Deep_Dive" class="tag" target="_blank" rel="noopener nofollow">#참고도서/모던_자바스크립트_Deep_Dive</a> <br>]]></description><link>resource\web\javascript\fetch.html</link><guid isPermaLink="false">resource/Web/JavaScript/fetch.md</guid><pubDate>Fri, 17 Jan 2025 07:41:00 GMT</pubDate></item><item><title><![CDATA[JavaScript 기초]]></title><description><![CDATA[<a class="tag" href="?query=tag:language/JavaScript" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#language/JavaScript</a> <a class="tag" href="?query=tag:web" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#web</a> <a class="tag" href="?query=tag:참고도서/혼자_공부하는_자바스크립트" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/혼자_공부하는_자바스크립트</a> 
 <br><br><a href=".?query=tag:language\JavaScript" class="tag" target="_blank" rel="noopener nofollow">#language/JavaScript</a> <a href=".?query=tag:web" class="tag" target="_blank" rel="noopener nofollow">#web</a><br>사탄 들린 언어<br><br><br>자바스크립트 JavaScript는 웹 브라우저에서 사용하는 프로그래밍 언어이다.<br><br>표현식 expression : 자바스크립트에서 값을 만들어내는 간단한 코드<br>문장 statement : 하나 이상의 표현식의 모음. 문장 끝에는 세미콜론 또는 줄바꿈을 입력한다 (둘 다 입력할 수도 있다.)<br>키워드 keyword : 자바스크립트가 처음 만들어질 때 정해놓은 특별한 의미가 있는 단어<br>식별자 identifier : 프로그래밍 언어에서 이름을 붙일 때 사용하는 단어. 주로 변수명이나 함수명으로 사용한다. 자바스크립트 식별자를 만들 때는 다음의 규칙을 준수해야 한다.<br>
<br>키워드를 사용하지 말아야 한다.
<br>숫자로 시작하지 말아야 한다.
<br>특수 문자는 _와 $만 허용한다.
<br>공백 문자를 포함할 수 없다.
<br>그리고 식별자의 선언에 있어 다음과 같은 관례들이 존재한다.<br>
<br>클래스의 이름은 항상 대문자로 시작한다.
<br>변수와 인스턴스, 함수, 메소드의 이름은 항상 소문자로 시작한다.
<br>여러 단어로 이루어진 식별자는 각 단어의 첫 글자를 대문자로 한다(Camel 케이스).
<br>그리고 자바스크립트에서는 아래와 같이 식별자를 분류할 수 있다.<br><br>위 표에서 속성과 메소드는 보통 객체나 클래스의 하위 단위로 존재하는 식별자를 의미한다.<br><br>주석은 아래와 같이 사용한다.<br>
// 한 줄만 주석 처리

/*
	여
	러
	줄
	주
	석
	처
	리
*/

<br><br><br>맥 기준으로, 크롬에서 option + cmd + I를 사용하면 개발자 콘솔을 열 수 있다.<br>
간단한 표현식의 결과를 확인하기 좋다.<br><br>alert() 함수를 사용하면 웹 브라우저에 경고창을 띄울 수 있다. alert() 함수는 다음과 같이 사용한다.<br>
alert('Hello JavaScript...!');

<br><br>console.log() 함수를 사용하면 개발자 콘솔을 통해 매개변수로 전달한 값을 출력할 수 있다.<br>
console.log('Hello JavaScript...!')

<br><br><br>문자들의 집합을 문자열 string이라고 한다. 자바스크립트에서는 문자가 하나 이상이면 문자열 자료형이라고 한다.<br>자바스크립트에서는 큰따옴표 또는 작은따옴표를 사용하여 문자열을 만들 수  있다.<br>
'안녕하세요.';

"안녕하세요.";

<br>문자열 안에 따옴표를 사용해야 한다면 따옴표 2개를 모두 사용한다.<br>
// 큰 따옴표를 쓰고 싶으면 작은 따옴표 안에 넣는다

'큰 따옴표 " 입니다';

// 작은 따옴표를 쓰고 싶으면 큰 따옴표 안에 넣는다

'작은 따옴표 " 입니다';

<br>또는 이스케이프 문자()를 사용하여 따옴표를 문자 그대로 사용할 수 있다.<br>
"작은 따욤표 \'과 큰따옴표 \"입니다."

<br>이스케이프 문자는 다음과 같이 사용되기도 한다.<br>\n : 줄바꿈을 의미한다<br>
\t : 탭을 의미한다<br>
\ : 역슬래시() 그 자체를 의미한다.<br><br>문자열 사이에 덧셈 기호(+)를 사용하면 문자열을 연결할 수 있다. 이때 덧셈 기호를 문자열 연결 연산자라고 한다.<br>
// "AB"를 결과로 내놓음
"A" + "B";

<br>문자열 내부의 문자 하나를 선택할 때는 문자 선택 연산자를 사용한다.<br>
// '안'이 출력됨.
"안녕하세요"[0];

<br>문자열의 길이를 구할 때는 length 속성을 사용한다.<br>
// 5가 반환됨

"안녕하세요".length;

<br><br>문자열에 표현식을 적용시키고 싶으면 템플릿 문자열을 사용한다. 템블릿 문자열은 백틱(`) 기호로 감싸 만든다. 문자열 내부에 ${표현식} 과 같이 사용하면 표현식이 문자열 안에서 계산된다.<br>
// 출력값: 표현식 273 + 52의 값은 325입니다.
console.log(`표현식 273 + 52의 값은 ${273 + 52}입니다.`);

<br><br>자바스크립트는 정수와 실수를 모두 숫자 자료형이라는 단일 카테고리로 취급하여 처리한다.<br>
그 외의 숫자 자료형의 특성은 c 언어와 동일하므로 생략한다(사칙연산을 적용할 수 있고 나머지 연산자가 있고 등등).<br><br>불 자료형은 true, false 2를 다루는 자료형이다.<br>불 자료형은 비교 연산자를 사용해서 만들 수 있다. 자바스크립트의 비교 연산자는 아래와 같다.<br><br>
|| 연산자의 경우, 좌변의 표현식이 참이면 우변의 식은 실행시키지 않는다. &amp;&amp; 연산자의 경우, 좌변의 표현식이 거짓이면 우변의 식은 실행시키지 않는다. 이러한 문법적 요소를 이용할 수 있다.
<br>문자열 자료형은 ascii 순으로 대소 비교를 적용한다.<br>
// false를 반환함
"가방" &gt; "하마"

<br><br>= 연산자와 ! 연산자는 값과 자료형이 같은지 비교한다. <br>하지만 == 연산자와 != 연산자는 자료형에 관계 없이 값이 같은지만 비교한다.<br>
자료형 변환 등을 적용한 결과가 같으면 같은 값이라고 취급한다는 뜻이다.<br>
// 자료형이 달라도 어떻게든 변환을 하고 나면 값이 같아지므로 true이다.
1 == "1";

// false가 0으로, "0"이 0으로 변환된 뒤에 비교하므로 true이다.
false == "0";

// 빈 문자열은 false, 비어있는 배열 []은 false로 변환된 뒤에 비교한다.
"" == [];

// 0은 false, 비어있는 배열 []은 false로 변환된 뒤에 비교한다
0 == [];

<br><br>자료형의 타입을 확인할 때는 typeof 연산자를 사용한다.<br>
// "string"을 반환
typeof('문자열');

// "number"를 반환
typeof(273);

// "boolean"을 반환
typeof(true);

// 다음과 같이 사용할 수 있다.
if (typeof(273) === "number")
	console.log("숫자 자료형입니다.");

<br><br><br>상수는 키워드 const를 사용하여 만든다<br>
const name = value;

<br><br>같은 이름으로 상수를 한 번 더 선언하면 발생하는 오류<br><br>상수는 한 번만 선언할 수 있으므로 선언할 때 반드시 값을 함께 지정해줘야 한다. 그렇지 않으면 이 오류가 발생한다.<br><br>상수의 값을 변경하려 할 때 발생한다.<br><br>let 키워드를 사용하여 변수를 만든다.<br>
let name = value;

<br><br>같은 이름으로 변수를 한 번 더 선언하면 발생하는 오류<br><br><br><br>c언어와 유사하므로 생략<br><br>자바스크립트에서 data가 undefined로 취급되는 경우는 아래와 같다.<br>
<br>식별자를 선언하지 않고 사용할때
<br>
// "undefined"를 반환함
typeof(abc);

<br>
<br>변수를  선언하면서 값을 지정하지 않은 경우에
<br>
let a;

typeof(a);

<br><br><br>문자열 자료형을 입력받을 때 사용하는 함수는 prompt()이다. 다음과 같은 형태로 사용한다.<br>
const input = prompt(메시지 문자열, 기본 입력 문자열);

<br><br>문자열 외에 불 자료형도 값으로 입력받을 수 있다. 이때 confirm() 함수를 사용한다.<br>
const input = confirm(메시지 문자열);

<br><br><br>다른 자료형을 숫자 자료형으로 변환할 때는 Number() 함수를 사용한다.<br>
Number("209348028");

<br>다른 문자가 들어있어서 숫자로 변환할 수 없는 문자열의 경우 NaN (Not a Number)라는 값을 출력한다.<br>
NaN은 자바스크립트에서 숫자이지만, 숫자로 나타낼 수 없는 숫자를 뜻한다.<br><br>String() 함수를 사용한다.<br>
// "289"를 반환
String(289);

<br><br>Boolean 함수를 사용한다.<br>
/* false case */
Boolean(0);
Boolean(NaN);
Boolean("");
Boolean(null);

// undefined variable ==&gt; false
let variable;
Boolean(variable);

<br><br><br>c언어와 동일하므로 생략<br><br>다음의 조건문은 아래와 같이 짧은 조건문으로 변환할 수 있다.<br>
let key = 4;

if (key == 4)
	console.log("key is 4");

// 좌변이 거짓이어야만 우변이 실행됨
key != 4 || console.log("key is not 4");

// 좌변이 참이어야만 우변이 실행됨
key == 4 &amp;&amp; console.log("key is 4");

<br><br><br>배열 내부에 들어 있는 요소의 개수를 확인할 때는 배열의 length 속성을 사용한다.<br>
arr.length;

<br><br>배열 뒷부분에 요소를 추가할 때는 push() 메소드를 사용한다.<br>
arr.push(요소);

<br><br>자바스크립트에서 배열의 길이는 고정이 아니다. 다음과 같이 3개의 요소를 가진 배열을 만든 뒤, 10번째 인덱스에 요소를 삽입하면 사이에 남는 공간은 비어있는 것으로 취급된다.<br>
const fruitA = ['사과', '배', '바나나'];
fruitA[10] = '귤'

// 출력값: ['사과', '배', '바나나', empty x 7, "귤"]
fruitA;

<br>다음과 같이 length 속성을 사용하여 배열의 마지막 위치에 요소를 추가할 수 있다.<br>
arr[arr.length] = "new value";

<br><br><br>배열의 특정 인덱스에 있는 요소를 제거할 때는 splice() 메소드를 사용한다.<br>
array.splice(인덱스, 제거할 요소의 개수);

<br><br>값을 기반으로 요소를 제거할 때는 배열 내부에서 특정 값의 위치를 찾는 indefOf() 메소드를 사용해서 값의 위치를 추출한 뒤 splice() 메소드를 사용해 제거한다.<br>
array.splice(array.indexOf(target), 1);

<br>참고로 indexOf() 메소드는 배열 내부에 요소가 있을 경우 인덱스를 리턴한다. 하지만 배열 내부에 요소가 없을 때는 -1을 리턴한다.<br>
문자열에도 indexOf() 메소드가 있다. 이를 이용하면 문자열 내부에서 특정 문자열의 위치를 찾을 수 있다.
<br><br>indexOf() 메소드와 splice() 메소드는 배열 내부 요소를 하나만 제거할 수 있다. 배열 내부에서 특정 값을 가진 요소를 모두 제거하고 싶을 때는 filter() 메소드를 사용해야 하면 사용방법은 아래와 같다.<br>
const array = ['사과', '배', '바나나', '귤', '귤']

// 귤이 아닌 요소만 필터링을 통해 남긴다.
array.filter((item) =&gt; item !== '귤');

<br><br>배열의 특정 위치에 요소를 추가할 때 또한 splice() 메소드를 사용한다. splice() 메소드의 2번째 매개변수에 0을 입력하면 splice() 메소드는 아무 것도 제거하지 않으며, 3번째 매개변수에 추가하고 싶은 요소를 입력한다.<br>다음과 같이 사용한다.<br>
array.splice(index, 0, value);

<br><br><br>for in 반복문은 배열 요소를 하나하나 꺼내서 특정 문장을 실행할 때 사용한다.<br>
const todos = ['우유 구매', '업무 메일 확인하기', '필라테스 수업'];

for (const i in todos)
{
	console.log(`${i}번째 할 일: ${todos[i]}`);
}

/*
	실행 결과
	0번째 할 일: 우유 구매
	1번째 할 일: 업무 메일 확인하기
	...
*/

<br>for 반복문의 반복 변수(위 코드에서 i)에는 요소의 인덱스들이 들어온다. 이를 활용해서 배열 요소에 접근할 수 있다.<br>for in 반복문은 불안정한 요소가 조금 있으므로, 후술할 다른 반복문을 사용하는 편이 낫다.<br><br>for of 반복문은 반복 변수에 요소의 값이 들어간다.<br>
const todos = ['우유 구매', '업무 메일 확인하기', '필라테스 수업'];
for (const todo of todos)
{
	console.log(`오늘의 할 일: ${todo}`);
}

<br><br>for 반복문은 특정 횟수만큼 반복하고 싶을 때 사용하는 범용적인 반복문이다.<br>
for (let i = 0; i &lt; 반복 횟수; i++)
{
	문장;
}

<br><br><br><br><br>c 언어와 동일하므로 생략<br><br>자바스크립트의 함수는 다른 언어의 함수와 동일하게 매개변수를 함수 몸체에서 처리한 후 리턴한다. 함수의 자료형은 function이다.<br><br>이름이 붙어 있지 않은 함수를 익명 함수 anonymous function이라고 표현한다.<br>
익명 함수의 기본 형태는 아래와 같다.<br>
function () { ... }

<br>
const func = function() {
	console.log("자바스크립트로 만든 첫번째 익명 함수.");
}

func();

<br>익명 함수는 이름이 부여되어 있지 않으므로 일반적으로 변수에 붙여서 사용한다.<br><br>일반적으로는 이름이 있는 함수를 많이 사용한다.<br>
이름을 부여하여 생성한 함수를 선언적 함수라고 한다.<br>
function functionName() { ... }

<br>
function func() {
	console.log("자바스크립트로 만든 첫번째 선언적 함수.");
}

func();

<br><br>선언적 함수는 순차적인 코드의 실행이 일어나기 전에 생성된다. 따라서 선언적 함수는 같은 블록이라면 어디에서 함수를 호출해도 상관없다.<br>아래와 같이 함수 선언 이전에 함수를 호출해도 문제없이 호출된다.<br>
// 선언적 함수를 호출한다.
선언적함수();

// 같은 이름의 함수가 있으면 나중에 생성된 함수가 먼저번 함수를 뒤집어쓴다.
function 선언적함수()
{
	console.log('1번째 선언적 함수입니다.');
}
function 선언적함수()
{
	console.log('2번째 선언적 함수입니다.');
}

<br>반면에 익명함수는 순차적인 코드 실행에서 코드가 해당 줄을 읽을 때 생성된다. 따라서 익명 함수로 위와 같은 예제를 실행 시키면 에러가 발생하게 된다.<br>그러면 아래의 코드를 보자<br>
// 익명 함수 생성
func = function () {
	console.log('익명 함수입니다.');
}

// 선언적 함수를 생성하고 할당
function func () {
	console.log('선언적 함수입니다.');
}

// 함수를 호출한다.
func();

<br>익명 함수는 우리가 코드를 읽을 때와 같은 순서로 함수가 선언되지만, 선언적 함수는 우리가 코드를 읽는 순서와 다르게 함수가 선언된다. 이러한 특성 때문에 예측하기 쉬운 익명 함수가 더 선호된다.<br><br>let 키워드에는 동일한 식별자의 선언을 방지하는 기능이 있다.<br>
let a = 10;

// error
let a;

<br>따라서 let 키워드를 통해 선언한 변수에 익명 함수를 붙이면 함수의 중복 선언을 방지할 수 있다.<br>
// 익명 함수를 생성한다
let func = function() {
	console.log('익명 함수입니다.');
}

// 선언적 함수를 생성하고 할당한다. 위의 let 키워드 때문에 에러가 발생한다.
function func () {
	console.log('선언적 함수입니다.');
}

// 함수를 호출합니다.
func()

<br>따라서 한 가지로 통일해서 사용하는 것이 오류의 위험을 더 줄일 수 있고, 통일한다면 익명 함수로 통일해서 사용하는 것이 안전을 위해서 더 편한 선택이다.<br><br>호출할 때 매개변수의 개수가 고정적이지 않은 함수를 가변 매개변수 함수라고 부른다. 자바스크립트에서 이러한 함수를 구현할 때는 나머지 매개변수 rest parameter라는 특이한 형태의 문법을 사용한다. 나머지 매개변수의 기본적인 사용 방법은 다음과 같다.<br>
function functionName(...나머지 매개변수) { ... }

<br>함수의 매개변수 앞에 마침표 3개(...)를 입력하면 매개변수들이 배열로 들어온다. 나머지 매개변수의 작동을 확인할 수 있는 간단한 예제를 보도록 하자.<br>
function sample(...items)
{
	console.log(items);
}

sample(1, 2);
sample(1, 2, 3);
sample(1, 2, 3, 4);

/*
실행 결과
[1, 2]
[1, 2, 3]
[1, 2, 3, 4]
*/

<br>

	// 매개변수 items는 배열처럼 사용한다.
	function min(...items)
	{
		let output = items[0];
		for (const item of items)
		{
			if (output &gt; item)
			{
				output = item;
			}
			return output;
		}
	}

	// 함수 호출하기
	console.log('min(52, 273, 24)');
	console.log(`${min(52, 273, 24)}`);

/*
실행 결과
min(52, 273, 24)
= 24
*/

<br><br>나머지 매개변수는 다음 패턴과 같이 일반적인 매개변수와 조합해서 사용할 수 있다.<br>
function functionName(매개변수, 매개변수, ...나머지_매개변수) {}

<br><br>다음과 같이 매개변수로 배열을 입력할 수 없고 숫자를 입력해야 하는 함수가 있다고 가정하자.<br>
min(52, 273, 24);

<br>이때 다음과 같이 배열을 사용해 min 함수를 사용하려면 기본적으로 배열 요소를 하나하나 전개해서 입력하는 방법밖에 생각할 수 없다.<br>
min(array[0], array[1], array[2], array[3]);

<br>이런 상황에 대비하고자 자바스크립트는 배열을 전개해서 함수의 매개변수로 전달해주는 전개 연산자 spread operator를 제공한다. 전개 연산자는 다음과 같이 배열 앞에 마침표 3개(...)를 붙이는 형태로 사용한다.<br>
functionName(...array);

<br><br>c 언어와 동일하므로 생략<br><br>다른 프로그래밍 언어는 함수를 지정된 위치에서 만들어야 하지만, 자바스크립트는 '함수도 하나의 자료'라는 개념을 가지고 있어서 중간에 만들 수 있다. 이는 2010년 전후에 등장한 비동기 프로그래밍을 이끌었다. 자바스크립트의 익명 함수는 문법적 가치를 크게 인정받아 다른 프로그래밍 언어로 전파되었다. 자바스크립트의 익명 함수는 문법적 가치를 크게 인정받아 다른 프로그래밍 언어로 전파되어 람다 또는 익명 함수라는 이름으로 기본 문법에 포함되었다.<br><br>자바스크립트는 함수도 하나의 자료형이므로 매개변수로 전달할 수 있다(c 언어에서 함수 포인터를 전달하는 것과 유사하다). 이렇게 매개변수로 전달하는 함수를 콜백 callback 함수라고 한다.<br>
// 함수를 선언한다.
function callThreeTimes (callback)
{
	for (let i = 0; i &lt; 3; i++)
	{
		// callback이라는 매개변수는 함수이므로 호출할 수 있다.
		callback(i);
	}
}

function print (i)
{
	console.log(`${i}번째 함수 호출`);
}

// 함수를 호출한다.
callThreeTimes(print);

<br>이전 예제의 선언적 함수를 익명 함수로 변경한다면 다음과 같이 코드를 구성할 수 있다.<br>
// 함수를 선언한다.
function callThreeTimes (callback)
{
	for (let i = 0; i &lt; 3; i++)
	{
		// callback이라는 매개변수는 함수이므로 호출할 수 있다.
		callback(i);
	}
}

// 함수를 호출한다.
callThreeTimes(function (i) {
	console.log(`${i}번째 함수 호출`);
});

<br><br>콜백 함수를 활용하는 가장 기본적인 함수는 forEach() 메소드이다. forEach() 메소드는 배열이 갖고 있는 함수(메소드)로써 단순하게 배열 내부의 요소를 사용해서 콜백 함수를 호출해준다.<br>배열이 갖고 있는 메소드 중에서 콜백 함수를 활용하는 메소드는 다음과 같은 형태의 콜백 함수를 사용한다.<br>
function (value, index, array) {}

<br>
const numbers = [273, 52, 103, 32, 57];

numbers.forEach(function (value, index, array) {
	console.log(`${index}번째 요소 : ${value}`);
})

<br><br>map() 메소드도 배열이 갖고 있는 함수 중 하나로, map() 메소드는 콜백 함수에서 리턴한 값들을 기반으로 새로운 배열을 만든다.<br>
// 배열을 선언한다
let numbers = [273, 52, 103, 32, 57];

// 배열의 모든 값을 제곱한다
numbers = numbers.map(function (value, index, array) {
	return value * value;
})

// 출력한다
numbers.forEach(console.log);

<br><br>배열의 메소드의 매개변수에 전달하는 콜백 함수의 완전한 형식은 function (value, index, array) {}가 맞지만, 일반적으로 value 또는  value와 index만 사용하는 경우가 많다.<br>콜백 함수의 매개변수는 모두 입력할 필요 없고, 사용하고자 하는 위치의 것만 순서에 맞춰 입력하면 된다.<br>
// 배열을 선언한다
let numbers = [273, 52, 103, 32, 57];

// 배열의 모든 값을 제곱한다
numbers = numbers.map(function (value) {
	return value * value;
})

// 출력한다
numbers.forEach(console.log);

<br><br>filter() 메소드도 배열이 갖고 있는 함수이다. filter() 메소드는 콜백 함수에서 리턴하는 값이 true인 것들만 모아서 새로운 배열을 만드는 함수이다.<br>
const numbers = [0, 1, 2, 3, 4, 5];
const evenNumbers = numbers.filter(function (value) {
	return (value % 2 === 0)
})

console.log(`원래 배열: ${numbers}`);
console.log(`짝수만 추출: ${evenNumbers}`);

<br><br>화살표 arrow 함수는 단순한 형태의 콜백 함수를 쉽게 입력하고자 하는 문법적 요소이다. 화살표 함수는 function 키워드 대신 화살표(=&gt;)를 사용하며, 다음과 같은 형태로 생성하는 간단한 함수이다.<br>
(매개변수) =&gt; {
	...
}

<br>다음과 같이 더 간편한 형태로 사용할 수도 있다.<br>
(매개변수) =&gt; 리턴값

<br>map()과 사용하는 예.<br>
array.map((value) =&gt; value * value);

<br>
익명함수와 화살표 함수는 내부에서 this 키워드가 지칭하는 대상이 다르다는 등의 미세한 차이가 있다.
<br><br>어떤 메소드가 리턴하는 값을 기반으로 해서 함수를 줄줄이 사용하는 것을 메소드 체이닝 method chaining이라고 부른다.<br>
// 배열을 선언한다
let numbers = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];

// 배열의 메소드를 연속적으로 사용한다
numbers
	.filter((value) =&gt; value % 2 === 0)
	.map((value) =&gt; value * value)
	.forEach((value) =&gt; {
		console.log(value);
	})

<br><br>자바스크립트에는 다음과 같이 특정 시간마다 또는 특정 시간 이후에 콜백 함수를 호출할 수 있는 타이머 timer 함수들이 있다. 이 함수를 사용하면 시간과 관련한 처리를 할 수 있다.<br><br>
// 타이머 걸기

setTimeout(() =&gt; {
	console.log('1초 후에 실행')
}, 1 * 1000)

let count = 0;
setInterval(() =&gt; {
	console.log(`1초마다 실행됩니다(${count}번째)`);
	count++;
}, 1 * 1000)

<br>setTimeout() 함수와 setInterval() 함수를 사용해서 특정 시간 후에 코드를 호출한다. 코드를 실행하면 1초 후에 setTimeout() 함수의 콜백 함수가 실행되고, 1초마다 setInterval() 함수의 콜백 함수가 실행되는 것을 볼 수 있다.<br>특이사항으로, 2번째 매개변수에 시간을 입력할 때 밀리초로 입력하여야 한다.<br>타이머를 종료하고 싶을 때는 clearTimeout() 함수와 clearInterval() 함수를 사용한다.<br><br>이 함수들의 매개변수에는 타이머 ID라는 것을 넣는데, 타이머 ID는 setTimeout() 함수와 setInterval() 함수의 리턴값이다.<br>
// 타이머 취소하기
let id;
let count = 0;
id = setInterval(() =&gt; {
	console.log(`1초마다 실행됩니다(${count}번째)`);
	count++;
}, 1 * 1000);

setTimeout(() =&gt; {
	console.log('타이머 종료.');
	clearInterval(id);
}, 5 * 1000);

<br><br>변수가 유효한 범위를 스코프 scope라고 부르는데, 이 스코프는 같은 단계에 있을 경우 무조건 충돌이 일어난다.<br>
자바스크립트에서 이러한 스코프 단계를 변경하는 방법은<br>
<br>중괄호를 사용해서 블록을 만들거나
<br>함수를 생성해서 블록을 만드는 방법이다
<br><br>
let pi = 3.14;
console.log(`파이 값은 ${pi}입니다.`);

// 블록을 사용한 스코프 생성
{
	let pi = 3.141592;
	console.log(`파이 값은 ${pi}입니다.`);
}
console.log(`파이 값은 ${pi}입니다.`);

// 함수 블록을 사용한 스코프 생성
function sample() {
	let pi = 3.141592;
	console.log(`파이 값은 ${pi}입니다.`);
}
sample();
console.log(`파이 값은 ${pi}입니다.`);

<br>위와 같이 블록 내부에서 외부의 변수와 같은 이름으로 변수를 선언하면 변수가 외부 변수와 충돌하지 않고 외부 변수를 가린다. 내부 블록에서는 내부 블록에서 선언한 변수만 볼 수 있다. 이렇게 블록이 다른 경우 내부 변수가 외부 변수를 가리는 현상을 조금 어려운 표현으로 섀도잉 shadowing이라고 부른다.<br><br>여러 자바스크립트 코드를 보면 블록의 가장 위쪽에 'use strict'라는 문자열이 등장하는 것을 볼 수 있다. 이를 엄격 모드 strict mode라고 부르는 기능으로 자바스크립트는 이러한 문자열을 읽어들인 순간부터 코드를 엄격하게 검사한다.<br>자세한 것은 <a data-tooltip-position="top" aria-label="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Strict_mode" rel="noopener nofollow" class="external-link" href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Strict_mode" target="_blank">모질라 엄격 모드 문서</a>를 참고.<br><br>자바스크립트에서 여러 자료를 다룰 때는 객체 Object를 사용한다. 객체에 typeof 연산자를 적용해보면 "object"라는 문자열이 출력된다.<br>자바스크립트에서는 앞서 다뤘던 배열도 객체로 취급한다. length 등의 속성과 filter() 등의 메소드를 사용할 수 있었던 것도 배열이 객체로 취급되기 때문이다.<br>객체는 중괄호( {...} )로 생성하며, 다음과 같은 형태의 자료를 쉼표(,)로 연결해서 입력한다.<br>키: 값<br>아래는 객체를 선언하는 구체적인 예시이다.<br>
const product = {
	제품명: '7D 건조 망고',
	유형: '당절임',
	성분: '망고, 설탕, 메타중아황산나트륨, 치자황색소',
	원산지: '필리핀'
}

<br>다음과 같이 객체 뒤에 대괄호를 사용하고 키를 입력하면 객체의 요소에 접근할 수 있다.<br>
product['제품명'];
product['유형'];
product['성분'];
product['원산지'];

<br>객체는 대괄호 대신에 다른 언어와 유사하게 온점을 사용하여 요소에 접근할 수도 있다.<br>
product.제품명;
product.유형;
product.성분;
product.원산지;

<br>단, 아래와 같이 식별자로 사용할 수 없는 문자열을 키로 사용했을 때는 무조건 대괄호를 사용해야 한다.<br>
// 식별자로 사용할 수 없는 단어를 키로 사용할 때는 문자열을 사용한다.
const object = {
	"with space" : 273,
	"with )%($#*(*@))" : 52
}

// 객체의 요소에 접근한다.
// 식별자로 사용할 수 없는 키에 접근할 때는 대괄호를 사용한다.
object["with space"];
object["with )%($#*(*@))"];

<br><br>객체의 속성 중 함수 자료형인 속성을 특별히 메소드 method라고 부른다. <br>메소드 내에서 자기 자신이 가진 속성을 출력하고 싶을 때는 자신이 가진 속성임을 분명하게 표시해야 한다. 자기 자신이 가진 속성이라는 것을 표시할 때는 this 키워드를 사용한다.<br>
// 변수 선언
const pet = {
	name: '구름',
	eat: function (food) {
		alert(this.name + '은/는' + food + '을/를 먹습니다.');
	}
}

// 메소드를 호출한다.
pet.eat('밥');

<br><br>자바스크립트에서는 객체가 선언된 이후에도 동적으로 요소를 추가하거나 제거하는 것이 가능하다.<br>요소를 추가할 때는 속성을 지정하고 값을 입력하면 된다.<br>
요소를 제거할 때는 delete 객체.속성의 형식으로 제거한다.<br>
// 객체 선언
const student = {};

// 객체의 속성 추가
student.이름 = '윤인성';
student.취미 = '악기';
student.장래희망 = '생명공학자';

// 출력해보기
console.log(JSON.stringify(student, null, 2));

// 객체의 속성 제거
delete student.장래희망;

// 출력해보기
console.log(JSON.stringify(student, null, 2));

<br><br>최신 버전 자바스크립트에서는 function () {} 보다 간단한 형식으로 메소드를 선언할 수 있는 전용 구문이 있다.<br>아래와 같이 선언한다.<br>
// 변수를 선언
const pet = {
	name: '구름',
	eat (food) {
		alert(this.name + '은/는' + food + '을/를 먹습니다.');
	}
}

// 메소드 호출
pet.eat('밥');

<br><br>function () {} 형태로 선언하는 익명 함수와 () =&gt; {} 형태로 선언하는 화살표 함수는 객체의 메소드로 사용될 때 this 키워드를 다루는 형식이 다르다.<br>
const test = {
	a: function () {
		console.log(this);
	},
	b: () =&gt; {
		console.log(this);
	}
}

// 메소드 호출
test.a();
test.b();

<br>화살표 함수 내에서 this 키워드를 사용하면 일반적으로 객체 스스로가 아닌 window 객체가 호출된다. 이러한 불확실성 때문에 객체 내부에서 화살표 함수를 메소드로 사용하지 않는 편이다.<br><br>자바스크립트의 data는 크게 기본 자료형 primitives과 객체 자료형 object로 구분할 수 있다.<br><br>자바스크립트에서는 객체로 선언한 요소만 객체가 아니라, 함수와 배열 또한 객체로 취급 받는다.<br>
function b () {}

b.sample = 10;

// 10이 반환되어 제대로 요소가 추가되었음을 확인할 수 있다.
// 기본 자료형에서는 이러한 동작이 불가능하다.
b.sample;

<br>함수는 실행 가능한 객체라는 특이한 data로 typeof 연산자를 사용해서 자료형을 확인하면 'function'을 출력한다. 함수는 객체의 특성을 완벽하게 가지고 있으므로 자바스크립트에서는 함수를 일급 객체 first-class object 또는 first-class citizen에 속한다고 표현하기도 한다.<br><br>기본 자료형은 객체가 아니기 때문에 속성이나 메소드를 가질 수 없지만, 자바스크립트는 기본 자료형을 객체로 선언하는 방법을 제공한다.<br>아래와 같은 방법으로 숫자 객체, 문자열 객체, 불 객체를 생성할 수 있다.<br>
const numObj = new Number(10);
const strObj = new String('안녕하세요');
const boolObj = new Boolean(true);

<br>위와 같이 생성된 객체들은 기본 자료형의 특징을 온전히 가지면서(연산자를 적용할 수 있다거나 등등) 객체로서의 특성도 활용할 수 있다.<br><br>앞서 문자열 자료형의 length, indexOf() 등을 사용하였는데, 기본 자료형은 속성, 메소드를 보유할 수 없으므로 이는 이상해 보인다. 이러한 방식의 사용이 가능한 것은 기본 자료형의 일시적 승급이라는 특성 때문이다.<br>자바스크립트는 사용의 편리성을 위해서 기본 자료형의 속성과 메소드를 호출할 때(기본 자료형 뒤에 온점을 찍고 무언가 하려고 하면) 일시적으로 기본 자료형을 객체로 승급시킨다.<br>이러한 승급은 일시적이다. 따라서 문자열 자료형에 동적으로 속성을 추가하는 등의 동작은 불가능하다.<br>
const h = '안녕하세요';

// 일시적으로 객체로 승급되어 sample 속성을 추가할 수 있다
h.sample = 10;

// 하지만 어디까지나 일시적인 승급이기 때문에 추가했던 속성은 이미 소멸하며 undefined를 반환한다.
h.sample;

<br><br><br><br>
const l = 123.456789;

// 소숫점 3번째 자리에서 반올림하여(즉, 2번째 자리까지만 출력한다) 문자열의 형태로 반환한다.
// 출력값 : "123.46"
l.toFixed(2);

<br><br>어떤 숫자가 Nan 또는 Infinity 인지 확인하기 위해 사용한다. 불 형식을 반환한다.<br>
// isNaN(), isFinite()는 기본자료형을 승급시켜 사용하는 것이 아닌, 자료형 객체의 메소드로서 호출해야 한다.

int n = 9238048;

// false 반환
Number.isFinite(n);
// false 반환
Number.isNaN(n);

<br><br><br>문자열 앞뒤의 공백, 줄바꿈을 제거한다.<br>
const stringA = '  
줄바꿈 공백  ';

// "줄바꿈 공백"을 반환
stringA.trim();

<br><br>delimeter를 사용하여 문자열을 잘라 배열을 만들어 반환한다.<br>
const str = "1,2,3,4,5";

// ["1", "2", "3", "4", "5"] 반환
str.split(",");

<br><br>문자열 자료형이 기본적으로 indexOf() 등의 메소드를 사용할 수 있는 것처럼, 다른 자료형에도 편리한 메소드나 속성을 지정할 수 있다. 예를 들어 숫자 자료형에 제곱 연산을 지원하는 power 메소드를 추가할 수 있으면 편리할 것이다.<br>이를 자료형의 prototype 속성에 추가한다라고 표현한다.<br>
/* 속성의 추가 */

// 객체 자료형 이름.prototype.메소드_이름 = function() {}의 형식으로 사용한다.
Number.prototype.example = 10;

const i = 273;

// 10이 반환된다.
i.sample;

<br>
/* 메소드의 추가 */
Number.prototype.power = function (n = 2) {
	return this.valueOf() ** n;
}

// Number 객체의 power() 메소드를 사용한다.
const a = 12;
console.log('a.power():', a.power());
console.log('a.power(3):', a.power(3));
console.log('a.power(4):', a.power(4));

<br>코드에서 this.valueOf()로 숫자값을 꺼내 사용하였다. 그냥 this ** n을 해도 아무 문제 없이 계산된다.<br>
하지만 객체 내부에서 값을 꺼내 쓰는 것임을 명확하게 하기 위해서 4행처럼 valueOf() 메소드를 사용하는 것이 일반적이다.<br><br><br>인터넷에서 문자열로 데이터를 주고 받을 때는 CSV, XML, CSON 등의 다양한 자료 표현 방식을 사용할 수 있다. 현재 가장 많이 사용되는 자료 표현 방식은 JSON 객체이다.<br>JSON은 JavaScript Object Notation의 약자로 자바스크립트의 객체처럼 자료를 표현하는 방식이다.<br>대부분의 프로그래밍 언어는 JSON 형식의 문자열을 읽어들이는 기능이 있다. 그래서 네트워크를 통해서 각각의 프로그래밍 언어로 만든 애플리케이션들이 데이터를 교환할 때 활용한다.<br>자바스크립트 객체를 JSON 문자열로 변환할 때는 JSON.stringify() 메소드를 사용한다.<br>
반대로 JSON 문자열을 자바스크립트 객체로 전개할 때는 JSON.parse() 메소드를 사용한다.<br><br>수학과 관련된 기본적인 연산을 할 때 사용한다.<br>많이 사용되는 Math 객체 속성으로는 pi, e와 같은 수학 상수가 있다.<br>
메소드로는 Math.sin(), Math.cos(), Math.tan()과 같은 삼각함수도 있다.<br><br>랜덤한 숫자를 생성할 때는 Math.random() 메소드를 사용한다. Math.random() 메소드는 0 이상, 1 미만의 랜덤한 실수를 생성한다. 따라서 그 이상의 범위에서 랜덤한 숫자를 구하려면 생성된 난수에 특정한 수를 곱하거나 더하는 등의 처리가 필요하다.<br><br>방법 1. &lt;script&gt; 블록의 src 속성에 읽어들일 js 파일의 경로를 기재<br>
&lt;!DOCTYPE html&gt;
&lt;html&gt;
	&lt;head&gt;
		&lt;title&gt;&lt;/title&gt;
		&lt;script src="test.js"&gt;&lt;/script&gt;
	&lt;/head&gt;
	&lt;body&gt;
	&lt;/body&gt;
&lt;/html&gt;

<br>방법 2. src 속성에 외부 라이브러리의 링크 기재하기<br>
&lt;!DOCTYPE html&gt;
&lt;html&gt;
	&lt;head&gt;
		&lt;title&gt;&lt;/title&gt;
		&lt;script src="https://..."&gt;&lt;/script&gt;
	&lt;/head&gt;
	&lt;body&gt;
	&lt;/body&gt;
&lt;/html&gt;

<br><br>CDN이란 콘텐츠 전송 네트워크라는 의미이다.<br>일반적으로 어떤 사이트는 어떤 특정한 지역의 서버에 위치한다. 먼 지역의 서버로부터 서비스를 지원받으려면, 속도가 느리거나, 아니면 서비스를 아예 지원받지 못할 수도 있다.<br>만약 전 세계 여러 지역에 전송할 데이터를 창고처럼 준비해두고 사용자가 데이터를 요청했을 때 가장 가까운 지역에서 데이터를 전송해준다면 훨씬 빠르게 데이터를 전송할 수 있다. 또한 가까운 지역에 문제가 있으면 그 다음으로 가까운 지역에서 데이터를 전송하면 데이터를 받을 수 없는 문제도 해결할 수 있다. 이러한 통신 네트워크를 CDN이라고 부른다.<br>참고로 CDN은 Contents Delivery Network의 약자이다.<br><br>min 버전의 자바스크립트 파일은 자바스크립트 코드를 집핑 zipping한 파일을 의미한다. 집핑이란 주석이나 개행 등의 코드의 실행에 필수적이지 않은 데이터를 최대한 줄이고 코드를 응축하는 과정을 말한다.<br><br><br>객체에 없는 속성에 접근을 시도하면 undefined 자료형을 반환한다.<br><br>다음과 같이 객체에 이미 속성이 존재하면 그대로 두고 그렇지 않다면 속성을 추가하는 기법이 존재한다.<br>
const obj = {
	a: "a";
};

obj.a = obj.a !== undefined ? obj.a : "a의 기본 값";

<br><br>최신 자바스크립트부터 배열과 비슷한 작성 기법으로 한 번에 여러 개의 변수에 값을 할당하는 다중 할당 기능이 추가되었다.<br>
let [a, b] = [1, 2];

// 1, 2를 출력
console.log(a, b);

// 다음과 같이 스왑을 간편하게 구현할 수 있다.
[a, b] = [b, a];

// 2, 1를 출력
console.log(a, b);

<br><br>최신 자바스크립트에서는 객체 내부에 있는 속성을 꺼내서 변수로 할당할 때 다음과 같은 코드를 사용할 수 있다.<br>
{ 속성 이름, 속성 이름 } = 객체
{ 식별자=속성 이름, 식별자=속성 이름 } = 객체

<br>
// 객체를 생성
const object = {
	name: '혼자 공부하는 파이썬',
	price: 18000,
	publisher: '한빛미디어'
}

// 객체에서 변수를 추출한다
const { name, price } = object;
console.log('# 속성 이름 그대로 꺼내서 출력하기');
console.log(name, price);
console.log('');

// name 속성을 a라는 이름으로, price 속성을 b라는 이름으로 꺼낸다.
const { a=name, b=price } = object;
console.log('# 다른 이름으로 속성 꺼내서 출력하기');
console.log(a, b);

<br><br>자바스크립트에서도 얕은 복사라는 개념이 존재한다. 다음과 같은 형식으로 배열을 복사하면 두 식별자는 같은 배열을 가리키게 된다.<br>
// 사야 하는 물건 목록
const obj_200301 = ['우유', '식빵'];
const obj_200302 = obj_200301;

<br>보통 깊은 복사를 할 때엔 앞에서 다룬 전개 연산자를 사용한다.<br>
// 전개 연산자를 대괄호로 감싸야 한다.
const obj_200301 = ['우유', '식빵'];
const obj_200302 = [...obj_200301];

<br>다음과 같이 배열을 전개하고 앞 또는 뒤에 자료를 추가하는 것도 가능하다.<br>
const obj_200302 = ['고구마', ...obj_200301, '토마토'];

<br><br>객체를 깊은 복사할 때는 전개 연산자를 아래와 같은 형식으로 사용한다.<br>
const cloud = {
	name: 'cloud',
	age: 6,
	type: 'puppy'
}

const star = {...cloud};

<br>배열의 경우와 마찬가지로 앞 뒤에 원하는 속성을 추가하는 것도 가능하다.<br>
const star = {
	...cloud,
	// 기존의 속성 덮어쓰기
	// ...cloud 가 맨 위에 위치하냐 아래에 위치하냐에 따라 덮어씌우는 서순이 다르다.
	name: 'star',
	// 새로운 속성 추가
	level: 45
}

<br><br><a data-href="HTML" href="resource\web\html\html.html" class="internal-link" target="_self" rel="noopener nofollow">HTML</a> 페이지에 있는 <a data-tooltip-position="top" aria-label="HTML 태그, 요소 그리고 속성" data-href="HTML 태그, 요소 그리고 속성" href="resource\web\html\html-태그,-요소-그리고-속성.html" class="internal-link" target="_self" rel="noopener nofollow">요소</a>들을 자바스크립트에서는 문서 객체 document object라고 부른다.<br>문서 객체를 조합해서 만든 전체적인 형태를 문서 객체 모델 DOM, Document Objects Model이라고 부른다.<br><br>자바스크립트는 문서 객체를 조작하여 동적으로 페이지를 변경시키는 일이 많다.<br>
이때 DOMContentLoaded 이벤트를 사용한다.<br>
document.addListener('DOMContentLoaded', () =&gt; {
	// 문장
})

<br>DOM을 사용할 때 주의해야 할 점이 있다. 기본적으로 HTML 태그는 위에서 아래 방향으로 순차적으로 생성되기 때문에 해당 태그가 생성되기 전에 DOM을 적용시키려고 하면 에러가 발생한다.<br>
&lt;!DOCTYPE html&gt;

&lt;html&gt;
&lt;head&gt;
	&lt;title&gt;DOMContentLoaded&lt;/title&gt;
	&lt;script&gt;
		// HTML 태그를 쉽게 만들 수 있는 콜백 함수를 선언한다.
		const h1 = (text) =&gt; `&lt;h1&gt;{text}&lt;/h1&gt;`
	&lt;/script&gt;
	&lt;script&gt;
		// 앞에서 선언한 h1 함수를 실행한다.
		// body 태그가 생성되기 전 script 태그로 body 태그를 조작하므로 에러가 난다.
		document.body.innerHTML += h1('1번째 script 태그');
	&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
	&lt;script&gt;
		document.body.innerHTML += h1('2번째 script 태그');
	&lt;/script&gt;
	&lt;h1&gt;1번째 h1 태그&lt;/h1&gt;
	&lt;script&gt;
		document.body.innerHTML += h1('3번째 script 태그');
	&lt;/script&gt;
	&lt;h1&gt;2번째 h2 태그&lt;/h1&gt;
&lt;/body&gt;
&lt;/html&gt;

<br>DOMContentLoaded 이벤트는 웹 브라우저가 문서 객체를 모두 읽고 나서 실행되는 이벤트이다. 다음과 같이 코드를 구성하면 DOMContentLoaded 상태가 되었을 때 콜백 함수를 호출한다.<br>
&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
	&lt;title&gt;DOMContentLoaded&lt;/title&gt;
	&lt;script&gt;
		// DOMContentLoaded 이벤트를 연결한다.
		document.addEventListener('DOMContentLoaded', () =&gt; {
			const h1 = (text) =&gt; `&lt;h1&gt;${text}&lt;/h1&gt;`;
			document.body.innerHTML += h1('DOMContentLoaded 이벤트 발생');
		})
	&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;/body&gt;
&lt;/html&gt;

<br><br>document.body 코드를 사용하면 문서의 body 요소를 읽어들일 수 있다. 이외에도 HTML 문서에 있는 head 요소와 title 요소 등은 다음과 같은 방법으로 읽어들일 수 있다.<br>
document.body
document.head
document.title

<br>이는 웹 브라우저의 자바스크립트가 '당연히 있겠지'라고 전제하고 만든 속성이다(그럴 일은 드물겠지만, html에 해당 태그를 만들어놓지 않으면 버그 난다는 소리다).<br>head, body 요소 내부에 있는 다른 요소들은 다음과 같은 별도의 메소드를 사용해서 접근한다.<br>
document.querySelector(선택자);
document.querySelectAll(선택자)

<br>선택자 부분에는 <a data-href="CSS 선택자" href="resource\web\css\css-선택자.html" class="internal-link" target="_self" rel="noopener nofollow">CSS 선택자</a>를 입력한다.<br>querySelector() 메소드는 요소를 하나만 추출하고, querySelectorAll() 메소드는 문서 객체를 여러 개 추출한다.<br>다음은 querySelector() 메소드를 사용해서 h1 태그를 추출하고 조작하는 예이다.<br>
&lt;script&gt;
	document.addEventListener('DOMContentLoaded', () =&gt; {
		// 요소를 읽어들인다.
		// h1 태그 이름으로 요소를 선택한다.
		const header = document.querySelector('h1');

		// 텍스트와 스타일을 변경한다.
		header.textContent = 'HEADERS';
		header.style.color = 'white';
		header.style.backgroundColor = 'black';
		header.style.padding = '10px';
	});
&lt;/script&gt;
&lt;body&gt;
	&lt;h1&gt;&lt;h1&gt;
&lt;/body&gt;

<br>querySelectorAll()은 문서 객체 여러 개를 배열로 읽어들이는 함수이므로 내부의 요소에 전근하고 활용하려면 반복문을 활용해야 한다.<br>
&lt;script&gt;
	document.addEventListener('DOMContentLoaded', () =&gt; {
		// 요소를 읽어들인다.
		const headers = document.querySelectorAll('h1');

		// 텍스트와 스타일을 변경한다.
		headers.forEach((header) =&gt; {
			header.textContent = 'HEADERS';
			header.style.color = 'white';
			header.style.backgroundColor = 'black';
			header.style.padding = '10px';
		})
	})
&lt;/script&gt;
&lt;body&gt;
	&lt;h1&gt;&lt;h1&gt;
	&lt;h1&gt;&lt;h1&gt;
	&lt;h1&gt;&lt;h1&gt;
	&lt;h1&gt;&lt;h1&gt;
&lt;/body&gt;

<br><br>문서 객체 내부의 글자들을 조작할 때는 다음과 같은 메소드를 사용한다.<br><br><br>문서 객체의 속성을 조작할 때는 다음과 같은 메소드를 사용한다.<br><br>다음 코드는 img 태그의 src 속성을 조작해서 이미지를 출력하는 예이다.<br>
&lt;script&gt;
	document.addEventListener('DOMContentLoaded', () =&gt; {
		const rects = document.querySelector('.rect');
	
		rects.forEach((rect, index) =&gt; {
			const width = (index + 1) * 100;
			const src = `http://placecats.com/${width}/250`;
			// src 속성에 값을 지정한다
			rect.setAttribute('src', src);
		})
	})
&lt;/script&gt;
&lt;body&gt;
	&lt;img class="rect"&gt;
	&lt;img class="rect"&gt;
	&lt;img class="rect"&gt;
	&lt;img class="rect"&gt;
&lt;/body&gt;

<br>get, setAttribute()를 사용하지 않고도 온점을 사용하여 문서 객체의 속성에 간단히 값을 지정할 수 있다.<br>
rects.forEach((rect, index) =&gt; {
	const width = (intex + 1) * 100;
	const src = `http://placecats.com/${width}/250`;
	rect.src = src;
})

<br><br>문서 객체의 스타일을 조작할 때는 style 속성을 사용한다. syle 속성은 객체이며, 내부에는 속성으로 CSS를 사용해서 지정할 수 있는 스타일들이 있다. 이러한 속성에는 CSS로 입력할 때 사용하는 값과 같은 값을 입력한다.<br>다만 자바스크립트에서 사용하는 속성들의 이름은 CSS에서 사용할 때의 속성들의 이름과 약간 다르다. 자바스크립트에서는 - 기호를 식별자에 사용할 수 없으므로, 두 단어 이상의 속성은 다음과 같이 캐멀 케이스로 나타낸다.<br><br>style 객체는 총 3가지 방법으로 스타일을 조정할 수 있다. 일반적으로 첫번째 방법을 가장 많이 사용한다.<br>
h1.style.backgroundColor;
h1.style['backgroundColor'];
h1.style['background-color'];

<br>다음 코드는 25개의  div 태그를 조작해서 검은색에서 흰색으로 변화하는 그레이디언트를 만드는 코드이다.<br>
&lt;script&gt;
	document.addEventListener('DOMContentLoaded', () =&gt; {
		// body 태그 아래에 있는 div 태그를 선택한다.
		const divs = document.querySelectorAll('body &gt; div');
		
		divs.forEach(div, index) =&gt; {
			console.log(div, index);
			const val = index * 10;
			// 크기를 지정할 때는 반드시 단위를 함께 붙여줘야 한다.
			div.style.height = '10px';
			div.style.backgroundColor = `rgba${val}, ${val}, ${val}`
		}})
&lt;/script&gt;
&lt;body&gt;
	&lt;div&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;...
&lt;/body&gt;

<br><br> 지금까지는 body 태그 내부에 특정 문서 객체를 읽어들이고 이를 조작하였다. 문서 객체를 생성하고 싶을 때에는 document.createElement() 메소드를 사용한다.<br>하지만 자바스크립트에서 문서 객체를 생성하는 것과 그 문서 객체를 어느 위치에 배치시킬 지 정하는 것은 별개의 작업이다.<br>어떠한 부모 객체 아래에 자식 객체를 추가하기 위해서  appendChild() 객체를 사용한다.<br>다음의 코드는 h1 태그를 새로 생성하고 이를 document.body의 자식으로 배치하는 코드이다.<br>
&lt;script&gt;
	document.addEventListener('DOMContentLoaded', () =&gt; {
		// 문서 객체 생성하기
		// h1 태그를 생성한다.
		const header = document.createElement('h1');

		// 생성한 태그를 조작한다.
		header.textContent = '문서 객체 동적으로 생성하기';
		header.setAttribute('data-custom', '사용자 정의 속성');
		header.style.color = 'white';
		header.style.backgroundColor = 'black';

		// h1 태그를 body 태그 아래에 추가한다.
		document.body.appendChild(header);
	})
&lt;/script&gt;
&lt;body&gt;
&lt;/body&gt;

<br><br>appendChild() 메소드는 문서 객체를 이동할 때도 사용할 수 있다. 문서 객체의 부모 parent는 언제나 하나여야 한다. 따라서 문서 객체를 다른 문서 객체에 추가하면 문서 객체가 이동한다.<br>다음 코드는 1초마다 h1 태그 요소가 div#first 태그와 div#second 태그 사이를 번갈아가며 움직이게 한다.<br>
&lt;script&gt;
	document.addEventListener('DOMContentLoaded', () =&gt; {
		// 문서 객체 읽어들이고 생성하기
		const divA = document.querySelector('#first');
		const divB = document.querySelector('#second');
		const h1 = document.createElement('h1');
		h1.textContent = '이동하는 h1 태그';
	
		// 서로 번갈아가면서 실행하는 함수를 구현한다
		const toFirst = () =&gt; {
			// h1을 divA에 추가한다.
			divA.appendChild(h1);
			// 1초 뒤에 toSecond 함수를 실행한다.
			setTimeout(toSecond, 1000);
		}
		const toSecond = () =&gt; {
			// h1을 divA에 추가한다
			divA.appendChild(h1);
			// 10초 뒤에 toFirst 함수를 실행한다.
			setTimeout(toFirst, 10000);
		}
		toFirst();
	})
&lt;/script&gt;
&lt;body&gt;
	&lt;div id="first"&gt;
		&lt;h1&gt;첫 번째 div 태그 내부&lt;/h1&gt;
	&lt;/div&gt;
	&lt;hr&gt;
	&lt;div id="second"&gt;
		&lt;h1&gt;두 번째 div 태그 내부&lt;/h1&gt;
	&lt;/div&gt;
&lt;/body&gt;

<br><br>문서 객체를 제거할 때는 removeChild() 메소드를 사용한다.<br>
부모_객체.removeChild(자식_객체);

<br>appendChild() 메소드 등으로 부모 객체와 이미 연결이 완료된 문서 객체의 경우 parentNode 속성으로 부모 객체에 접근할 수 있으므로, 일반적으로 어떤 문서 객체를 제거할 때는 다음과 같은 형태의 코드를 사용한다.<br>
문서_객체.parentNode.removeChild(문서_객체);

<br>
&lt;script&gt;
	document.addEventListener('DOMContentLoaded', () =&gt; {
		setTimeout(() =&gt; {
			const h1 = document.querySelector('h1');

			// h1 태그의 부모 객체 body 태그에 접근하여 제거한다.
			h1.parentNode.removeChild(h1);
			// h1.parentnode가 document.body이므로, 이런 형태로 제거할 수 있다
			// document.body.removeChild(h1);
		}, 3000)
	});
&lt;/script&gt;
&lt;body&gt;
	&lt;hr&gt;
	&lt;h1&gt;제거 대상 문서 객체&lt;/h1&gt;
	&lt;hr&gt;
&lt;/body&gt;

<br><br>지금까지 계속 documen.addEventListener('DOMConentLoaded', () =&gt; {})라는 형태의 코드를 사용하고 있다. 이 코드는 document라는 문서 객체의 DOMContentLoaded 이벤트가 발생했을 때, 매개변수로 지정한 콜백 함수를 실행해라는 의미이다.<br>모든 문서 객체는 생성되거나 클릭되거나 마우스를 위에 올리거나 할 때 이벤트 event라는 것이 발생한다. 그리고 이 이벤트가 발생할 때 실행할 함수는 addEventListener() 메소드를 사용한다.<br>
문서_객체.addEventListener(이벤트_이름, 콜백_함수);

<br>이벤트가 발생할 때 실행할 함수를 이벤트 리스너 Event Listener 또는 이벤트 핸들러 Event Handler라고 부른다. 어떤 이벤트가 있고, 어떤 형태로 활용하는지는 다음 절에서 살펴보기로 하고 이번 절에서는 이벤트를 연결하는 형태만 살펴본다.<br>다음 코드는 addEventListener() 메소드를 사용해서 h1 태그를 클릭할 때 이벤트 리스너(콜백 함수)를 호출하는 예이다. 이벤트 리스너 내부에서 변수 counter를 증가시키고 출력하고 있다.<br>
&lt;script&gt;
	document.addEventListener('DOMContentLoaded', () =&gt; {
		let counter = 0;
		const h1 = document.querySelector('h1');

		h1.addEventListener('click', (event) =&gt; {
			// h1 태그에 이벤트가 발생할 때 실행할 함수
			counter++;
			h1.textContent = `클릭 횟수: ${counter}`;
		})
	})
&lt;/script&gt;
&lt;style&gt;
	h1 {
		/*
			클릭을 여러 번 했을 때 글자가 선택되는 것을 막기 위한 스타일. 디자인 상 넣는 것이므로 안 넣어도 상관은 없다.
		*/
		user-select: none;
	}
&lt;/style&gt;
&lt;body&gt;
	&lt;h1&gt;클릭 횟수: 0&lt;/h1&gt;
&lt;/body&gt;

<br>이벤트 핸들러를 제거할 때는 다음과 같은 형태로 removeEventListener() 메소드를 사용한다.<br>문서_객체.removeEventListener(이벤트 이름, 이벤트 리스너)<br>이벤트 리스너 부분에 연결할 때 사용했던 이벤트 리스너를 넣는다.<br><br><br>이벤트를 연결하는 방법을 이벤트 모델 event model이라고 부른다. 이제껏 사용한 addEventListener()메소드는 현재 표준으로 사용하고 있는 방법이므로 표준 이벤트 모델이라고 부른다.<br>고전 이벤트 모델과 인라인 모델에 관한 서술은 생략한다.<br><br><br>keydown 이벤트와 keypress 이벤트는 웹 브라우저에 따라서 아시아권의 문자(한국어, 중국어, 일본어)를 제대로 처리하지 못하는 문제가 있어서 일반적으로는 keyup 이벤트를 사용한다.<br>
&lt;script&gt;
	document.addEventListener('DOMContentLoaded', () =&gt; {
		const textarea = document.querySelector('textarea');
		const h1 = document.querySelector('h1');

		textarea.addEventListener('keyup', (event) =&gt; {
			// value 속성으로 입력 양식의 글자를 읽어들일 수 있다.
			const length = textarea.value.length;
			h1.textContent = `글자 수: ${length}`;
		});
	})
&lt;/script&gt;
&lt;body&gt;
	&lt;h1&gt;&lt;/h1&gt;
	&lt;textarea&gt;&lt;/textarea&gt;
&lt;/body&gt;

<br><br>키보드 이벤트가 발생할 때는 이벤트 객체로 어떤 키를 눌렀는지와 관련된 속성들이 따라온다. 주로 쓰이는 속성들은 다음과 같다.<br><br>code 속성은 입력한 키를 나타내는 문자열이 들어있고, altKey, ctrlKey, shiftKey 속성은 해당 키를 눌렀는지 불 자료형 값이 들어있다.<br>다음 코드는 keydown 이벤트와 keyup 이벤트가 발생할 때 표에서 설명한 속성을 모두 출력하는 프로그램이다.<br>
&lt;script&gt;
	document.addEventListener('DOMContentLoaded', () =&gt; {
		const h1 = document.querySelector('h1');
		const print = (event) =&gt; {
			let output = '';
			// 이벤트가 발생하면 불 값을 반환해야 한다.
			output += `alt: ${event.altKey}&lt;br&gt;`;
			output += `ctrl: ${event.ctrlKey}&lt;br&gt;`;
			output += `shift: ${event.shiftKey}&lt;br&gt;`;
			// event.code가 있으면 event.code를 출력하고, undefined라면 event.keyCode를 출력한다.
			output += `code: ${typeof(event.code) !== 'undefined' ?
				event.code : event.keyCode}&lt;br&gt;`
			h1.innerHTML = output;
		}

		// 키가 눌릴 때 출력한다
		document.addEventListener('keydown', print);
		// 키가 떨어질 때 출력한다
		document.addEventListener('keyup', print);
	});
&lt;/script&gt;
&lt;body&gt;
	&lt;h1&gt;&lt;/h1&gt;
&lt;/body&gt;

<br>
&lt;script&gt;
	document.addEventListener('DOMContentLoaded', () =&gt; {
		// 별의 초기 설정
		const star = document.querySelector('h1');
		// style 속성을 조작하여 position 값을 설정한다
		star.style.position = 'absolute';

		// 별의 이동을 출력하는 기능
		let [x, y] = [0, 0];
		const block = 20;
		const print = () =&gt; {
			star.style.left = `${x * block}px`;
			star.style.top = `${y * block}px`;
		}
		print();

		// 별을 이동하는 기능
		const [left, up, right, down] = [37, 38 ,39 ,40];
		// 아시아권 문자를 사용하지 않으므로 keydown 이벤트를 사용해도 된다.
		document.body.addEventListener('keydown', (event) =&gt; {
			switch (event.keyCode)
			{
				case left:
					x -= 1;
					break ;
				case up:
					y -= 1;
					break ;
				case right:
					x += 1;
					break ;
				case down:
					y += 1;
					break ;
			}
			print();
		})

<br><br>지금까지는 이벤트 내부에서 문서 객체 변수를 사용해 문서 객체와 관련된 정보를 추출하였다.<br>
// 이전에 사용했던 코드
document.addEventListener('DOMContentLoaded', () =&gt; {
	const textarea = document.querySelector('textarea');
	const h1 = document.querySelector('h1');

	textarea.addEventListener('keyup', (event) =&gt; {
		// value 속성으로 입력 양식의 글자를 읽어들일 수 있다.
		const length = textarea.value.length;
		h1.textContent = `글자 수: ${length}`;
	})
})

<br>그런데 코드의 규모가 켜지면 이벤트 리스너를 외부로 분리하는 경우가 많다. 상황에 따라서는 이벤트 리스너 내부에서 그러한 변수에 접근하지 못할 수 있다. 다음 코드에서는 listener() 함수 내부에서 textarea 변수에 접근할 수 없어 오류가 발생한다.<br>
// 이벤트 리스너를 외부로 빼낸 경우
const listener = (event) =&gt; {
	// scope 때문에 현재 블록에서는 textarea 변수를 사용할 수 없다.
	const length = textarea.value.length;
	h1.textContent = `글자 수 : ${length}`;
}

document.addEventListener('DOMContentLoaded', () =&gt; {
	const textarea = document.querySelector('textarea');
	const h1 = document.querySelector('h1');

	textarea.addEventListener('keyup', listener)
})

<br>이러한 경우 이벤트를 발생시킨 객체(현재 코드의 textarea)에 접근할 수 있는 방법은 2가지이다.<br>방법 1. event.currentTarget 속성을 사용한다.<br>
// event.currentTarget이 textarea가 된다.
const listener = (event) =&gt; {
	const length = event.currentTarget.value.length;
	h1.textContent = `글자 수 : ${length}`;
}

document.addEventListener('DOMContentLoaded', () =&gt; {
	const textarea = document.querySelector('textarea');
	const h1 = document.querySelector('h1');

	textarea.addEventListener('keyup', listener)
})

<br>방법 2. this 키워드를 사용한다<br>이 방법은 화살표 함수가 아닌 function () {} 형태로 함수를 선언한 경우에 사용한다.<br>
// this가 textarea가 된다.
const listener = (event) =&gt; {
	const length = this.value.length;
	h1.textContent = `글자 수 : ${length}`;
}

document.addEventListener('DOMContentLoaded', () =&gt; {
	const textarea = document.querySelector('textarea');
	const h1 = document.querySelector('h1');

	textarea.addEventListener('keyup', listener)
})

<br><br>
&lt;!--입력 양식을 기반으로 inch를 cm 단위로 변환하는 프로그램--&gt;

&lt;script&gt;
	document.addEventListener('DOMContentLoaded', () =&gt; {
		const input = document.querySelector('input')
		const button = document.querySelector('button');
		const p = document.querySelector('p');

		button.addEventListener('click', () =&gt; {
			// 입력을 숫자로 변환한다
			const inch = Number(input.value);
			// 숫자가 아니라면 바로 리턴한다
			if (isNaN(inch))
			{
				p.textContent = '숫자를 입력해주세요.';
				return ;
			}
			// 변환해서 출력한다.
			const cm = inch * 2.54;
			p.textContent = `${cm} cm`;
		})
	})
&lt;/script&gt;
&lt;body&gt;
	&lt;input type="text"&gt; inch&lt;br&gt;
	&lt;button&gt;계산&lt;/button&gt;
	&lt;p&gt;&lt;/p&gt;
&lt;/body&gt;

<br>
&lt;!--이메일 형식을 확인하기--&gt;

&lt;script&gt;
	document.addEventListener('DOMContentLoaded', () =&gt; {
		const input = document.querySelector('input');
		const p = document.querySelector('p');
		// 이메일인지 검사하는 함수
		const isEmail = (value) =&gt; {
			// 골뱅이를 갖고 있고 &amp;&amp; 골뱅이 뒤에 점이 있다면
			return (value.index('@') &gt; 1)
				&amp;&amp; (value.split('@')[1].indexOf('.') &gt; 1);
		}

		input.addEventListener('keyup', (event) =&gt; {
			const value = event.currentTarget.value;
			if (isEmail(value))
			{
				p.style.color = 'green';
				p.textContent = `이메일 형식입니다: ${value}`;
			}
			else
			{
				p.style.color = 'red';
				p.textContent = `이메일 형식이 아닙니다: ${value}`;
			}
		})
	})
&lt;/script&gt;
&lt;body&gt;
	&lt;input type="text"&gt;
	&lt;p&gt;&lt;/p&gt;
&lt;/body&gt;

<br>위의 이메일 확인 예제에서 유효성 검사를 할 때 문자열을 분석하는데, 차후 정규 표현식 regular expression을 사용하면 이러한 종류의 문제를 더욱 쉽게 해결할 수 있다.<br>

원래 입력 양식은 값이 변경될 때 change 이벤트를 발생한다. 글자 입력 양식은 입력 양식을 선택(focus 상태)해서 글자를 입력하고, 선택을 해제(blur 상태)할 때 change 이벤트를 발생시킨다. 따라서 사용자가 입력하는 중에는 change 이벤트가 발생하지 않는다. 지금까지 살펴본 코드는 값을 입력할 때 실시간으로 처리하고자 keyup 이벤트를 값을 입력할 때 실시간으로 처리하고자 keyup 이벤트를 사용하였다.
<br><br>드롭다운 목록은 기본적으로 select 태그로 구현한다.<br>
&lt;!--기본 select 태그--&gt;
&lt;script&gt;
	document.addEventListener('DOMContentLoaded', () =&gt; {
		const select = document.querySelector(`select`);
		const p = document.querySelector('p');

		select.addEventListener('change', (event) =&gt; {
			const options = event.currentTarget.options;
			const index = options.selectedIndex;

			p.textContent = `선택: ${options[index].textContent}`;
		})
	})
&lt;/script&gt;
&lt;body&gt;
	&lt;select&gt;
		&lt;option&gt;떡볶이&lt;/option&gt;
		&lt;option&gt;순대&lt;/option&gt;
		&lt;option&gt;오뎅&lt;/option&gt;
		&lt;option&gt;튀김&lt;/option&gt;
	&lt;/select&gt;
	&lt;p&gt;선택: 떡볶이&lt;/p&gt;
&lt;/body&gt;

<br>select 태그에 multiple 속성을 부여하면 ctrl 키 또는 shift 키를 누르고 여러 항목을 선택할 수 있는 선택 상자가 나온다.<br>
&lt;!--multiple select 태그--&gt;
&lt;script&gt;
	document.addEventListener('DOMContentLoaded', () =&gt; {
		const select = document.querySelector(`select`);
		const p = document.querySelector('p');

		select.addEventListener('change', (event) =&gt; {
			const options = event.currentTarget.options;
			const list = [];
			// options 속성에는 forEach() 메소드가 없으므로 반복문으로 돌려야 한다.
			for (const option of options)
			{
				if (option.selected)
				{
					list.push(option.textContent);
				}
			}
			p.textContent = `선택: ${list.join(',')}`;
		})
	})
&lt;/script&gt;
&lt;body&gt;
	&lt;select&gt;
		&lt;option&gt;떡볶이&lt;/option&gt;
		&lt;option&gt;순대&lt;/option&gt;
		&lt;option&gt;오뎅&lt;/option&gt;
		&lt;option&gt;튀김&lt;/option&gt;
	&lt;/select&gt;
	&lt;p&gt;선택: 떡볶이&lt;/p&gt;
&lt;/body&gt;

<br><br>체크 박스처럼 체크 상태를 확인할 때는 입력 양식의 checked 속성을 활용한다.<br>
&lt;!--체크 상태일 때만 타이머를 증가시키는 프로그램--&gt;
&lt;script&gt;
	document.addEventListener('DOMContentLoaded', () =&gt; {
		let [timer, timerId] = [0, 0];
		const h1 = document.querySelector('h1');
		const checkbox = document.querySelector('input');

		checkbox.addEventListener('change', (event) =&gt; {
			if (event.currentTarget.checked)
			{
				// checked 속성을 사용한다.
				if (event.currentTarget.checked)
				{
					// 체크 상태
					timerId = setInterval(() =&gt; {
						timer += 1;
						h1.textContent = `${timer}초`
					}, 1 * 1000);
				}
				else
				{
					// 체크 해제 상태
					clearInterval(timerId);
				}
			}
		})
	})
&lt;/script&gt;
&lt;body&gt;
	&lt;input type="checkbox"&gt;
	&lt;span&gt;타이머 활성화&lt;/span&gt;
	&lt;h1&gt;&lt;/h1&gt;
&lt;/body&gt;

<br><br>라디오 버튼은 여러 개의 선택지 중에 하나의 요소를 checked 속성을 사용하여 선택할 수 있게 해주는 옵션이다.<br>
&lt;script&gt;
	document.addEventListener('DOMContentLoaded', () =&gt; {
		// 문서 객체 추출하기
		const output = document.querySelector('#output');
		const radios = document.querySelectorAll('[name=pet]');

		// 모든 라디오 버튼에
		radios.forEach((radio) =&gt; {
			// 이벤트 연결
			radio.addEventListener('change', (event) =&gt; {
				const current = event.currentTarget;
				if (current.checked)
				{
					output.textContent = `좋아하는 애완동물은 ${current.value}이시군요!`;
				}
			})
		})
	})
&lt;/script&gt;
&lt;body&gt;
	&lt;h3&gt;# 좋아하는 애완동물을 선택해주세요&lt;/h3&gt;
	&lt;!--라디오 버튼을 하나씩만 선택하려면 name 속성을 동일하게 입력해 그룹으로 만든다.--&gt;
	&lt;input type="radio" name="pet" value="강아지"&gt;
	&lt;span&gt;강아지&lt;/span&gt;
	&lt;input type="radio" name="pet" value="고양이"&gt;
	&lt;span&gt;고양이&lt;/span&gt;
	&lt;input type="radio" name="pet" value="햄스터"&gt;
	&lt;span&gt;햄스터&lt;/span&gt;
	&lt;input type="radio" name="pet" value="기타"&gt;
	&lt;span&gt;기타&lt;/span&gt;
	&lt;hr&gt;
	&lt;h3 id="output"&gt;&lt;/h3&gt;
&lt;/body&gt;

<br>
name 속성이 없는 라디오 버튼<br>
참고로 name 속성을 입력하지 않으면 라디오 버튼을 한번에 여러 개 선택할 수 있다. 카테고리 구분 없이 선택할 수 있으며, 한번 선택하고 나면 선택을 취소할 수도 없다.<br>
따라서 라디오 버튼을 사용할 때는 name 속성과 함께 사용하는 것이 좋다.
<br><br>웹 브라우저에서 마우스 오른쪽 버튼을 클릭하면 출력되는 메뉴를 컨텍스트 메뉴 context menu라고 한다.<br>
이처럼 어떤 이벤트가 발생했을 때 웹 브라우저가 기본적으로 처리해주는 것을 기본 이벤트라고 부른다.<br>링크를 클릭했을 때 이동하는 것, 제출 버튼을 눌렀을 때 이동하는 것 등이 모두 기본 이벤트의 예이다. 이러한 기본 이벤트를 제거할 때는 event 객체의 preventDefault() 메소드를 사용한다.<br>
&lt;script&gt;
	document.addEventListener('DOMContentLoaded' () =&gt; {
		const imgs = document.querySelectorAll('img');

		imgs.forEach((img) =&gt; {
			img.addEventListener('contextmenu', (event) =&gt; {
				// 컨텍스트 메뉴를 출력하는 기본 이벤트를 제거한다.
				event.preventDefault();
			})
		})
	})
&lt;/script&gt;
&lt;body&gt;
	&lt;img src="http://placecats.com/300/300" alt=""&gt;
&lt;/body&gt;

<br>인터넷에서 이미지 불펌 방지 등을 구현할 때 사용하는 코드이므로 기억해두면 유용하게 활용할 수 있다.<br>
&lt;!--다른 입력 양식과 조합해서 사용하는 예
	체크 때만 링크 활성화하기--&gt;

&lt;script&gt;
	document.addEventListener('DOMContentLoaded', () =&gt; {
		let status = false;

		const checkbox = document.querySelector('input');
		checkbox.addEventListener('change', (event) =&gt; {
			status = event.currentTarget.checked;
		});

		const link = document.querySelector('a');
		lint.addEventListener('click', (event) =&gt; {
			if (!status)
			{
				// status가 false가 아니면 링크의 기본 이벤트를 제거한다
				event.preventDefault()
			}
		})
	})
&lt;/script&gt;
&lt;body&gt;
	&lt;input type="checkbox"&gt;
	&lt;span&gt;링크 활성화&lt;/span&gt;
	&lt;br&gt;
	&lt;a href="http://hanbit.co.kr"&gt;한빛미디어&lt;/a&gt;
&lt;/body&gt;

<br><br>아시아권의 문자는 키보드 이벤트로 원하는 것을 제대로 구현할 수 없는 경우가 많다.<br>실제로 트위터는 아래 코드와 같이 타이머를 사용해서 50밀리초마다 입력 양식 내부의 글자를 확인해서 글자 수를 센다. focus 이벤트와 blur 이벤트를 활용하였다.<br>
&lt;script&gt;
	document.addEventListener('DOMContentLoaded', () =&gt; {
		const textarea = document.querySelector('textarea');
		const h1 = document.querySelector('h1');
		let timerId;

		textarea.addEventListener('focus', (event) =&gt; {
			// 입력 양식 활성화
			timerId = setInterval(() =&gt; {
				const length = textarea.value.length;
				h1.textContent = `글자 수: ${length}`;
			}, 50)
		})
		textarea.addEventListener('blur', (event) =&gt; {
			// 입력 양식 비활성화
			clearInterval(timerId);
		})
	})
&lt;/script&gt;
&lt;body&gt;
	&lt;h1&gt;&lt;/h1&gt;
	&lt;textarea&gt;&lt;/textarea&gt;
&lt;/body&gt;

<br><br>localStorage 객체는 웹 브라우저가 기본적으로 제공하는 객체이며, 데이터를 저장하고 반환하는 기능을 가지고 있다.<br>아래와 같은 메소드를 가지고 있다.<br>
<br>localStorage.getItem(키) : 저장된 값을 추출한다. 없으면 undefined가 나온다. 객체의 속성을 추출하는 일반적인 형태로 localStorage.키 또는 localStorage[키] 형태로 사용할 수도 있다.
<br>localStorage.setItem(키, 값) : 값을 저장한다. 이전과 마찬가지로 객체에 속성을 지정하는 일반적인 형태를 사용할 수도 있다.
<br>localStorage.removeItem(키) : 특정 키의 값을 제거한다.
<br>localStorage.clear() : 저장된 모든 값을 제거한다.
<br>
&lt;!--localStorage 객체의 활용--&gt;
&lt;script&gt;
	document.addEventListener('DOMContentLoaded', () =&gt; {
		const p = document.querySelector('p');
		const input = document.querySelector('input');
		const button = document.querySelector('button');

		// 값을 읽을 때는 getItem() 메소드를 사용한다.
		const savedValue = localStorage.getItem('input');
		// localStorage.input도 가능하다.
		if (savedValue)
		{
			input.value = savedValue;
			p.textContent = `이전 실행 때의 마지막 값: ${savedValue}`;
		}

		input.addEventListener('keyup', (event) =&gt; {
			const value = event.currentTarget.value;
			localStorage.setItem('input', value);
		})

		button.addEventListener('click', (event) =&gt; {
			localStorage.clear();
			input.value = '';
		})
	})
&lt;/script&gt;
&lt;body&gt;
	&lt;p&gt;&lt;/p&gt;
	&lt;button&gt;지우기&lt;/button&gt;
	&lt;input type="text"&gt;
&lt;/body&gt;

<br><br>자바스크립트의 오류는 2가지로 나뉜다.<br>구문 오류 syntax error: 괄호 개수를 잘못 입력하는 등의 오류로 코드가 실행조차 되지 않는 오류<br>
예외 exception, 런타임 오류 runtime error : 구문 오류를 제외하고 코드 실행 중간에 발생하는 오류(반대로 말하면, 코드 실행까지는 어떻게든 된다는 소리다.)<br><br>자바스크립트의 try catch finally 구문은 c++의 try catch 구문과 유사하다. 다만, finally 구문은 예외가 발생하는지와 상관없이 무조건 실행된다는 차이점이 있다.<br>참고로, finally 구문은 필수적이지 않으므로 생략해도 무방하다.<br>
function test () {
	try
	{
		// nothing.nothing() -&gt; nothing이라는 객체의 nothing
		alert('A 위치');
		// throw 키워드로 예외를 강제로 발생시킨다
		throw "예외 강제 발생";
	}
	catch (exception)
	{
		alert('B 위치');
		return ;
	}
	alert('C 위치');
}

// 함수를 호출
test();

<br>
function test () {
	try
	{
		// nothing.nothing() -&gt; nothing이라는 객체의 nothing
		alert('A 위치');
		// throw 키워드로 예외를 강제로 발생시킨다
		throw "예외 강제 발생";
	}
	catch (exception)
	{
		alert('B 위치');
		return ;
	}
	finally
	{
		alert('C 위치');
	}
}

// 함수를 호출
test();

<br>finally 구문의 반드시 실행된다는 특성은 매우 강력하기 때문에, 다음과 같은 경우에조차 실행이 보장된다.<br>
<br>try catch 구문 내부에서 return 키워드를 만날 때
<br>try catch 구문 내부에서 break 또는 continue 키워드를 만날 때
<br>
catch 의 괄호 안의 인자를 예외 객체 exception object라고 한다. 아무 식별자나 입력해도 괜찮지만, 일반적으로 e나  exception이라는 식별자를 사용한다.
<br>throw는 다음과 같은 방식으로 조금 다르게 실행시킬 수 있다. 한 번 직접 실행해보도록 하자.<br>
// 단순하게 예외를 발생시킨다
throw 문자열;

// 조금 더 자세하게 예외를 발생시킨다
throw new Error(문자열);

<br>
자바스크립트는 다른 프로그래밍 언어면 퉤퉤할 것도 꾸역꾸역 실행시키기 때문에 예외 처리가 좀 더 중요해보입니다 by sihong
<br><br>클래스에 관해서는 별 거 없기 때문에 기본적인 문법으로 설명합니다.<br>
클래스에 관해서는 c++과 유사한 문법이 많습니다<br>js 개발자들은 크게 클래스 class와 프로토타입 prototype이라는 2가지 문법으로 객체를 효율적으로 만들 수 있게 하였다. 간단하게 구분하면 클래스는 객체를 만들 때 수많은 지원을 하는 대신 많은 제한을 거는 문법이다. 반면 프로토타입은 제한을 많이 하지 않지만, 대신 지원도 별로 하지 않는 문법이다.<br>
프로토타입은 고대의 js에서나 쓰던 문법이므로 생략합니다.
<br>클래스는 다음과 같은 형태로 생성한다.<br>
class ClassName {
	...
}

<br>객체는 new 키워드를 사용하여 생성한다.<br>
c class 언어와 달리 별도로 동적 메모리 관리를 할 필요가 없다.<br>
js에서도 클래스의 첫 글자는 대문자로 하는 것이 규약이다.
<br>
new ClassName();

<br><br>자바스크립트에서는 생성자만 존재하고 소멸자 desturctor만 존재한다.<br>
사변 피셜 그래서 소멸자 역할을 하는 함수를 만들어서 수동으로 호출하는 식으로 처리한다 합니다.
<br>
class Student
{
	constructor () {
		/* 생성자 코드 예시 */
		this.이름 = 이름;
		this.국어 = 국어;
		this.영어 = 영어;
		this.수학 = 수학;
		this.과학 = 과학;
	}
}

<br><br>클래스의 메소드는 객체의 메소드와 달리 내부적으로 중복되지 않고 하나만 생성된다.<br>따라서 쥐꼬리만큼이라도 성능을 끌어올리고 싶다면 여러 번 중복되는 것들은 객체보다 클래스를 활용하는 것이 좋다.<br>
class Student
{
	// 중략
	
	// 아래와 같은 형식으로 선언한다. 객체에서 간단한 형식으로 메소드를 선언하는 것과 동일하다.
	getSum ()
	{
		return this.국어 + this.영어 + this.수학 + this.과학;
	}
}

<br><br><br>상속 문법<br>
class ClassName extends ParentClass
{
	...
}

<br>자식의 생성자는 super 키워드를 사용하여 부모의 생성자 코드를 호출한다.<br>
class Rectangle
{
	constructor (width, height)
	{
		this.width = width;
		this.height = height;
	}
}

class Square extends Rectangle
{
	constructor (length) {
		super(length, length);
	}
}

<br><br>클래스의 메소드 혹은 멤버를 private하게 선언하고 싶다면 맨 앞에 #을 붙이면 된다.<br>
class Example
{
	#privateMember

	#privateMethod () {}
}

<br>게터와 세터에 관해서는 생략<br><br>get 키워드와 set 키워드는 게터 세터를 좀 더 편리하게 선언하기 위한 문법적인 요소이다.<br>
class Square
{
	#length

	constructor (length)
	{
		this.length = length;
	}

	// 참고로 get 키워드를 이용해 만든 객체는 어떠한 인자도 받지 못한다.
	get length ()
	{
		return this.#length;
	}

	get perimeter ()
	{
		return this.#length * 4;
	}

	set length (length)
}

// 클래스 사용하기
const squareA = new Square(10);
// .length로 접근하면 get length가 호출된다
console.log(`한 변의 길이: ${squareA.length}`);
console.log(`둘레: ${squareA.perimeter}`);
// .length로 값을 넣으면 set length가 호출된다.
squareA.length = 10;

<br><br>static 키워드로 선언된 클래스의 멤버와 메소드는 클래스를 생성하지 않아도 사용할 수 있다 (c++과 동일하다.)<br>
class ClassName {
	static member = value;
	static method () {
		...
	}
}

// 아래와 같이 사용
ClassName.member;
ClassName.method();

<br><br>부모가 선언한 함수를 자식이 똑같은 이름으로 선언해서 덮어쓰는 것.<br>
class LifeCycle
{
	a () { console.log("부모의 a 메소드입니다.") }
}

class Child
{
	a () { console.log("자식의 a 메소드입니다.") }
}

// 부모 객체를 호출하면 부모의 a가, 자식 객체를 호출하면 자식의 a가 호출된다.

<br><br>참고자료<br><a href=".?query=tag:참고도서\혼자_공부하는_자바스크립트" class="tag" target="_blank" rel="noopener nofollow">#참고도서/혼자_공부하는_자바스크립트</a> <br>]]></description><link>resource\web\javascript\javascript-기초.html</link><guid isPermaLink="false">resource/Web/JavaScript/JavaScript 기초.md</guid><pubDate>Tue, 21 Jan 2025 06:01:52 GMT</pubDate></item><item><title><![CDATA[JSON]]></title><description><![CDATA[<a class="tag" href="?query=tag:language/JavaScript" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#language/JavaScript</a> <a class="tag" href="?query=tag:web" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#web</a> <a class="tag" href="?query=tag:참고도서/모던_자바스크립트_Deep_Dive" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/모던_자바스크립트_Deep_Dive</a> 
 <br><br><a href=".?query=tag:language\JavaScript" class="tag" target="_blank" rel="noopener nofollow">#language/JavaScript</a> <a href=".?query=tag:web" class="tag" target="_blank" rel="noopener nofollow">#web</a><br>JavaScript Object Notation<br><br><br>JSON은 클라이언트와 서버 간의 HTTP 통신을 위한 텍스트 데이터 포맷이다. 자바스크립트에 종속되지 않는 언어 독립형 데이터 포맷으로, 대부분의 프로그래밍 언어에서 사용할 수 있다.<br><br>JSON은 자바스크립트의 객체 리터럴과 유사하게 키와 값으로 구성된 순수한 텍스트다.<br>
{
	"name": "Lee",
	"age": 20,
	"alive": true,
	"hobby": ["traveling", "tennis"]
}

<br>JSON의 키는 반드시 큰따옴표로 묶어야 한다. 값은 객체 리터럴과 같은 표기법을 그대로 사용할 수 있다. 하지만 문자열은 반드시 큰따옴표로 묶어야 한다.<br><br>JSON.stringify 메서드는 객체를 JSON 포맷의 문자열로 변환한다. 클라이언트가 서버로 객체를 전송하려면 객체를 문자열화해야 하는데 이를 직렬화 Serializing이라 한다.<br>
const obj = {
    name: 'Lee',
    age: 20,
    alive: true,
    hobby: ['traveling', 'tennis']
};

// 객체를 JSON 포맷의 문자열로 변환한다.
const json = JSON.stringify(obj);
console.log(typeof json, json);

// 객체를 JSON 포맷의 문자열로 변환하면서 들여쓰기 한다.
const prettyJson = JSON.stringify(obj, null, 2);
console.log(typeof prettyJson, prettyJson);

// replacer 함수. 값의 타입이 Number이면 필터링되어 반환되지 않는다.
function filter(key, value)
{
    return typeof value === 'number' ? undefined : value;
}

// JSON.stringify 메서드에 두 번째 인수로 replacer 함수를 전달한다.
const strFilteredObject = JSON.stringify(obj, filter, 2);
console.log(typeof strFilteredObject, strFilteredObject);

<br>참고로 JSON.stringify 메서드는 객체뿐만 아니라 배열도 JSON 포맷의 문자열로 변환한다.<br>
const todos = [
    { id: 1, content: 'HTML', completed: false},
    { id: 2, content: 'CSS', completed: true },
    { id: 3, content: 'JavaScript', completed: false }
];

// 배열을 JSON 포맷의 문자열로 변환한다.
const json = JSON.stringify(todos, null, 2);
console.log(typeof json, json);

<br><br>JSON.parse 메서드는 JSON 포맷의 문자열을 객체로 변환한다. 서버로부터 클라이언트에게 전송된 JSON 데이터는 문자열이다. 이 문자열을 객체로서 사용하려면 JSON 포맷의 문자열을 객체화해야 하는데 이를 역직렬화 desirializing이라 한다.<br>
const obj = {
    name: 'Lee',
    age: 20,
    alive: true,
    hobby: ['traveling', 'tennis']
};

// 객체를 JSON 포맷의 문자열로 변환한다.
const json = JSON.stringify(obj);

// JSON 포맷의 문자열을 객체로 변환한다.
const parsed = JSON.parse(json);
console.log(typeof parsed, parsed);

<br>배열의 JSON 포맷의 문자열로 변환되어 있는 경우 JSON.parse는 문자열을 배열 객체로 변환한다. 배열의 요소가 객체인 경우 배열의 요소까지 객체로 변환한다.<br>
const todos = [
    { id: 1, content: 'HTML', completed: false},
    { id: 2, content: 'CSS', completed: true },
    { id: 3, content: 'JavaScript', completed: false }
];

// 배열을 JSON 포맷의 문자열로 변환한다.
const json = JSON.stringify(todos);

// JSON 포맷의 문자열을 배열로 변환한다. 배열의 요소까지 객체로 변환된다.
const parsed = JSON.parse(json);
console.log(typeof parsed, parsed);

<br><br>참고자료<br><a href=".?query=tag:참고도서\모던_자바스크립트_Deep_Dive" class="tag" target="_blank" rel="noopener nofollow">#참고도서/모던_자바스크립트_Deep_Dive</a> <br>]]></description><link>resource\web\javascript\json.html</link><guid isPermaLink="false">resource/Web/JavaScript/JSON.md</guid><pubDate>Thu, 16 Jan 2025 02:49:23 GMT</pubDate></item><item><title><![CDATA[npm]]></title><description><![CDATA[<a class="tag" href="?query=tag:language/JavaScript" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#language/JavaScript</a> <a class="tag" href="?query=tag:web" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#web</a> <a class="tag" href="?query=tag:참고도서/모던_자바스크립트_Deep_Dive" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/모던_자바스크립트_Deep_Dive</a> 
 <br><br><a href=".?query=tag:language\JavaScript" class="tag" target="_blank" rel="noopener nofollow">#language/JavaScript</a> <a href=".?query=tag:web" class="tag" target="_blank" rel="noopener nofollow">#web</a> <br>node package manager<br><br>npm은 자바스크립트 패키지 매니저이다. Node.js에서 사용할 수 있는 모듈들을 패키지화하여 모아둔 저장소 역할과 패키지 설치 및 관리를 위한 CLI를 제공한다. 자신이 작성한 패키지를 공개할 수도 있고 필요한 패키지를 검색하여 재사용할 수도 있다.<br>
<br><a data-tooltip-position="top" aria-label="https://poiemaweb.com/nodejs-npm" rel="noopener nofollow" class="external-link" href="https://poiemaweb.com/nodejs-npm" target="_blank">모듈화와 npm</a>
<br><br>참고자료<br><a href=".?query=tag:참고도서\모던_자바스크립트_Deep_Dive" class="tag" target="_blank" rel="noopener nofollow">#참고도서/모던_자바스크립트_Deep_Dive</a> <br>]]></description><link>resource\web\javascript\npm.html</link><guid isPermaLink="false">resource/Web/JavaScript/npm.md</guid><pubDate>Thu, 16 Jan 2025 05:40:34 GMT</pubDate></item><item><title><![CDATA[REST API]]></title><description><![CDATA[<a class="tag" href="?query=tag:language/JavaScript" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#language/JavaScript</a> <a class="tag" href="?query=tag:web" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#web</a> <a class="tag" href="?query=tag:참고도서/모던_자바스크립트_Deep_Dive" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/모던_자바스크립트_Deep_Dive</a> 
 <br><br><a href=".?query=tag:language\JavaScript" class="tag" target="_blank" rel="noopener nofollow">#language/JavaScript</a> <a href=".?query=tag:web" class="tag" target="_blank" rel="noopener nofollow">#web</a> <br>REpresentational State Transfer<br><br><br>REST는 HTTP를 기반으로 클라이언트가 서버의 리소스에 접근하는 방식을 규정한 아키텍처고, REST API는 REST를 기반으로 서비스 API를 구현한 것을 의미한다.<br>REST의 기본 원칙을 성실히 지킨 서비스 디자인을 RESTful하다고 표현한다.<br><br>REST API는 자원 resource, 행위 verb, 표현 representation의 3가지 요소로 구성된다. REST는 자체 표현 구조 self-descripitiveness로 구성되어 REST API만으로 HTTP 요청의 내용을 이해할 수 있다.<br><br><br>REST에서 가장 중요한 기본적인 원칙은 두 가지다. URI는 리소스를 표현하는 데 집중하고, 행위에 대한 정의는 HTTP 요청 메서드를 통해 하는 것이 RESTful API를 설계하는 중심 규칙이다.<br><br>URI는 리소스를 표현하는 데 중점을 두어야 한다. 리소스를 식별할 수 있는 이름은 동사보다는 명사를 사용한다. 따라서 이름에 get 같은 행위에 대한 표현이 들어가서는 안 된다.<br>
# bad
GET /getTodos/1
GET /todos/show/1

# good
GET /todos/1

<br><br>HTTP 요청 메서드는 클라이언트가 서버에게 요청의 종류와 목적(리소스에 대한 행위)를 알리는 방법이다. 주로 5가지 요청 메서드(GET, POST, PUT, PATCH, DELETE 등)을 사용하여 CRUD를 구현한다.<br><br>리소스에 대한 행위는 HTTP 요청 메서드를 통해 표현하며 URI에 표현하지 않는다. 예를 들어, 리소스를 취득하는 경우에는 GET, 리소스를 삭제하는 경우에는 DELETE를 사용하여 리소스에 대한 행위를 명확히 표현한다.<br>
# bad
GET /todos/delete/1

# good
DELETE /todos/1

<br><br>HTTP 요청을 전송하고 응답을 받으려면 서버가 필요하다. JSON Server를 사용해 가상 REST API 서버를 구축하여 HTTP 요청을 전송하고 응답을 받는 실습을 진행해보자.<br><br>JSON Server는 json 파일을 사용하여 가상 REST API 서버를 구축할 수 있는 툴이다.<br>
다음과 같이 <a data-href="npm" href="resource\web\javascript\npm.html" class="internal-link" target="_self" rel="noopener nofollow">npm</a>을 사용하여 설치한다.<br>
mkdir json-server &amp;&amp; cd json-server
npm init -y
npm install json-server --save-dev

<br><br>프로젝트 루트 폴더(/json-server)에 다음과 같이 db.json 파일을 생성한다. db.json 파일은 리소스를 제공하는 데이터베이스 역할을 한다.<br>
{
    "todos": [
        {
            "id": 1,
            "content": "HTML",
            "completed": true
        },
        {
            "id": 2,
            "content": "CSS",
            "completed": false
        },
        {
            "id": 3,
            "content": "JavaScript",
            "completed": true
        }
    ]
}

<br><br>package.json 파일의 scripts를 다음과 같이 수정하여 JSON Server를 실행하여 보자. package.json 파일에서 불필요한 항목은 삭제하였다.<br>
{
  "name": "json-server",
  "version": "1.0.0",
  "scripts": {
    "start": "json-server --watch db.json"
  },
  "devDependencies": {
    "json-server": "^1.0.0-beta.3"
  }
}

<br>터미널에서 npm start 명령어를 입력하여 JSON Server를 실행한다.<br><br><br>todos 리소스에서 모든 todo를 취득(index)한다.<br>JSON Server의 루트 폴더(/json-server)에 public 폴더를 생성하고 JSON Server를 중단한 후 재실행한다. 그리고 public 폴더에 다음 get_index.html을 추가하고 브라우저에서 http://localhost:3000/get_index.html로 접속한다.<br>
&lt;!DOCTYPE html&gt;
&lt;html&gt;
    &lt;body&gt;
        &lt;pre&gt;&lt;/pre&gt;
        &lt;script&gt;
            // XMLHttpRequest 객체 생성
            const xhr = new XMLHttpRequest();

            // HTTP 요청 초기화
            // todos 리소스에서 모든 todo를 취득(index)
            xhr.open('GET', '/todos');

            // HTTP 요청 전송
            xhr.send();

            // load 이벤트는 요청이 성공적으로 완료된 경우 발생한다.
            xhr.onload = () =&gt; {
                // status 프로퍼티 값이 200이면 정상적으로 응답된 상태다.
                if (xhr.status === 200)
                {
                    document.querySelector('pre').textContent = xhr.response;
                }
                else
                {
                    console.error('Error', xhr.status, xhr.statusText)
                }
            };
        &lt;/script&gt;
    &lt;/body&gt;
&lt;/html&gt;

<br><br>todos 리소스에서 id를 사용하여 특정 todo를 취득(retrieve)한다. public 폴더에 다음 get_retrieve.html을 추가하고 브라우저에서 http://localhost:3000/get_retrieve.html로 접속한다.<br>
&lt;!DOCTYPE html&gt;
&lt;html&gt;
    &lt;body&gt;
        &lt;pre&gt;&lt;/pre&gt;
        &lt;script&gt;
            // XMLHttpRequest 객체 생성
            const xhr = new XMLHttpRequest();

            // HTTP 요청 초기화
            // todos 리소스에서 id를 사용하여 특정 todo를 취득(retrieve)
            xhr.open('GET', '/todos/1');

            // HTTP 요청 전송
            xhr.send();

            // load 이벤트는 요청이 성공적으로 완료된 경우 발생한다.
            xhr.onload = () =&gt; {
                if (xhr.status === 200)
                {
                    document.querySelector('pre').textContent = xhr.response;
                }
                else
                {
                    console.error('Error', xhr.status, xhr.statusText);
                }
            };
        &lt;/script&gt;
    &lt;/body&gt;
&lt;/html&gt;

<br><br>todos 리소스에 새로운 todo를 생성한다. POST 요청 시에는 setRequestHeader 메서드를 사용하여 요청 몸체에 담아 서버로 전송할 페이로드의 MIME 타입을 지정해야 한다.<br>public 폴더에 다음 post.html을 추가하고 브라우저에서 http://localhost:3000/post.html로 접속한다.<br>
&lt;!DOCTYPE html&gt;
&lt;html&gt;
    &lt;body&gt;
        &lt;pre&gt;&lt;/pre&gt;
        &lt;script&gt;
            // XMLHTTPRequest 객체 생성
            const xhr = new XMLHttpRequest();

            // HTTP 요청 초기화
            // todos 리소스에 새로운 todo를 생성
            xhr.open('POST', '/todos');

            // 요청 몸체에 담아 서버로 전송할 페이로드의 MIME 타입을 지정
            xhr.setRequestHeader('content-type', 'application/json');

            // HTTP 요청 전송
            // 새로운 todo를 생성하기 위해 페이로드를 서버에 전송해야 한다.
            xhr.send(JSON.stringify({ id: 4, content: 'Angular', completed: false }));

            // load 이벤트는 요청이 성공적으로 완료된 경우 발생한다.
            xhr.onload = () =&gt; {
                // status 프로퍼티 값이 200(OK) 또는 201(Created)이면 정상적으로 응답된 상태다.
                if (xhr.status === 200 || xhr.status === 201) {
                    document.querySelector('pre').textContent = xhr.response;
                }
                else {
                    console.error('Error', xhr.status, xhr.statusText);
                }
            };
        &lt;/script&gt;
    &lt;/body&gt;
&lt;/html&gt;

<br><br>PATCH는 특정 리소스의 일부를 수정할 때 사용한다. 다음 예제에서는 todos 리소스의 id로 todo를 특정하여 completed만 수정한다. PATCH 요청 시에는 setRequestHeader 메서드를 사용하여 요청 몸체에 담아 서버로 전송할 페이로드의 MIME 타입을 지정해야 한다.<br>public 폴더에 다음 patch.html을 추가하고 브라우저에서 http://localhost:3000/patch.html로 접속한다.<br>
&lt;!DOCTYPE html&gt;
&lt;html&gt;
    &lt;body&gt;
        &lt;pre&gt;&lt;/pre&gt;
        &lt;script&gt;
            // XMLHttpRequest 객체 생성
            const xhr = new XMLHttpRequest();
            
            // HTTP 요청 초기화
            // todos 리소스의 id로 todo를 특정하여 completed만 수정
            xhr.open('PATCH', '/todos/4');

            // 요청 몸체에 담아 서버로 전송할 페이로드의 MIME 타입을 지정
            xhr.setRequestHeader('content-type', 'application/json');

            // HTTP 요청 전송
            // 리소스를 수정하기 위해 페이로드를 서버에 전송해야 한다.
            xhr.send(JSON.stringify({ completed: false }));

            // load 이벤트는 요청이 성공적으로 완료된 경우 발생한다.
            xhr.onload = () =&gt; {
                // status 프로퍼티 값이 200이면 정상적으로 응답된 상태다.
                if (xhr.status === 200) {
                    document.querySelector('pre').textContent = xhr.response;
                }
                else
                {
                    console.error('Error', xhr.status, xhr.statusText);
                }
            };
        &lt;/script&gt;
    &lt;/body&gt;
&lt;/html&gt;

<br><br>todos 리소스에서 id를 사용하여 todo를 삭제한다. public 폴더에 다음 delete.html을 추가하고 브라우저에서 http://localhost:3000/delete.html로 접근한다.<br>
&lt;!DOCTYPE html&gt;
&lt;html&gt;
    &lt;body&gt;
        &lt;pre&gt;&lt;/pre&gt;
        &lt;script&gt;
            // XMLHttpRequest 객체 생성
            const xhr = new XMLHttpRequest();

            // HTTP 요청 초기화
            // todos 리소스에서 id를 사용하여 todo를 삭제한다.
            xhr.open('DELETE', '/todos/4');

            // HTTP 요청 전송
            xhr.send();

            // load 이벤트는 요청이 성공적으로 완료된 경우 발생한다.
            xhr.onload = () =&gt; {
                // status 프로퍼티 값이 200이면 정상적으로 응답된 상태다.
                if (xhr.status === 200) {
                    document.querySelector('pre').textContent = xhr.response;
                }
                else {
                    console.error('Error', xhr.status, xhr.statusText);
                }
            };
        &lt;/script&gt;
    &lt;/body&gt;
&lt;/html&gt;

<br><br>참고자료<br><a href=".?query=tag:참고도서\모던_자바스크립트_Deep_Dive" class="tag" target="_blank" rel="noopener nofollow">#참고도서/모던_자바스크립트_Deep_Dive</a> <br>]]></description><link>resource\web\javascript\rest-api.html</link><guid isPermaLink="false">resource/Web/JavaScript/REST API.md</guid><pubDate>Fri, 17 Jan 2025 02:09:40 GMT</pubDate></item><item><title><![CDATA[TDZ]]></title><description><![CDATA[<a class="tag" href="?query=tag:language/JavaScript" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#language/JavaScript</a> <a class="tag" href="?query=tag:참고도서/모던_자바스크립트_핵심_가이드" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/모던_자바스크립트_핵심_가이드</a> 
 <br><br><a href=".?query=tag:language\JavaScript" class="tag" target="_blank" rel="noopener nofollow">#language/JavaScript</a> <br>temporal dead zone<br><br>자바스크립트 언어는 코드를 해석하기 전 변수의 초기화에 관련된 코드를 변수의 선언과 초기화로 분리한 뒤, 변수의 선언 부분만 컨텍스트의 최상단 부분으로 끌어올린다. 그리고 일시적으로 undefined를 할당한다. 이러한 동작을 호이스팅 hoisting이라고 한다.<br>이러한 특성 때문에 var 키워드로 선언된 변수는 변수의 초기화 이전에 사용해도 별다른 에러가 출력되지 않는다. 단지 undefined가 할당될 뿐이다.<br>
console.log(i);
var i = "I an a variable";

// undefined

console.log(j);
let j = "I an a let";

// ReferenceError: can't access lexical declaration `j' before initialization

<br>하지만 let, const로 선언된 변수는 변수의 초기화 이전에 사용하면 에러를 출력한다.<br>호이스팅은 변수의 키워드와 상관없이 동일하게 동작한다.<br>
하지만 let, const로 선언된 변수는 호이스팅 후 TDZ temporal dead zone 일시적 비활성 영역이라는 영역으로 이동한다. TDZ는 변수의 선언 이전에 변수에 접근을 시도하면 에러가 발생시키는 역할을 한다..<br>

var은 정의되기 전에 접근할 수 있지만, 그 값에는 접근할 수 없다. let과 const는 정의하기 전에 접근할 수 있다.
<br><br>참고자료<br><a href=".?query=tag:참고도서\모던_자바스크립트_핵심_가이드" class="tag" target="_blank" rel="noopener nofollow">#참고도서/모던_자바스크립트_핵심_가이드</a> <br>]]></description><link>resource\web\javascript\tdz.html</link><guid isPermaLink="false">resource/Web/JavaScript/TDZ.md</guid><pubDate>Mon, 13 Jan 2025 04:45:45 GMT</pubDate></item><item><title><![CDATA[XMLHttpRequest]]></title><description><![CDATA[<a class="tag" href="?query=tag:language/JavaScript" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#language/JavaScript</a> <a class="tag" href="?query=tag:web" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#web</a> <a class="tag" href="?query=tag:참고도서/모던_자바스크립트_Deep_Dive" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/모던_자바스크립트_Deep_Dive</a> 
 <br><br><a href=".?query=tag:language\JavaScript" class="tag" target="_blank" rel="noopener nofollow">#language/JavaScript</a> <a href=".?query=tag:web" class="tag" target="_blank" rel="noopener nofollow">#web</a> <br>서버와의 통신<br><br><br>브라우저는 주소창이나 HTML의 form 태그 또는 a 태그를 통해 HTTP 요청 전송 기능을 기본 제공한다. 자바스크립트를 사용하여 HTTP 요청을 전송하려면 XMLHTTPRequest 객체를 사용한다. Web API인 XMLHttpRequest 객체는 HTTP 요청 전송과 HTTP 응답 수신을 위한 다양한 메서드와 프로퍼티를 제공한다.<br><br>XMLHttpRequest 객체는 XMLHttpRequest 생성자 함수를 호출하여 생성한다. XMLHttpRequest 객체는 브라우저에서 제공하는 Web API이므로 브라우저 환경에서만 정상적으로 실행된다.<br>
// XMLHttpRequest 객체의 생성
const xhr = new XMLHttpRequest();

<br><br>XMLHttpRequest 객체는 다양한 프로퍼티와 메서드를 제공한다. 대표적인 프로퍼티와 메서드는 다음과 같다. 중요한 프로퍼티와 메서드는 볼드체로 표시했다.<br><br><br>HTTP 요청의 현재 상태를 나타내는 정수. 다음과 같은 XMLHttpRequest의 정적 프로퍼티를 값으로 갖는다.<br>
<br>UNSENT: 0
<br>OPENED: 1
<br>HEADERS_RECEIVED: 2
<br>LOADING: 3
<br>DONE: 4
<br><br>HTTP 요청에 대한 응답 상태(HTTP 상태 코드)를 나타내는 정수<br>
ex) 200<br><br>HTTP 요청에 대한 응답 메시지를 나타내는 문자열<br>
ex) "OK"<br><br>HTTP 응답 타입<br>
ex) document, json, text, blob, arraybuffer<br><br>HTTP 요청에 대한 응답 몸체 reponse body. reponseType에 따라 타입이 다르다.<br><br>서버가 전송한 HTTP 요청에 대한 응답 문자열<br><br><br><br>(추후 보충)<br><br>HTTP 요청을 전송하는 경우 다음 순서를 따른다.<br>
<br>XMLHttpRequest.prototype.open 메서드로 HTTP 요청을 초기화한다.
<br>필요에 따라 XMLHttpRequest.prototype.setRequestHeader 메서드로 특정 HTTP 요청의 헤더 값을 설정한다.
<br>XMLHttpRequest.prototype.send 메서드로 HTTP 요청을 전송한다.
<br>
// XMLHttpRequest 객체 생성
const xhr = new XMLHttpRequest();

// HTTP 요청 초기화
xhr.open('GET', '/users');

// HTTP 요청 헤더 설정
// 클라이언트가 서버로 전송할 데이터의 MIME 타입 지정: json
xhr.setRequestHeader('content-type', 'application/json');

// HTTP 요청 전송
xhr.send();

<br><br>open 메서드는 서버에 전송할 HTTP 요청을 초기화한다. open 메서드를 호출하는 방법은 다음과 같다. <br>
xhr.open(method, url[, async]);

<br><br>HTTP 요청 메서드는 클라이언트가 서버에게 요청의 종류와 목적(리소스에 대한 행위)을 알리는 방법이다.<br>
주로 5가지 요청 메서드(GET, POST, PUT, PATCH, DELETE 등)을 사용하여 CRUD를 구현하다.<br><br><br>send 메서드는ㄴ open 메서드로 초기화된 HTTP 요청을 서버에 전송한다. 기본적으로 서버로 전송하는 데이터는 GET, POST 요청 메서드에 따라 전송 방식에 차이가 있다.<br>
<br>GET 요청 메서드의 경우 데이터를 URL의 일부분인 쿼리 문자열 query string로 서버에 전송한다.
<br>POST 요청 메서드의 경우 데이터(페이로드 payload)를 요청 몸체 request body에 담아 전송한다.
<br>send 메서드에는 요청 몸체에 담아 전송할 데이터(페이로드)를 인수로 전달할 수 있다. 페이로드가 객체인 경우 반드시 JSON.stringify 메서드를 사용하여 직렬화한 다음 전달해야 한다.<br>
xhr.send(JSON.stringify({ id: 1, content: 'HTML', conpleted: false }));

<br>HTTP 요청 메서드가 GET인 경우 send 메서드에 페이로드로 전달한 인수는 무시되고 요청 몸체는 null로 설정된다.<br><br>setRequestHeader 메서드는 특정 HTTP 요청의 헤더 값을 설정한다. setRequestHeader 메서드는 반드시 open 메서드를 호출한 이후에 호출해야 한다. 자주 사용하는 HTTP 요청 헤더인 Content-type과 Accept에 대해 살펴보자.<br>Content-type은 요청 몸체에 담아 전송할 데이터의 MIME 타입의 정보를 표현한다. 자주 사용되는 MIME 타입은 다음과 같다.<br><br>다음은 요청 몸체에 담아 서버로 전송할 페이로드의 MIME 타입을 지정하는 예다.<br>
// XMLHttpRequest 객체 생성
const xhr = new XMLHttpRequest();

// HTTP 요청 초기화
xhr.open('POST', '/users');

// HTTP 요청 헤더 설정
// 클라이언트가 서버로 전송할 데이터의 MIME 타입 지정: json
xhr.setRequestHeader('content-type', 'application/json');

// HTTP 요청 전송
xhr.send(JSON.stringify({ id: 1, content: 'HTML', completed: false }));

<br>HTTP 클라이언트가 서버에 요청할 때 서버가 응답할 데이터의 MIME 타입을 Accept로 지정할 수 있다. 다음은 서버가 응답할 데이터의 MIME 타입을 지정하는 예다.<br>
// 서버가 응답할 데이터의 MIME 타입 지정: json
xhr.setRequestHeader('accept', 'application/json');

<br>만약 Accept 헤더를 설정하지 않으면 send 메서드가 호출될 때 Accept 헤더가 */*으로 전송된다.<br><br>서버가 전송한 응답을 처리하려면 XMLHttpRequest 객체가 발생시키는 이벤트를 캐치해야 한다.<br>상술했듯이 XMLHttpRequest 객체는 onreadystate, onload, onerror 같은 이벤트 핸들러 프로퍼티를 갖는다. 이 이벤트 핸들러 프로퍼티 중에서 HTTP 요청의 현재 상태를 나타내는 readyState 프로퍼티 값이 변경된 경우 발생하는 readyStatechange 이벤트를 캐치하여 다음과 같이 HTTP 응답을 처리할 수 있다.<br>참고로 HTTP 요청을 전송하고 응답을 받으려면 서버가 필요하다. 다음 예제에서는 JSONPlaceholder에서 제공하는 가상 (fake) REST API를 사용한다.<br>
// XMLHttpRequest 객체 생성
const xhr = new XMLHttpRequest();

// HTTP 요청 초기화
// https://jsonplaceholder.typicode.com은 Fake REST API를 제공하는 서비스다.
xhr.open('GET', 'https://jsonplaceholder.typicode.com/todos/1');

// HTTP 요청 전송
xhr.send();

// readystatechange 이벤트는 HTTP 요청의 현재 상태를 나타내는
// readyState 프로퍼티가 변경될 때마다 발생한다.
xhr.onreadystatechange = () =&gt; {
	// readyState 프로퍼티는 HTTP 요청의 현재 상태를 나타낸다.
	// readyState 프로퍼티 값이 4(XMLHttpRequest.DONE)가 아니면 서버 응답이 완료되지 않은 상태다.
	// 만약 서버 응답이 아직 완료되지 않았다면 아무런 처리를 하지 않는다.
	if (xhr.readyState !== XMLHttpRequest.DONE) return;

	// status 프로퍼티는 응답 상태 코드를 나타낸다.
	// status 프로퍼티 값이 200이면 정상적으로 응답된 상태이고
	// status 프로퍼티 값이 200이 아니면 에러가 발생한 상태다.
	// 정상적으로 응답된 상태라면 response 프로퍼티에 서버의 응답 결과가 담겨 있다.
	if (xhr.status === 200)
	{
		console.log(JSON.parse(xhr.reponse));
	}
	else
	{
		console.error('Error', xhr.status, xhr.statusText);
	}
};

<br><br>참고자료<br><a href=".?query=tag:참고도서\모던_자바스크립트_Deep_Dive" class="tag" target="_blank" rel="noopener nofollow">#참고도서/모던_자바스크립트_Deep_Dive</a> <br>]]></description><link>resource\web\javascript\xmlhttprequest.html</link><guid isPermaLink="false">resource/Web/JavaScript/XMLHttpRequest.md</guid><pubDate>Fri, 17 Jan 2025 07:42:26 GMT</pubDate></item><item><title><![CDATA[2FA]]></title><description><![CDATA[<a class="tag" href="?query=tag:security" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#security</a> <a class="tag" href="?query=tag:web" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#web</a> 
 <br><br><a href=".?query=tag:security" class="tag" target="_blank" rel="noopener nofollow">#security</a> <a href=".?query=tag:web" class="tag" target="_blank" rel="noopener nofollow">#web</a><br>2단계 인증<br><br><a data-tooltip-position="top" aria-label="https://www.entrust.com/ko/resources/learn/what-is-two-factor-authentication" rel="noopener nofollow" class="external-link" href="https://www.entrust.com/ko/resources/learn/what-is-two-factor-authentication" target="_blank">참고 링크 1</a><br>
<a data-tooltip-position="top" aria-label="https://www.microsoft.com/ko-kr/security/business/security-101/what-is-two-factor-authentication-2fa" rel="noopener nofollow" class="external-link" href="https://www.microsoft.com/ko-kr/security/business/security-101/what-is-two-factor-authentication-2fa" target="_blank">참고 링크 2</a><br>
<a data-tooltip-position="top" aria-label="https://80000coding.oopy.io/bf6a038e-9f4b-43a7-96dd-c9ee22d9d9f6" rel="noopener nofollow" class="external-link" href="https://80000coding.oopy.io/bf6a038e-9f4b-43a7-96dd-c9ee22d9d9f6" target="_blank">트센 프로젝트 관련 자료</a>]]></description><link>resource\web\2fa.html</link><guid isPermaLink="false">resource/Web/2FA.md</guid><pubDate>Mon, 20 Jan 2025 10:10:19 GMT</pubDate></item><item><title><![CDATA[JWT]]></title><description><![CDATA[<a class="tag" href="?query=tag:security" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#security</a> <a class="tag" href="?query=tag:cryptograph" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#cryptograph</a> <a class="tag" href="?query=tag:web" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#web</a> <a class="tag" href="?query=tag:참고링크/생활코딩" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고링크/생활코딩</a> 
 <br><br><a href=".?query=tag:security" class="tag" target="_blank" rel="noopener nofollow">#security</a> <a href=".?query=tag:cryptograph" class="tag" target="_blank" rel="noopener nofollow">#cryptograph</a> <a href=".?query=tag:web" class="tag" target="_blank" rel="noopener nofollow">#web</a><br>Json Web Token<br><br><br>JWT는 Json Web Token의 약자이다. 자료를 <a data-href="JSON" href="resource\web\javascript\json.html" class="internal-link" target="_self" rel="noopener nofollow">JSON</a> 형태로 다른 장치에게 안전하게 전송하기 위한 프로토콜이다.<br>JWT는 다음의 세 가지 요소로 이루어져 있다.<br>
<br>헤더 header : "alg"(알고리즘의 약자)와 "typ"이라는 두 개의 프로퍼티로 구성되어있다. alg 프로퍼티에는 서명을 어떠한 알고리즘으로 암호화했는지를 저장한다.
<br>페이로드 payload : 실질적인 내용을 저장하는 부분이다. payload의 각 부분을 claim(주장)이라고 하는데, 이는 받는 입장에서 payload의 내용을 완전히 신뢰할 수 없기 때문이다.
<br>서명 signature : 페이로드의 내용을 보증하는 보안적 요소
<br>JWT 토큰은 누군가에게 갈취당하더라도 아무나 해독하지 못하도록 base64라는 방식으로 인코딩되어 전송된다.<br>JWT는 다음과 같은 방식으로 사용된다.<br>
<br>JWT 토큰을 작성하여 보내는 측은(예를 들어, 웹 서버라고 하자) 본문(페이로드)를 작성한 후 특정한 암호화 알고리즘과(HMAC을 썼다고 가정하자) private 키를 사용하여 본문을 암호화하여 서명을 작성한다. HMAC 알고리즘을 사용하였으므로 토큰의 헤더 부분이 HMAC 알고리즘이 사용되었음이 기록된다.
<br>JWT 토큰을 받은 프론트 측은 긴 시간이 지난 후 웹 서버에게 자신을 인증하기 위해 해당 토큰을 다시 웹 서버에게 보낸다.
<br>토큰의 헤더의 HMAC 알고리즘이 저장되어 있으므로 웹 서버는 HMAC 알고리즘을 불러와 가지고 있는 private 키와 토큰의 페이로드를 사용하여 새로운 서명을 만든다.
<br>새로 만든 서명이 토큰의 서명과 일치한다면 서버는 토큰이 자신이 발행한 것이라고 확신할 수 있다.
<br><br>
<br>인증 Authentication
<br>정보 공유 Information Exchange
<br>권한 부여 Authorization
<br>단일 로그인 Single Sign-On
<br>서버 간 통신 Server-to-server communication
<br>가장 주된 활용처는 로그인 기능을 구현할 때 인증에 사용되는 것이다.<br><br>세션 id의 단점은 다음과 같다.<br>
<br>세션 기반의 인증은 특정한 작업을 할 때마다 서버에 세션 id를 확인 받아야 한다. 서버가 해당 세션 id가 유효한지 확인하기 위해서는 세션 id가 저장된 db를 싹 다 순회해야 하므로 추가 비용이 발생한다.
<br>세션 id에는 사용자의 개인 정보가 포함되어 있지 않기 때문에 해당 정보가 필요하다면 서버에 다시 요청해야 한다.
<br>사용자가 새로운 기기로 접속할 때마다 쿠키를 다시 발행해야 한다.
<br>반면에 JWT는 다음과 같은 절차를 거친다.<br>
<br>사용자가 서버에 로그인을 요청한다.
<br>서버는 db를 조회해 해당 사용자가 실제로 존재하는지 확인한다. 확인이 끝나면 해당 사용자에게 JWT 토큰을 발행한다.
<br>사용자는 페이로드를 통해 사용자 정보를 전달받을 수 있기 때문에 서버에 다시 요청할 필요가 없다.(쿠키 기반 세션 인증의 2번째 단점 해결)
<br>사용자가 서버에 특정 요청을 다시 할 때 서버는 토큰의 서명을 대조하는 것만으로 진위를 확인할 수 있으므로 db를 조회하지 않아도 된다(쿠키 기반 세션 인증의 1번째 단점 해결 )
<br><br>참고자료<br><a href=".?query=tag:참고링크\생활코딩" class="tag" target="_blank" rel="noopener nofollow">#참고링크/생활코딩</a> <br>]]></description><link>resource\web\jwt.html</link><guid isPermaLink="false">resource/Web/JWT.md</guid><pubDate>Mon, 20 Jan 2025 09:53:18 GMT</pubDate></item><item><title><![CDATA[WWW]]></title><description><![CDATA[<a class="tag" href="?query=tag:web" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#web</a> <a class="tag" href="?query=tag:network" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#network</a> <a class="tag" href="?query=tag:참고도서/모던_웹_디자인을_위한_HTML5_CSS3_입문" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/모던_웹_디자인을_위한_HTML5_CSS3_입문</a> 
 <br><br><a href=".?query=tag:web" class="tag" target="_blank" rel="noopener nofollow">#web</a> <a href=".?query=tag:network" class="tag" target="_blank" rel="noopener nofollow">#network</a><br>World Wide Web<br><br>월드 와이드 웹은 인터넷에 연결된 컴퓨터를 통해 사람들이 정보를 공유할 수 있는 정보 공간을 말한다.<br>인터넷은 전 세계를 연결하고 있는 국제 정보 통신망이고 웹은 그 위에서 작동하는 서비스이므로 2가지를 구분할 필요가 있다.<br>W3C (World Wide Web Consortium)은 웹 표준을 지정하는 기관이며 HTML 표준을 제정하는 단체이다. W3C는 HTML 표준을 제정하지만 강제하지는 않는다. <br><br>참고자료<br><a href=".?query=tag:참고도서\모던_웹_디자인을_위한_HTML5_CSS3_입문" class="tag" target="_blank" rel="noopener nofollow">#참고도서/모던_웹_디자인을_위한_HTML5_CSS3_입문</a> <br>]]></description><link>resource\web\www.html</link><guid isPermaLink="false">resource/Web/WWW.md</guid><pubDate>Sat, 22 Mar 2025 07:32:00 GMT</pubDate></item><item><title><![CDATA[정확도와 정밀도]]></title><description><![CDATA[<a class="tag" href="?query=tag:language/c" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#language/c</a> <a class="tag" href="?query=tag:cpp" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#cpp</a> <a class="tag" href="?query=tag:computer_science" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#computer_science</a> 
 <br><br> <a href=".?query=tag:language\c" class="tag" target="_blank" rel="noopener nofollow">#language/c</a> <a href=".?query=tag:cpp" class="tag" target="_blank" rel="noopener nofollow">#cpp</a> <a href=".?query=tag:computer_science" class="tag" target="_blank" rel="noopener nofollow">#computer_science</a> <br>accuracy and precision<br><br>정확도와 정밀도는 int와 float의 특징을 규정하는 개념이다. 정확도는 자료형이 나타내는 값이 실제 값과 일치하는 정도이고, 정밀도는 해당 값에 대해 얼마나 많은 정보를 갖고 있는지, 해당 정보를 얼마나 고유하게 고정하고 있는지와 관련이 있다.<br>예를 들어, integer 기반의 자료형은 완벽한 정확도를 가지고 있다. integer가 표현하는 값 2는 실제 정수 2와 완전히 일치한다. 하지만 integer 기반의 자료형은 정밀도가 부족하다. 5를 4로 나누면 원래 2.5가 되어야 하지만 2라는 결과를 반환한다. 값 자체는 일치하지만 정수가 가지는 특성을 완전히 표현하지 못한다.<br>float 기반의 자료형의 경우, 정확도가 부족하다. 컴퓨터가 저장할 수 있는 용량에는 한계가 있고, 지수부와 소수부를 나누어 저장하는 특성상 값에 오차가 존재할 수 있다. 하지만 float 기반 자료형은 높은 정밀도를 가진다. 예를 들어 int형과 달리 5 / 2 = 2.5를 정확히 출력화는 등 소수의 특성을 높은 정도로 재현한다.<br><br>참고자료<br><a data-tooltip-position="top" aria-label="https://www.cprogramming.com/tutorial/floating_point/understanding_floating_point.html" rel="noopener nofollow" class="external-link" href="https://www.cprogramming.com/tutorial/floating_point/understanding_floating_point.html" target="_blank">Cprogramming.com</a><br>]]></description><link>resource\정확도와-정밀도.html</link><guid isPermaLink="false">resource/정확도와 정밀도.md</guid><pubDate>Sat, 22 Mar 2025 07:32:00 GMT</pubDate></item><item><title><![CDATA[ANSI escape code]]></title><description><![CDATA[<a class="tag" href="?query=tag:ect" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#ect</a> <a class="tag" href="?query=tag:참고링크/ANSI_escape_code_깃헙_정리자료" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고링크/ANSI_escape_code_깃헙_정리자료</a> 
 <br><br><a href=".?query=tag:ect" class="tag" target="_blank" rel="noopener nofollow">#ect</a><br><br>터미널이 가져야 할 기본적인 동작들을 모아 표준화시킨 것.<br>문자를 인쇄하는 것을 넘어 이미 인쇄된 문자들 수정하거나, 커서를 조작하거나, 글자의 색상을 부여햐는 등 다양한 기능을 지원한다.<br>보통 이스케이프 문자 \033 뒤에 추가적인 옵션을 부여해 사용한다.<br><br>참고자료<br><a href=".?query=tag:참고링크\ANSI_escape_code_깃헙_정리자료" class="tag" target="_blank" rel="noopener nofollow">#참고링크/ANSI_escape_code_깃헙_정리자료</a><br>]]></description><link>resource\ansi-escape-code.html</link><guid isPermaLink="false">resource/ANSI escape code.md</guid><pubDate>Sat, 22 Mar 2025 07:32:02 GMT</pubDate></item><item><title><![CDATA[index]]></title><description><![CDATA[ 
 ]]></description><link>index.html</link><guid isPermaLink="false">index.md</guid><pubDate>Sat, 22 Mar 2025 07:37:43 GMT</pubDate></item><item><title><![CDATA[obsidian]]></title><description><![CDATA[ 
 <br><br>옵시디언 동기화를 위한 저장소]]></description><link>readme.html</link><guid isPermaLink="false">README.md</guid><pubDate>Fri, 20 Dec 2024 13:50:12 GMT</pubDate></item></channel></rss>