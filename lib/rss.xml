<rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><parsererror xmlns="http://www.w3.org/1999/xhtml" style="display: block; white-space: pre; border: 2px solid #c77; padding: 0 1em 0 1em; margin: 1em; background-color: #fdd; color: black"><h3>This page contains the following errors:</h3><div style="font-family:monospace;font-size:12px">error on line 2684 at column 3443: Invalid bytes in character encoding
</div><h3>Below is a rendering of the page up to the first error.</h3></parsererror><channel><title><![CDATA[obsidian]]></title><description><![CDATA[Obsidian digital garden]]></description><link>http://github.com/dylang/node-rss</link><image><url>lib\media\favicon.png</url><title>obsidian</title><link/></image><generator>Webpage HTML Export plugin for Obsidian</generator><lastBuildDate>Sat, 22 Mar 2025 08:07:31 GMT</lastBuildDate><atom:link href="lib\rss.xml" rel="self" type="application/rss+xml"/><pubDate>Sat, 22 Mar 2025 08:06:59 GMT</pubDate><ttl>60</ttl><dc:creator/><item><title><![CDATA[코드 블록 html]]></title><description><![CDATA[ 
 <br>


]]></description><link>재료\미사용-template-저장-폴더\코드-블록-html.html</link><guid isPermaLink="false">재료/미사용 template 저장 폴더/코드 블록 html.md</guid><pubDate>Sat, 22 Mar 2025 07:43:51 GMT</pubDate></item><item><title><![CDATA[코드 블록 javascript]]></title><description><![CDATA[ 
 <br>


]]></description><link>재료\미사용-template-저장-폴더\코드-블록-javascript.html</link><guid isPermaLink="false">재료/미사용 template 저장 폴더/코드 블록 javascript.md</guid><pubDate>Sat, 22 Mar 2025 07:43:51 GMT</pubDate></item><item><title><![CDATA[js 문서 임시 템플릿]]></title><description><![CDATA[<a class="tag" href="?query=tag:language/JavaScript" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#language/JavaScript</a> <a class="tag" href="?query=tag:web" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#web</a> <a class="tag" href="?query=tag:참고도서/모던_자바스크립트_Deep_Dive" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/모던_자바스크립트_Deep_Dive</a> 
 <br><br><a href=".?query=tag:language\JavaScript" class="tag" target="_blank" rel="noopener nofollow">#language/JavaScript</a> <a href=".?query=tag:web" class="tag" target="_blank" rel="noopener nofollow">#web</a> <br>__<br><br><br>참고자료<br><a href=".?query=tag:참고도서\모던_자바스크립트_Deep_Dive" class="tag" target="_blank" rel="noopener nofollow">#참고도서/모던_자바스크립트_Deep_Dive</a> <br>]]></description><link>재료\미사용-template-저장-폴더\js-문서-임시-템플릿.html</link><guid isPermaLink="false">재료/미사용 template 저장 폴더/js 문서 임시 템플릿.md</guid><pubDate>Sat, 22 Mar 2025 07:43:52 GMT</pubDate></item><item><title><![CDATA[No title]]></title><description><![CDATA[ 
 <br><br><br>__<br><br><br>참고자료<br><br>]]></description><link>재료\template\개요와-참고자료.html</link><guid isPermaLink="false">재료/template/개요와 참고자료.md</guid><pubDate>Thu, 16 Jan 2025 02:51:16 GMT</pubDate></item><item><title><![CDATA[참고도서]]></title><description><![CDATA[<a class="tag" href="?query=tag:updating" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#updating</a> <a class="tag" href="?query=tag:참고도서" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서</a> <a class="tag" href="?query=tag:참고도서/그림으로_이해하는_네트워크_용어" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/그림으로_이해하는_네트워크_용어</a> <a class="tag" href="?query=tag:참고도서/후니의_쉽게_쓴_시스코_네트워킹" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/후니의_쉽게_쓴_시스코_네트워킹</a> <a class="tag" href="?query=tag:참고도서/윤성우의_열혈_cpp_프로그래밍" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/윤성우의_열혈_cpp_프로그래밍</a> <a class="tag" href="?query=tag:참고도서/윤성우의_열혈_TCP_IP_소켓_프로그래밍" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/윤성우의_열혈_TCP_IP_소켓_프로그래밍</a> <a class="tag" href="?query=tag:참고도서/이득우의_게임_수학" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/이득우의_게임_수학</a> <a class="tag" href="?query=tag:참고도서/그림과_실습으로_배우는_도커_쿠버네티스" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/그림과_실습으로_배우는_도커_쿠버네티스</a> <a class="tag" href="?query=tag:참고도서/시작하세요_도커_쿠버네티스" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/시작하세요_도커_쿠버네티스</a> <a class="tag" href="?query=tag:참고도서/모던_웹_디자인을_위한_HTML5_CSS3_입문" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/모던_웹_디자인을_위한_HTML5_CSS3_입문</a> <a class="tag" href="?query=tag:참고도서/혼자_공부하는_자바스크립트" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/혼자_공부하는_자바스크립트</a> <a class="tag" href="?query=tag:참고도서/모던_자바스크립트_핵심_가이드" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/모던_자바스크립트_핵심_가이드</a> <a class="tag" href="?query=tag:참고도서/모던_자바스크립트_Deep_Dive" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/모던_자바스크립트_Deep_Dive</a> <a class="tag" href="?query=tag:참고도서/포르잔_cpp_바이블" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/포르잔_cpp_바이블</a> 
 <br><br><a href=".?query=tag:updating" class="tag" target="_blank" rel="noopener nofollow">#updating</a> <a href=".?query=tag:참고도서" class="tag" target="_blank" rel="noopener nofollow">#참고도서</a><br><br>]]></description><link>area\참고도서.html</link><guid isPermaLink="false">area/참고도서.md</guid><pubDate>Sat, 22 Mar 2025 07:43:52 GMT</pubDate></item><item><title><![CDATA[참고링크]]></title><description><![CDATA[<a class="tag" href="?query=tag:updating" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#updating</a> <a class="tag" href="?query=tag:참고링크" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고링크</a> <a class="tag" href="?query=tag:참고링크/후니의_IT_블로그" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고링크/후니의_IT_블로그</a> <a class="tag" href="?query=tag:참고링크/ANSI_escape_code_깃헙_정리자료" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고링크/ANSI_escape_code_깃헙_정리자료</a> <a class="tag" href="?query=tag:참고링크/nginx_org" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고링크/nginx_org</a> <a class="tag" href="?query=tag:참고링크/생활코딩" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고링크/생활코딩</a> <a class="tag" href="?query=tag:참고링크/php-fpm_org" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고링크/php-fpm_org</a> 
 <br><br><a href=".?query=tag:updating" class="tag" target="_blank" rel="noopener nofollow">#updating</a> <a href=".?query=tag:참고링크" class="tag" target="_blank" rel="noopener nofollow">#참고링크</a><br><br>]]></description><link>area\참고링크.html</link><guid isPermaLink="false">area/참고링크.md</guid><pubDate>Sat, 22 Mar 2025 07:43:52 GMT</pubDate></item><item><title><![CDATA[흑요석 공예]]></title><description><![CDATA[<a class="tag" href="?query=tag:updating" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#updating</a> <a class="tag" href="?query=tag:obsidian" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#obsidian</a> 
 <br><br><a href=".?query=tag:updating" class="tag" target="_blank" rel="noopener nofollow">#updating</a> <a href=".?query=tag:obsidian" class="tag" target="_blank" rel="noopener nofollow">#obsidian</a><br>옵시디언 사용법, 테마, 플러그인에 관한 문서입니다.<br><br><br>]]></description><link>area\흑요석-공예.html</link><guid isPermaLink="false">area/흑요석 공예.md</guid><pubDate>Sat, 22 Mar 2025 07:43:52 GMT</pubDate></item><item><title><![CDATA[국내 기사]]></title><description><![CDATA[ 
 <br><br><br><a data-tooltip-position="top" aria-label="https://www.newsis.com/view/NISX20160824_0014343648" rel="noopener nofollow" class="external-link" href="https://www.newsis.com/view/NISX20160824_0014343648" target="_blank">기사 1</a><br>
<a data-tooltip-position="top" aria-label="https://www.joongang.co.kr/article/20495498" rel="noopener nofollow" class="external-link" href="https://www.joongang.co.kr/article/20495498" target="_blank">기사 2</a><br>
<a data-tooltip-position="top" aria-label="https://www.kookje.co.kr/news2011/asp/newsbody.asp?key=20160825.22030190902" rel="noopener nofollow" class="external-link" href="https://www.kookje.co.kr/news2011/asp/newsbody.asp?key=20160825.22030190902" target="_blank">기사 3</a><br><br><a data-tooltip-position="top" aria-label="https://www.edinburghzoo.org.uk/news/nils-olav-most-famous-king-penguin-world-parades-his-way-new-honour" rel="noopener nofollow" class="external-link" href="https://www.edinburghzoo.org.uk/news/nils-olav-most-famous-king-penguin-world-parades-his-way-new-honour" target="_blank">기사 1 - 2016년 준장 진급식</a><br>번역(chatgpt)<br>2022년 8월 22일 월요일 아침, 노르웨이 왕국의 왕실 근위대가 에든버러 동물원(RZSS Edinburgh Zoo)을 특별히 방문하여, 우리의 왕 펭귄 '닐스 올라프(Sir Nils Olav) 경'에게 독특한 영예를 안겼습니다. 이미 기사 작위를 가진 세계에서 가장 유명한 왕 펭귄인 닐스 올라프 경은 새로운 직책인 '준장 닐스 올라프 경(Brigadier Sir Nils Olav)'라는 칭호를 부여받았습니다.<br>이 명예로운 칭호는 2022년 왕실 근위대의 군복을 입은 50명 이상의 군인들이 참석한 특별한 의식에서 수여되었습니다. 이들은 올해 로열 에든버러 밀리터리 타투(Royal Edinburgh Military Tattoo)에 참여 중이었습니다. 닐스 경은은 펭귄 워크(Penguin Walk)를 걸으며 근위대 군인들을 점검했습니다.<br>검은색, 흰색, 노란색의 위엄 있는 펭귄은 노르웨이 왕실 근위대의 마스코트이며, 2008년에는 왕 하랄 5세가 승인한 기사 작위를 받았습니다.<br>닐스 올라프 경의 이야기는 1972년으로 거슬러 올라갑니다. 당시 에든버러 동물원의 한 임금 펭귄은 그 펭귄의 입양을 주선한 Nils Egelien 소령과 당시 노르웨이 왕이었던 올라프 왕의 이름을 따서 지어졌습니다. 에든버러 동물원은 1914년, 노르웨이의 크리스티안 살베센 가족이 동물원에 첫 왕 펭귄을 선물하면서 노르웨이와 펭귄들과의 오랜 인연을 이어왔습니다. 1919년에는 왕 펭귄 새끼가 처음으로 부화되었고, 이는 남대서양 이외 지역에서 첫 번째 성공적인 왕 펭귄 부화 사례였습니다. 이후로 에든버러 동물원은 펭귄들의 과학적 연구와 돌봄에 선도적인 역할을 해왔고, 펭귄은 지금까지도 로열 동물학회(RZSS)의 중요한 상징으로 자리잡고 있습니다.<br>로열 동물학회의 바바라 스미스(Barbara Smith) 대행 CEO는 "노르웨이 왕실 근위대가 우리의 왕 펭귄 닐스 올라프 경에게 명예로운 새로운 칭호를 수여하는 것을 맞이하게 되어 영광입니다. 이는 두 나라, 스코틀랜드와 노르웨이 간의 긴밀한 협력 관계를 나타내는 자랑스러운 순간입니다."라고 말했습니다.<br>로열 에든버러 군사 타투의 프로듀서이자 CEO인 데이비드 올프리(Brigadier David Allfrey)는 "이것은 두 나라 간의 훌륭한 관계를 보여주는 멋진 사례이며, 더할 나위 없이 매력적인 전통입니다. 타투에서는 많은 장교들이 있지만, 이만큼 특별한 장교는 없었습니다. 브리가디어 올라프, 축하합니다!"라고 덧붙였습니다.<br>군인들은 매년 에든버러 군사 타투에 참여할 때마다 닐스 경를 방문하여 새로운 진급을 수여합니다. 1972년 입양 이후 서 뉼스는 마스코트에서 시작해 1982년에는 상등병(Corporal), 1987년에는 병장(Sergeant), 1993년에는 연대 원사(Regimental Sergeant Major), 2001년에는 명예 연대 원사(Honourable Regimental Sergeant Major), 2005년에는 명예 연대장(Colonel-in-Chief), 2008년에는 기사 작위(Knighthood), 그리고 이제 준장(Brigadier Sir)으로 진급하게 되었습니다.<br><a data-tooltip-position="top" aria-label="https://www.edinburghzoo.org.uk/news/sir-nils-olav-promoted-edinburgh-zoo" rel="noopener nofollow" class="external-link" href="https://www.edinburghzoo.org.uk/news/sir-nils-olav-promoted-edinburgh-zoo" target="_blank">기사 2 - 2023년 소장 진급식</a><br>번역(chatgpt)<br>2023년, 로열 에든버러 군사 타투(Royal Edinburgh Military Tattoo)에 참여 중인 노르웨이 왕실 근위대 밴드와 훈련 팀은 에든버러 동물원(RZSS Edinburgh Zoo)을 방문하여 왕 펭귄 닐스 올라프 경경(Sir Nils Olav)에게 독특한 영예를 수여했습니다.<br>이미 브리가디어인 세계적으로 유명한 왕 펭귄 서 뉼스 올라프는 이제 "소장 닐스 올라프 3세(Major General Sir Nils Olav III), 부베 섬의 남작(Baron of the Bouvet Islands)"이라는 웅장한 칭호와 함께 노르웨이 왕실 근위대의 공식 마스코트로서 새로운 타이틀을 부여받았습니다.<br>닐스 경은 노르웨이 왕실 근위대 밴드와 훈련 팀의 사전 정해진 퍼레이드를 지나며 펭귄 록(Penguins Rock)에서 열린 특별한 의식에서 새로 부여받은 명예 배지를 수여받았습니다. 이 의식에는 올해 로열 에든버러 군사 타투 쇼 '스토리(Stories)'에 참여 중인 노르웨이 왕실 근위대 군인 160명이 참석했습니다.<br>로열 에든버러 군사 타투의 최고운영책임자(COO)인 제이슨 바렛(Jason Barrett)은 “올해 로열 에든버러 군사 타투의 주제는 ‘스토리’이며, 닐스 올라프 경의 군 계급 상승 이야기가 이 쇼와 잘 연결됩니다. 노르웨이 왕실 근위대는 우리 공연에 풍부한 역사와 명예, 전통을 가져오며, 그들은 수년간 팬들의 사랑을 받아왔습니다. 왕실 근위대와 같은 공연을 통해 타투에서 찾을 수 있는 문화 간 요소가 드러나며, 이는 타투가 다른 엔터테인먼트 행사와 구별되는 점입니다. 로열 에든버러 군사 타투의 모든 출연자와 스태프를 대표하여, 닐스 올라프 3세의 소장 진급을 축하합니다."라고 전했습니다.<br>로열 동물학회(RZSS)의 최고경영자(CEO)인 데이비드 필드(David Field)는 "이번에 노르웨이 왕실 근위대 밴드와 훈련 팀을 다시 한 번 맞이하게 되어 영광입니다. 그들이 우리 왕 펭귄 닐스 올라프 경에게 새로운 명예 칭호를 수여하는 것을 보게 되어 매우 자랑스럽습니다. 이는 두 나라, 스코틀랜드와 노르웨이 간의 지속적인 협력 관계를 나타내는 중요한 순간입니다."라고 말했습니다.<br>노르웨이 왕실 근위대 밴드와 훈련 팀의 병장인 프레드릭 그레세스(Staff Sergeant Fredrik Gresseth)는 "닐스 올라프 경은 노르웨이 왕실 근위대의 마스코트이며, 밴드와 훈련 팀이 로열 에든버러 군사 타투에 참여했을 때 그를 입양했습니다. 닐스 경과 그의 가족에게 생선과 크리스마스 카드 보내기, 그리고 타투 참여 시 그를 방문하는 전통은 근위대 대대의 역사에서 중요한 부분이었습니다. 이번 8월의 진급은 그의 훌륭한 행실과 에든버러 동물원의 다른 펭귄들에게 본보기가 되는 모습 덕분에 이루어진 것이며, 이는 그가 마스코트로서의 경력에서 중요한 이정표입니다. 훈련 팀의 군인들은 자신들의 마스코트를 점검하는 이 드문 기회를 기대하고 있으며, 밴드는 기사 작위를 받은 왕 펭귄에게 걸맞은 분위기를 만들어낼 것입니다."라고 덧붙였습니다.<br>검은색, 흰색, 노란색이 돋보이는 이 위엄 있는 펭귄은 노르웨이 왕실 근위대의 마스코트이며, 그의 이야기는 1972년까지 거슬러 올라갑니다. 그 당시 에든버러 동물원에 있던 왕 펭귄은 두 사람의 이름을 따서 지어졌습니다. 그 한 명은 에든버러 동물원에 펭귄을 입양하는 일을 주선한 니얼스 에겔리엔 소령(Major Nils Egelien)이고, 다른 한 명은 당시 노르웨이 왕이었던 올라프 왕(King Olav)이었습니다.<br>군인들은 매 몇 년마다 에든버러 군사 타투에 참여하면서 서 뉼스를 방문하여 그의 진급을 수여합니다. 1972년 입양 이후 닐스 경은 마스코트로 시작하여 1982년에는 상등병(Corporal), 1987년에는 병장(Sergeant), 1993년에는 연대 원사(Regimental Sergeant Major), 2001년에는 명예 연대 원사(Honourable Regimental Sergeant Major), 2005년에는 명예 연대장(Colonel-in-Chief), 2008년에는 기사 작위(Knighthood), 2016년에 준장(Brigadier Sir), 2023년인 지금 소장(Major General)으로 진급하게 되었습니다.<br><br>계급은 해외랑 국내 기사의 표현이 달라서 통일되지 않은 부분이 있습니다<br>
<br>펭귄 한 마리가 일등병 ~ 준장의 계급을 모두 거친 것이 아니다. 펭귄이 수명을 다해 자연사할 때마다 그 펭귄의 자손이 계급을 이어받아 왔다.
<br>첫 번째 펭귄인 닐스 올라프 1세는 1987년 하사로 진급한 뒤 얼마 안되어 자연사했다.
<br>진급은 노르웨이 왕실 근위대가 에든버러를 방문할 때마다 거듭되었다. 순서는 1972년 마스코트 -&gt; 1982년 상등병 -&gt; 1987년 병장 -&gt; 1993년 연대 원사 -&gt; 2001년 명예 연대 원사 -&gt; 2005년 명예 연대장 -&gt; 2008년 기사 작위 -&gt; 2016년 준장 -&gt; 2023년 소장
<br>노르웨이 작위를 부여받았다고 해서 펭귄이 노르웨이로 옮겨가 사는 것은 아니고, 계속 스코틀랜드 에든버러 동물원에서 거주한다.
<br>노르웨이 왕실 군위대는 매년 영국&nbsp; 에든버러에서 열리는 전 세계 군악대 공연 경연인 ‘에든버러 밀리터리 타투(Royal Edinburgh Military Tattoo)’에 참여하고 있다.
]]></description><link>project\4-2학기\닐스-올라프-경-자료조사.html</link><guid isPermaLink="false">project/4-2학기/닐스 올라프 경 자료조사.md</guid><pubDate>Thu, 06 Mar 2025 16:49:59 GMT</pubDate></item><item><title><![CDATA[42 innercirle 정리]]></title><description><![CDATA[ 
 <br><br>그동안 수행했던 개발자 교육과정 42 서울의 공통 과정 과제들을  정리한 저장소입니다.<br><br><br>
<br>각 폴더마다 컴파일을 위한 Makefile이 존재하지만, 이미 make된 상태로 푸시하였으므로 별도로 Makefile을 실행시키지 않아도 됩니다.
<br>NetPractice, Born2beroot는 42 서울의 인트라넷에서만 테스트 가능한 과제이므로 별도의 실행 가능한 파일을 올리지 않은 점 양해 바랍니다다.
<br><br>C 기초<br>strlcpy, strlcat 같은 c 라이브러리의 함수들을 직접 구현해보는 과제<br><br>파일 입출력, static 변수<br>다음의 기능과 형식을 가진 get_next_line이라는 함수를 만드는 과제<br>
// 입력값 : 파일 디스크립터
// 반환값 : 파일로부터 문장 하나를 추출하여 반환.
// n번째로 get_next_line을 호출하면 파일의 n번째 문장을 반환한다.
char *get_next_line(int fd);

<br>/42_innercircle_course/get_next_line/ 경로의 tester.c 파일을 참조하여 tester 파일을 실행시키면 get_next_line의 동작을 확인할 수 있다.<br><br>가변 인자<br>VA_ARG를 활용하여 c 라이브러리의 printf의 기능을 제한적으로(type, flag, precision의 가짓수가 제한되어 있음) 구현하는 과제<br>/42_innercircle_course/ft_printf/ 경로의 tester.c 파일을 참조하여 tester 파일을 실행시키면 ft_printf의 동작을 확인할 수 있다.<br><br>가상 머신, 리눅스 기초<br>VirtualBox를 사용하여 linux 가상 환경을 띄운 후, 그 환경에서 여러 서비스들을 설정하는 과제<br><br>멀티 프로세싱, 프로세스 간 통신<br>fork, pipe 시스템 콜을 활용하여 쉘의 파이프 기능을 구현해보는 과제<br>
&lt; infile ls -l | wc -l &gt; outfile

<br>위와 같은 쉘의 파이프 기능을 아래와 같은 형식으로 구현한다.<br>
./pipex infile "ls -l" "wc -l" outfile

<br>2개 이상의 명령어를 이을 수도 있다.<br>
&lt; infile cmd1 | cmd2 | cmd3 | ... | cmdn &gt; outfile

<br>
./pipex infile cmd1 cmd2 cmd3 ... cmdn outfile

<br>heredoc 기능을 사용할 수도 있다.<br>
cmd &lt;&lt; LIMITER | cmd1 &gt;&gt; file

<br>
./pipex here_doc LIMITER cmd cmd1 file

<br><br>자료구조, 알고리즘<br>두 개의 스택을 사용하여 뒤섞인 숫자 배열을 정렬하는 과제<br>다음과 같은 조건 하에 문제를 해결해야 한다.<br>
<br>스택 a, 스택 b 총 두 개의 스택이 있다.
<br>입력받은 뒤섞인 숫자 배열은 스택 a에 위치한다.
<br>후술할 스택의 동작들을 활용하여 최종적으로 스택 a에 숫자들이 정렬되도록 한다.
<br>이 과제에서 제시하는 스택은 일반적인 스택과 달리 다음의 추가적인 동작들을 적용할 수 있다(사실 말이 스택이지 별도의 자료구조라 보는 게 무방하다).<br>
<br>sa (swap a): 스택 a의 맨 위 두 개 요소를 바꾼다. 요소가 하나 이하일 때는 아무것도 하지 않는다.
<br>sb (swap b): 스택 b의 맨 위 두 개 요소를 바꾼다. 요소가 하나 이하일 때는 아무것도 하지 않는다.
<br>ss: sa와 sb를 동시에 한다.
<br>pa (push a): 스택 b의 맨 위 요소를 꺼내서 스택 a의 맨 위에 넣는다. 만약 스택 b가 비어 있으면 아무것도 하지 않는다.
<br>pb (push b): 스택 a의 맨 위 요소를 꺼내서 스택 b의 맨 위에 넣는다. 만약 스택 a가 비어 있으면 아무것도 하지 않는다.
<br>ra (rotate a): 스택 a의 모든 요소를 위로 1칸씩 이동시킨다. 첫 번째 요소가 마지막 요소가 된다.
<br>rb (rotate b): 스택 b의 모든 요소를 위로 1칸씩 이동시킨다. 첫 번째 요소가 마지막 요소가 된다.
<br>rr: ra와 rb를 동시에 한다.
<br>rra (reverse rotate a): 스택 a의 모든 요소를 아래로 1칸씩 이동시킨다. 마지막 요소가 첫 번째 요소가 된다.
<br>rrb (reverse rotate b): 스택 b의 모든 요소를 아래로 1칸씩 이동시킨다. 마지막 요소가 첫 번째 요소가 된다.
<br>rrr: rra와 rrb를 동시에 한다.
<br>push_swap에 뒤섞인 숫자 배열을 입력하면 숫자들을 정렬하기 위한 명령어의 나열을 출력한다.<br>
참고로 입력하는 숫자 배열의 숫자들은 서로 중복되지 않아야 한다.<br>
./push_swap 5 2 1 4 7 6 3

sa
pb
rra
pb
sa
pb
rb
sa
pb
pb
sa
pb
pb
pa
pa
pa
pa
pa
pa
pa

<br><a data-tooltip-position="top" aria-label="https://windowdong11.github.io/push_swap_visualizer/" rel="noopener nofollow" class="external-link" href="https://windowdong11.github.io/push_swap_visualizer/" target="_blank">push swap visualizer</a>를 활용하면 push_swap의 동작을 시각적으로 확인할 수 있다. 단, 이 저장소를 사용하는 사람들은 WSL 환경에서 push_swap을 실행시킬 것이므로 push_swap [뒤섞인 숫자 나열] | clip, push_swap [뒤섞인 숫자 나열] | pbcopy가 아닌 push_swap [뒤섞인 숫자 나열] | xclip -selection clipboard를 사용해야 한다.<br><br>그래픽스 기초<br>아래와 같은 형태의 map 파일을 사용하여<br>
cat 42.fdf

0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 10 10 0 0 10 10 0 0 0 10 10 10 10 10 0 0 0
0 0 10 10 0 0 10 10 0 0 0 0 0 0 0 10 10 0 0
0 0 10 10 0 0 10 10 0 0 0 0 0 0 0 10 10 0 0
0 0 10 10 10 10 10 10 0 0 0 0 10 10 10 10 0 0 0
0 0 0 10 10 10 10 10 0 0 0 10 10 0 0 0 0 0 0
0 0 0 0 0 0 10 10 0 0 0 10 10 0 0 0 0 0 0
0 0 0 0 0 0 10 10 0 0 0 10 10 10 10 10 10 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0

<br>아래의 예시와 같이 3차원의 형상(wire frame이긴 하지만)으로 투사하는 과제이다.<br><img alt="FdF.png" src="lib\media\fdf.png"><br>map 파일의 숫자들은 다음과 같이 해석된다.<br>
<br>숫자의 열 위치 : x축 좌표값
<br>숫자의 행 위치 : y축 좌표값
<br>숫자의 값 : z축 좌표값
<br>과제 수행을 위하여 행렬을 통한 공간 변환, 브레젠험 알고리즘 같은 지식을 배우게 된다.<br>fdf를 실행하기 전 의존성 문제를 해결하기 위해 다음의 명령어를 실행해야한다.<br>
sudo apt-get update &amp;&amp; sudo apt-get install xorg libxext-dev zlib1g-dev libbsd-dev

<br>아래와 같은 명령어를 통해 테스트 해볼 수 있다. 예제 map 파일들은 test_maps 경로에 위치해 있다.<br>
./fdf ./test_maps/42.fdf

<br>창을 띄우는 데까지 성공했다면, 다음의 키들을 활용하여 추가 기능을 테스트할 수 있다.<br>scale<br>
<br>위 화살표 : 확대
<br>아래 화살표 : 축소
<br>rotate<br>
<br>A, D : y 축 회전
<br>W, S : x 축 회전
<br>Q, E : z 축 회전
<br>translate<br>
<br>I, K : x 축 이동
<br>J, L :  y 축 이동
<br>U, E : z 축 이동
<br>기타<br>
<br>space : 투영법 변환(등각 투영 &lt;-&gt; 캐비넷 투영)
<br>esc : 나가기
<br><br>파일 입출력, 멀티 프로세스, 시그널 심화<br>제한된 기능의 bash shell을 구현하는 과제<br>minishell 실행 파일은 readline 라이브러리에 의존성을 가지므로 아래의 명령어를 실행시킨 후 실행시켜야 한다.<br>
sudo apt-get install libreadline-dev

<br>microshell은 아래와 같은 기능을 가지고 있다.<br>
<br>히스토리 : 위, 아래 화살표를 이용해 과거에 사용했던 명령어를 편리하게 조회, 재사용할 수 있다.
<br>쌍따옴표, 따옴표 파싱
<br>괄호 파싱
<br>&lt;, &gt;, &lt;&lt;, &gt;&gt;, &amp;&amp;, || 연산자
<br>파이프라인(|)
<br>환경변수 관리
<br>$?를 통한 exit status 조회
<br>ctrl-C, ctrl-D, ctrl-\ 입력이 bash shell과 동일한 동작을 보장함
<br>와일드 카드(*)
<br><br>멀티 스레드<br>pthread, mutex_lock 등을 사용하여 식사하는 철학자 문제(dining philosophers problem)를 구현, 멀티 스레딩, 데이터 레이스(data race), 데드 락(dead lock)을 공부하는 과제<br>각 철학자(스레드)는 제한된 숫자의 포크(공유 자원)을 사용하여 굶어죽지 않고 무사히 식사를 마칠 수 있어야 한다.<br>philo 실행 파일은 다음의 인자를 받아 실행된다.<br>
<br>철학자 인원
<br>죽는 데 걸리는 시간
<br>먹는 데 걸리는 시간
<br>자는 데 걸리는 시간
<br>각 철학자가 먹어야 하는 횟수(없어도 무방하며, 입력하지 않을 시 철학자들은 무한히 식사하게 된다)
<br>즉, 아래와 같이 사용된다.<br>
./philo 2 450 200 200 4

<br>philo_bonus 실행 파일은 멀티 스레드 대신 멀티 프로세스, 세마포어를 사용하여 구현한 철학자 모델이다.<br>phlio 또는 philo_bonus 파일의 실행결과를 <a data-tooltip-position="top" aria-label="https://nafuka11.github.io/philosophers-visualizer/" rel="noopener nofollow" class="external-link" href="https://nafuka11.github.io/philosophers-visualizer/" target="_blank">philosopher visualizer</a>에 붙여넣기 하면 보다 시각적으로 결과를 확인할 수 있다.<br><br>ray tracing<br>phong lighting model을 구현하는 과제이다.<br>miniRR 실행 파일은 환경광(ambient lighting), 카메라, 광원, 구체, 평면, 원기둥 정보가 담겨 있는 .rt 파일을 파싱하여 3차원으로 렌더링할 수 있어야 한다. FdF의 wire frame 렌더링이 아닌, 보다 현실감 있는 3차원 렌더링으로 말이다.<br>아래와 같이 사용한다.<br>
./miniRT rtFileName.rt

<br>예제 rt 파일은 maps 경로에 위치한다.<br><br>네트워크 기초<br>NetPractice는 가상의 네트워크 망이 서로 잘 통신할 수 있도록 빈 칸에 알맞은 ip 주소를 채워넣는 퍼즐 문제이다.<br>공인 ip, 사설 ip, LAN, WAN, 서브넷 마스킹 등을 공부하게 된다.<br><br>C++ 기초<br>CPP Module은 cpp 언어의 기초를 학습하기 위한 과제이다. 각 모듈은 다음의 주제를 다룬다.<br>
<br>모듈 0 : Namespaces, classes, member functions, stdio streams, initialization lists, static, const
<br>모듈 1 : Memory allocation, pointers to members, references, switch statement
<br>모듈 2 : Ad-hoc polymorphism, operator overloading and Orthodox Canonical class form
<br>모듈 3 : Inheritance
<br>모듈 4 : Subtype polymorphism, abstract classes, interfaces
<br>모듈 5 : Repetition and Exceptions
<br>모듈 6 : C++ casts
<br>모듈 7 : C++ templates
<br>모듈 8 : Templated containers, iterators, algorithms
<br>모듈 9 : STL
<br><br>socket programming<br>C++ 언어를 사용하여 irc 서버를 만드는 과제이다.<br>
irc란, 채팅 서버를 만들기 위한 프로토콜이다. 물론 irc 서버를 온전히 구현하는 것은 너무 벅찬 일이므로, 일부 기능을 제외하고 구현하였다(ex. 서버 간 통신).<br>클라이언트와 통신하는 기능을 만들기 위해 소켓 프로그래밍 socket programming을, 정해진 프로토콜 대로 서버를 만들기 위해 rfc 문서를 보는 방법을 배우게 된다.<br>nc(netcat) 같은 간단한 클라이언트 프로그램으로도 서버를 테스트할 수 있지만, 사용자 친화적이지 못하므로 제대로 된 irc 클라이언트를 설치하여 테스트하는 것을 권장한다.<br>
sudo apt install irssi

<br>그리고 먼저 서버를 실행시킨다. 첫번째 인자는 서버가 통신에 사용할 포트 번호, 두번째 인자는 서버에 연결하는데 사용할 비밀번호이다.<br>
./ircserv 4242 4242

<br>그리고 irssi 클라이언트를 실행시킨다.<br>
./irssi

<br>화면에 irssi 윈도우가 띄워지면, 다음의 명령어를 사용하여 서버에 접속한다.<br>
/connect -nocap localhost 4242 4242 nickname

<br>연결에 성공하였다면 <a data-tooltip-position="top" aria-label="https://www.rfc-editor.org/rfc/rfc2812.html" rel="noopener nofollow" class="external-link" href="https://www.rfc-editor.org/rfc/rfc2812.html" target="_blank">rfc 2812</a> 문서를 참고하여 irc 프로토콜의 다양한 명령어를 테스트하여보자.<br><br>Docker<br>도커를 사용하여 wordpress 페이지를 서비스하기 위한 MSA(micro service architecture)를 띄우는 과제.<br>이 과제를 테스트하기 위해선 리눅스에 docker가 설치되어 있어야 한다.<br>
sudo apt install docker

<br>sudo make build로 MSA를 올릴 수 있고 호스트에서 https://localhost로 접속할 수 있다. sudo make fclean으로 MSA를 내릴 수 있다.<br><br>웹 프로그래밍 기초<br>플레이어들이 서로 ping pong 게임을 즐길 수 있는 웹페이지를 만드는 과제<br>
다음의 스택을 사용한다.<br>
<br>프론트엔드 : pure vanila javascript, html, css, bootstrap, socket.io, three.js
<br>백엔드 : Django
<br>과제를 테스트하기 위해서는 backend 경로로 이동하여 sudo make하고 호스트에서 chrome을 사용하여 https://localhost로 접속하면 된다.<br>sudo make fclean으로 MSA를 내릴 수 있다.]]></description><link>project\42seoul\42-innercircle-정리\42-innercirle-정리.html</link><guid isPermaLink="false">project/42Seoul/42 innercircle 정리/42 innercirle 정리.md</guid><pubDate>Fri, 28 Feb 2025 15:02:18 GMT</pubDate><enclosure url="lib\media\fdf.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="lib\media\fdf.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[authentication.mjs]]></title><description><![CDATA[<a class="tag" href="?query=tag:42Seoul" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#42Seoul</a> <a class="tag" href="?query=tag:ft_transcendence" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#ft_transcendence</a> 
 <br><br><a href=".?query=tag:42Seoul" class="tag" target="_blank" rel="noopener nofollow">#42Seoul</a> <a href=".?query=tag:ft_transcendence" class="tag" target="_blank" rel="noopener nofollow">#ft_transcendence</a><br><br><br>인증 모듈은 로그인 시 사용자 인증에 필요한 기능들을 클래스의 정적 메소드의 형태로 지원한다.<br>FtOauth 클래스는 42 oauth 인증에 관련된 기능을 지원한다.<br>
TwoFactorOauth 클래스는 2fa 인증에 관련된 기능을 지원한다.<br><br>
<br>clientId : 42 api의 클라이언트 id
<br>redirectUri : 42 api에서 콜백할 uri
<br>authUrl : 42 oauth 페이지로 넘어가기 위한 최종 url
<br><br>
<br>static isAlreadyAuth() : 현재 url에 code가 포함되어 있으면 code를, 그렇지 않으면 undefined를 반환한다.
]]></description><link>project\42seoul\ft_transcendence\모듈-설계\authentication.mjs.html</link><guid isPermaLink="false">project/42Seoul/ft_transcendence/모듈 설계/authentication.mjs.md</guid><pubDate>Fri, 24 Jan 2025 07:12:26 GMT</pubDate></item><item><title><![CDATA[page.mjs]]></title><description><![CDATA[<a class="tag" href="?query=tag:42Seoul" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#42Seoul</a> <a class="tag" href="?query=tag:ft_transcendence" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#ft_transcendence</a> 
 <br><br><a href=".?query=tag:42Seoul" class="tag" target="_blank" rel="noopener nofollow">#42Seoul</a> <a href=".?query=tag:ft_transcendence" class="tag" target="_blank" rel="noopener nofollow">#ft_transcendence</a><br><br><br>페이지 모듈은 각 페이지를 화면에 렌더링하는 기능을 지원한다.<br><br><br>
<br>static renderLoginPage(ftOauthUrl) : 화면에 로그인 페이지를 렌더링한다. 이 때, 버튼에 42 인증 페이지로의 링크를 부여하기 위해 42 Oauth url을 인자로 주어야 한다.
<br>static destroyLoginPage() : 로그인 페이지를 화면에서 지운다.
<br><br>
<br>static renderTwoFAPage() : 화면에 2fa(google otp) 인증 페이지를 렌더링한다.
<br>static destroyTwoFAPage() : 2fa 인증 페이지를 화면에서 지운다.
]]></description><link>project\42seoul\ft_transcendence\모듈-설계\page.mjs.html</link><guid isPermaLink="false">project/42Seoul/ft_transcendence/모듈 설계/page.mjs.md</guid><pubDate>Tue, 21 Jan 2025 08:00:53 GMT</pubDate></item><item><title><![CDATA[42 oauth 기반 로그인 구현 방법]]></title><description><![CDATA[ 
 <br><a data-tooltip-position="top" aria-label="https://yeslee-v.medium.com/django%EB%A1%9C-42api-%EB%A1%9C%EA%B7%B8%EC%9D%B8-%EA%B5%AC%ED%98%84%ED%95%98%EA%B8%B0-1f7a206cb4a4" rel="noopener nofollow" class="external-link" href="https://yeslee-v.medium.com/django%EB%A1%9C-42api-%EB%A1%9C%EA%B7%B8%EC%9D%B8-%EA%B5%AC%ED%98%84%ED%95%98%EA%B8%B0-1f7a206cb4a4" target="_blank">링크</a>]]></description><link>project\42seoul\ft_transcendence\42-oauth-기반-로그인-구현-방법.html</link><guid isPermaLink="false">project/42Seoul/ft_transcendence/42 oauth 기반 로그인 구현 방법.md</guid><pubDate>Mon, 20 Jan 2025 11:15:34 GMT</pubDate></item><item><title><![CDATA[참고할만한 것들]]></title><description><![CDATA[<a class="tag" href="?query=tag:42Seoul" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#42Seoul</a> <a class="tag" href="?query=tag:ft_transcendence" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#ft_transcendence</a> 
 <br><br><a href=".?query=tag:42Seoul" class="tag" target="_blank" rel="noopener nofollow">#42Seoul</a> <a href=".?query=tag:ft_transcendence" class="tag" target="_blank" rel="noopener nofollow">#ft_transcendence</a><br><br><br><br>Start-Process "C:\Program Files\Google\Chrome\Application\chrome.exe" -- "--disable-web-security --user-data-dir=C:\chrome_dev"<br><br>&lt;script src="https://cdn.jsdelivr.net/npm/qrcode@1.4.4/build/qrcode.min.js"&gt;&lt;/script&gt;<br><br>
QRCode.toCanvas(qrcodeUrl, { width:256 } , function (error, canvas) {
        if (error) {
          console.error(error);
        }
        else {
          target.appendChild(canvas); // qr code가 담겨있는 캔버스를 원하는 대상에 추가시킨다.
        }
      });

<br><br><br>
document.cookie.split(";").forEach((value) =&gt; {
      let property = value.trim();
      if (property.startsWith(accessTokenString))
        tokens.accessToken = property.substring(accessTokenString.length);
      if (property.startsWith(refreshTokenString))
        tokens.refreshToken = property.substring(refreshTokenString.length);
    });

<br>
<br>쿠키를 ;로 쪼갠다.
<br>앞뒤에 있는 whitespace를 날린다.
<br>propertyName=value 꼴로 되어 있는 각 문자열 중 원하는 프로퍼티를  찾아 propertyName= 부분만 제거한다.
<br><br>
document.cookie = `${accessTokenString}${access_token};`;
document.cookie = `${refreshTokenString}${refresh_token};`;

<br>document.cookie = propertyName=value; 형식으로 저장하면 된다. 이미 쿠키에 저장된 내용이 있는 경우 기존의 내용이 지워지진 않는다. 마치 객체에 새로운 내용을 동적할당하는 것처럼 동작한다.<br>쿠키의 내용을 수정할 때도 마찬가지로 document.cookie = propertyName=newValue; 같이 사용한다.<br><br>강제로 쿠키의 유효기간을 만료시켜 제거한다.<br>
static clearCookie() {
    document.cookie =
      accessTokenString + "; expires=Thu, 01 Jan 1970 00:00:01 GMT;";
    document.cookie =
      refreshTokenString + "; expires=Thu, 01 Jan 1970 00:00:01 GMT;";
  }

<br><br><a data-tooltip-position="top" aria-label="https://ko.javascript.info/websocket" rel="noopener nofollow" class="external-link" href="https://ko.javascript.info/websocket" target="_blank">자바스크립트 튜토리얼 ko</a><br>
<a data-tooltip-position="top" aria-label="https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API" rel="noopener nofollow" class="external-link" href="https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API" target="_blank">모질라</a>]]></description><link>project\42seoul\ft_transcendence\참고할만한-것들.html</link><guid isPermaLink="false">project/42Seoul/ft_transcendence/참고할만한 것들.md</guid><pubDate>Mon, 27 Jan 2025 08:35:01 GMT</pubDate></item><item><title><![CDATA[낙서장]]></title><description><![CDATA[<a class="tag" href="?query=tag:inception" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#inception</a> <a class="tag" href="?query=tag:memo" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#memo</a> 
 <br><br><a href=".?query=tag:inception" class="tag" target="_blank" rel="noopener nofollow">#inception</a> <a href=".?query=tag:memo" class="tag" target="_blank" rel="noopener nofollow">#memo</a><br>중요하지만 세세하기에 적기에는 너무 피말리는 것<br><br><br>nginx.conf 파일에 외부의 환경변수를 적용시키려면 envsubst를 사용해야 한다.<br>envsubst "\$&lt;변수명&gt;" &lt; &lt;환경변수를 적용하기를 원하는 파일&gt; &gt; 결과 파일<br>결과 파일은 별도로 생성되므로 입력 파일의 이름은 target.before이나 target.template 등의 형태로 만드는 것이 좋다.<br>주의 : 이 명령어는 이미지 빌드 타임에는 환경 변수를 제대로 읽지 못한다. 따라서 반드시 Dockerfile의 RUN이 아니라 ENTRYPOINT로 넘겨서 실행시켜야 한다.<br><a data-tooltip-position="top" aria-label="https://gukjan9.tistory.com/134" rel="noopener nofollow" class="external-link" href="https://gukjan9.tistory.com/134" target="_blank">envsubst 자료 출처</a><br><a data-tooltip-position="top" aria-label="https://make.wordpress.org/cli/handbook/guides/quick-start/" rel="noopener nofollow" class="external-link" href="https://make.wordpress.org/cli/handbook/guides/quick-start/" target="_blank">wp cli</a><br><br><br><a data-tooltip-position="top" aria-label="https://ko.wordpress.org/plugins/redis-cache/" rel="noopener nofollow" class="external-link" href="https://ko.wordpress.org/plugins/redis-cache/" target="_blank">redis cache란?</a> = Redis로 구동되는 영구 객체 캐시 <br><br><a data-tooltip-position="top" aria-label="https://hoing.io/archives/53699" rel="noopener nofollow" class="external-link" href="https://hoing.io/archives/53699" target="_blank">참고 링크</a><br>systemctl을 쓰지 않고 redis-server를 백그라운드로 실행하는 법 -&gt;<br>
redis-server --daemonize yes<br>php-predis 설치 -&gt;<br>
apt install php-predis<br>wordpress의 redis object cache 플러그인 설치(주의!!! redis-object-cache가 아닌 redis-cache를 설치해야 함(Tlqkf))<br>
wp plugin install --allow-root redis-cache]]></description><link>project\42seoul\inception\낙서장.html</link><guid isPermaLink="false">project/42Seoul/inception/낙서장.md</guid><pubDate>Sat, 22 Mar 2025 07:43:56 GMT</pubDate></item><item><title><![CDATA[마이크로서비스]]></title><description><![CDATA[ 
 <br><br>microservice<br><br>마이크로서비스 아키텍처는 하나의 애플리케이션 내에 있는 각 핵심 기능이 독립적으로 존재할 수 있도록 소프트웨어를 구축하는 클라우드 네이티브 접근 방식이다.<br><br>애플리케이션 빌드의 전통적인 방식은 모눌리식 위주이다. 모눌리식 아키텍처에서는 애플리케이션 내의 모든 기능과 서비스가 함께 맞물려 단일 유닛으로 운영된다. 애플리케이션이 어떤 방식으로든 추가되면 아키텍처는 더 복잡해진다. 그 결과 전체 애플리케이션을 분리하지 않고는 애플리케이션 내의 단일 기능을 최적화하기가 더 어려워지고, 만약 애플리케이션 내의 하나의 프로세스가 확장되어야 할 때는 전체 애플리케이션도 확장되어야 한다.<br>마이크로서비스 아키텍처에서 애플리케이션은 애플리케이션 내의 각 핵심 기능이 독립적으로 작동하도록 빌드된다. 따라서 개발 팀은 애플리케이션 전체를 중단하지 않고 변화하는 비즈니스 요구 사항을 충족하기 위한 새로운 구성 요소를 구축하고 업데이트할 수 있다.<br><br>마이크로서비스는 분산형 개발을 통해 팀의 역량과 일상적인 업무 능력을 향상시킨다. 또한, 여러 마이크로서비스를 동시에 개발하는 것도 가능하다. 따라서 동일한 애플리케이션 개발에 더 많은 개발자들이 동시 참여할 수 있으므로 개발에 소요되는 시간을 단축할 수 있다.<br><br>더 자세한 정보를 원한다면 아래로<br><a data-tooltip-position="top" aria-label="https://www.redhat.com/ko/topics/microservices/what-are-microservices" rel="noopener nofollow" class="external-link" href="https://www.redhat.com/ko/topics/microservices/what-are-microservices" target="_blank">redhat 홈페이지</a><br>]]></description><link>project\42seoul\inception\마이크로서비스.html</link><guid isPermaLink="false">project/42Seoul/inception/마이크로서비스.md</guid><pubDate>Sat, 22 Mar 2025 07:43:56 GMT</pubDate></item><item><title><![CDATA[캐시]]></title><description><![CDATA[<a class="tag" href="?query=tag:computer_science" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#computer_science</a> 
 <br><br><a href=".?query=tag:computer_science" class="tag" target="_blank" rel="noopener nofollow">#computer_science</a><br>cache<br><br>캐시는 컴퓨터 과학에서 데이터나 값을 미리 복사해 놓는 임시 장소를 가리킨다. 캐시는 캐시의 접근 시간에 비해 미가공 데이터 또는 1차 데이터(raw data or primary data)에 접근하는 시간이 오래 걸리는 경우나 값을 다시 계산하는 시간을 절약하고 싶은 경우에 사용한다. 캐시에 데이터를 미리 복사해 놓으면 계산이나 접근 시간 없이 더 빠른 속도로 데이터에 접근할 수 있다.<br>캐시는 시스템의 효율성을 위해 다음과 같은 여러 분야에서 두루 쓰이고 있다.<br>
<br>CPU 캐시
<br>디스크 캐시
<br>기타 캐시
<br><br>CPU 캐시는 하드웨어를 통해 관리되고, 그 밖에 다른 캐시들은 대개 소프트웨어적으로 관리된다. 운영 체제의 메인 메모리를 하드 디스크에 복사해 놓는 페이퍼 캐시는 운영 체제 커널과 파일 시스템을 통해 관리된다. BIND DNS 데몬은 도메인 이름과 IP 주소 사이의 매핑을 저장해 둔다.<br>신뢰성이 적은 네트워크(이더넷 등)에서, 네트워크 사이에 주고 받는 데이터를 캐시해 놓는 것은 매우 흔한 일이다. 이를테면, 웹 브라우저는 최근 방문한 사이트를 캐시에 저장해 놓는다. 많은 인터넷 제공업체들과 대규모 네트워크의 운영자들은 인기 있는 웹 페이지의 캐시를 프록시 서버에 저장하여 웹 페이지 요청에 응답하게 함으로써 네트워크 대역폭을 아낀다.<br>구글 검색 엔진은 검색 대상 사이트들의 내용을 캐시에 저장해 검색 엔진에 사용하기도 하고, 검색 결과의 일부로서 사용자들에게 보여 주기도 한다.<br><br>캐시가 효율적으로 동작하려면, 캐시에 저장할 데이터가 지역성을 가져야 한다. 지역성이란 데이터 접근이 시간적, 혹은 공간적으로 가깝게 일어나는 것을 의미한다.<br><br>특정 데이터가 한번 접근되었을 경우, 가까운 미래에 또 한번 데이터에 접근할 가능성이 높은 것을 시간적 지역성이라고 한다.<br>메모리 상의 같은 주소에 여러 차례 읽기 쓰기를 수행할 경우 상대적으로 작은 크기의 캐시를 사용해도 효율성을 꾀할 수 있다.<br><br>특정 데이터와 가까운 주소가 순서대로 접근되었을 경우를 공간적 지역서이라고 한다. CPU 캐시나 디스크 캐시의 경우 한 메모리 주소에 접근할 때 그 주소뿐 아니라 해당 블록을 전부 캐시에 가져오게 된다. 이때 메모리 주소를 오름차순이나 내림차순으로 접근한다면, 캐시에 이미 저장된 같은 블록의 데이터를 접근하게 되므로 캐시의 효율성이 크게 향상된다.<br><br>참고자료<br><br>]]></description><link>project\42seoul\inception\캐시.html</link><guid isPermaLink="false">project/42Seoul/inception/캐시.md</guid><pubDate>Sat, 22 Mar 2025 07:43:56 GMT</pubDate></item><item><title><![CDATA[NGINX]]></title><description><![CDATA[<a class="tag" href="?query=tag:web" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#web</a> <a class="tag" href="?query=tag:server/web_server" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#server/web_server</a> <a class="tag" href="?query=tag:uncomplete" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#uncomplete</a> <a class="tag" href="?query=tag:참고링크/nginx_org" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고링크/nginx_org</a> 
 <br><br><a href=".?query=tag:web" class="tag" target="_blank" rel="noopener nofollow">#web</a> <a href=".?query=tag:server\web_server" class="tag" target="_blank" rel="noopener nofollow">#server/web_server</a> <a href=".?query=tag:uncomplete" class="tag" target="_blank" rel="noopener nofollow">#uncomplete</a><br>engine x<br><br>본 문서는 미완성 문서입니다.<br>본 문서는 필요에 따라 <a data-tooltip-position="top" aria-label="https://nginx.org/" rel="noopener nofollow" class="external-link" href="https://nginx.org/" target="_blank">nginx 공식 문서</a>의 일부분만을 정리한 것입니다.<br>
누락한 부분은 누락과 같이 표시됩니다.<br>
누락한 부분은 차후 보충될 수도, 그렇지 않을 수도 있습니다.<br><br>nginx는 다음의 기능을 수행할 수 있는 프로그램이다.<br>
<br>http 웹 서버
<br>리버스 프록시
<br>콘텐츠 캐시
<br>로드 밸런서
<br>tcp/udp 프록시 서버
<br>메일 프록시 서버
<br>nginx는 하나의 master 프로세스와 여러 개의 worker 프로세스로 수행된다.<br>master 프로세스는 config 파일을 읽고 분석하며, worker 프로세스를 유지 및 관리한다.<br>
worker 프로세스는 요청을 처리하는 작업을 담당한다.<br>nginx는 event-based 모델을 사용하며 운영체제(아마도 리눅스)에 의존적이다. 이는 worker 프로세스들에게 작업을 효율적으로 분배하기 위해서이다. worker 프로세스의 개수는 configuration 파일에서 정의되며 현재 가용한 cpu 코어 수에 따라 조정될 수 있다.<br>nginx가 동작하는 방식은 configuration 파일에 의해 정의된다. 일반적으로 configuration 파일은 nginx.conf라는 이름을 가지며 다음의 디렉토리 중 하나에 위치한다.<br>
<br>/usr/local/nginx/conf
<br>/etc/nginx
<br>/usr/local/etc/nginx
<br><br><a data-tooltip-position="top" aria-label="https://nginx.org/en/docs/install.html" rel="noopener nofollow" class="external-link" href="https://nginx.org/en/docs/install.html" target="_blank">nginx 공식 문서</a> 참조<br><br><br>nginx를 시작하기 위해선 실행파일을 동작시킨다.<br>동작 중인 nginx를 제어하기 위해서는 -s 매개변수를 사용하여 응용 프로그램을 동작시킨다.<br>
다음의 문법을 따른다.<br>nginx -s &lt;signal&gt;<br>signal 위치에는 다음의 인자들이 위치할 수 있다.<br>
<br>stop : 빠른 강제 종료
<br>quit : 우아한(graceful) 종료
<br>reload : configuration file을 reload함
<br>reopen : log 파일을 다시 염
<br>예를 들어, 현재 요청을 처리하기 위해 동작 중인 worker 프로세스들을 정지하기 위해서는 아래의 커맨드를 동작한다.<br>nginx -s quit<br>
이 커맨드는 nginx를 실행시킨 유저와 동일한 유저에 의하여 호출되어야 한다.
<br>configuration 파일이 수정되어도 그것이 reload 되거나 nginx가 다시 시작하기 전까지는 수정사항이 반영되지 않는다. configuration 파일을 reload 하려면 아래의 커맨드를 동작시킨다.<br>nginx -s reload<br>master 프로세스는 reload configuration 신호를 받으면, 수정된 configuration 파일의 유효성을 확인하고 변경사항을 적용한다.<br>이 작업이 성공한다면, master 프로세스는 새로운 worker 프로세스를 생성하고 기존에 존재하던 worker 프로세스에게는 종료 명령을 보낸다.<br>이 작업이 실패한다면, master 프로세스는 변경 사항을 롤백하고 기존 configuration 파일에 따라 작업을 계속한다.<br>종료 명령을 받은 worker 프로세스는 새로운 요청을 받는 것을 중단한 후, 제공하고 있던 요청(=서비스)를 마저 제공한다. 그런 후 exit 한다.<br>unix의 kill 유틸리티를 이용하여 신호를 보낼 수도 있다. 이 경우 신호를 보내고자 하는 프로세스의 id를 알아야 한다. nginx master 프로세스의 id는 일반적으로 /usr/local/nginx/logs/nginx.pid에 저장되어 있다.<br>
아래와 같은 명령어를 사용한다.<br>kill -s QUIT &lt;nginx master process id&gt;<br>ps 명령을 통해 현재 동작 중인 nginx 프로세스들의 목록을 가져올 수도 있다.<br>ps -ax | grep nginx<br><br>nginx는 configuration 파일에 열거된 지침(directives)을 따른다. 지시 사항은 단순한 지침(simple directives)와 블록 지침(block directives)로 나뉜다.<br>단순한 지침은 아래와 같은 형식을 취한다.<br>name parameter;<br>블록 지침은 다른 여러 개의 지침들을 {, }로 둘러싸는 형태로 보유할 수 있으며, 이를 context(문맥)라고 부른다(예 : events, http, server, location).<br>http {
	server {
	}
}
<br>configuration 파일에 있는 모든 지침들은 어디에 위치해있던지 main context에 존재하는 것으로 간주한다(오역의 가능성 있음).<br># 기호 뒤에 오는 문장은 주석으로 간주한다.<br><br>웹 서버의 주요 업무는 이미지나 정적 html 페이지 같은 파일을 제공하는 것이다.<br>html 파일은 보통 /data/www 디렉토리에 위치해 있고<br>
이미지 파일은 보통 /data/images에 위치해 있다.<br>http 블록 내부의 server 블록에 두 개의 location 블록을 설정함으로서 이를 설정할 수 있다.<br>
아래와 같은 절차를 통해 예제를 진행해보자.<br>
<br>
/data/www 디렉토리를 만든 후 그 안에 index.html을 위치시킨다. index.html에는 어떠한 내용이 있어도 괜찮다.

<br>
/data/image 디렉토리를 만든 후 그 안에 아무 이미지나 넣는다.

<br>
configuration 파일을 연다. 파일 안에는 이미 여러 개의 server 블록이 있을 것이고 그 중에서는 주석 처리가 된 것도, 그렇지 않은 것도 있을 것이다. 주석 처리되지 않은 모든 server 블록을 주석처리하고 아래와 같이 새로운 server 블록을 만든다.
http {
	server {
	}
}


<br>
일반적으로 configuration 파일 내부에는 수신하고 있는 포트 번호, 그리고 서버의 이름에 따라 여러 개의 server 블록이 있다. nginx는 요청의 헤더 부분에 있는 URI를 분석하여 server 블록 내부의 location 지침에 있는 인자와 대조함으로서 어느 서버가 요청을 수행할지를 결정한다.
<br>
<br>
다음의 location 블록을 server 블록에 더한다.
location / {
	root /data/www;
}

location /images/ {
	root /data;
}


<br>
URI의 경로는 root 지침의 인자와 location 지침의 인자를 조합한 결과물과 대조된다. /data/images 블록을 보면 경로가 역순으로 되어 있는데(하위 디렉토리인 /images/ 가 상단에 있고 상위 디렉토리인 /data/가 하단에 있음) 이는 탐색의 효율성을 위해서이다.<br>
예를 들어 /data/www와 /data/images를 구별하는 것은 상위 디렉토리인 /data가 아니라 하위 디렉토리인 /www와 /images이다. 따라서 둘 중 /data/www를 탐색하는 경우 상위 디렉토리 -&gt; 하위 디렉토리 순으로 검색하는 것보다 하위 디렉토리 -&gt; 상위 디렉토리 순으로 검색하는 것이 빠를 것이다.<br>
따라서 configuration 파일에서는 하위 디렉토리를 location 지침의 인자로, 상위 디렉토리를 root 지침의 인자로 전달한다.<br>
참고로 configuration 파일은 인자의 길이가 긴 location 블록을 우선적으로 탐색한다.
<br>위 과정이 완료되면 위 설정 파일은 80 포트(nginx의 기본 포트이다)로 웹 서비스를 제공하라는 의미를 가지게 된다.<br>http://localhost/ 뒤에 /images/가 붙으면 /data/images/의 파일을 제공하게 된다.<br>
<br>ex. http://localhost/images/example.png 주소는 /data/images/example.png를 제공하라는 뜻
<br>/images/ 외의 다른 경로는 /data/www/의 파일을 제공하게 된다.<br>
<br>ex. http://localhost/images/some/example.html은 /data/www/some/example.html을 제공하라는 뜻
<br>
예상대로 작업이 수행되지 않는다면 access.log와 error.log 파일에 이유가 기록되어 있을 수 있다. 두 파일은 보통 /usr/local/nginx/logs나 /var/log/nginx에 위치해 있다.
<br><br>nginx의 주된 기능 중 하나는 프록시 서버를 구축하는 것이다. 프록시 서버란 클라이언트부터 요청을 받아 또다른 서버(보통 proxied 서버라 칭한다.)에게 그 요청을 전달해주는, 일종의 중개 역할을 하는 서버를 칭한다.<br>다음의 예제를 진행하여 단순한 프록시 서버를 만들어보자. 우리가 만들 프록시 서버는 이미지 파일 요청은 로컬 디렉토리에 있는 파일을 제공하고, 다른 요청은 proxied 서버로 전달해주는 기능을 한다.<br><a data-tooltip-position="top" aria-label="NGINX > ^0bc08f" data-href="NGINX#^0bc08f" href="project\42seoul\inception\nginx.html#^0bc08f" class="internal-link" target="_self" rel="noopener nofollow">정적 컨텐츠 제공하기</a>에서 만든 configuration 파일에 아래와 같은 서버 블록을 추가한다.<br>server {
	listen 8080;
	root /data/upl;

	location / {
	}
}
<br>
listen 지침은 해당 서버가 어느 포트를 사용해서 수신할 지를 명시한다. 만약 listen이 server 블록 내에 정의되지 않았다면, 기본 포트인 80포트를 사용하여 수신한다.
location / {}와 같이 location 지침 내부에 아무것도 지정이 안 되어 있을 경우, root /data/upl;와 같이 서버 블록이 독자적으로 root 지침을 보유한다.
<br>이제 본격적으로 proxy 서버 설정을 하는 부분을 configuration 파일에 추가해보자.<br>
<a data-tooltip-position="top" aria-label="NGINX > ^0bc08f" data-href="NGINX#^0bc08f" href="project\42seoul\inception\nginx.html#^0bc08f" class="internal-link" target="_self" rel="noopener nofollow">정적 컨텐츠 제공하기</a>에서 만들었던 server 블록을 아래와 같이 수정한다.<br>server {
	location / {
		proxy_pass http://localhost:8080;
	}

	location /images/ {
		root /data;
	}
}
<br>
proxy_pass 지침은 클라이언트의 요청을 전달할 proxied 서버의 server name과 포트 번호를 기재한다. 위 configuration 파일의 경우, http://localhost:8080이다.
<br>아까의 블록에서 location /images/ 블록을 아래와 같이 수정한다.<br>location ~ \.(gif|jpg|png)$ {
	root /data/images;
}
<br>
위 블록은 파일 중 gif, jpg, png 확장자를 가지는 파일만을 로컬의 /data/images 디렉토리로 매핑하겠다는 정규 표현식이다. 이러한 형태의 표현식은 반드시 ~기호로 시작해야 한다.<br>
nginx가 요청을 처리하기 위해 location 블록을 선택할 때, 먼저 접두사를 지정한 location 지시어를 확인하여 가장 긴 접두사를 기억하고, 그 다음에 정규 표현식을 확인한다. 정규 표현식이 일치하는 경우 nginx는 해당 location을 선택하고, 그렇지 않으면 이전에 기억된 location을 선택한다.
<br>server {
	location / {
		proxy_pass http://localhost:8080;
	}

	location ~ \.(gif/jpg/png)$ {
		root /data/images;
	}
}
<br>
즉 위 server 블록에서 요청을 처리하기 위한 location 블록을 선택할 때, gif, jpg, pnd 형식의 파일은 모두 로컬의 /data/images/ 디렉토리로 매핑되고, 그 외 요청은 localhost:8080 서버로 넘어간다.
<br><br>nginx는 FastCGI 서버로 통하는 경로를 요청하는 데 사용될 수도 있다. FastCGI 서버란 다양한 프레임워크와 프로그래밍 언어로 짜여진 응용 프로그램을 실행시켜 주는 서버이다.<br>FastCGI 서버로의 매핑을 요청하려면 fastcgi_pass 지침에 server_name:port의 형태로 인자를 전달해야 한다.<br>
PHP에서는 스크립트의 이름을 정의하기 위해 SCRIPT_FILENAME 인자가 필요하고, 요청 인자를 전달하기 위해 QUERY_STRING 인자가 필요하다.<br>결과적으로 다음과 같은 블록을 사용한다. <a data-tooltip-position="top" aria-label="NGINX > ^7fc5ba" data-href="NGINX#^7fc5ba" href="project\42seoul\inception\nginx.html#^7fc5ba" class="internal-link" target="_self" rel="noopener nofollow">간단한 프록시 서버 구축하기</a>에서 만든 configuration 파일에 다음 블록을 추가하여 보자.<br>server {
	listen 90;
    location / {
        fastcgi_pass  localhost:9000;
        fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;
        fastcgi_param QUERY_STRING    $query_string;
    }
}
<br>
위의 서버 블록은 90 포트로 들어오는 모든 요청을  localhost:9000에 위치한 FastCGI 서버로 전달해주는 역할을 한다.
<br><br>참고자료<br><a href=".?query=tag:참고링크\nginx_org" class="tag" target="_blank" rel="noopener nofollow">#참고링크/nginx_org</a> <br>]]></description><link>project\42seoul\inception\nginx.html</link><guid isPermaLink="false">project/42Seoul/inception/NGINX.md</guid><pubDate>Sat, 22 Mar 2025 07:43:56 GMT</pubDate></item><item><title><![CDATA[No title]]></title><description><![CDATA[<a class="tag" href="?query=tag:참고링크/php-fpm_org" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고링크/php-fpm_org</a> 
 <br><br><br>php fastcgi process manager<br><br>php-fpm은 다음의 특징을 가진 FastCGI(fast common gateway interface) 솔루션이다.<br>
<br>적응형 프로세스 생성
<br>기본 통계(아파치의 mod_status와 유사)
<br>우아한 종료/시작을 지원하는 향상된 프로세스 관리
<br>다른 uid/gid/chroot/environment 및 다른 php.ini로 작업자를 시작할 수 있는 기능(safe_mode를 대체)
<br>Stdout 및 stderr 로깅
<br>실수로 opcode 캐시가 파괴된 경우 긴급 재시작
<br>가속 업로드 지원
<br>"slowlog" 지원
<br>FastCGI에 추가된 fastcgi_finish_request() 기능은 시간이 많이 걸리는 작업(비디오 변환, 통계 처리 등)을 계속 진행하면서 요청을 완료하고 모든 데이터를 플러시하는 특수 기능입니다.
<br><br><a data-tooltip-position="top" aria-label="https://ko.wikipedia.org/wiki/%EA%B3%B5%EC%9A%A9_%EA%B2%8C%EC%9D%B4%ED%8A%B8%EC%9B%A8%EC%9D%B4_%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4" rel="noopener nofollow" class="external-link" href="https://ko.wikipedia.org/wiki/%EA%B3%B5%EC%9A%A9_%EA%B2%8C%EC%9D%B4%ED%8A%B8%EC%9B%A8%EC%9D%B4_%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4" target="_blank">위키백과</a><br>
<a data-tooltip-position="top" aria-label="https://www.ibm.com/docs/ko/i/7.5?topic=functionality-cgi" rel="noopener nofollow" class="external-link" href="https://www.ibm.com/docs/ko/i/7.5?topic=functionality-cgi" target="_blank">IBM 홈페이지</a><br><br>fastCGI는 Fast Common gate interface의 약자이다.<br><a data-tooltip-position="top" aria-label="https://ko.wikipedia.org/wiki/FastCGI" rel="noopener nofollow" class="external-link" href="https://ko.wikipedia.org/wiki/FastCGI" target="_blank">위키백과</a><br><br>참고자료<br><a href=".?query=tag:참고링크\php-fpm_org" class="tag" target="_blank" rel="noopener nofollow">#참고링크/php-fpm_org</a> <br>]]></description><link>project\42seoul\inception\php-fpm.html</link><guid isPermaLink="false">project/42Seoul/inception/php-fpm.md</guid><pubDate>Sat, 22 Mar 2025 07:43:56 GMT</pubDate></item><item><title><![CDATA[tls]]></title><description><![CDATA[ 
 <br><a data-tooltip-position="top" aria-label="https://www.cloudflare.com/ko-kr/learning/ssl/transport-layer-security-tls/" rel="noopener nofollow" class="external-link" href="https://www.cloudflare.com/ko-kr/learning/ssl/transport-layer-security-tls/" target="_blank">참고 링크</a>]]></description><link>project\42seoul\inception\tls.html</link><guid isPermaLink="false">project/42Seoul/inception/tls.md</guid><pubDate>Sat, 22 Mar 2025 07:43:56 GMT</pubDate></item><item><title><![CDATA[microshell 문제 번역]]></title><description><![CDATA[<a class="tag" href="?query=tag:42Seoul" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#42Seoul</a> 
 <br><br><a href=".?query=tag:42Seoul" class="tag" target="_blank" rel="noopener nofollow">#42Seoul</a> <br><br>Assignment name&nbsp; : microshell<br>
Expected files &nbsp; : microshell.c<br>
Allowed functions: malloc, free, write, close, fork, waitpid, signal, kill, exit, chdir, execve, dup, dup2, pipe, strcmp, strncmp<br>과제 이름 : microshell<br>
제출 파일 : microshell.c<br>
허용 함수 : malloc, free, write, close, fork, waitpid, signal, kill, exit, chdir, execve, dup, dup2, pipe, strcmp, strncmp<br>Write a program that will behave like executing a shell command<br>쉘 커맨드를 실행시키는 역할을 하는 프로그램을 작성하시오.<br>
<br>The command line to execute will be the arguments of this program
<br>실행시킬 명령문이 곧 프로그램의 매개인자입니다.<br>
<br>Executable's path will be absolute or relative but your program must not build a path (from the PATH variable for example)
<br>프로그램은 절대 경로와 상대 경로 둘 다 실행 가능하지만 경로를 직접 빌드해선 안됩니다(예를 들어, ls를 입력받았을때 PATH 변수와 조합해서 /bin/ls로 파싱하는 것과 같은 작업을 하지 말라는 뜻).<br>
<br>You must implement "|" and ";" like in bash
<br>당신은 파이프("|")와 세미콜론(";")을 bash 에서와 같이 동작하도록 구현하여야 합니다.<br>
<br>we will never try a "|" immediately followed or preceded by nothing or "|" or ";"
<br>우리는 파이프("|")의 앞과 뒤에 아무것도 없는 경우, 또는 파이프가 위치한 경우, 또는 세미콜론(";")이 위치한 경우를 시험하지 않습니다(syntax error 검사하지 않겠다는 뜻).<br>
<br>Your program must implement the built-in command cd only with a path as argument (no '-' or without parameters)
<br>당신은 빌트 인 커맨드로 cd를 구현해야 합니다. 단, 매개인자가 입력되지 않는 경우는 고려하지 않습니다.<br>
<br>if cd has the wrong number of argument your program should print in STDERR "error: cd: bad arguments" followed by a '\n'
<br>만약에 cd가 잘못된 개수의 매개인자를 받으면 당신의 프로그램은 STDERR로 "error: cd: bad arguments"에 개행을 붙힌 문자열을 출력해야 합니다.<br>
<br>if cd failed your program should print in STDERR "error: cd: cannot change directory to path_to_change" followed by a '\n' with path_to_change replaced by the argument to cd
<br>만약 cd에 잘못된 경로명을 입력하여 프로그램이 실패할 경우 STDERR로 "error: cd: cannot change directory to path_to_change"에 개행을 붙힌 문자열을 출력해야 합니다(path_to change는 cd가 입력받은 경로명으로 대체)<br>
<br>a cd command will never be immediately followed or preceded by a "|"
<br>cd 커맨드는 파이프라인과 같이 사용될 수 없습니다.<br>
<br>You don't need to manage any type of wildcards (*, ~ etc...)
<br>당신은 와일드카드(*, ~ 등등)을 구현할 필요가 없습니다.<br>
<br>You don't need to manage environment variables ($BLA ...)
<br>당신은 환경변수($BLA ... 등등)와 관련된 기능을 구현할 필요가 없습니다.<br>
<br>If a system call, except execve and chdir, returns an error your program should immediatly print "error: fatal" in STDERR followed by a '\n' and the program should exit
<br>execve와 chdir을 제외한 시스템 콜이 에러를 반환하면 프로그램은 즉시 STDERR로 "error: fatal"에 개행을 붙인 문자열을 출력하고 exit하여야 합니다.<br>
<br>If execve failed you should print "error: cannot execute executable_that_failed" in STDERR followed by a '\n' with executable_that_failed replaced with the path of the failed executable (It should be the first argument of execve)
<br>만약 execve가 fail한다면 STDERR로 "error: cannot execute executable_that_failed"에 개행을 붙힌 문자열을 출력해야 합니다(executable_that_failed는 execve가 입력받은 첫번째 매개인자로 대체해야 함).<br>
<br>Your program should be able to manage more than hundreds of "|" even if we limit the number of "open files" to less than 30.  
<br>프로그램은 백 단위의 파이프("|")와 30개 이하의 열린 파일들을 처리할 수 있어야 합니다.<br>for example this should work:<br>예를 들어 아래와 같은 명령문이 동작해야 합니다.<br>$&gt;./microshell /bin/ls "|" /usr/bin/grep microshell ";" /bin/echo i love my microshell<br>microshell<br>i love my microshell<br>$&gt;<br>Hints:<br>
Don't forget to pass the environment variable to execve<br>execve에 환경변수를 전달하는 것을 잊지 마세요.<br>Hints:<br>
Do not leak file descriptors!<br>fd의 누수는 허용하지 않습니다(파이프 잘 닫고 열린 파일 잘 닫으라는 뜻).]]></description><link>project\42seoul\microshell\microshell-문제-번역.html</link><guid isPermaLink="false">project/42Seoul/microshell/microshell 문제 번역.md</guid><pubDate>Sat, 22 Mar 2025 07:43:58 GMT</pubDate></item><item><title><![CDATA[mini_serv 억까 방지용 시트]]></title><description><![CDATA[<a class="tag" href="?query=tag:42Seoul" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#42Seoul</a> <a class="tag" href="?query=tag:network" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#network</a> <a class="tag" href="?query=tag:server" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#server</a> <a class="tag" href="?query=tag:socket_programming" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#socket_programming</a> 
 <br><br><a href=".?query=tag:42Seoul" class="tag" target="_blank" rel="noopener nofollow">#42Seoul</a> <a href=".?query=tag:network" class="tag" target="_blank" rel="noopener nofollow">#network</a> <a href=".?query=tag:server" class="tag" target="_blank" rel="noopener nofollow">#server</a> <a href=".?query=tag:socket_programming" class="tag" target="_blank" rel="noopener nofollow">#socket_programming</a> <br>micro_serv<br><br>Assignment name  : mini_serv<br>
과제 이름 : mini_serv<br>Expected files   : mini_serv.c<br>
제출할 파일 : mini_serv.c<br>Allowed functions: write, close, select, socket, accept, listen, send, recv, bind, strstr, malloc, realloc, free, calloc, bzero, atoi, sprintf, strlen, exit, strcpy, strcat, memset<br>
허용 함수는 위와 같습니다.<br><br>Write a program that will listen for client to connect on a certain port on 127.0.0.1 and will let clients to speak with each other.<br>
클라이언트들로 하여금 127.0.0.1 주소의 특정한 포트로 연결하여 서로 소통할 수 있게끔하는 프로그램을 만드세요.<br>This program will take as first argument the port to bind to.<br>
이 프로그램은 첫 번째 인자로 bind에 사용할 포트를 받습니다.<br>If no argument is given, it should write in stderr "Wrong number of arguments" followed by a \n and exit with status 1.<br>
만약에 아무런 인자도 주어지지 않는다면, 표준 에러로 "Wrong number of arguments"에 개행(\n)을 붙여 출력하고 exit status 1로 종료되어야 합니다.<br>If a System Calls returns an error before the program start accepting connection, it should write in stderr "Fatal error" followed by a \n and exit with status 1.<br>
만약에 시스템 콜이 연결이 완료되기 전에(accepting connection) 오류를 반환한다면, 표준 에러로 "Fatal error"에 개행(\n)을 붙여 출력하고 exit status 1로 종료되어야 합니다.<br>If you can't allocate memory it should write in stderr "Fatal error" followed by a \n and exit with status 1<br>
만약에 당신이 메모리를 할당할 수 없다면 표준 오류로 "Fatal error"에 개행(\n)을 붙여 출력하고 exit status 1로 종료되어야 합니다.<br>Your program must be non-blocking but client can be lazy and if they don't read your message you must NOT disconnect them...<br>
당신의 프로그램은 non-block으로 실행되어야 합니다. 하지만 클라이언트는 게으를 수 있으니 그들이 당신의 메시지를 읽지 않는다고 해서 연결을 끊어서는 안됩니다.<br>Your program must not contains #define preproc<br>
당신의 프로그램은 #define preproc을 포함해선 안됩니다.<br>Your program must only listen to 127.0.0.1.<br>
당신의 프로그램은 오직 127.0.0.1 주소로만 수신해야 합니다.<br>The fd that you will receive will already be set to make 'recv' or 'send' to block if select hasn't be called before calling them, but will not block otherwise.<br>
당신에게 주어지는 파일 디스크립터(fd)는 recv 또는 send를 위해 쓰일 것이고, select를 앞선 함수들을 호출하기 전에 호출하면 block을 방지할 수 있습니다.<br>
<br>
When a client connect to the server:<br>
<br>the client will be given an id. the first client will receive the id 0 and each new client will received the last client id + 1
<br>%d will be replace by this number
<br>a message is sent to all the client that was connected to the server: "server: client %d just arrived\n"<br>
클라이언트가 서버에 연결할 때:
<br>클라이언트는 id를 부여받습니다. 첫번째 클라이언트는 id 0을 부여받고 새로운 클라이언트는 그 직전 클라이언트의 id + 1을 id로 부여받습니다.
<br>%d는 이 id로 대체되어야 합니다.
<br>서버에 접속해 있던 모든 클라이언트에게 다음의 메세지를 보냅니다: "server: client %d just arrived\n"
<br>clients must be able to send messages to your program.<br>
<br>message will only be printable characters, no need to check
<br>a single message can contains multiple \n
<br>when the server receive a message, it must resend it to all the other client with "client %d: " before every line!
<br>클라이언트는 당신의 프로그램에 메시지를 전송할 수 있어야 합니다.<br>
<br>메시지는 출력 가능한(printable) 캐릭터로만 구성되며, 이를 체크할 필요는 없습니다(예외 처리할 필요 없다는 뜻).
<br>하나의 메시지는 여러 개의 개행(\n)을 포함할 수 있습니다.
<br>서버가 메시지를 수신할 때, 다른 모든 클라이언트에게 "client %d: "를 접두사로 붙여 해당 메시지를 broadcast해야 합니다.
<br>When a client disconnect from the server:<br>
<br>a message is sent to all the client that was connected to the server: "server: client %d just left\n"
<br>클라이언트가 서버와의 연결을 끊을 때:<br>
<br>서버에 연결되어 있는 모든 클라이언트에게 다음의 메시지를 보내야 합니다: "server: client %d just left\n"
<br>Memory or fd leaks are forbidden<br>
메모리나 fd의 누수는 용납되지 않습니다.<br>To help you, you will find the file main.c with the beginning of a server and maybe some useful functions. (Beware this file use forbidden functions or write things that must not be there in your final program)<br>
당신을 돕기위해서, 우리는 서버의 기초와 몇몇 유용한 함수를 포함하고 있는 main.c 파일을 준비했습니다(이 파일이 당신의 최종 프로그램에 포함되어서는 안될 금지 함수와 출력을 포함하고 있다는 사실에 유의하세요).<br>Warning our tester is expecting that you send the messages as fast as you can. Don't do un-necessary buffer.<br>
저희의 테스터기는 당신의 프로그램이 가능한 한 빠르게 메시지를 전송할 것을 가정한다는 사실에 유의하세요. 불필요하게 프로그램을 지연시키지 마세요.<br>Evaluation can be a bit longer than usual...<br>
평가는 평소보다 좀 더 오래 걸릴 수 있습니다...<br>Hint: you can use nc to test your program<br>
힌트: 당신은 테스트를 위해서 nc를 사용할 수 있습니다.<br>Hint: you should use nc to test your program<br>
힌트: 당신은 테스트를 위해서 nc를 사용해야만 합니다.<br>Hint: To test you can use fcntl(fd, F_SETFL, O_NONBLOCK) but use select and NEVER check EAGAIN (man 2 send)<br>
힌트: 테스트를 위해서 당신은 fcntl(fd, F_SETFL, O_NONBLOCK)을 사용할 수 있지만 select를 사용하여야 하며 절대 EAGAIN 옵션을 체크해서는 안됩니다.<br><br><br><br>이상이 exam 06 mini_serv의 subject 원본이다. 언뜻 보면 일반적인 echo 서버에 접두사(client : %d)를 붙이는 기능만 추가하면 되는 간단한 과제로 보인다. 하지만 불친절하기 짝이 없는 42 교육 과정의 exam답게 본 시험에는 숨겨진 조건이 존재한다. 사실 tcp의 특성을 알고 있는 사람이라면 다음과 같은 의문이 들 것이다.<br>
<br>tcp 프로토콜은 임의로 자신이 필요하다고 판단할 시(ex. 한 번에 송신하기에는 너무 대량의 데이터일 경우) 패킷을 분할하여 송신한다. 예를 들어 10000 바이트 길이의 데이터를 송신할 시 1000바이트씩 쪼개서 보내지는 것이 가능하다.
<br>데이터를 송신하는 쪽은 당연히 메시지가 온전히 보전되기를 바라고 송신할 것이다. 즉, 접두사(client : %d) 뒤의 데이터는 전송되기 전과 동일하기를 기대할 것이다.
<br>하지만 앞서 설명했듯이 패킷은 tcp 프로토콜에 의하여 임의로 분할될 수 있으므로 용량이 큰 메시지를 보낼 경우 높은 확률로 훼손된다. 분할된 메시지의 앞부분마다 접두사가 끼어들어 버리기 때문이다.
<br>// client 0이 매우 긴 메시지를 보내는 상황이라고 가정하자

보내는 메시지 : vvvveeeerrrryyyy lllloooonnnngggg mmmmssssgggg

// 전송자는 다음과 같이 메시지가 전송되기를 바랄 것이다.

client 0: vvvveeeerrrryyyy lllloooonnnngggg mmmmssssgggg

// 하지만 현실은 다음과 같을 확률이 높다.

client 0: vvvveeeerrrryyyy client 0: lllloooonnnngggg client 0: mmmmssssgggg 

<br>
<br>일반적인 echo 서버는 위와 같은 걱정을 할 필요가 없다. 왜냐하면 접두사를 붙여서 보내지 않기 때문이다. 클라이언트에서 패킷을 분할해서 보내도 보내는 대로 받아서 send back하면 그만이다. 하지만 접두사를 앞에 붙여서 보내야 한다는 조건이 추가되는 순간 이는 중대한 문제가 된다. 분할된 패킷 사이에 들어가는 접두사는 불순물로 전락해버린다. 접두사는 메시지의 맨 앞에 단 한 번만 들어가야 한다.
<br>이와 같은 문제를 해결하는 가장 간단한 방법은 구분자(delimeter, seperator)을 지정하는 것이다. 예를 들어 마침표(.)를 구분자로 지정했다고 가정해보자. 그러면 메시지가 분할되어 도착해도 구분자가 없음을 확인한 후 버퍼에 저장해두었다가, 구분자가 도착하면 합쳐서 한꺼번에 처리하는 방식이 가능할 것이다.
<br>// 메시지가 다음과 같이 분할되어 전송된다.

packet0: vvvveeeerrrryyyy
packet1: lllloooonnnngggg
packet2: mmmmssssgggg.

// 하지만 구분자(.)가 발견될 때까지 패킷은 전송되지 않고 버퍼에 저장된다.

buffer: vvvveeeerrrryyyy + lllloooonnnngggg + (waiting for '.' ....)

// 구분자가 도착하면 비로소 전송한다.

client 0: vvvveeeerrrryyyy lllloooonnnngggg mmmmssssgggg.

<br>
<br>그런데 subject에는 구분자가 무엇인지 명시되어 있지 않다.
<br>결론부터 말하자면, exam 06을 통과하기 위해선 구분자를 지정해야 한다. subject에 명시가 되어있지 않더라도 말이다. exam 06의 test case 08을 통과하기 위해서는 약 36만 바이트 길이의 메시지를 문제없이 echo 시킬 수 있어야 한다. 당연히 메시지는 분할되어서 들어올 것이고, 구분자를 지정하지 않으면 echo되는 메시지 사이사이에는 client: %d이 덕지덕지 붙어있을 것이다.<br>그나마 exam 06은 trace를 제공해주기 때문에, subject에 명시가 안되어 있는 구분자가 무엇인지 trace를 뜯어서 알아맞히는 식의 접근이 가능하다. 하지만 문제는 trace가 영어도 아니고 프랑스어로 되어있다는 점이다. 그리고 그렇게 자세히 나와있지도 않다. 따라서 사전 지식 없이 exam 06을 보는 사람은 높은 확률로 모르면 뒤져야지 당할 확률이 높다.<br>여러 삽질을 한 끝에 알아낸 결과<br>mini_serv는 개행(\n)을 구분자로 삼아 메시지를 처리해야 한다.<br>사실 subject 폴더에서 제공하는 main.c의 extract_message 함수에 개행을 기준으로 메시지를 추출하는 기능이 구현되어 있기 때문에 이게 힌트라면 힌트였던 셈이다.<br>즉, exam 06은 추가적으로 다음의 조건을 따라야 한다.<br>
<br>수신받은 메시지에 개행이 포함되어 있다면 그냥 평범하게 send back 하면 된다.
<br>수신받은 메시지에 개행이 포함되어 있지 않다면 버퍼에 저장해두었다가 나중에 구분자가 도착했을 때 합쳐서 보내야 한다. 따라서 클라이언트마다 별개로 버퍼가 존재해야 하고, 새로운 클라이언트가 서버에 접속할 때마다 버퍼도 새로 만들어야 한다.
<br>subject에는 이런 내용이 포함되어 있다.

<br>a single message can contains multiple \n
<br>하나의 메시지에는 여러 개의 개행(\n)이 포함될 수 있다.<br>
-&gt; 이러한 경우, 개행을 기준으로 서버가 메시지를 직접 분할하여 송신해야 한다.


<br><br>subject에는 다음과 같은 조건이 있다.<br>
<br>when the server receive a message, it must resend it to all the other client with "client %d: " before every line!
<br>서버가 메시지를 수신할 때, 다른 모든 클라이언트에게 "client %d: "를 접두사로 붙여 해당 메시지를 broadcast해야 합니다.
<br>위 문장에서 다른에 강조를 건 이유는, 자기 자신에게는 send back 하지 말아야 하기 때문이다.<br>예를 들어 서버에 클라이언트 1, 2, 3, 4, 5가 접속하고 있는 상황을 가정해보자.<br>
1이 보낸 메시지는 2, 3, 4, 5에게는 전달되어야 하지만, 메시지를 보낸 당사자인 1에게는 전달되지 말아야 한다.<br>참고로 이 조건은 클라이언트가 서버에 접속할 때 보내지는 메시지, 클라이언트가 연결을 해제했을 때의 메시지에도 해당한다.<br>즉, 클라이언트는 서버와 연결을 끊을 때 자기 자신의 left 메시지를 받지 못하며(사실 이건 당연하다), 서버에 접속했을 때 자기 자신의 arrive 메시지를 받지 못한다.<br><br>이 문서를 읽으시는 모든 분들은 저처럼 시간 낭비하지 마시고 1트에 mini_serv 통과하시길 바랍니다.]]></description><link>project\42seoul\mini_serv\mini_serv-억까-방지용-시트.html</link><guid isPermaLink="false">project/42Seoul/mini_serv/mini_serv 억까 방지용 시트.md</guid><pubDate>Sat, 22 Mar 2025 07:43:58 GMT</pubDate></item><item><title><![CDATA[메모장]]></title><description><![CDATA[<a class="tag" href="?query=tag:42Seoul" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#42Seoul</a> <a class="tag" href="?query=tag:graphics" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#graphics</a> <a class="tag" href="?query=tag:memo" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#memo</a> 
 <br><br><a href=".?query=tag:42Seoul" class="tag" target="_blank" rel="noopener nofollow">#42Seoul</a> <a href=".?query=tag:graphics" class="tag" target="_blank" rel="noopener nofollow">#graphics</a> <a href=".?query=tag:memo" class="tag" target="_blank" rel="noopener nofollow">#memo</a><br><br>minirt logic<br>
<br>원시 도형의 중점과 방향 벡터를 입력받는다.
<br>중점과 방향 벡터가 별도로 있으면 중점에는 이동 행렬을, 벡터에는 회전 행렬을 별도로 적용해야 한다. 그러면 행렬은 압축하여 연산량을 줄일 수 없으므로

<br>점 1(중점)과 점 2(중점 + 방향 벡터의 결과값)를 저장한다.
<br>2개의 점에 각각 압축된 행렬을 적용한다.
<br>점 2에서 점 1을 빼 방향 벡터를 복구한다.


<br>최적화

<br>도형이 절투체 바깥에 위치하는지 검사한다 -&gt; 안쪽에 위치하는 도형에만 별도로 태그


<br>투영 평면의 위치를 계산한다.
<br>카메라 -&gt; 투영 평면 방향으로, 스크린의 각 픽셀에 대응하는 위치로 광선을 발사한다.
<br>3-4에서 태그하였던 도형들과 광선의 충돌 테스트를 진행한다.(이 때, 벡터의 내적을 계산하여 충돌 지점이 카메라를 등지고 있는 경우는 배제한다.) 충돌하는 도형이 여러 개일 경우, 가장 충돌 거리가 가까운 지점을 계산에 사용한다.
<br>충돌 지점이 산출되면, 충돌한 도형의 종류를 고려하여 법선벡터를 산출한 후, 충돌 지점과 법선 벡터를 저장한다.
<br>충돌 지점과 광원을 잇는 선분의 방정식을 구한다.
<br>8에서 구한 선분과 존재하는 모든 도형과의 충돌 테스트를 진행한다. 만약 한 번이라도 충돌이 있으면 픽셀에 색상 가중치를 주지 않는다.
<br>충돌이 없다면, (광원의 위치 - 충돌 지점)인 벡터 l을 구한 후 정규화하여 7에서 저장한 법선 벡터와 내적하여 픽셀의 색상 가중치를 계산한다(diffuse reflection).
<br>벡터 l의 반사 벡터 r, 충돌 지점에서 카메라로 뻗어나가는 벡터 정규 벡터 v를 구한 후 내적하여 픽셀의 색상 가중치를 계산한다(specular reflection).
<br>존재하는 모든 광원에 대하여 8 ~ 11을 진행한다.
<br>모든 픽셀에 대하여 5 ~ 12을 진행한다.
]]></description><link>project\42seoul\minirt\메모장.html</link><guid isPermaLink="false">project/42Seoul/miniRT/메모장.md</guid><pubDate>Sat, 22 Mar 2025 07:44:00 GMT</pubDate></item><item><title><![CDATA[miniRT.pdf]]></title><description><![CDATA[<a class="tag" href="?query=tag:42Seoul" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#42Seoul</a> <a class="tag" href="?query=tag:graphics" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#graphics</a> 
 <br><br><a href=".?query=tag:42Seoul" class="tag" target="_blank" rel="noopener nofollow">#42Seoul</a> <a href=".?query=tag:graphics" class="tag" target="_blank" rel="noopener nofollow">#graphics</a><br>ray tracing<br><br><br>When it comes to rendering 3-dinemsional computer-generated images there are 2 possible approaches: "Rasterization", which is used by almost all graphic engines because of its efficiency and "Ray Tracing"<br>컴퓨터로 3차원 이미지를 렌더링하는 방식은 2가지가 있다. 첫번째는 효율성 때문에 대부분의 그래픽 엔진에 의해 사용되는 Rasterization이다. 두번째는 Ray Tracing이다.<br>The "Ray Tracing" method, developed for the first time in 1968 (but improved upon since) is even today more expensive in computation than the "Rasterization" method.<br>Ray Tracing 기법은 1968년에 처음 고안되었고, 큰 발전을 거듭했음에도 Rasterization 방법에 비해 훨신 많은 연산이 필요하다.<br>As a result, it is not yet fully adapted to real time use-cases but it produce a much higher degree of visual realism.<br>결과적으로, Ray Tracing은 실시간으로 무언가를 투영해야 하는 경우에는 아직 적합하지 않지만, 훨씬 시각적으로 사실적인 표현이 가능하다.<br>Before you can even begin to produce such high-quality grapics, you must master the basics: the miniRT is your first ray tracer coded in C, normed and humble but functional.<br>높은 품질의 그래픽을 구현하기 전에, 당신은 우선 기초를 숙달해야 한다: miniRT는 C 언어로 짜인 당신의 표준적이고, 소박하지만 기능적인 첫번째 광선 추적기가 될 것이다.<br>The main goal of miniRT is to prove to yourself that you can implement any mathematics or physics formulas without being a mathematician, we will only implement the most basic ray tracing features here so just keep calm, take a deep breath and don't panic! After this project you'll be able to show off nice-looking pictures to justify the number of hours you're spending at school...<br>miniRT 과제의 주목적은 수학 그리고 물리 공식을 구현할 수 있음을 스스로에게 증명하는 것이다. 우리는 가장 기초적인 Ray Tracing의 특징만을 구현할 것이므로 너무 겁먹지 말라. 이번 프로젝트가 끝나면 여러분이 얼마나 많은 시간을 노력했는지 증명할 멋진 이미지를 얻을 것이다.<br><br><br><br>The constraints are as follows:<br>다음의 제약을 따라야 한다.<br>You must use the miniLibX. Either the version that is available on the operatiing system, or from its sources. If you choose to work with the sources, you will need to apply the same rules for your libft as those written above in Common Instructions part.<br>반드시 miniLibX를 사용해야 한다. 운영체제에 설치되어 있는 버전을 써도 되고, 소스 파일을 다운받아 사용해도 된다. 만약 소스 파일을 다운받는다면, Common Instructions에 기술된 libft의 사용규칙을 그대로 적용해야 한다.<br>The management of your window must remain fluid: switching to another window, minimization, ect..<br>프로그램 창의 관리는 유동적이어야 한다: 다른 창으로의 전환, 최소화 등등이 적용되야 한다는 뜻.<br>When you change the resolution of the window, the content of the window must remain unchanged and be adjusted accordingly.<br>화면의 해상도를 바꿀 때, 화면의 구성은 그대로 유지한 채 보정만을 적용해야한다.<br>You need at least these 3 simple geometric objects: plane, sphere, cylinder.<br>적어도 3개의 간단한 기하학적 사물을 배치해야 한다: 평면, 구, 원기둥.<br>If applicable, all possible intersections and the inside of the object must be handled correctly.<br>사물 간의 중첩과 도형의 내부를 잘 제어할 수 있어야 한다.<br>Your program must be able to resize the object's unique properties: diameter for a sphere and the width and height for a cylinder.<br>사물의 크기 요소를 다시 설정할 수 있어야 한다: 원의 지름, 원기둥의 넓이 높이 등등.<br>Your program must be able to apply translation and rotation transformation to objects, lights and cameras (except for spheres and lights that cannot be rotated)<br>사물, 광원, 카메라의 이동과 회전을 구현해야 한다 (구와 회전이 적용될 수 없는 광원은 예외)<br>Light management: spot brightness, hard shodows, ambiance lighting (objects are never completely in the dark). You must implement Ambient and diffuse lighting.<br>광원 관리 : 점 광원 밝기, hard shadows(그림자의 경계가 명확하게 끊어지는 렌더링 기법), 환경광 Ambiance lighting(사물이 완전히 검게 물드는 부분이 없어야 함). 당신은 환경광과 난반사를 구현해야 한다.<br>The program displays the image in a window and respect the following rules:<br>
<br>Pressing Esc must close the window and quit the program cleanly.
<br>Clicking on the red cross on the window's frame must close the window and uit the program cleanly.
<br>The use of images of the minilibX is strongly recommanded.
<br>프로그램은 창에 이미지를 띄워야 하며 다음의 규칙을 따라야 한다.<br>
<br>Esc를 누르면 창이 닫히고 프로그램이 종료되어야 한다.
<br>창의 틀에 있는 빨간 십자 버튼을 누르면 창이 닫히고 프로그램이 종료되어야 한다.
<br>minilibX의 이미지를 사용하는 것이 강력하게 권장된다.
<br>Your program must take as a first argument a scene description fiie with the .rt extension.<br>
<br>Each type of element can be seperated by one or more line break(s).
<br>Each type of imformation from an element can be separated by one or more space(s).
<br>Each type of element cat be set in any order in the file.
<br>Elements which are defined by a capital letter can only be declared once in the scene.
<br>프로그램은 .rf 확장자를 가진, 장면을 정의하는 파일을 첫번째 인자로 받아야 한다.<br>
<br>각각의 요소는 하나 이상의 개행으로 분리되어야 한다.
<br>요소로부터 비롯된 각각의 속성은 하나 이상의 공백으로 분리되어야 한다.
<br>각각의 요소는 파일의 어떠한 위치에도 존재할 수 있다.
<br>대문자로 정의되는 요소들은 하나의 장면에 하나만 존재할 수 있다.
<br>Each element first’s information is the type identifier (composed by one or two character(s)), followed by all specific information for each object in a strict order such as:<br>요소의 첫번째 속성은 타입 정의자(하나 혹은 두 개의 문자로 구성된다)이며, 그 뒤의 속성들은 사물의 정보를 아래와 같이 구체적으로 명시해야 한다:<br><br>Ambient lightning:<br>A 0.2 255,255,255<br>
<br>identifier: A
<br>ambient lighting ratio in range [0.0, 1.0]: 0.2
<br>R,G,B colors in range [0-255]: 255, 255, 255
<br>환경광:<br>A 0.2 255,255,255<br>
<br>식별자: A
<br>환경광 비율([0.0, 1.0]의 범위를 가진다.): 0.2
<br>R,G,B 색상([0-255]의 범위를 가진다.): 255, 255, 255
<br><br>Camera:<br>C -50.0,0,20 0,0,1 70<br>
<br>identifier: C
<br>x,y,z coordinates of the view point: -50.0,0,20
<br>3d normalized orientation vector. In range [-1, 1] for each x,y,z axis: 0.0,0.0,1.0
<br>FOV : Horizontal field of view in degrees in range [0,180]: 70
<br>카메라:<br>C -50.0,0,20 0,0,1 70<br>
<br>식별자: C
<br>시점 veiw point의 x, y, z 좌표값 : -50.0, 0, 20
<br>정규화된 3차원 방향 벡터. x, y, z 축 모두 [-1, 1] 범위를 가진다.
<br>FOV : 수평 시야각. ([0, 180] 사이의 범위를 가지고 있다.) : 70
<br><br>Light:<br>L -40.0,50.0,0.0. 0.6  10,0,255<br>
<br>identifier: L 
<br>x,y,z coordinates of the light point: -40.0,50.0,0.0
<br>the light brightness ratio in range [0.0,1.0]: 0.6
<br>(unused in mandatory part)R,G,B colors in range [0-255]: 10, 0, 255
<br>광원:<br>L -40.0,50.0,0.0. 0.6  10,0,255<br>
<br>식별자: L
<br>광원의 x, y, z 좌표: -40.0,50.0,0.0
<br>빛의 밝기 비율. ([0.0,1.0]의 범위를 가짐): 0.6
<br>(mendatory part에서는 사용되지 않음)R,G,B 색상 ([0-255]의 범위를 가짐): 10, 0, 255
<br><br>Sphere:<br>sp 0.0,0.0,20.6 12.6 10,0,255<br>
<br>identifier: sp
<br>x,y,z coordinates of the sphere center: 0.0,0.0,20.6
<br>the sphere diameter: 12.6
<br>R,G,B colors in range [0-255]: 10, 0, 255
<br>구:<br>sp 0.0,0.0,20.6 12.6 10,0,255<br>
<br>식별자: sp
<br>구의 중심의 x, y, z 좌표: 0.0,0.0,20.6
<br>구의 지름: 12.6
<br>R,G,B 색상. ([0-255] 사이의 범위를 가짐.): 10, 0, 255
<br><br>Plane:<br>pl 0.0,0.0,-10.0 0.0,1.0,0.0 0,0,255<br>
<br>identifier: pl
<br>x,y,z coordinates of a point in the plane: 0.0,0.0,-10.0
<br>3d normalized normal vector. In range [-1,1] for each x,y,z axis: 0.0,1.0,0.0
<br>R,G,B colors in range [0-255]: 0,0,225
<br>평면:<br>pl 0.0,0.0,-10.0 0.0,1.0,0.0 0,0,255<br>
<br>식별자: pl
<br>x,y,z 평면의 중점 좌표: 0.0,0.0,-10.0
<br>정규화된 3차원 법선 벡터 (x,y,z 축 좌표의 값은 [-1,1] 범위를 가짐): 0.0,1.0,0.0
<br>R,G,B 색상 범위 : 0,0,225
<br><br>Cylinder:<br>cy 50.0,0.0,20.6 0.0,0.0,1.0 14.2 21.42 10,0,255<br>identifier: cy<br>
x,y,z coordinates of the center of the cylinder: 50.0,0.0,20.6<br>
3d normalized vector of axis of cylinder. In range [-1,1] for each x,y,z axis: 0.0,0.0,1.0<br>
the cylinder diameter: 14.2<br>
the cylinder height: 21.42<br>
R,G,B colors in range [0,255]: 10, 0, 255<br>원기둥: cy<br>
실린더 중심의 x,y,z 좌표값: 50.0,0.0,20.6<br>
실린더 축의 3차 정규화 벡터. x,y,z 축 모두 [-1,1] 범위: 0.0,0.0,1.0<br>
원기둥 지름: 14.2<br>
원기둥 높이: 21.42<br>
[0,255] 범위의 R,G,B 색상: 10, 0, 255<br><br><br>The Ray-Tracing technique could handle many more things like reflection, transparency, refraction, more complex objects, soft shadows, caustics, global illumination, bump mapping, .obj file rendering etc..<br>Ray-Tracing 기술은 반사, 투명도, 굴절, 더 복잡한 모양의 사물, 부드러운 그림자, 물결, 채색, 범프 매핑, 목적 파일 렌더링 등 더 복잡한 것들을 다룰 수 있다.<br>But for the miniRT project, we want to keep things simple for your first raytracer and your first steps in CGI.<br>하지만 miniRT 과제는 여러분의 첫번째 광선 추적기이자 컴퓨터 생성 화상 과제이므로, 최대한 단순함을 지키고 싶습니다.<br>So here is a list of few simple bonuses you could implement, if you want to do bigger bonuses we strongly advise you to recode a new ray-tracer later in your developer life after this little one is finished and fully functionnal.<br>그러므로 우리는 당신에게 단순한 보너스 목록 - 당신이 충분히 구현할 수 있을만한 - 을 제시합니다. 만약에 당신이 더 어려운 무언가를 구현하고 싶다면 우리는 우선 이 과제를 완전히 끝난 후에 새로운 광선 추적기를 만들면서 구현하기를 강력하게 권장합니다.<br>Bonus list:<br>보너스 목록:<br>
<br>
Add specular reflection to have a full Phong reflection model.

<br>
Color disruption: checkerboard.

<br>
Colored and multi-spot lights.

<br>
One other 2nd degree object: Cone, Hyperboloid, Paraboloid..

<br>
Handle bump map textures.

<br>
퐁 반사 모델을 완벽히 구현하기 위해 정반사를 추가할 것

<br>
색상 왜곡: 체커보드.

<br>
색상이 있고 여러 군데 존재하는 광원.

<br>
다른 2차 사물을 구현할 것: 원뿔, 쌍곡면, 포물면 등등

<br>
범프맵 텍스처를 다룰 것.

]]></description><link>project\42seoul\minirt\minirt.pdf.html</link><guid isPermaLink="false">project/42Seoul/miniRT/miniRT.pdf.md</guid><pubDate>Sat, 22 Mar 2025 07:44:00 GMT</pubDate></item><item><title><![CDATA[NetPractice]]></title><description><![CDATA[<a class="tag" href="?query=tag:42Seoul" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#42Seoul</a> <a class="tag" href="?query=tag:network" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#network</a> 
 <br><br><a href=".?query=tag:42Seoul" class="tag" target="_blank" rel="noopener nofollow">#42Seoul</a> <a href=".?query=tag:network" class="tag" target="_blank" rel="noopener nofollow">#network</a> <br>about IP addressing &amp; subnet masking<br><br><br><img alt="NetPractice_lv1_before.png" src="lib\media\netpractice_lv1_before.png"><br>
<br>A1과 D1의 IP 주소가 잘못되었다. IP 주소의 각 옥텟은 255를 넘을 수 없다.
<br>A1과 B1, C1과 D1의 네트워크 주소 부분이 서로 일치하지 않는다.
<br><br><img alt="NetPractice_lv2_before.png" src="lib\media\netpractice_lv2_before.png"><br>
<br>A1과 B1의 서브넷 마스크, 네트워크 주소가 서로 일치하지 않는다.
<br>C1과 D1 : 127은 스스로를 가리키는 특수 IP 주소이기 때문에 서로 통신하는 데 사용할 수 없다.
<br><img alt="NetPractice_lv2_after.png" src="lib\media\netpractice_lv2_after.png"><br><br><img alt="NetPractice_lv3_before.png" src="lib\media\netpractice_lv3_before.png"><br>
<br>같은 LAN 안의 IP 주소는 네트워크 주소와 서브넷 마스크가 모두 일치해야 한다.
<br><img alt="NetPractice_lv3_after.png" src="lib\media\netpractice_lv3_after.png"><br><br><img alt="NetPractice_lv4_before.png" src="lib\media\netpractice_lv4_before.png"><br>
<br>라우터 인터페이스 포함 같은 LAN 안의 IP 주소는 네트워크 주소와 서브넷 마스크가 모두 일치해야 한다.
<br>라우터의 인터페이스는 서로 중복되지 않아야 한다.
<br><img alt="NetPractice_lv4_after.png" src="lib\media\netpractice_lv4_after.png"><br><br><img alt="NetPractice_lv5_before.png" src="lib\media\netpractice_lv5_before.png"><br>
<br>라우터의 인터페이스는 서로 중복되지 않아야 한다.
<br>경로가 하나 밖에 없으면 디폴트 라우팅이 유리하다.
<br>당장 목적지로 가기 위한 경로를 모를 경우, 해당 경로의 정보를 가지고 있는 라우터로 전송하도록 정적 라우팅한다.
<br><br><img alt="NetPractice_lv6_before.png" src="lib\media\netpractice_lv6_before.png"><br>
<br>인터넷에서는 디폴트 라우팅을 사용할 수 없다.
<br>인테넷에서 라우트를 지정할 때, 사설 ip 주소를 destination으로 삼을 수 없다.
<br><img alt="NetPractice_lv6_after.png" src="lib\media\netpractice_lv6_after.png"><br><br><img alt="NetPractice_lv7_before.png" src="lib\media\netpractice_lv7_before.png"><br>
<br>라우터끼리 잇는 인터페이스는 서로 같은 네트워크에 속해야 한다.
<br><img alt="NetPractice_lv7_after.png" src="lib\media\netpractice_lv7_after.png"><br><br>이하의 문제는 상술한 개념들의 응용<br><br><br><img alt="NetPractice_lv8_before.png" src="lib\media\netpractice_lv8_before.png"><br><img alt="NetPractice_lv8_after.png" src="lib\media\netpractice_lv8_after.png"><br><br><img alt="NetPractice_lv9_before.png" src="lib\media\netpractice_lv9_before.png"><br><img alt="NetPractice_lv9_after.png" src="lib\media\netpractice_lv9_after.png"><br><br><img alt="NetPractice_lv10_before.png" src="lib\media\netpractice_lv10_before.png"><br><img alt="NetPractice_lv10_after.png" src="lib\media\netpractice_lv10_after.png">]]></description><link>project\42seoul\netpractice.html</link><guid isPermaLink="false">project/42Seoul/NetPractice.md</guid><pubDate>Sat, 22 Mar 2025 07:44:00 GMT</pubDate><enclosure url="lib\media\netpractice_lv1_before.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="lib\media\netpractice_lv1_before.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[그래프]]></title><description><![CDATA[<a class="tag" href="?query=tag:algorithm" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#algorithm</a> <a class="tag" href="?query=tag:graph" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#graph</a> 
 <br><br><a href=".?query=tag:algorithm" class="tag" target="_blank" rel="noopener nofollow">#algorithm</a> <a href=".?query=tag:graph" class="tag" target="_blank" rel="noopener nofollow">#graph</a><br>graph<br><br><br>그래프는 노드 vertex와 간선 edge을 이용한 비선형 데이터 구조이다. 보통 그래프는 데이터 간의 관계를 표현하는 데 사용한다. 데이터를 노드로, 노드 간의 관계나 흐름을 간선으로 표현한다.<br><br>그래프는 방향성 가중치, 순환 특성에 따라 종류를 구분할 수 있다.<br><br>간선은 방향을 가질 수도 있고 없을 수도 있다.<br>방향이 있는 간선을 포함하면 방향 그래프 directed graph, 방향이 없는 간선을 포함하면 무방향 그래프 undirected graph라고 한다.<br>이때 방향 그래프는 어느 한쪽으로만 간선이 있는 것이 아니라 서로 반대를 가리키는 간선이 있을 수 있다.<br><br>두 번째 특성은 가중치이다. 어떤 데이터는 흐름의 방향뿐 아니라 양도 중요할 수 있다. 그런 정도를 간선에 표현할 때 이를 가중치라고 한다.<br>가중치가 있는 그래프를 가중치 그래프 weight graph라고 한다.<br><br>마지막 특성은 순환이다. 순환은 특정 노드에서 시작해 간선을 따라 다시 돌아오는 경로가 있는 것을 말한다.<br>순환이 존재하는 그래프를 순환 그래프 cycle graph라 하고, 순환이 존재하지 않는 그래프를 비순환 그래프 acyclic graph라고 한다.<br><br>그래프의 구현 방식에는 인접 행렬 adjacency matrix과 인접 리스트 adjacency list가 있다.<br><br>인접 행렬은 이중 배열을 활용하여 구현하는 경우가 많다.<br>이때의 배열의 인덱스는 노드, 배열의 값은 노드의 가중치로 생각하고, 인덱스의 세로 방향을 출발 노드, 가로 방향을 도착 노드로 생각하면 자연스럽게 그래프를 표현할 수 있다.<br>예를 들어 아래의 그래프는<br>
서울(0) - 400(km) -&gt; 부산(1)

<br>다음과 같이 표현할 수 있다.<br><br><br>인접 리스트로 그래프를 표현하려면 우선 적절한 노드를 정의해야 한다. 정점(v), 가중치(w)를 묶어 관리한다.<br>인접 리스트 그래프 표현 방식은 다음과 같은 과정으로 동작한다.<br>
<br>우선은 노드 개수만큼 배열을 준비한다.
<br>배열의 인덱스는 각 시작 노드를 의미하며 배열의 값에는 해당 노드를 시작 노드로 하는 노드들을 추가한다. 이때, v가 도착 노드를 의미한다.
<br><br>참고자료<br><br>]]></description><link>resource\algorithm\그래프.html</link><guid isPermaLink="false">resource/Algorithm/그래프.md</guid><pubDate>Tue, 18 Mar 2025 07:02:40 GMT</pubDate></item><item><title><![CDATA[브루트 포스]]></title><description><![CDATA[<a class="tag" href="?query=tag:algorithm" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#algorithm</a> 
 <br><br><a href=".?query=tag:algorithm" class="tag" target="_blank" rel="noopener nofollow">#algorithm</a><br>brute force<br><br><br>brute : 짐승 같은, 난폭한<br>
force : 힘<br>즉  브루트 포스는 직역하자면 (정제되지 않은) 난폭한 힘, 폭력이라는 뜻이다.<br>브루트 포스의 실질적으로 가능한 모든 경우의 수를 시도하여 문제를 해결하는 방식을 칭하는 표현이다. 얼핏 보면 우격다짐 식으로 보여 이러한 명칭이 붙었지만, 컴퓨팅 파워가 충분하다면 가장 단순하면서도 확실한 방법이기도 하다.<br>원래는 보안 분야에서 유래한 표현이다. 예를 들어, 가능한 모든 경우의 수를 암호에 대입하여 보안 요소를 무력화하는 것을 브루트 포스 공격이라고 한다.<br>키 전수조사(exhaustive key search), 무차별 대입 공격이라 칭하기도 한다.<br><br>브루트 포스 방식은 문제의 복잡도(Complexity)에 매우 민감하다는 단점이 있다.<br>이 때문에 실제로 브루트 포스는 문제의 규모가 현재의 자원으로 충분히 커버가 가능한 경우에만 쓰이고, 대부분은 <a data-href="동적 계획법" href="동적 계획법" class="internal-link" target="_self" rel="noopener nofollow">동적 계획법</a> 등으로 많이 우회하는 편이다. 정확도를 조금 희생하더라도 어떻게든 '이론상 가능한' 자원으로 해결할 수 있게 알고리즘을 설계하기도 한다.]]></description><link>resource\algorithm\브루트-포스.html</link><guid isPermaLink="false">resource/Algorithm/브루트 포스.md</guid><pubDate>Thu, 06 Mar 2025 04:10:04 GMT</pubDate></item><item><title><![CDATA[데이터베이스란]]></title><description><![CDATA[<a class="tag" href="?query=tag:database" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#database</a> <a class="tag" href="?query=tag:참고링크/생활코딩" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고링크/생활코딩</a> 
 <br><br><a href=".?query=tag:database" class="tag" target="_blank" rel="noopener nofollow">#database</a><br>database<br><br><br><br>대규모의 데이터를 편리하게 저장, 관리, 열람할 수 있게 해주는 소프트웨어.<br><br><br>데이터베이스의 가장 본질적인 기능은 입력 Input과 출력 Output이다.<br>
입력 기능은 다시 생성 Create, 갱신 Update, 삭제 Delete으로 세분화할 수 있고 출력 기능은 읽기 Read 기능을 포함한다.<br>데이터베이스에서 가장 본질적인 이 네가지 기능을 통틀어 CRUD라고 한다.<br><br><br>굳이 공들여 데이터베이스를 공부해야하는 이유를 제시하기 위해선 사람들이 보편적으로 데이터를 관리하기 위해 사용하는 수단인 파일에 비교했을 때 데이터베이스가 확실한 강점을 보유하고 있어야 한다.<br>데이터베이스의 대표적인 장점으로 다음을 제시할 수 있다.<br>
<br>정보를 구조화하여 저장한다.

<br>예를 들어, 정보를 여러 개의 속성(ex. 주제, 제목, 내용, 작성자, 프로필 등등)으로 나누어 저장할 수 있고, 특정 속성을 기준으로 정렬할 수 있고, 특정 속성만 표시하거나 숨길 수 있고, 특정 속성의 값을 사용하여 검색하는 등의 일을 할 수 있다.


<br>프로그래밍 언어를 사용하여 이러한 작업을 자동화 할 수 있다.

<br>1의 작업을 사람이 수동으로 명령어를 입력하는 것이 아닌, 프로그래밍 언어를 사용하여 자동화 로직을 구성할 수 있다.


<br><br><br>주의 : 위 가이드는 2018년 기준으로 작성되었으므로 현 시류와 맞지 않는 부분이 있을 수 있습니다 (그런데 2024년 기준으로 검색해봐도 통계가 비슷한게 함정)<br><br>참고자료<br><a href=".?query=tag:참고링크\생활코딩" class="tag" target="_blank" rel="noopener nofollow">#참고링크/생활코딩</a> <br>]]></description><link>resource\database\데이터베이스.html</link><guid isPermaLink="false">resource/Database/데이터베이스.md</guid><pubDate>Sat, 22 Mar 2025 07:31:38 GMT</pubDate></item><item><title><![CDATA[MySQL]]></title><description><![CDATA[<a class="tag" href="?query=tag:database" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#database</a> <a class="tag" href="?query=tag:uncomplete" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#uncomplete</a> <a class="tag" href="?query=tag:참고링크/생활코딩" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고링크/생활코딩</a> 
 <br><br><a href=".?query=tag:database" class="tag" target="_blank" rel="noopener nofollow">#database</a> <a href=".?query=tag:uncomplete" class="tag" target="_blank" rel="noopener nofollow">#uncomplete</a><br>MySQL의 my는 개발자의 딸의 이름에서 유래한 것이다.<br><br>들어가기에 앞서<br>본 문서는 42 seoul의 프로젝트 inception의 해결을 위해 작성되었습니다. inception은 MariaDB 지식을 요구하고 아래에서 제시되는 자료들은 모두 MySQL을 기준으로 하나 MySQL의 커맨드는 대부분이 MaraiDB에서 호환되기 때문에 문제가 없다고 생각하여 첨부합니다.<br><br><br><br><a data-href="데이터베이스" href="resource\database\데이터베이스.html" class="internal-link" target="_self" rel="noopener nofollow">데이터베이스</a> 문서 참고.<br>
현 데이터베이스의 가장 보편적인 형식은 관계형 데이터베이스이며 데이터를 표의 형태로 관리하여 정렬, 검색, 표시 및 숨김 그 외에도 많은 기능들을 편리하게 사용할 수 있다.<br>MySQL의 가장 큰 장점은 무료이면서 관계형 데이터베이스의 핵심 기능들을 포함하고 있다는 것이다. 웹이 폭발적으로 성장하면서 웹 개발자들에게 선택받은 MySQL은 많은 수요를 확보하였다.<br><br><br>MySQL은 SQL이라는 언어를 사용해서 데이터를 조작할 수 있다.<br><br><a data-tooltip-position="top" aria-label="https://opentutorials.org/course/3161/19532" rel="noopener nofollow" class="external-link" href="https://opentutorials.org/course/3161/19532" target="_blank">다음 참고</a><br><br><br>MySQL은 3가지 구성요소로 되어 있다.<br>
<br>표 table : 정보가 저장되는 장소
<br>데이터베이스 database 또는 스키마 schema: 여러 개의 표들을 묶어 관리하는 단위
<br>데이터베이스 서버 database server : 여러 개의 스키마를 묶어 관리하는 단위
<br><br><br>데이터베이스의 효용<br>
<br>보안성이 좋다.

<br>자체적인 보안 체계를 가지고 있다.
<br>사용자 권한 설정을 할 수 있다.


<br>다음의 커맨드를 이용하여 서버에 접속한다.<br>./mysql -uroot -p<br><br>다음의 커맨드를 사용하여 서버와의 연결을 끊는다.<br>exit<br><br> <br>다음의 명령어를 사용하여 새로운 스키마를 만든다.<br>CREATE DATABASE &lt;만들고자 하는 스키마의 이름&gt;;<br>다음의 명령어를 사용하여 기존의 스키마를 삭제한다.<br>DROP DATABASE &lt;제거하고자 하는 스키마의 이름&gt;;<br>다음의 명령어를 사용하여 현재 있는 스키마들의 목록을 출력한다.<br>SHOW DATABASES;<br>다음의 명령어를 사용하여 MySQL에게 지금부터 작업할 스키마를 통지한다.<br>USE &lt;작업하고자 하는 스키마의 이름&gt;;<br><br><br>SQL은 Structured Query Language의 약자이다. 여기서 Query는 요청하다, 질의하다라는 뜻이다.<br>표 table은 열 colume과 행 row으로 이루어져 있다.<br><br><br><br>;을 붙이고 줄바꿈하면 해당 line이 실행되지만 그냥 줄바꿈하면 line이 실행되지 않고 계속 입력을 받는다 -&gt; 긴 line을 입력할 때 줄바꿈을 해가며 가독성 좋게 입력할 수 있다.<br>다음의 커맨드를 사용하여 새로운 열을 만든다.<br>CREATE TABLE topic(
	&lt;Field의 이름&gt; &lt;topic의 data type&gt;(&lt;얼만큼의 길이만큼 저장할 수 있는가&gt;) &lt;필드 공백의 허용 여부&gt;
);
<br>topic의 data type<br>
<a data-tooltip-position="top" aria-label="https://incodom.kr/DB_-_%EB%8D%B0%EC%9D%B4%ED%84%B0_%ED%83%80%EC%9E%85/MYSQL" rel="noopener nofollow" class="external-link" href="https://incodom.kr/DB_-_%EB%8D%B0%EC%9D%B4%ED%84%B0_%ED%83%80%EC%9E%85/MYSQL" target="_blank">다음 참고</a><br>필드 공백의 허용 여부란 무엇인가<br>
해당 열(Field)에 무조건 값이 들어가야 하는지, 아니면 비어있을 수 있는지를 설정하는 영역이다.<br>
<br>NOT NULL : 무조건 값을 대입하여야 한다.
<br>NULL : 비어있는 채로 둘 수 있다.
<br>AUTO_INCREMENT<br>
특정 열의 값을 위의 행의 공간 + 1로 자동으로 대입해주는 옵션<br>다음은 실행 가능한 구체적인 예이다.<br>CREATE TABLE topic(
	id INT(11) NOT NULL AUTO_INCREMENT,
	title VARCHAR(100) NOT NULL,
	description TEXT NULL,
	created DATETIME NOT NULL,
	author VARCHAR(30) NULL,
	profile VARCHAR(100) NULL,
	PRIMARY KEY(id)
);
<br>PRIMARY KEY(&lt;Field의 이름&gt;)<br>
<br>해당 열(Field)에서는 중복을 허용하지 않는다는 의미
<br>ERROR1820 (HY000)<br>MySQL에 처음 접속하면 기본적으로 유저마다 비밀번호를 자동으로 할당해주는데, 이 비밀번호를 갱신하지 않고 작업을 시도하면 ERROR1820 (HY000)을 맞게 된다.<br>아래의 커맨드를 사용하여 비밀번호를 갱신하여 해결할 수 있다.<br>SET PASSWORD = PASSWORD('&lt;갱신하고자 하는 새로운 비밀번호&gt;')<br><br>MySQL은 사용자로 하여금 정해진 포맷대로 데이터를 저장하도록 강제할 수 있다.<br><br><br><br><br>다음의 명령어를 통해 테이블의 구조를 볼 수 있다.<br>DESC &lt;구조를 보고자 하는 표의 이름&gt;;<br>다음의 명령어를 통해 표에 새로운 행을 입력할 수 있다.<br>INSERT INTO &lt;삽입하고자하는 table 이름&gt; (&lt;Field의 이름 입력, 이름 2, ..., 이름 n&gt;) VALUES(&lt;Field에 대응하는 값 입력, 값 2, ..., 값 n&gt;)<br><br><br>다음의 명령어를 통해 표를 출력할 수 있다.<br>SELECT &lt;option&gt; FROM &lt;출력하고자 하는 표의 이름&gt; WHERE &lt;field&gt;='&lt;value&gt;' ORDER BY &lt;field&gt; &lt;정렬 옵션&gt; LIMIT &lt;출력할 행 개수의 상한&gt;<br>
<br>option : 표에서 어떤 요소들을 노출할 것인지 설정한다.
<br><br>
<br>WHERE &lt;field&gt;='&lt;value&gt;' : 특정 field가 value인 행만 출력한다는 뜻
<br>ORDER BY &lt;field&gt; &lt;정렬 옵션&gt; : 특정 field를 기준으로 정렬. &lt;정렬 옵션&gt; 위치에 DESC(descending의 약자)가 오면 큰 값이 위로 가도록 정렬한다.
<br>LIMIT &lt;출력할 행 개수의 상한&gt; : 출력할 행의 개수를 제한하는 데에 사용한다.
<br><br><br>특정 행의 특정 필드를 수정하려면<br>UPDATE &lt;table 이름&gt; SET &lt;고치고자 하는 필드의 이름&gt;='&lt;수정할 내용&gt;', ... WHERE &lt;field&gt;=&lt;value&gt;<br>SET을 통해 고치고자 하는 필드의 이름(=열)을 설정하고 WHERE을 통해 고치고자 하는 행의 정보를 설정한다.<br>
WHERE을 빼먹어 행 정보를 제한하지 않으면 모든 행의 정보가 바뀌는 대참사가 일어나므로 꼭 WHERE을 포함하도록 하자.<br><br><br>특정 행을 삭제하려면<br>DELETE FROM &lt;삭제를 진행하고자 하는 table 이름&gt; WHERE &lt;field&gt;='&lt;value&gt;'<br>ex)<br> DELETE FROM topic WHERE id = 5<br>삭제 범위를 규정하는 WHERE 구문을 뺴먹으면 테이블의 모든 행이 삭제된다. 때와 상황에 따라서 인생이 바뀔 수도 있는 문제이니 매우 주의하도록 하자.<br><br><br><br><br><br><br><br><br><br><br>참고자료<br><a href=".?query=tag:참고링크\생활코딩" class="tag" target="_blank" rel="noopener nofollow">#참고링크/생활코딩</a> <br>]]></description><link>resource\database\mysql.html</link><guid isPermaLink="false">resource/Database/MySQL.md</guid><pubDate>Mon, 20 Jan 2025 07:29:41 GMT</pubDate></item><item><title><![CDATA[도커]]></title><description><![CDATA[<a class="tag" href="?query=tag:docker" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#docker</a> <a class="tag" href="?query=tag:참고도서/그림과_실습으로_배우는_도커_쿠버네티스" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/그림과_실습으로_배우는_도커_쿠버네티스</a> 
 <br><br><a href=".?query=tag:docker" class="tag" target="_blank" rel="noopener nofollow">#docker</a><br>virtual machine과 비슷하지만 좀 더 가볍다.<br><br>도커란 데이터 또는 프로그램을 격리시키는 기능을 하는 소프트웨어이다.<br><br><img alt="도커의 구조.jpeg" src="lib\media\도커의-구조.jpeg"><br>일반적인 도커의 구조.<br><img alt="윈도우에서의 도커의 구조.png" src="lib\media\윈도우에서의-도커의-구조.png" style="width: 700px; max-width: 100%;"><br>윈도우에서의 도커의 구조. 도커는 리눅스용으로 설계되었기 때문에, 윈도우용 도커 패키지에는 리눅스를 윈도우 상에 올리기 위한 하이퍼바이저와 가상 머신이 포함되어 있다. 즉, 윈도우 -&gt; (가상 머신 위의) 리눅스 -&gt; 도커 형식.<br><br><br>
<br>환경이 독립되어 있다.

<br>동일한 프로그램을 한 컴퓨터에 여러 개 설치, 실행할 수 있다 (일반적으로는 불가능).
<br>예를 들어 A 프로그램은 아파지 5.0 버전으로만 실행가능하고, B 프로그램은 아파치 8.0 버전으로만 실행 가능한 경우, 도커를 사용하면 서로 다른 컨테이너에 각각 5.0, 8.0 버전을 설치함으로서 간단하게 해결할 수 있다.
<br>프로그램 간의 충돌, 간섭을 예방할 수 있다.


<br>이미지를 만들 수 있다.

<br>그렇게 만든 <a data-href="이미지" href="resource\docker\이미지.html" class="internal-link" target="_self" rel="noopener nofollow">이미지</a>를 <a data-href="도커 허브" href="resource\docker\도커-허브.html" class="internal-link" target="_self" rel="noopener nofollow">도커 허브</a>에 올릴 수 있다( = 배포가 용이하다)
<br>반대로 도커 허브로부터 필요한 이미지를 쉽게 다운로드 받을 수도 있다.
<br>이미지를 통해 간단하게 컨테이너를 만들 수 있으므로 교체 및 업데이트가 용이하다.
<br>컨테이너를 자유자재로 옮길 수 있다 (정확히는 이미지의 형태로 컨테이너를 추출한 다음 해당 이미지를 기반으로 다른 환경에서 컨테이너를 복원할 수 있다).


<br>컨테이너에 '커널'을 포함시지 않으며, 운영체제의 주변 영역만을 포함한다.

<br>따라서 가볍다.
<br>또한 컨테이너에 올라가는 운영체제의 배포판을 자유자재로 바꿀 수 있다.


<br><br>
<br>리눅스 운영체제를 사용하는 것을 전제로 만들어졌기 때문에 리눅스용 소프트웨어 밖에 지원하지 않는다.
<br>물리 장치 하나에 여러 개의 컨테이너를 띄우는 형태이기 때문에 호스트 서버에 문제가 생기면 여러 컨테이너에 영향이 미친다. 따라서 물리 장치의 이상에 확실한 대책을 세워야 한다.
<br>애초에 컨테이너 여러 개를 사용하는 형태를 가정하여 만든 기술이므로 컨테이너 하나를 장시간에 걸쳐 사용할 때는 큰 장점을 느끼기 어렵다. 도커를 사용하려면 반드시 도커 엔진을 구동해야 하는데, 컨테이너를 하나밖에 사용하지 않으면 도커 엔진이 단순한 오버헤드에 지나지 않는다.
<br><br>
<br>리눅스에서 사용되는 것을 전제로 만들어졌기 때문에 리눅스 운영체제가 필요하다.
<br>따라서, 도커의 <a data-href="컨테이너" href="resource\docker\컨테이너.html" class="internal-link" target="_self" rel="noopener nofollow">컨테이너</a>에서 동작할 수 있는 프로그램도 리눅스용 프로그램으로 한정된다.
<br>본격적인 도커 사용법은 <a data-href="도커 명령어" href="resource\docker\도커-명령어.html" class="internal-link" target="_self" rel="noopener nofollow">도커 명령어</a>를 참고.<br><br>참고자료<br><a href=".?query=tag:참고도서\그림과_실습으로_배우는_도커_쿠버네티스" class="tag" target="_blank" rel="noopener nofollow">#참고도서/그림과_실습으로_배우는_도커_쿠버네티스</a> <br>]]></description><link>resource\docker\도커.html</link><guid isPermaLink="false">resource/Docker/도커.md</guid><pubDate>Fri, 20 Dec 2024 13:58:24 GMT</pubDate><enclosure url="lib\media\도커의-구조.jpeg" length="0" type="image/jpeg"/><content:encoded>&lt;figure&gt;&lt;img src="lib\media\도커의-구조.jpeg"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[도커 네트워크]]></title><description><![CDATA[<a class="tag" href="?query=tag:docker" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#docker</a> <a class="tag" href="?query=tag:참고도서/그림과_실습으로_배우는_도커_쿠버네티스" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/그림과_실습으로_배우는_도커_쿠버네티스</a> <a class="tag" href="?query=tag:참고도서/시작하세요_도커_쿠버네티스" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/시작하세요_도커_쿠버네티스</a> 
 <br><br><a href=".?query=tag:docker" class="tag" target="_blank" rel="noopener nofollow">#docker</a><br>docker network<br><br><a data-href="컨테이너" href="resource\docker\컨테이너.html" class="internal-link" target="_self" rel="noopener nofollow">컨테이너</a>를 다루다 보면 하나가 아닌 여러 개의 프로그램을 연동해 사용해야 하는 경우가 있다.<br>
예를 들어, 간단한 웹사이트를 만드는 데에도 워드프레스 + php 런타임 + apache + mysql 콤보가 필요하다.<br>
이러한 프로그램들을 하나의 컨테이너에 때려넣을 수도 있지만, 그러면 프로그램을 격리해 관리한다는 <a data-href="도커" href="resource\docker\도커.html" class="internal-link" target="_self" rel="noopener nofollow">도커</a>의 목적이 퇴색된다.<br>따라서 각각의 프로그램을 별도의 컨테이너에 보관하는 것이 바람직한데, 앞서 말했듯이 컨테이너는 격리되어 있기 때문에 프로그램 간 연동이 안된다는 문제가 있다.<br>컨테이너는 가상 ip 주소를 할당받는다. 컨테이너 안에서 ifconfig 명령어를 사용한 후 출력되는 목록 중에서 eth0(도커의 NAT IP) 부분이 컨테이너가 할당받은 가상 ip 주소이다.<br>따라서 이 가상 ip를 통해 접근하면 다른 컨테이너와 통신할 수 있다. 예를 들어, B 컨테이너의 ip가 172.17.0.3이라면 A 컨테이너는 이 ip를 써서 B 컨테이너에 접근할 수 있다. 그러나 도커 엔진은 컨테이너가 시작할 때마다 가상 ip를 재할당하므로 매번 변경되는 컨테이너의 ip로 접근하기는 어렵다.<br><br>--link 옵션은 컨테이너에 별명(alias)를 붙인 후 그 컨테이너에 ip가 아닌 별명으로 접근하게 해주는 설정이다. --link 옵션을 사용할 때 --link에 입력된 컨테이너가 실행 중이지 않거나 존재하지 않는다면 --link를 적용한 컨테이너 또한 실행할 수 없다는 점을 주의해야 한다.<br>이처럼 --link 옵션은 컨테이너 간에 이름으로 서로를 찾을 수 있게 도와주지만, 현재 deprecated 된 옵션이며 추후 삭제될 수 있다. 따라서 얌전히 후술할 도커 네트워크를 쓰는 편이 좋다.<br><br>도커는 컨테이너끼리 연결할 수 있는 가상 네트워크를 제공한다. 이를 도커 네트워크라고 한다.<br>토커는 컨테이너를 생성할 때마다 veth(virtual eth)라는 가상 네트워크 인터페이스를 생성한다. docker0이라는 브릿지는 각 veth 인터페이스와 바인딩되어 호스트의 eth0 인터페이스와 이어주는 역할을 한다. 즉, 컨테이너와 호스트의 네트워크는 아래의 그림과 같은 구조를 띈다.<br><img alt="도커 네트워크 구조.png" src="lib\media\도커-네트워크-구조.png"><br>아무런 설정을 하지 않고 컨테이너를 생성하면 컨테이너는 자동으로 docker0을 사용한다.<br>
docker0 브릿지 이외에도 사용자의 선택에 따라 여러 네트워크 드라이브를 사용할 수 있다.<br>
<br>브리지 bridge
<br>호스트 host
<br>논 none
<br>컨테이너 container
<br>오버레이 overlay
<br>사용자 정의 네트워크는 컨테이너에 유동적으로 연결하고 분리할 수 있다.<br>#분리
docker network disconnect &lt;네트워크 이름&gt; &lt;컨테이너 이름&gt;

#연결
docker network connect &lt;컨테이너 이름&gt; &lt;네트워크 이름&gt;
<br>네트워크의 서브넷, 게이트웨이, ip 할당 범위 등을 임의로 설정하려면 네트워크를 생성할 때 아래와 같이 --subnet, --ip-range, --gateway 옵션을 추가한다. 단, --subnet과 --ip-range는 같은 대역이여야 한다.<br>ex)<br>
docker network create --driver=&lt;network type&gt; --subnet=172.72.0.0/16 --ip-range=172.72.0.0/24 --gateway=172.72.0.1 &lt;network_name&gt;<br><br>브리지 네트워크는 docker0이 아닌 사용자 정의 브릿지를 새로 생성해 각 컨테이너에 연결하는 네트워크 구조이다.<br>컨테이너는 연결된 브릿지를 통해 외부와 통신할 수 있다.<br>
아래와 같은 명령어를 통해 생성한다.<br>docker network create --driver=&lt;네트워크 타입. 브리지 네트워크를 만들고 싶다면 bridge가 들어간다.&gt; &lt;만들고자 하는 네트워크 이름&gt;<br><br>docker run에 --net host 인자를 붙이면 컨테이너의 네트워크를 호스트로 설정할 수 있다.<br>네트워크를 호스트로 설정하면 호스트의 네트워크 환경을 그대로 쓸 수 있다.<br>
즉, 별도의 포트 포워딩 없이 외부와 통신할 수 있다.<br><br>docker run에 --net none 인자를 붙이면 컨테이너의 네트워크를 논으로 설정할 수 있다.<br>논 none은 말 그대로 아무런 네트워크를 쓰지 않는 것을 뜻한다. 논 네트워크로 컨테이너를 설정하면 해당 컨테이너는 외부와 단절된다. <br><br>docker run에 --net container:&lt;다른 컨테이너의 id&gt;와 인자를 붙이면 해당 컨테이너 네트워크의 네임스페이스 환경을 공유할 수 있다. 공유되는 속성은 내부 ip, 네트워크 인터페이스의 맥(MAC) 주소 등이다.<br><br>참고자료<br><a href=".?query=tag:참고도서\그림과_실습으로_배우는_도커_쿠버네티스" class="tag" target="_blank" rel="noopener nofollow">#참고도서/그림과_실습으로_배우는_도커_쿠버네티스</a><br>
<a href=".?query=tag:참고도서\시작하세요_도커_쿠버네티스" class="tag" target="_blank" rel="noopener nofollow">#참고도서/시작하세요_도커_쿠버네티스</a><br>]]></description><link>resource\docker\도커-네트워크.html</link><guid isPermaLink="false">resource/Docker/도커 네트워크.md</guid><pubDate>Fri, 20 Dec 2024 13:58:19 GMT</pubDate><enclosure url="lib\media\도커-네트워크-구조.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="lib\media\도커-네트워크-구조.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[도커 명령어]]></title><description><![CDATA[<a class="tag" href="?query=tag:docker" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#docker</a> <a class="tag" href="?query=tag:참고도서/그림과_실습으로_배우는_도커_쿠버네티스" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/그림과_실습으로_배우는_도커_쿠버네티스</a> <a class="tag" href="?query=tag:참고도서/시작하세요_도커_쿠버네티스" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/시작하세요_도커_쿠버네티스</a> 
 <br><br><a href=".?query=tag:docker" class="tag" target="_blank" rel="noopener nofollow">#docker</a><br>docker command는 상위 커맨드와 하위 커맨드로 이루어져 있다.<br><br><a data-href="도커" href="resource\docker\도커.html" class="internal-link" target="_self" rel="noopener nofollow">도커</a>는 도커 명령어를 사용하여 조작한다.<br>도커 명령어는 일반적으로 아래의 형식을 취한다.<br>docker &lt;상위 커맨드&gt;&lt;하위 커맨드&gt; &lt;옵션&gt; &lt;대상&gt; &lt;인자&gt;<br><br>상위 커맨드는 원칙적으로 삭제될 수 없으나 상위 커맨드가 container인 경우, 그리고 version 같은 특수한 커맨드를 사용하는 경우엔 예외로 한다.<br><br><br>
<br>대상이 id를 가지고 있을 경우, 대상의 이름 대신 id를 입력하여 커맨드를 입력할 수 있다. 보통 2~3 글자만 입력하여도 된다.
<br>아래 서술에서 옵션, 인자에 대한 설명이 없는 커맨드는 옵션, 인자를 거의 활용하지 않거나, 아예 없는 커맨드이다.
<br><br><br>컨테이너를 생성해 실행하는 커맨드이다. docker image pull, docker container create, docker container start의 기능을 하나로 합친 것과 같다. 현재 해당 이미지를 내려받은 상태가 아니라면 먼저 이미지를 내려받는다.<br>기본적으로 다음의 형식을 가진다.<br>docker run &lt;옵션&gt; &lt;대상 : 컨테이너를 만드는데 사용할 이미지의 이름&gt; &lt;인자&gt;<br><br>-d를 붙이지 않고 컨테이너를 실행하면 실행된 컨테이너가 프로그램의 실행을 마칠 때까지 터미널의 제어를 차지하므로 그다음 명령을 입력할 수 없는 상태가 된다.<br>
또한 -it 옵션을 붙이지 않으면 컨테이너 안의 파일 시스템에 접근할 수 없다.<br>

docker run = docker pull(이미지가 없을 때 한정) -&gt; docker create -&gt; docker start -&gt; docker attach(-it 옵션을 사용했을 때 한정)<br>
docker create = docker pull(이미지가 없을 때 한정) -&gt; docker create
<br><br>컨테이너의 목록을 출력하는 커맨드.<br>docker ps는 현재 실행 중인 컨테이너의 목록을 출력한다.<br>
docker ps -a는 모든 컨테이너의 목록을 출력한다.<br>
docker ps -q는 컨테이너의 id만을 출력한다. 이를 이용하여<br>docker stop $(docker ps -a -q)
docker rm $(docker ps -a -q)
<br>와 같이 모든 컨테이너를 정지 및 삭제할 수 있다.<br><br>호스트의 파일을 컨테이너에, 또는 컨테이너의 파일을 호스트에 복사하기 위하여 사용하는 명령어.<br>
아래와 같이 원본경로 복사할경로 순서로 인자를 기재하면 된다.<br>컨테이너로 파일을 복사하는 커맨드 사용 예(호스트 -&gt; 컨테이너)<br>
docker cp 호스트_경로 컨테이너_이름:컨테이너_경로<br>호스트로 파일을 복사하는 커맨드 사용 예(컨테이너 -&gt; 호스트)<br>
docker cp 컨테이너_이름:컨테이너_경로 호스트 경로<br><br>기존에 존재하는 컨테이너를 이미지로 변환.<br>
기존 컨테이너를 복제하거나 이동해야 할 때 편리하다.<br>docker commit &lt;컨테이너_이름&gt; &lt;새로운 이미지 이름&gt;<br><br>컨테이너의 내부로 들어가는 명령어. docker exec -it &lt;container id&gt; /bin/bash 명령어와 유사하다.<br>docker attach &lt;container_name&gt;<br>이 명령어의 반대로, ctrl + P, Q로 컨테이너에서 빠져나올 수 있다. exit과 달리 컨테이너를 정지시키지 않고 빠져나올 수 있다는 장점이 있다.<br><br><br><br><br><br>이미지를 대상으로 하는 명령어는 버전을 지정하지 않아도 아래와 같이 동작한다.<br>`docker run --name ubuntoCont -it ubuntu'<br>그러면 이미지의 최신 버전(latest tag)을 내려받는다.<br>
하지만 특정 버전을 사용해야 할 때도 있다. 그런 경우에는 아래와 같은 형식으로 버전을 지정할 수 있다.<br>image:image_version<br><br>docker image --filter "label=..."은 특정 <a data-tooltip-position="top" aria-label="Dockerfile > ^c135e6" data-href="Dockerfile#^c135e6" href="resource\docker\dockerfile.html#^c135e6" class="internal-link" target="_self" rel="noopener nofollow">라벨</a>만을 가진 이미지만들 출력한다.<br><br><br><br><br><br>build는 도커의 일반적인 명령어와 달리 상위 커맨드와 하위 커맨드의 구분이 존재하지 않는 독립된 특수한 명령어이다.<br><a data-href="Dockerfile" href="resource\docker\dockerfile.html" class="internal-link" target="_self" rel="noopener nofollow">Dockerfile</a>과 재료 파일들이 들어 있는 재료 폴더를 대상으로 사용해 새로운 이미지를 만드는 명령어이다.<br>docker build -t &lt;생성할 이미지 이름&gt; &lt;재료 폴더 경로&gt;<br>-t 인자는 생성할 이미지의 이름을 지정하기 위한 옵션이다.<br><br>참고자료<br><a href=".?query=tag:참고도서\그림과_실습으로_배우는_도커_쿠버네티스" class="tag" target="_blank" rel="noopener nofollow">#참고도서/그림과_실습으로_배우는_도커_쿠버네티스</a><br>
<a href=".?query=tag:참고도서\시작하세요_도커_쿠버네티스" class="tag" target="_blank" rel="noopener nofollow">#참고도서/시작하세요_도커_쿠버네티스</a> <br>]]></description><link>resource\docker\도커-명령어.html</link><guid isPermaLink="false">resource/Docker/도커 명령어.md</guid><pubDate>Fri, 20 Dec 2024 13:58:29 GMT</pubDate></item><item><title><![CDATA[도커 컴포즈]]></title><description><![CDATA[<a class="tag" href="?query=tag:docker" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#docker</a> 
 <br><br><a href=".?query=tag:docker" class="tag" target="_blank" rel="noopener nofollow">#docker</a><br>docker compose<br><br>도커 컴포즈는 다음과 같이 정의할 수 있다. <br>
<br>시스템 구축과 관련된 명령어를 하나의 텍스트 파일(정의 파일)에 기재해 명령어 한번에 시스템 전체를 실행하고 종료와 폐기까지 한 번에 하도록 도와주는 도구.
<br>시스템 구축에 필요한 설정을 YAML(YAML Ain't a Markup Language) 포맷으로 기재한 정의 파일을 이용해 전체 시스템을 일괄 실행(run) 또는 일괄 종료 및 삭제(down)할 수 있는 도구다.
<br>본래 도커 엔진과 별개의 프로그램으로 존재했지만(구버전. docker-compose로 실행) 도커 측에서 도커 엔진을 설치할 때 도커 컴포즈도 패키지로 같이 설치되도록 방침을 바꾸었다(신버전. docker compose로 실행). 따라서 별도의 파일을 설치할 필요는 없다.<br><br>컴포즈 파일의 이름은 미리 정해진 docker-compose.yml이라는 이름을 사용해야 한다.<br>정의 파일은 한 폴더에 하나만 있을 수 있다.<br><br>정의 파일은 YAML 형식을 따른다.<br>
정의 파일에는 services와 networks, volumes를 기재할 수 있다.<br>

도커 컴포즈에서는 컨테이너가 모인 것을 '서비스'라고 부른다.<br>
공식 참조 문서에서는 컨테이너와 서비스라는 두 가지 용어가 함께 사용되는데, 그냥 모두 컨테이너로 이해하면 되므로 큰 문제는 없다.
<br><br><br><br><br>
<br>depends_on : 은 다른 서비스에 대한 의존 관계를 나타낸다. 컨테이너를 생성하는 순서를 정의할 수 있다. 예를 들어, penguin 컨테이너의 정의에 
depends_on
  - namgeuk


<br>라는 내용이 포함되어 있다면 namgeuk 컨테이너를 생성한 다음에 penguin 컨테이너를 만든다.
<br>restart : 컨테이너 종료 시 재시작 여부를 설정한다.
<br>
restart 설정 옵션

<br><br><br><br>build 항목에 정의된 컨텍스트 디렉토리에서 이미지를 빌드해 서비스의 컨테이너를 생성하도록 설정한다. image 항목을 기재한다면, build한 이미지의 이름은 image 항목에 기재된 것이 된다. 만약 image 항목을 기재하지 않는다면, 이미지의 이름은 [프로젝트 이름]:[서비스 이름]이 된다.<br>또한 build 항목에서는 도커 파일에 사용될 컨텍스트나 도커 파일의 이름, 도커 파일에서 사용될 인자 값을 설정할 수 있다.<br>services:
  web:
    build: ./composetest
    context: ./composetest
    dockerfile: myDockerfile
    args:
      HOST_NAME: web
      HOST_CONFIG: self_config
<br><br><br><br>도커 컴포즈는 생성된 컨테이너를 위해 기본적으로 브리지 타입의 네트워크를 생성한다. 그러나 YAML 파일에서 driver 항목을 정의해 서비스의 컨테이너가 브리지 네트워크가 아닌 다른 네트워크를 사용하도록 설정할 수 있다. 특정 드라이버에 필요한 옵션은 하위 항목인 driver_ops로 전달할 수 있다.<br>다음 예제는 docker-compose up -d 명령어로 컨테이너를 생성할 때 mynetwork라는 overlay 타입의 네트워크도 함께 생성하고, myservice 서비스의 네트워크가 mynetwork 네트워크를 사용하도록 설정한다. 단, overlay 타입의 네트워크는 스웜 모드나 주키퍼를 사용하는 환경이어야만 생성할 수 있다.<br>services:
  myservice:
    image: nginx
    networks:
      - mynetwork
networks:
  mynetwork:
    driver: overlay
    driver_opts:
      subnet: "255.255.255.0"
      IPAdress: "10.0.0.2"
<br><br><br><br><br><br>도커 컴포즈는 YAML 파일에서 volume, volumes-from 옵션 등을 사용하면 프로젝트마다 볼륨을 생성한다. 이때 external 옵션을 설정하면 볼륨을 프로젝트를 생성할 때마다 매번 생성하지 않고 기존 볼륨을 사용하도록 설정한다.<br>다음 예제에서 myvolume이라는 이름의 외부 볼륨을 web서비스의 컨테이너에 마운트한다.<br>volumes:
  myvolume:
    external: true
<br><br>
services:
  mysql000ex11:
    image: mysql:5.7
    networks:
      - wordpress000net1
    volumes:
	  - mysql000vol11:/var/lib/mysql
	restart: always
	environment:
	  MYSQL_ROOT_PASSWORD: myrootpass
	  MYSQL_DATABASE: wordpress000db
	  MYSQL_USER: wordpress000kun
	  MYSQL_PASSWORD: kunpass
	wordpress000ex12:
	  depends_on:
	    - mysql000ex11
	  image: wordpress
	  networks:
	    - wordpress000net1
	  volumes:
	    - wordpress000vol12:/var/www/html
	  ports:
	    - 8080:80
	  restart: always
	  environment:
	    WORDPRESS_DB_HOST: mysql1000ex11
	    WORDPRESS_DB_NAME: wordpress000db
	    WORDPRESS_DB_USER: wordpress000kun
	    WORDPRESS_DB_PASSWORD: wkunpass
networks:
  wordpress000net1:
volumes:
  mysql000vol11:
  wordpress000vol12:

<br><br>모든 docker compose 커맨드는 docker compose로 시작한다.<br>현재 작업 디렉토리에 도커 컴포즈 파일이 있다면 그냥 사용한다.<br>
그렇지 않다면, -f 옵션으로 컴포즈 파일의 경로를 지정하여야 한다.<br>docker-compose -f &lt;도커 컴포즈 파일 경로&gt; command &lt;옵션 ...&gt;<br><br><a data-tooltip-position="top" aria-label="도커 명령어 > ^8a9da8" data-href="도커 명령어#^8a9da8" href="resource\docker\도커-명령어.html#^8a9da8" class="internal-link" target="_self" rel="noopener nofollow">docker run 커맨드</a>와 유사하다.<br>정의 파일에 기재된 내용대로 이미지를 내려받고 컨테이너를 생성 및 실행한다. 정의 파일에는 네트워크나 볼륨에 대한 정의도 기재할 수 있어서 주변 환경을 한꺼번에 생성할 수 있다.<br><br>docker compose up 명령어의 끝에 서비스의 이름을 입력해 docker-compose.yml 파일에 명시된 특정 서비스의 컨테이너만 생성할 수 있다.<br>docker compose up &lt;도커 컴포즈에서 정의된 서비스 이름&gt;<br><br>docker compose run 명령어로 컨테이너를 생성할 수도 있다. docker compose up과의 차이점은 Interactive 셸을 사용할 수 있다는 것이다.<br><br>정의 파일에 기재된 컨테이너와 네트워크를 정지 및 삭제한다. 볼륨과 이미지는 삭제하지 않는다. 컨테이너와 네트워크 삭제 없이 종료만 하고 싶다면 stop 커맨드를 사용한다.<br><br><br>정의 파일에 기재된 컨테이너를 정지한다.<br><br>docker-compose.yml 파일의 포맷이 적절한지 검사한다.<br>
기본적으로 현재 디렉토리의 docker-compose.yml 파일을 검사한다.<br>docker compose config<br>아래와 같이  검사할 파일의 경로를 설정할 수 있다.<br> docker compose -f &lt;yml 파일 경로&gt; config<br><br>도커 컴포즈 파일에 기재된 서비스를 여러 개 복제하는 명령어이다.<br>docker compose scale &lt;도커 컴포즈 파일에 명시된 서비스 이름&gt;=&lt;복제하고자 하는 개수&gt;<br>예를 들어 도커 컴포즈 파일에 mysql이라는 서비스가 정의되어 있다면, 다음의 명령어를 통해 mysql 컨테이너 4개를 한 번에 만들 수 있다.<br>docker compose scale mysql=4<br><br>YAML 파일에 네트워크 항목을 정의하지 않으면 도커 컴포즈는 프로젝트 별로 브리지 타입의 네트워크를 생성한다. 생성된 네트워크의 이름은 {프로젝트 이름}_default로 설정되며, docker compose up 명령어로 생성되고 docker-compose down 명령어로 삭제된다.<br>서비스 내의 컨테이너는 --net-alias가 서비스의 이름을 갖도록 자동으로 설정되므로 이 네트워크에 속한 컨테이너는 서비스의 이름으로 서비스 내의 컨테이너에 접근할 수 있다.<br>예를 들어, web 서비스와 mysql 서비스가 각기 존재할 때 web 서비스의 컨테이너가 mysql이라는 호스트 이름으로 접근하면 mysql이라는 호스트 이름으로 접근하면 mysql 서비스의 컨테이너 중 하나의 IP로 변환(resolve)되며, 컨테이너가 여러 개 존재할 경우 라운드 로빈으로 연결을 분산한다.<br><br>도커 컴포즈는 컨테이너를 프로젝트 및 서비스 단위로 구분하므로 컨테이너의 이름은 일반적으로 다음과 같은 형식으로 정해진다.<br>[프로젝트 이름]_[서비스 이름]_[서비스 내에서 컨테이너의 번호]<br>도커 컴포즈는 기본적으로 docker-compose.yml 파일이 위치한 디렉터리의 이름을 프로젝트 이름으로 사용한다. 하지만 다음과 같이 -p 옵션을 사용해 프로젝트의 이름을 명시하고 명령어를 적용할 대상(=프로젝트)를 지정할 수 있다<br>docker compose -p &lt;project_name&gt; &lt;cmd&gt; &lt;option&gt;<br>하나의 프로젝트는 여러 개의 서비스로 구성되고, 각 서비스는 여러 개의 컨테이너로 구성된다. 더 나아가, 하나의 서비스에는 컨테이너의 복사본 여러 개가 포함되어 있을 수 있으므로(ex. 서버 컨테이너를 여러 개 올려 부하를 분산한다던가) 차례대로 증가하는 컨테이너의 번호를 붙여 서비스 내의 컨테이너를 구별한다.<br>ubuntu_mysql_1, ubuntu_mysql_2, ..., ubuntu_mysql_n<br>컨테이너의 복제품을 만드는 방법은 앞선 <a data-tooltip-position="top" aria-label="도커 컴포즈 > ^c5d140" data-href="도커 컴포즈#^c5d140" href="resource\docker\도커-컴포즈.html#^c5d140" class="internal-link" target="_self" rel="noopener nofollow">도커 컴포즈 커맨드</a> 단락에 기술되어 있다.<br><br>참고자료<br>]]></description><link>resource\docker\도커-컴포즈.html</link><guid isPermaLink="false">resource/Docker/도커 컴포즈.md</guid><pubDate>Sat, 22 Mar 2025 07:31:39 GMT</pubDate></item><item><title><![CDATA[도커 허브]]></title><description><![CDATA[<a class="tag" href="?query=tag:docker" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#docker</a> <a class="tag" href="?query=tag:참고도서/그림과_실습으로_배우는_도커_쿠버네티스" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/그림과_실습으로_배우는_도커_쿠버네티스</a> 
 <br><br><a href=".?query=tag:docker" class="tag" target="_blank" rel="noopener nofollow">#docker</a><br>docker hub<br><br>도커 허브란 공식적으로 운영되는 도커 레지스트리(도커 이미지를 배포하는 서비스)의 이름이다.<br>
도커 허브에는 공개된 <a data-href="이미지" href="resource\docker\이미지.html" class="internal-link" target="_self" rel="noopener nofollow">이미지</a>들이 모여 있으며 이중에서 원하는 것을 다운로드 받을 수 있다.<br>
반대로 사용자가 자신이 만든 이미지를 도커 허브에 업로드하는 것도 가능하다.<br>도커 허브에 등록된 이미지는 공식 이미지와 그렇지 않은 이미지로 나뉜다.<br><br>도커에서 직접 배포하거나 해당 소프트웨어를 개발 및 관리하는 기업이나 조직에서 제공하는 이미지를 일컫는다.<br>
이미지 선택이 쉬우며 보안도 챙길 수 있다는 장점이 있다.<br>공식 이미지가 아니더라도 유용하고 안전한 이미지도 많지만 경험이 쌓이지 않으면 신중하게 이미지를 선택하는 것이 좋다.<br><br>참고자료<br><a href=".?query=tag:참고도서\그림과_실습으로_배우는_도커_쿠버네티스" class="tag" target="_blank" rel="noopener nofollow">#참고도서/그림과_실습으로_배우는_도커_쿠버네티스</a> <br>]]></description><link>resource\docker\도커-허브.html</link><guid isPermaLink="false">resource/Docker/도커 허브.md</guid><pubDate>Sat, 22 Mar 2025 07:31:39 GMT</pubDate></item><item><title><![CDATA[마운트]]></title><description><![CDATA[<a class="tag" href="?query=tag:docker" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#docker</a> <a class="tag" href="?query=tag:참고도서/그림과_실습으로_배우는_도커_쿠버네티스" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/그림과_실습으로_배우는_도커_쿠버네티스</a> <a class="tag" href="?query=tag:참고도서/시작하세요_도커_쿠버네티스" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/시작하세요_도커_쿠버네티스</a> 
 <br><br><a href=".?query=tag:docker" class="tag" target="_blank" rel="noopener nofollow">#docker</a><br>mount<br><br>마운트란 '연결하다'라는 의미 그대로 대상을 연결해 운영체제 또는 소프트웨어의 관리하에 두는 일을 말한다.<br><a data-href="컨테이너" href="resource\docker\컨테이너.html" class="internal-link" target="_self" rel="noopener nofollow">컨테이너</a>는 그 특성상 폐기가 빈번하고(<a data-tooltip-position="top" aria-label="컨테이너 > ^66906a" data-href="컨테이너#^66906a" href="resource\docker\컨테이너.html#^66906a" class="internal-link" target="_self" rel="noopener nofollow">컨테이너의 생애 주기 참고</a>), 폐기 시 내부 데이터도 함께 소멸하기 때문에 보존되어야 하는 데이터를 외부로 대피시켜야 한다는 번거로움이 있다.<br>이러한 문제를 해결하기 위해 도커는 컨테이너와 호스트의 스토리지에 마운트하는 기능을 제공한다.<br>보통 운영체제나 스택 같이 주기적으로 업데이트되는 부분은 컨테이너 형태로 만들어 변경 사항이 있을 때마다 최신 컨테이너로 갈아끼우고(<a data-tooltip-position="top" aria-label="컨테이너 > ^66906a" data-href="컨테이너#^66906a" href="resource\docker\컨테이너.html#^66906a" class="internal-link" target="_self" rel="noopener nofollow">컨테이너의 생애 주기 참고</a>) 사용자 정보 같은 보존되어야 하는 데이터는 마운트된 공간에 보존한다.<br>이를 데이터 퍼시스턴시 data persistency라고 한다.<br>도커의 마운트는 볼륨 마운트와 바인드 마운트로 나뉜다.<br><br><br>볼륨이란 스토리지의 한 영역을 분할한 것을 말한다.<br>도커에서는 <a data-tooltip-position="top" aria-label="도커 명령어" data-href="도커 명령어" href="resource\docker\도커-명령어.html" class="internal-link" target="_self" rel="noopener nofollow">docker volume 명령어</a>로 볼륨을 만들 수 있으며, 이렇게 만들어진 볼륨은 도커 엔진이 관리하는 영역 내에 만들어지게 된다. 볼륨 마운트란 도커가 관리하는 볼륨에 마운트하는 방식이다.<br>이름만으로 관리가 가능하므로 다루기 쉽지만 볼륨에 비해 직접 조작하기 어려우므로 '임시 목적의 사용'이나 '자주 쓰지는 않지만 지우면 안되는 파일'을 두는 목적으로 많이 사용한다.<br>
<br>
장점

<br>도커 엔지의 관리 하에 있으므로 사용자가 파일 위치를 신경 쓸 필요가 없다.
<br>운영체제에 따른 의존성 문제가 일어나지 않는다.


<br>
단점

<br>도커 컨테이너를 경유하지 않고 직접 볼륨에 접근할 방법이 없다.
<br>백업을 하기 위해 복잡한 절차가 필요하다.


<br><br>어느 마운트 방식을 사용하든 스토리지 마운트는 <a data-tooltip-position="top" aria-label="도커 명령어 > ^8a9da8" data-href="도커 명령어#^8a9da8" href="resource\docker\도커-명령어.html#^8a9da8" class="internal-link" target="_self" rel="noopener nofollow">run 커맨드</a>의 옵션 형태로 지정한다. 마운트하려는 스토리지의 경로가 컨테이너 속 특정 경로와 연결되도록 설정하는 형태이다.<br>볼륨 마운트의 경우 마운트와 동시에 볼륨을 만들 수도 있지만 이 방법은 권장하지 않는다. 마운트 전에 별도로 볼륨을 먼저 생성하는 것이 좋다.<br>구체적인 커맨드는 아래와 같다.<br>docker run (생략) -v &lt;볼륨 이름:컨테이너_마운트_경로&gt; (생략)<br>만약 -v 옵션을 입력할 때 -v /root와 같이 볼륨의 이름을 기입하지 않으면 컨테이너가 자동으로 생성한다.<br><br>상술했듯이 컨테이너를 거치지 않으면 볼륨을 확인할 수 있는 방법이 없다.<br>따라서 <a data-tooltip-position="top" aria-label="도커 명령어 > ^d619a1" data-href="도커 명령어#^d619a1" href="resource\docker\도커-명령어.html#^d619a1" class="internal-link" target="_self" rel="noopener nofollow">docker volume inspect</a>나 <a data-tooltip-position="top" aria-label="도커 명령어" data-href="도커 명령어" href="resource\docker\도커-명령어.html" class="internal-link" target="_self" rel="noopener nofollow">docker container inspect</a> 같이 간접적으로 확인하는 방법이 아닌, 직접적으로 볼륨 내부를 확인하고 싶다면 아래와 같은 절차를 거쳐야 한다.<br>
<br>해당 볼륨에 마운트된 컨테이너가 -it 옵션으로 실행되어 docker exec -it &lt;container_name&gt; /bin/bash로 외부에서 조작이 가능한 경우, 그 컨테이너를 통해 볼륨을 확인한다.
<br>그렇지 않다면, -it 옵션, linux 운영체제 이미지를 사용하여, 관찰하고자 하는 볼륨에 마운트하여 컨테이너를 새로 만든다. 그리고 해당 컨테이너에 docker exec -it &lt;container_name&gt; /bin/bash를 사용하여 볼륨을 확인할 수 있다.
<br><br>볼륨 자체를 복사하는 것은 불가능하다.<br>따라서 볼륨을 확인할 때처럼 별도의 리눅스 컨테이너를 연결하여 볼륨의 내용을 압축해 저장하여야 한다.<br>아래는 볼륨 백업 커맨드의 예시이다.<br>docker run --rm -v &lt;백업할 볼륨명:/source&gt; -v &lt;백업_저장_폴더명:/target&gt; busybox tar cvzf /target/ 백업파일이름.tar.gz -C /source<br>
<br>run 커맨드로 리눅스 운영체제(busybox) 컨테이너를 실행한다.
<br>--rm : 이 컨테이너는 실행 후 바로 삭제할 예정이므로 옵션에 --rm을 추가했다.
<br>-v &lt;백업할 볼륨명:/source&gt; : 백업할 볼륨을 컨테이너의 /source에 마운트한다.
<br>-v &lt;백업_저장_폴더명:/target&gt; : 압축된 백업 파일을 저장할 호스트의 디렉토리를 마운트한다.
<br>tar cvzf /target/백업파일이름.tar.gz -C /source

<br>tar은 tar 압축을 사용하는 명령어이다.
<br>czvf : 압축 옵션
<br>-C /source : 압축 대상을 /source로 지정
<br>/target/백업파일이름.tar.gz : 압축 결과물을 /target/의 백업파일이름.tar.gz 파일로 저장


<br><br>바인드 마운트는 도커가 설치된 컴퓨터의 문서 폴더 또는 바탕화면 폴더 등 도커에서 관리하지 않는 영역의 기존 디렉터리를 컨테이너에 마운트하는 방식이다. 디렉터리가 아닌 파일 단위로도 마운트가 가능하다.<br>폴더(디렉토리) 속에 파일을 직접 두거나 열어볼 수 있기 떄문에 자주 사용하는 파일을 두는 데 사용한다.<br>
<br>장점

<br>도커가 관리하지 않는 어디라도 파일을 둘 수 있다.
<br>기존과 동일한 방식으로 파일을 사용할 수 있으므로 다른 소프트웨어를 사용해 쉽게 편집할 수 있다.


<br><br>아래와 같은 커맨드로 사용한다.<br>docker run (생략) -v &lt;호스트의 마운트하고자하는 디렉토리 경로:컨테이너 마운트 경로&gt; (생략)<br><br>컨테이너를 생성할 때 --volumes-from 옵션을 설정하면 -v 또는 --volume 옵션을 적용한 컨테이너의 볼륨 디렉토리를 공유할 수 있다. 이는 직접 볼륨을 공유하는 것이 아닌 -v 옵션을 적용한 컨테이너를 통해 공유하는 것이다.<br>docker run -it --name &lt;볼륨을 공유받을 컨테이너의 이름&gt; --volumes-from &lt;볼륨을 공유해 줄 컨테이너의 이름&gt; &lt;image name&gt;<br><br>컨테이너 안의 파일이 마운트된 디렉토리로 복사되는 것이 아닌, 아예 같은 디렉토리로 처리된다는 점에 유의해야 한다.<br>-v 옵션에 존재하지 않는 호스트의 디렉토리를 전달하면 해당 디렉토리가 생성되며 컨테이너 상의 파일이 옮겨온다.<br>만약 호스트와 컨테이너 모두에 디렉토리가 존재하고 해당 컨테이너 안에 파일이 있다면 컨테이너의 디렉토리가 호스트의 디렉토리로 덮어씌워진다(즉, 호스트의 경로가 우선권을 가진다).<br><br>디스크가 아닌 주 메모리 영역을 마운트한다. 디스크보다 훨씬 빠른 속도로 읽고 쓰기가 가능하기 때문에 접근 속도를 높일 목적으로 사용하지만 도커 엔진이 정지되거나 호스트가 재부팅하면 소멸한다.<br><br>두 가지 마운트 방식의 차이점은<br>
<br>간단한지 복잡한지
<br>호스트 컴퓨터에서 파일을 다룰 필요가 있는지
<br>환경의 의존성을 배제해야 하는지
<br>이다.<br>보통 파일을 직접 편집해야 할 일이 많다면 바인드 마운트, 그렇지 않다면 볼륨 마운트를 사용한다.<br><br>스테이트리스 stateless : 컨테이너가 아닌 외부에 데이터를 저장하고 컨테이너는 그 데이터로 동작하도록 설계하는 것. 다르게 말하자면, 컨테이너 자체는 상태가 없고 상태를 결정하는 데이터는 외부로부터 제공받는다.<br>스테이트 풀 stateful : 컨테이너 자체가 데이터를 포함하고 있어 상태가 존재하는 경우<br><br>--mount 옵션은 -v 옵션을 대체하여 사용할 수 있는 옵션이다.<br>
<br>
볼륨 마운트의 경우<br>
docker run -it --name &lt;컨테이너의 이름&gt; --mount type=volume,source=&lt;볼륨의 이름&gt;,target=&lt;마운트할 컨테이너의 경로&gt; &lt;이미지 이름&gt;

<br>
바인드 마운트의 경우<br>
docker run -it --name &lt;컨테이너의 이름&gt; --mount type=bind,source=&lt;호스트의 디렉토리&gt;,target=&lt;마운트할 컨테이너의 경로&gt; &lt;이미지 이름&gt;

<br><br>참고자료<br><a href=".?query=tag:참고도서\그림과_실습으로_배우는_도커_쿠버네티스" class="tag" target="_blank" rel="noopener nofollow">#참고도서/그림과_실습으로_배우는_도커_쿠버네티스</a><br>
<a href=".?query=tag:참고도서\시작하세요_도커_쿠버네티스" class="tag" target="_blank" rel="noopener nofollow">#참고도서/시작하세요_도커_쿠버네티스</a> <br>]]></description><link>resource\docker\마운트.html</link><guid isPermaLink="false">resource/Docker/마운트.md</guid><pubDate>Sat, 22 Mar 2025 07:31:39 GMT</pubDate></item><item><title><![CDATA[이미지]]></title><description><![CDATA[<a class="tag" href="?query=tag:docker" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#docker</a> <a class="tag" href="?query=tag:참고도서/그림과_실습으로_배우는_도커_쿠버네티스" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/그림과_실습으로_배우는_도커_쿠버네티스</a> <a class="tag" href="?query=tag:참고도서/시작하세요_도커_쿠버네티스" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/시작하세요_도커_쿠버네티스</a> 
 <br><br><a href=".?query=tag:docker" class="tag" target="_blank" rel="noopener nofollow">#docker</a><br>container의 설계도<br><br><a data-href="도커" href="resource\docker\도커.html" class="internal-link" target="_self" rel="noopener nofollow">도커</a>의 <a data-href="컨테이너" href="resource\docker\컨테이너.html" class="internal-link" target="_self" rel="noopener nofollow">컨테이너</a>를 만들기 위해 사용되는 설정 파일이다. 이미지를 사용하면 컨테이너를 간편하게 만들 수 있기 때문에 배포에 용이하다.<br><a data-href="Dockerfile" href="resource\docker\dockerfile.html" class="internal-link" target="_self" rel="noopener nofollow">Dockerfile</a> 스크립트를 작성하고 이 스크립트를 빌드해 이미지를 직접 만들 수도 있다.<br>거꾸로, 컨테이너로부터 이미지를 추출할 수도 있다(<a data-tooltip-position="top" aria-label="도커 명령어 > ^1afd73" data-href="도커 명령어#^1afd73" href="resource\docker\도커-명령어.html#^1afd73" class="internal-link" target="_self" rel="noopener nofollow">도커 명령어의 commit 참조</a>). 이 방법을 사용하면<br>
<br>이미지로부터 컨테이너를 만듬 
<br>컨테이너에서 변경 사항을 적용
<br>해당 컨테이너로부터 이미지를 추출하면 이미지에도 변경사항이 적용
<br>따라서 변경 사항을 이미지의 형태로 편하게 배포 가능
<br>하다는 장점이 있다.<br><br>도커 이미지는 아래와 같은 구조를 가지고 있다.<br>&lt;저장소 이름&gt;/&lt;이미지 이름&gt;:&lt;태그&gt;<br>
<br>저장소(Repository) 이름 : 이미지가 저장된 장소. 저장소 이름이 명시되지 않은 이미지는 도커 허브의 공식 이미지를 뜻한다.
<br>이미지 이름 : 해당 이미지가 어떤 역할을 하는 지 나타낸다. 생략할 수 없다.
<br>태그 : 이미지의 버전 또는 리비전(Revision) 관리에 사용한다. 태그를 생략하면 도커 엔진은 이미지의 버전을 latest라고 인식한다.
<br><br>도커 이미지는 (직접 Dockerfile을 건드리거나 하지 않는다면) 수정이 불가능한 읽기 전용 레이어이다.<br>
반대로, 도커 컨테이너 레이어는 임의로 수정이 가능하다.<br>도커 컨테이너는 도커 이미지 레이어 위에 컨테이너 레이어가 올라간 구조이다.<br><br>참고자료<br><a href=".?query=tag:참고도서\그림과_실습으로_배우는_도커_쿠버네티스" class="tag" target="_blank" rel="noopener nofollow">#참고도서/그림과_실습으로_배우는_도커_쿠버네티스</a><br>
<a href=".?query=tag:참고도서\시작하세요_도커_쿠버네티스" class="tag" target="_blank" rel="noopener nofollow">#참고도서/시작하세요_도커_쿠버네티스</a><br>]]></description><link>resource\docker\이미지.html</link><guid isPermaLink="false">resource/Docker/이미지.md</guid><pubDate>Sat, 22 Mar 2025 07:31:39 GMT</pubDate></item><item><title><![CDATA[컨테이너]]></title><description><![CDATA[<a class="tag" href="?query=tag:docker" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#docker</a> <a class="tag" href="?query=tag:참고도서/그림과_실습으로_배우는_도커_쿠버네티스" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/그림과_실습으로_배우는_도커_쿠버네티스</a> 
 <br><br><a href=".?query=tag:docker" class="tag" target="_blank" rel="noopener nofollow">#docker</a><br>container<br><br><a data-href="도커" href="resource\docker\도커.html" class="internal-link" target="_self" rel="noopener nofollow">도커</a>에 의해 생성된 운영체제의 다른 영역과 독립된 공간.<br>
<a data-href="이미지" href="resource\docker\이미지.html" class="internal-link" target="_self" rel="noopener nofollow">이미지</a>를 통해 생성한다. 반대로, 기존의 컨테이너로부터 <a data-href="이미지" href="resource\docker\이미지.html" class="internal-link" target="_self" rel="noopener nofollow">이미지</a>를 추출할 수 있다. 이를 통해 변경사항을 빠르게 배포할 수 있다.<br><img alt="컨테이너의 구조.png" src="lib\media\컨테이너의-구조.png" style="width: 700px; max-width: 100%;"><br>운영체제는 커널 + 주변 영역의 구조로 이루어져 있는데, 컨테이너에는 주변 영역만 포함되고 커널은 호스트의 것을 빌려쓴다. 이를 통해 가벼움을 확보할 수 있다.<br>용량이 허용하는 한 컨테이너는 얼마든지 올릴 수 있다.<br><br>일반적으로 컨테이너는 한 번 생성한 것을 오랫동안 유지보수하기보다는, 오래된 컨테이너는 폐기하고 업데이트가 반영된 최신 이미지를 사용하여 새로운 컨테이너를 만들어 쓴다.<br>이는 애초에 도커가 여러 개의 컨테이너를 동시에 돌리는 상황을 가정하여 만들어졌기 때문으로, 이러한 상황에서는 업데이트 사항을 컨테이너 하나하나에 일일히 적용하기 보다는 새로운 컨테이너를 사용하는 방식이 비용이 적다.<br>이러한 컨테이너의 제작 -&gt; 실행 -&gt; 종료 -&gt; 폐기 -&gt; 제작 -&gt; ... 과정을 컨테이너의 생애 주기라 부른다.<br><br>컨테이너에 stop, start 등의 명령어를 사용할 때 도커 엔진은 해당 명령을 수행하기 위해 해당 컨테이너의 pid 1번에 signal을 전달한다. 컨테이너의 pid 1번 프로세스가 종료하면, 도커 엔진은 해당 컨테이너가 동작을 마친 것으로 간주하고 해당 컨테이너를 exited 상태로 만든다. 주의할 점은 도커는 foreground로만 동작하는 프로세스만 인식한다는 것이다. background로 ENTRYPOINT를 지정하면 해당 컨테이너가 즉각 종료되어 버릴 수 있다.<br>따라서 서버(ex. nginx) 같이 무한히 실행되어야 하는 프로세스의 경우, foreground로 실행시켜야 해당 서비스를 제공하는 컨테이너가 지속적인 생명력을 가질 수 있다.<br>본 문단은 chatgpt 발 정보이므로 오류가 있을 수 있습니다.<br><br>참고자료<br><a href=".?query=tag:참고도서\그림과_실습으로_배우는_도커_쿠버네티스" class="tag" target="_blank" rel="noopener nofollow">#참고도서/그림과_실습으로_배우는_도커_쿠버네티스</a> <br>]]></description><link>resource\docker\컨테이너.html</link><guid isPermaLink="false">resource/Docker/컨테이너.md</guid><pubDate>Sat, 22 Mar 2025 07:31:39 GMT</pubDate><enclosure url="lib\media\컨테이너의-구조.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="lib\media\컨테이너의-구조.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Dockerfile]]></title><description><![CDATA[<a class="tag" href="?query=tag:docker" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#docker</a> <a class="tag" href="?query=tag:uncomplete" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#uncomplete</a> <a class="tag" href="?query=tag:참고도서/그림과_실습으로_배우는_도커_쿠버네티스" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/그림과_실습으로_배우는_도커_쿠버네티스</a> <a class="tag" href="?query=tag:참고도서/시작하세요_도커_쿠버네티스" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/시작하세요_도커_쿠버네티스</a> 
 <br><br><a href=".?query=tag:docker" class="tag" target="_blank" rel="noopener nofollow">#docker</a> <a href=".?query=tag:uncomplete" class="tag" target="_blank" rel="noopener nofollow">#uncomplete</a> <br>Dockerfile<br><br>Dockerfile은 <a data-href="이미지" href="resource\docker\이미지.html" class="internal-link" target="_self" rel="noopener nofollow">이미지</a>를 직접 만들기 위한 설정 파일이다.<br>Dockerfile 스크립트에는 토대가 될 이미지나 실행할 명령어 등을 기재한다.<br>이 파일을 호스트 컴퓨터의 이미지 재료가 들어있는 폴더(위치는 어디라도 상관없다.)에 넣는다.<br>
재료 폴더에는 그 외 컨테이너에 넣을 파일을 함께 둔다. 실제 컨테이너를 만들 필요는 없다.<br><br><br>생성할 이미지의 베이스가 될 이미지를 뜻한다. FROM 명령어는 Dockderfile을 작성할 때 반드시 한 번 이상 입력해야 한다. 이미지 이름의 포맷은 docker run 명령어에서 이미지 이름을 사용했을 때와 같다. 사용하려는 이미지가 도커에 없다면 자동으로 pull 한다.<br><br>이미지를 생성한 개발자의 정보를 나타낸다. 일반적으로 Dockefile을 작성한 사람과 연락할 수 있는 메일 등을 입력한다. 단, MAINTAINER는 도커 1.13.0 버전 이후로 사용하지 않는다. 대신 아래와 같은 LABEL로 교체해 표현할 수 있다.<br>LABEL maintainer "alicek106 &lt;alicek106@naver.com&gt;"<br><br>이미지에 메타데이터를 추가한다. 메타데이터는 '키:값'의 형태로 저장되며, 여러 개의 메타데이터가 저장될 수 있다. 추가된 메다데이터는 docker inspect 명령어로 이미지의 정보를 구해서 확인할 수 있다.<br>docker images --filter "label=... <a data-tooltip-position="top" aria-label="도커 명령어 > ^2a04f8" data-href="도커 명령어#^2a04f8" href="resource\docker\도커-명령어.html#^2a04f8" class="internal-link" target="_self" rel="noopener nofollow">명령어</a>를 통해 특정 라벨만을 가지는 이미지를 출력할 수 있다.<br><br>이미지를 만들기 위해 컨테이너 내부에서 명령어를 실행한다. 주의할 사항으로, 이미지를 빌드할 때 별도의 입력을 받아야 하는 RUN이 있다면 build 명령어는 이를 오류로 간주하고 빌드를 종료한다.<br>RUN 명령어에 ["/bin/bash", "echo hello &gt;&gt; test2.html"]과 같이 입력하면 /bin/bash 셸을 이용해 echo hello &gt;&gt; test2.html을 실행한다. Dockerfile의 일부 명령어는 이저철 배열의 형태로 사용할 수 있다. RUN의 경우에는 다음과 같은 형태로 사용된다.<br>RUN ["실행 가능한 파일", "명령줄 인자 1", "명령줄 인자 2, ... ]<br>이는 JSON 배열의 입력 형식을 따르기 때문에 JSON 형식과 일치해야 한다. 단, JSON 배열 형태로 Dockerfile의 명령어를 사용하면 셸을 실행하지 않는다. 예를 들어, ["echo", "$MY_ENV"]는 $MY_ENV 환경변수를 사용하지 않는다. 이 형태로 셸을 사용하려면  ["sh", "-c", "echo $MY_ENV]와 같이 사용하는 것이 좋다.<br><br>파일을 이미지에 추가한다. 추가하는 파일은 Dockerfile이 위치한 디렉터리인 컨텍스트(Context)에서 가져온다.<br>ADD 명령어는 JSON 배열의 형태로 ["추가할 파일 이름", ... "컨테이너에 추가될 위치"]와 같이 사용할 수 있다. 추가할 파일명은 여러 개를 지정할 수 있으며 배열의 마지막 원소가 컨테이너에 추가될 위치이다.<br><br>COPY 또한 로컨 리렉터리에서 읽어들인 컨텍스트로부터 이미지에 파일을 복사하는 역할을 한다.<br>
COPY를 사용하는 형식은 ADD와 같다.<br>COPY test.html /home/
COPY ["test.html", "/home/"]
<br>ADD와 COPY의 차이점<br>COPY는 로컬의 파일만 이미지에 추가할 수 있지만 ADD는 외부 URL 및 tar 파일에서도 파일을 추가할 수 있다는 점에서 다르다.<br>즉, COPY의 기능이 ADD에 포함되는 셈이다.<br>
예를 들어, ADD 명령어는 다음과 같이 사용할 수 있다.<br>ADD https://raw.github...../test.html /home<br>또는 tar 파일을 추가할 수도 있다. 그러나 tar 파일을 그대로 추가하는 것이 아니라 tar 파일을 자동으로 해체해서 추가한다. 다음 명령어는 test.tar 파일을 이미지의 /home 디렉터리에 푼다.<br>ADD test.tar /home<br>그러나 ADD를 사용하는 것은 그다지 권장하지 않는다. 그 이유는 ADD로 URL이나 tar 파일을 추가할 경우 이미지에 정확히 어떤 파일이 추가될지 알 수 없기 때문이다. 그에 비애 COPY는 로컬 컨텍스트로부터 파일을 직접 추가하기 때문에 빌드 시점에서도 어떤 파일이 추가될지 명확하다.<br><br>명령어를 실행할 디렉터리를 나타낸다. 배시 셸에서 cd 명령어를 입력하는 것과 같은 기능을 한다. 예를 들어, WORKDIR /var/www/html이 실행되고 나서 RUN touch test를 실행하면 /var/www/html 디렉터리에 test 파일이 생성된다.<br><br>Dockerfile의 빌드로 생성된 이미지에서 노출할 포트를 설정한다. 그러나 EXPOSE를 설정한 이미지로 컨테이너를 생성했다고 해서 반드시 이 포트가 호스트의 포트와 바인딩되는 것은 아니며, 단지 컨테이너의 80번 포트를 사용할 것임을 나타내는 것 뿐이다. EXPOSE는 컨테이너를 생성하는 run 명령어에서 모든 노출된 컨테이너의 포트를 호스트에 퍼블리시(publish)하는 <a data-tooltip-position="top" aria-label="도커 명령어 > ^ec27f8" data-href="도커 명령어#^ec27f8" href="resource\docker\도커-명령어.html#^ec27f8" class="internal-link" target="_self" rel="noopener nofollow">-P 플래그</a>와 함께 사용된다.<br>Dockerfile을 작성하는 개발자로서는 EXPOSE를 이용해 이미지가 실제로 사용될 때 어떤 포트가 사용돼야 하는지 명시할 수 있으며, 이미지를 사용하는 입장에서는 컨테이너의 애플리케이션이 컨테이너 내부에서 어떤 포트를 사용하는지 알 수 있게 된다.<br><br>CMD는 컨테이너가 시작될 때마다 실행할 명령어(커맨드)를 설정하며, Dockerfile에서 한 번만 사용할 수 있다. Dockerfile에서 CMD를 명시함으로서 이미지에 apachectl -DFOREGROUND를 내장하면 컨테이너를 생성할 때 별도의 커맨드를 입력하지 않아도 이미지에 내장된 apachectl -DFOREGROUND가 적용되어 컨테이너가 시작될 때 자동으로 아파치 웹서버가 실행된다. 그리고 아파치 웹 서버는 하나의 터미널을 차지하는 포크라운드 모드로 실행되기 때문에 -d 옵션을 사용해 detached 모드로 컨테이너를 생성해야 한다.<br>즉 CMD는 run 명령어의 이미지 이름 뒤에 입력하는 커맨드와 같은 역할을 하지만 docker run 명령어에서 커맨드 명령줄 인자를 입력하면 Dockerfile에서 사용한 CMD의 명령어는 run의 커맨드로 덮어 쓰인다. 이와 마찬가지로 ubuntu:14.04 이미지에 기본적으로 내장된 커맨드인 /bin/bash 또한 Dockerfile의 CMD에 의해 덮어 씌인다.<br>CMD의 입력은 JSON 배열 형태인 ["실행 가능한 파일",  "명령줄 인자 1", "명령줄 인자 2" ...] 형태로도 사용할 수 있다.<br><br>ENTRYPOINT와 CMD의 차이점<br>entrypoint는 커맨드와 동일하게 컨테이너가 시작될 때 수행할 명령을 지정한다는 점에서 같다. 그러나 entrypoint는 커맨드를 인자로 받아 사용할 수 있는 스크립트의 역할을 할 수 있다는 점에서 다르다.<br>entrypoint가 설정되지 않았다면 cmd에 설정된 명령어를 그대로 실행하지만 entrypoint가 설정되었다면 cmd는 단지 entrypoint에 대한 인자의 기능을 한다.<br># # entrypoint: 없음, cmd: /bin/bash
# docker run -it --name no_entrypoint ubuntu:14.04 /bin/bash
-&gt; bash 쉘이 실행
<br># # entrypoint: echo, cmd: /bin/bash
# docker run -i -t --entrypoint="echo" --name yes_entrypoint ubuntu:14.04 /bin/bash
-&gt; /bin/bash가 출력. 즉, /bin/bash는 echo의 인자로 넘어감

<br><br>JSON 배열 형태가 아닌 CMD와 ENTRYPOINT를 사용하면 실제로 이미지를 생성할 때 cmd와 entrypoint에 /bin/sh -c가 앞에 추가된다.<br>따라서 CMD 또는 ENTRYPOINT에 설정하려는 명령어를 /bin/sh로 사용할 수 없다면 JSON 배열의 형태로 명령어를 설정해야 한다.<br># 예시

CMD echo tset
# -&gt; /bin/sh -c echo test

ENTRYPOINT /entrypoint.sh
# -&gt; /bin/sh -c /entrypoint.sh
<br>CMD와  ENTRYPOINT를 JSON 형태로 명령어를 입력하면 입력된 명령어가 그대로 이미지에서 사용된다.<br><br>Dockerfile에서 사용될 환경 변수를 지정한다. 설정한 환경변수는 ${ENV_NAME} 또는 $ENV_NAME의 형태로 사용할 수 있다. 이 환경변수는 Dockerfile 뿐 아니라 이미지에도 저장되므로 빌드된 이미지로 컨테이너를 생성하면 이 환경 변수를 사용할 수 있다.<br>run 명령어에서 -e 옵션을 사용해 같은 이름의 환경변수를 사용하면 기존의 값은 덮어씌어진다.<br>Dockerfile에서 환경변수의 값을 사용할 때 배시 셸에서 사용하는 것처럼 값이 설정되지 않는 경우와 설정된 경우를 구분해 사용할 수 있다.<br>쉘 상에서 ${env_name:-value}는 env_name이라는 환경변수의 값이 설정되지 않았으면 이 환경변수의 값을 value로 사용한다. 반대로 ${env_name:+value}는 env_name의 값이 설정돼 있으면 value를 값으로 사용하고, 값이 설정되지 않았다면 빈 문자열을 생성한다.<br><br>빌드된 이미지로 컨테이너를 생성했을 때 호스트와 공유할 컨테이너 내부의 디렉터리를 설정합니다. VOLUME ["/home/dir", "home/dir2"]처럼 JSON 배열의 형식으로 여러 개를 사용하거나 VOLUME /home/dir /home/dir2로도 사용할 수 있다.<br>VOLUME이 포함된 Dockerfile로 이미지를 빌드한 뒤 컨테이너를 생성하면 자동으로 볼륨이 생성된다.<br><br>build 명령어를 실행할 때 추가로 입력을 받아 Dockerfile 내에서 사용될 변수의 값을 설정한다. 다음 Dockefile은 build 명령어에서 my_arg와 my_arg_2라는 이름의 변수를 추가로 입력받을 것이라고 ARG를 통해 명시한다. ARG의 값은 기본적으로 build 명령어에서 입려받아야 하지만 다음의 my_arg_2와 같이 기본값을 지정할수도 있다.<br>FROM ubuntu:14.04
ARG my_arg
ARG my_arg_2=value2
RUN touch ${my_arg}/mytouch
<br><a data-tooltip-position="top" aria-label="도커 명령어 > ^fb817c" data-href="도커 명령어#^fb817c" href="resource\docker\도커-명령어.html#^fb817c" class="internal-link" target="_self" rel="noopener nofollow">build 명령어</a>를 실행할 때 --build-arg 옵션을 사용해 Dockerfile의 ARG에 값을 입력할 수 있다. 입력하는 형식은 &lt;키&gt;=&lt;값&gt;과 같이 쌍을 이뤄야 한다.<br># docker build --build0-arg my_arg=/home -t myarg:0.0 ./<br>ARG와 ENV의 값을 사용하는 방법은 ${}로 같으므로 Dockerfile에서 ARG로 설정한 변수를 ENV에서 같은 이름으로 다시 정의하면 --build-arg 옵션에서 설정하는 값은 ENV에 의해 덮어쓰여진다.<br>위의 Dockerfile 예제에서는 $(my_arg)의 디렉터리에 mytouch라는 파일을 생성했기 때문에 빌드된 이미지로 컨테이너를 생성해 확인하면 mytouch라는 이름의 파일을 확인할 수 있다.<br># docker run -it --name arg_test myarg:0.0
root@ccdlakjldj:/# ls /home/mytouch
/home/mytouch
<br><br>USER로 컨테이너 내에서 사용될 사용자 계정의 이름이나 UID를 설정하면 그 아래의 명령어는 해당 사용자 권한으로 실행된다. 일반적으로 RUN으로 사용자의 그룹과 계정을 생성한 뒤 사용한다. 루트 권한이 필요하지 않다면 USER를 사용하는 것을 권장한다.<br>RUN groupadd -r author &amp;&amp; useradd -r -g author alicek106
USER alicek106
<br>
기본적으로 컨테이너 내부에서는 root 사용자를 사용하도록 설정된다. 이는 컨테이너가 호스트의 root 권한을 가질 수 있다는 것을 의미하기 때문에 보안 측면에서 매우 바람직하지 않다. 예를 들어 root가 소유한 호스트의 디렉터리를 컨테이너에 공유했을 때, 컨테이너 내부에서는 공유된 root 소유의 디렉터리를 마음대로 조작할 수도 있다.<br>
때문에 컨테이너 애플리케이션을 최종적으로 배포할 때는 컨테이너 내부에서 새로운 사용자를 새롭게 생성해 사용하는 것을 권장한다. docker run 명령어 자체에서도 --user 옵션을 지원하지만, 가능하다면 이미지 자체에 root가 아닌 다른 사용자를 설정해놓는 것이 좋다.
<br><br><br><br><br><br><a data-tooltip-position="top" aria-label="도커 명령어 > ^fb817c" data-href="도커 명령어#^fb817c" href="resource\docker\도커-명령어.html#^fb817c" class="internal-link" target="_self" rel="noopener nofollow">이미지 빌드</a>를 시작하면 도커는 가장 먼저 빌드 컨텍스트를 읽어들인다. 빌드 컨텍스트는 이미지를 생성하는 데 필요한 각종 파일, 소스 코드, 메타 데이터 등을 담고 있는 디렉터리를 의미하며, Dockerfile이 위치한 디렉터리가 빌드 컨텍스트가 된다.<br>빌드 컨텍스트는 Dockerfile에서 빌드될 이미지에 파일을 추가할 때 사용된다. Dockerfile에서 이미지에 파일을 추가하는 방법은 앞에서 설명한 ADD 외에도 COPY가 있는데, 이 명령어들은 빌드 컨테스트의 파일을 이미지에 추가한다.<br>컨테스트에 대한 정보는 이미지를 빌드할 때 출력된 내용 중 맨 위에 위치한다.<br>컨텍스트는 build 명령어의 맨 마지막에 지정된 위치에 있는 파일을 전부 포함한다. 깃(Git)과 같은 외부 URL에서 Dockerfile을 읽어들인다면 해당 저장소(Repository)에 있는 파일과 서브 모듈을 포함한다.<br>따라서 Dockerfile이 위치한 곳에는 이미지 빌드에 필요한 파일만 있는 것이 바람직하다. 컨텍스트는 단순 파일 뿐 아니라 하위 디렉토리도 전부 포함하게 되므르 빌드에 불필요한 파일이 포함된다면 빌드 속도가 느려질 뿐더러 호스트의 메모리를 지나치게 점유할 수도 있다.<br><br>상기한 문제를 방지하기 위해 .dockerignore라는 파일을 작성할 수 있다. 이미지 빌드 시 .dockerignore에서 명시된 파일은 컨텍스트에서 제외된다.<br>.dockerignore 파일은 컨텍스트의 최상위 경로, 즉 build 명령어에서 맨 마지막에 오는 경로인 Dockerfile이 위치한 경로와 같은 곳에 위치해야 한다.<br>다음은 .dockerignore 파일의 예시이다.<br>test2.html
*.html
*/*.html
test.htm?
<br>컨텍스트에서 제외할 파일의 경로는 Dockerfile이 존재하는 경로를 기준으로 한다. 예를 들어, build 명령어에서 설정한 경로가 현재 디렉터리이고 /home/alicek106이라면 *.html은 /home/alicek106/*.html에 해당하는 모든 파일을 뜻한다.<br>test.htm?은 test.htm을 접두어로 두고 ? 자리에 임의의 1자리 문자가 들어가는 파일을 제외한다는 뜻이다. .dockerignore에 test.htm?을 지정하면 test.htma, test.htmb, ... 등이 컨텍스트에서 제외된다.<br>.dockerignore의 제외 목록에 해당하지만 특수한 파일만 포함하도록 설정하고 싶다면 !를 사용한다.<br>
!는 특정 파일을 제외하지 않음을 뜻한다. 다음 예시는 확장자가 html인 파일을 모두 제외하지만 test로 시작하는 html 파일은 컨텍스트에서 제외하지 않는다.<br>*.html
!test*.html
<br><br><br><br><br>참고자료<br><a href=".?query=tag:참고도서\그림과_실습으로_배우는_도커_쿠버네티스" class="tag" target="_blank" rel="noopener nofollow">#참고도서/그림과_실습으로_배우는_도커_쿠버네티스</a><br>
<a href=".?query=tag:참고도서\시작하세요_도커_쿠버네티스" class="tag" target="_blank" rel="noopener nofollow">#참고도서/시작하세요_도커_쿠버네티스</a><br>]]></description><link>resource\docker\dockerfile.html</link><guid isPermaLink="false">resource/Docker/Dockerfile.md</guid><pubDate>Sat, 22 Mar 2025 07:31:40 GMT</pubDate></item><item><title><![CDATA[가상 상속]]></title><description><![CDATA[<a class="tag" href="?query=tag:language/cpp" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#language/cpp</a> <a class="tag" href="?query=tag:참고도서/윤성우의_열혈_cpp_프로그래밍" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/윤성우의_열혈_cpp_프로그래밍</a> 
 <br><br><a href=".?query=tag:language\cpp" class="tag" target="_blank" rel="noopener nofollow">#language/cpp</a><br><br>
#include &lt;iostream&gt;
using namespace std;

class Base
{
	public :
		Base() { cout&lt;&lt;"Base Constructor"&lt;&lt;endl; }
		void SimpleFunc() { cout&lt;&lt;"BaseOne"&lt;&lt;endl; }
};

class MiddleDerivedOne : virtual public Base
{
	public :
		MiddleDerivedOne() : Base()
		{
			cout&lt;&lt;"MiddleDerivedOne Constructor"&lt;&lt;endl;
		}
		void MiddleFuncOne()
		{
			SimpleFunc();
			cout&lt;&lt;"MiddleDerivedOne"&lt;&lt;endl;
		}
};

class MiddleDerivedTwo : virtual public Base
{
	public :
		MiddleDerivedTwo() : Base()
		{
			cout&lt;&lt;"MiddleDerivedTwo Constructor"&lt;&lt;endl;
		}
		void MiddleFuncTwo()
		{
			SimpleFunc();
			cout&lt;&lt;"MiddleDerivedTwo"&lt;&lt;endl;
		}
};

class LastDerived : public MiddleDerivedOne, public MiddleDerivedTwo
{
	public :
		LastDerived() : MiddleDerivedOne(), MiddleDerivedTwo()
		{
			cout&lt;&lt;"LastDerived Constructor"&lt;&lt;endl;
		}
		void ComplexFunc()
		{
			MiddleFuncOne();
			MiddleFuncTwo();
			SimpleFunc();
		}
};

  

int main(void)
{
	cout&lt;&lt;"객체 생성 전 ..... "&lt;&lt;endl;
	
	LastDerived ldr;

	cout&lt;&lt;"객체 생성 후 ..... "&lt;&lt;endl;

	ldr.ComplexFunc();

	return (0);
}

<br><a data-href="다중 상속" href="resource\language\c++\다중-상속.html" class="internal-link" target="_self" rel="noopener nofollow">다중 상속</a>에서 하나의 클래스가 다른 클래스를 간접적으로 여러 번 상속받는 경우, 부모 클래스의 생성자, 소멸자를 여러 번 호출하며, 멤버 변수도 복제되어 여러 번 상속받는다는 문제가 존재한다.<br><a data-href="virtual 키워드" href="resource\language\c++\virtual-키워드.html" class="internal-link" target="_self" rel="noopener nofollow">virtual 키워드</a>를 사용하여 가상으로 클래스를 상속할 수 있으며, 가상 상속하면 생성자, 소멸자가 여러 번 호출되지 않으며, 멤버 변수도 복제되어 상속받지 않는다.<br><br>참고자료<br><a href=".?query=tag:참고도서\윤성우의_열혈_cpp_프로그래밍" class="tag" target="_blank" rel="noopener nofollow">#참고도서/윤성우의_열혈_cpp_프로그래밍</a><br>]]></description><link>resource\language\c++\가상-상속.html</link><guid isPermaLink="false">resource/Language/C++/가상 상속.md</guid><pubDate>Fri, 20 Dec 2024 13:55:24 GMT</pubDate></item><item><title><![CDATA[가상 소멸자]]></title><description><![CDATA[<a class="tag" href="?query=tag:language/cpp" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#language/cpp</a> <a class="tag" href="?query=tag:참고도서/윤성우의_열혈_cpp_프로그래밍" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/윤성우의_열혈_cpp_프로그래밍</a> 
 <br><br><a href=".?query=tag:language\cpp" class="tag" target="_blank" rel="noopener nofollow">#language/cpp</a><br>virtual destructor<br><br>자식 클래스 객체를 부모 포인터로 가리킬 경우, 부모 포인터에서 정의된 함수만 호출할 수 있다.1<br>
이는 소멸자의 경우에도 마찬가지여서, 자식 클래스의 소멸자가 호출되지 않아 할당 해제해야 할 멤버를 해체하지 못하는 등의 문제가 발생한다.<br><a data-href="virtual 키워드" href="resource\language\c++\virtual-키워드.html" class="internal-link" target="_self" rel="noopener nofollow">virtual 키워드</a>를 사용하여 소멸자를 가상 소멸자로 선언할 수 있으며, 부모 클래스가 가상 소멸자를 보유하고 있으면 자식 클래스의 소멸자들도 모두 가상 소멸자가 된다. 그리고 가상 소멸자가 호출되면, 상속의 계층 구조상 맨 아래에 존재하는 자식 클래스의 소멸자가 대신 호출되면서, 부모 클래스의 소멸자가 순차적으로 호출된다.<br><br>참고자료<br><a href=".?query=tag:참고도서\윤성우의_열혈_cpp_프로그래밍" class="tag" target="_blank" rel="noopener nofollow">#참고도서/윤성우의_열혈_cpp_프로그래밍</a><br><br>[^]: <a data-href="상속" href="resource\language\c++\상속.html" class="internal-link" target="_self" rel="noopener nofollow">상속</a> 참조]]></description><link>resource\language\c++\가상-소멸자.html</link><guid isPermaLink="false">resource/Language/C++/가상 소멸자.md</guid><pubDate>Fri, 20 Dec 2024 13:55:25 GMT</pubDate></item><item><title><![CDATA[가상 함수]]></title><description><![CDATA[<a class="tag" href="?query=tag:language/cpp" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#language/cpp</a> <a class="tag" href="?query=tag:참고도서/윤성우의_열혈_cpp_프로그래밍" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/윤성우의_열혈_cpp_프로그래밍</a> 
 <br><br><a href=".?query=tag:language\cpp" class="tag" target="_blank" rel="noopener nofollow">#language/cpp</a> <br>virtual function<br><br><br>부모 클래스 포인터는 자식 관계에 있는 클래스들의 객체를 가리킬 수 있지만, 이 경우 부모 클래스에서 정의된 함수만 호출할 수 있다. <a data-footref="1" href="about:blank#fn-1-d7709dc1a90a163e" class="footnote-link" target="_self" rel="noopener nofollow">[1]</a><br>
<a data-href="virtual 키워드" href="resource\language\c++\virtual-키워드.html" class="internal-link" target="_self" rel="noopener nofollow">virtual 키워드</a>를 사용하여  가상 함수를 선언함으로서 이러한 문제를 해결할 수 있다.<br>virtual 키워드는 다음과 같은 특징을 가진다.<br>
<br>가상 함수를 오버라이딩하는 함수는 자동으로 가상 함수가 된다 ( 하지만 코드의 명확성을 위해 virtual 키워드를 사용하여 명시하는 것이 좋다 ).
<br>가상 함수는 해당 함수 호출 시, 포인터의 자료형을 기반으로 호출 대상을 결정하지 않고 포인터의 변수가 실제로 가리키는 객체를 참조하여 호출의 대상을 결정한다.
<br>하나 이상의 가상 함수를 포함한 클래스를 'Polymorphic class'라고 한다.<br>가상 함수의 구체적인 작동 원리는 <a data-href="가상 함수 테이블" href="resource\language\c++\가상-함수-테이블.html" class="internal-link" target="_self" rel="noopener nofollow">가상 함수 테이블</a>을 참고하자.<br><br>클래스 중에서는 객체생성이 목적이 아닌, 순수히 상속을 목적으로 정의된 클래스도 존재한다.<br>
이러한 클래스를 객체로 선언하는 것은 바람직하지 않지만, 문법적으로는 아무런 이상이 없기 떄문에 고치기 쉽지 않다.<br>가상 함수를 순수 가상 함수로 선언하면 이러한 객체의 생성을 문법적으로 막을 수 있다.<br>순수 가상 함수란 함수의 몸체가 정의되어 있지 않은 함수를 의미한다. 이를 표현하기 위해서 함수의 몸체를 작성하지 않고 그 자리에 '0의 대입'을 표시한다.<br>
virtual int GetPay() const = 0;

<br>순수 가상 함수는 아래와 같은 이점을 가진다.<br>
<br>순수 가상 함수를 가진 클래스는 완전하지 않은 클래스로 간주되기 떄문에 객체를 생성하려 하면 컴파일 에러가 발생한다. 이를 이용해 잘못된 객체의 생성을 문법적으로 막는다.
<br>순수히 상속만을 위한 클래스가 존재하는 것처럼, 함수를 순수 가상 함수로 선언함으로서 순수히 오버라이딩만을 위한 함수를 만들 수 있다.
<br>하나 이상의 멤버 함수를 순수 가상 함수로 선언한 클래스를 가리켜 <a data-href="추상 클래스" href="resource\language\c++\추상-클래스.html" class="internal-link" target="_self" rel="noopener nofollow">추상 클래스</a>라 한다.<br><br>참고자료<br><a href=".?query=tag:참고도서\윤성우의_열혈_cpp_프로그래밍" class="tag" target="_blank" rel="noopener nofollow">#참고도서/윤성우의_열혈_cpp_프로그래밍</a><br><br><br>
<br>
<br><a data-href="상속" href="resource\language\c++\상속.html" class="internal-link" target="_self" rel="noopener nofollow">상속</a> 문서를 참고할 것.<a href="about:blank#fnref-1-d7709dc1a90a163e" class="footnote-backref footnote-link" target="_self" rel="noopener nofollow">↩︎</a>
]]></description><link>resource\language\c++\가상-함수.html</link><guid isPermaLink="false">resource/Language/C++/가상 함수.md</guid><pubDate>Fri, 20 Dec 2024 13:55:28 GMT</pubDate></item><item><title><![CDATA[가상 함수 테이블]]></title><description><![CDATA[<a class="tag" href="?query=tag:language/cpp" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#language/cpp</a> <a class="tag" href="?query=tag:참고도서/윤성우의_열혈_cpp_프로그래밍" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/윤성우의_열혈_cpp_프로그래밍</a> 
 <br><br><a href=".?query=tag:language\cpp" class="tag" target="_blank" rel="noopener nofollow">#language/cpp</a><br>virtual function table<br><br>본 문서는 가상 함수의 구체적인 작동 방법에 관하여 다룬다.<br>한 개 이상의 가상 함수를 포함하는 클래스에 대해서는 컴파일러가 다음 그림과 같은 형태의 가상 함수 테이블이라는 것을 만든다. 간단히 'V-Table(Virtual Table)'이라고도 하는데, 이는 실제 호출되어야 할 함수의 위치 정보를 담고 있는 테이블이다.<br>클래스의 객체가 생성되면 객체는 클래스의 가상 함수를 참조할 수 있는 주소 값을 저장한다. <br>
#include &lt;iostream&gt;
using namespace std;

class AAA
{
	private :
		int num;
	public :
		virtual void Func1() { cout&lt;&lt;"Func1"&lt;&lt;endl; }
		virtual void Func2() { cout&lt;&lt;"Func2"&lt;&lt;endl; }
};

class BBB : public AAA
{
	private :
		int num2;
	public :
		virtual void Func1() { cout&lt;&lt;"BBB::Func1"&lt;&lt;endl; }
		void Func3() { cout&lt;&lt;"Func3"&lt;&lt;endl; }
};

int main(void)
{
	AAA *aptr = new AAA();
	aptr-&gt;Func1();

	AAA *bptr = new BBB();
	bptr-&gt;Func1();

	return (0);
}

<br><img alt="가상 함수 테이블.png" src="lib\media\가상-함수-테이블.png"><br>가상 함수 테이블에는 key가 있고 value가 있다. 여기서 key는 호출하고자 하는 함수를 구분지어주는 구분자의 역할을 한다. 그리고 value는 구분자에 해당하는 함수의 주소정보를 알려주는 역할을 한다. 그래서 AAA 객체의 Func1 함수를 호출해야 하는 경우, 위의 테이블에 첫 번째 행의 정보를 참조하여 0x1024번지에 등록되어 있는 Func1 함수를 호출하게 되는 것이다.<br>가상 함수의 중요한 특징은 자식 클래스의 가상 함수 테이블에는 부모 함수의 오버라이딩 되기 전 가상 함수의 정보가 포함되지 않는다는 것이다. 그래서 오버라이딩 된 가상 함수를 호출하면, 무조건 가장 마지막에 오버라이딩을 한 자식 클래스의 멤버 함수가 호출된다.<br><br>참고자료<br><a href=".?query=tag:참고도서\윤성우의_열혈_cpp_프로그래밍" class="tag" target="_blank" rel="noopener nofollow">#참고도서/윤성우의_열혈_cpp_프로그래밍</a><br>]]></description><link>resource\language\c++\가상-함수-테이블.html</link><guid isPermaLink="false">resource/Language/C++/가상 함수 테이블.md</guid><pubDate>Fri, 20 Dec 2024 13:55:30 GMT</pubDate><enclosure url="lib\media\가상-함수-테이블.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="lib\media\가상-함수-테이블.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[구조체]]></title><description><![CDATA[<a class="tag" href="?query=tag:language/cpp" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#language/cpp</a> <a class="tag" href="?query=tag:참고도서/윤성우의_열혈_cpp_프로그래밍" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/윤성우의_열혈_cpp_프로그래밍</a> 
 <br><br><a href=".?query=tag:language\cpp" class="tag" target="_blank" rel="noopener nofollow">#language/cpp</a> <br>struct<br><br>본 문서는 c의 구조체와 c++ 구조체의 차이점을 중점으로 설명한다.
<br>구조체의 의의는 서로 연관이 있는 데이터를 하나의 구조체에 넣어 관리할 수 있다는 것이다.<br>경우를 하나 가정해보자.<br>
2차원 좌표계의 정점을 저장하는 Point 구조체가 있고, 정점을 이동시키는 기능을 가진 vertexMove 함수가 있다.<br>
typedef struct Point
{
	int x;
	int y;
} Point;

Point vertexMove(Point vertex1, int moveX, int moveY)
{
	Point movedVertex = {vertex1.x + moveX, vertex1.y + moveY};
	return (movedVertex);
}

<br>vertexMove 함수는 Point 구조체에 종속적이라고 할 수 있다. 그러나 c 언어는 구조체 내부의 함수 선언을 허용하지 않는다는 한계가 있다.<br>하지만 c++ 힘수에서는 구조체 내부 함수 선언을 아래와 같이 허용한다.<br>
struct Point
{
	//멤버변수
	int x;
	int y;

	//멤버함수
	void vertexMove(int moveX, int moveY)
	{
		x + moveX;
		y + moveY;
		return ;
	}
};

<br>c++에서 구조체 내부에 함수선언을 할 때, 다음과 같은 특징이 있다.<br>
<br>구조체의 변수를 멤버변수, 구조체의 함수를 멤버함수라고 한다.
<br>멤버함수는 매개변수에 멤버변수를 전달하지 않아도 멤버함수에 접근할 수 있다.
<br>멤버함수의 원형선언과 함수의 정의를 아래와 같은 형식으로 분리할 수 있다.
<br>
struct Car
{
	//. . .
	//함수의 원형선언
	void ShowCarStat();
	void Accel();
	//. . .
};

//함수의 정의
//structName::functionName의 형식으로 어느 구조체의 멤버함수인지를 지정해야 한다.
void Car::ShowCarState()
{
	//. . .
}

void Car::Accel()
{
	//. . .
}

<br>
<br>멤버함수는 기본적으로 <a data-tooltip-position="top" aria-label="인라인 함수" data-href="인라인 함수" href="resource\language\c++\인라인-함수.html" class="internal-link" target="_self" rel="noopener nofollow">인라인</a>으로 처리된다. 그러나 함수의 선언과 정의를 분리하면 인라인 처리되지 않는다. 키워드 inline을 이용해서 선언과 정의를 분리하고도 함수가 인라인 처리되도록 할 수 있다.
<br>
inline void Car::ShowCarState() { . . . . . }

<br>
<br>멤버 함수는 객체 외부의 별도의 공간에 선언된다 ( 객체가 아직 생성되지 않은 시점에서도 그러하다 ). 객체는 외부에 있는 멤버 함수의 주소를 참조한다.
<br>별도의 <a data-href="접근제어 지시자" href="resource\language\c++\접근제어-지시자.html" class="internal-link" target="_self" rel="noopener nofollow">접근제어 지시자</a>가 없을 경우, 구조체의 멤버함수와 멤버변수는 기본적으로 public으로 선언된다.
<br><br>참고자료<br><a href=".?query=tag:참고도서\윤성우의_열혈_cpp_프로그래밍" class="tag" target="_blank" rel="noopener nofollow">#참고도서/윤성우의_열혈_cpp_프로그래밍</a><br>]]></description><link>resource\language\c++\구조체.html</link><guid isPermaLink="false">resource/Language/C++/구조체.md</guid><pubDate>Fri, 20 Dec 2024 13:55:32 GMT</pubDate></item><item><title><![CDATA[깊은 복사]]></title><description><![CDATA[<a class="tag" href="?query=tag:language/cpp" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#language/cpp</a> <a class="tag" href="?query=tag:참고도서/윤성우의_열혈_cpp_프로그래밍" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/윤성우의_열혈_cpp_프로그래밍</a> 
 <br><br><a href=".?query=tag:language\cpp" class="tag" target="_blank" rel="noopener nofollow">#language/cpp</a><br><br>객체 간 복사의 한 형태이다.<br>heap 영역의 공간을 가리키는 포인터를 멤버 변수로 삼는 객체를 복사할 때, <a data-href="얕은 복사" href="resource\language\c++\얕은-복사.html" class="internal-link" target="_self" rel="noopener nofollow">얕은 복사</a>의 형태로 복사할 경우 원본 객체와 복사본 객체가 동일한 공간을 가리켜, 원본 객체가 소멸할 경우 ( = heap에 할당된 공간이 해제될 경우 ) 복사본 객체 또한 heap 영역에 대한 참조를 상실한다는 문제가 있다.<br>이러한 문제를 방지하기 위하여, heap에 할당된 공간을 복사하여 복사본 객체에 할당하는 방식의 복사 형태를 깊은 복사라 한다.<br><img alt="얕은 복사 깊은 복사.png" src="lib\media\얕은-복사-깊은-복사.png"><br><br>참고자료<br><a href=".?query=tag:참고도서\윤성우의_열혈_cpp_프로그래밍" class="tag" target="_blank" rel="noopener nofollow">#참고도서/윤성우의_열혈_cpp_프로그래밍</a><br>]]></description><link>resource\language\c++\깊은-복사.html</link><guid isPermaLink="false">resource/Language/C++/깊은 복사.md</guid><pubDate>Fri, 20 Dec 2024 13:55:39 GMT</pubDate><enclosure url="lib\media\얕은-복사-깊은-복사.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="lib\media\얕은-복사-깊은-복사.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[다중 상속]]></title><description><![CDATA[<a class="tag" href="?query=tag:language/cpp" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#language/cpp</a> <a class="tag" href="?query=tag:참고도서/윤성우의_열혈_cpp_프로그래밍" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/윤성우의_열혈_cpp_프로그래밍</a> 
 <br><br><a href=".?query=tag:language\cpp" class="tag" target="_blank" rel="noopener nofollow">#language/cpp</a><br><br>하나의 클래스가 복수의 클래스를 상속받는 것이 가능하다. 이를 다중 상속이라고 한다.<br>
다중 상속은 다음과 같이 선언된다.<br>
class Parent1
{ /* 생략 */ };

class Parent2
{ /* 생략 */ };

class child : public Parent1, protected Parent2
{ /* 생략 */ };


<br>그러나 다중 상속은 대부분의 경우 아예 사용되지 않거나, 특수한 상황에서만 매우 제한적으로 사용된다 ( 이러한 경우에도 다중 상속을 사용하지 않고 처리할 수 있다. 다중 상속을 사용해야만 하는 케이스는 없다. ).<br>다중 상속이 잘 사용되지 않는 이유는 아래와 같은 단점, 모호함들을 가졌기 때문이다.<br>
<br>
부모 클래스 1과 2가 서로 같은 함수명, 매개변수를 가진 함수를 보유한 경우, 컴파일러가 어느 함수를 호출해야 할지 알 수 없어 에러가 발생한다.<br>
-&gt; 아래와 같은 형식으로 어느 클래스의 함수인지 명시하여 해결할 수 있다.<br>
Parent1::Func(); Parent2::Func(); //부모클래스명::함수명()

<br>
아래와 같이 하나의 클래스가 간접적으로 같은 클래스를 2번 상속받을 수 있다.

<br>Parent 클래스를 선언한다.
<br>Child1, Child2 클래스를 선언한다. 이 클래스들은 모두 Parent를 상속받는다.
<br>GrandChild 클래스를 선언한다. 이 클래스는 Child1, Child2 클래스들을 다중 상속한다.
<br>결과적으로 GrandChild 클래스는 간접적으로 Parent 함수를 2번 상속 받는다.


<br>GrandChild 함수는 결과적으로 Parent 클래스의 생성자도 2번, 소멸자도 2번 호출되며, 멤버 변수도 복제되어 2배로 상속받는다. 대부분의 경우에서 이는 의도되지 않은 현상이며, 코드의 직관성을 해친다는 문제가 있다.<br>
-&gt; <a data-href="가상 상속" href="resource\language\c++\가상-상속.html" class="internal-link" target="_self" rel="noopener nofollow">가상 상속</a>을 사용하여 이러한 문제를 해결할 수 있다.


<br><br>참고자료<br><a href=".?query=tag:참고도서\윤성우의_열혈_cpp_프로그래밍" class="tag" target="_blank" rel="noopener nofollow">#참고도서/윤성우의_열혈_cpp_프로그래밍</a><br>]]></description><link>resource\language\c++\다중-상속.html</link><guid isPermaLink="false">resource/Language/C++/다중 상속.md</guid><pubDate>Sat, 22 Mar 2025 07:31:40 GMT</pubDate></item><item><title><![CDATA[다형성]]></title><description><![CDATA[<a class="tag" href="?query=tag:language/cpp" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#language/cpp</a> <a class="tag" href="?query=tag:참고도서/윤성우의_열혈_cpp_프로그래밍" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/윤성우의_열혈_cpp_프로그래밍</a> 
 <br><br><a href=".?query=tag:language\cpp" class="tag" target="_blank" rel="noopener nofollow">#language/cpp</a> <br>polymorphism<br><br>다형성은 객체지향 언어의 특징 중 하나이다.<br>다형성은 사전적으로 다음을 의미한다.<br>동질이상(同質異像)<br>
모습은 같은데 형태는 다르다.<br>이를 컴퓨터의 관점으로 생각하면 다음으로 해석할 수 있다.<br>문장은 같은데 결과가 다르다.<br>
class First
{
	public :
		virtual void SimpleFunc() { cout&lt;&lt;"First"&lt;&lt;endl; }
};

class Second : public First
{
	public :
		virtual void SimpleFunc() { cout&lt;&lt;"Second"&lt;&lt;endl; }
};

int main(void)
{
	First *ptr = new First();
	ptr -&gt; SimpleFunc(); // 아래에 동일한 문장이 존재한다.
	delete ptr;

	ptr = new Second();
	ptr -&gt; SimpleFunc(); // 위에 동일한 문장이 존재한다.
	delete ptr;

	return (0);
}

<br>위 예제에서 ptr은 동일한 포인터 변수이지만, ptr이 참조하는 객체의 자료형이 다르기 때문에 다른 결과를 출력한다. 이것이 '다형성'의 예이다.<br><br>참고자료<br><a href=".?query=tag:참고도서\윤성우의_열혈_cpp_프로그래밍" class="tag" target="_blank" rel="noopener nofollow">#참고도서/윤성우의_열혈_cpp_프로그래밍</a><br>]]></description><link>resource\language\c++\다형성.html</link><guid isPermaLink="false">resource/Language/C++/다형성.md</guid><pubDate>Sat, 22 Mar 2025 07:31:40 GMT</pubDate></item><item><title><![CDATA[디폴트 생성자]]></title><description><![CDATA[<a class="tag" href="?query=tag:language" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#language</a> <a class="tag" href="?query=tag:tag" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#tag</a> <a class="tag" href="?query=tag:참고도서/윤성우의_열혈_cpp_프로그래밍" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/윤성우의_열혈_cpp_프로그래밍</a> 
 <br><br><a href=".?query=tag:language" class="tag" target="_blank" rel="noopener nofollow">#language</a> <a href=".?query=tag:tag" class="tag" target="_blank" rel="noopener nofollow">#tag</a> <br>default constructor<br><br>c++ 언어에서 모든 객체는 생성될 때 하나의 생성자가 호출되어야 한다는 규칙이 있다.<br>이러한 기준에 예외를 두지 않기 위해 생성자가 정의되지 않은 클래스가 있다면 c++ 컴파일러는 디폴트 생성자를 삽입한다. 디폴트 생성자는 아무런 인자도 받지 않으며 아무런 기능도 하지 않는다.<br>그러므로 아래의 첫번째 예제의 클래스 정의는 두번째 예제의 클래스 정의와 완전히 동일하다.<br>
class AAA
{
	private :
		int num;
	public :
		int GetNum() {return num;}
}

<br>
class AAA
{
	private :
		int num;
	public :
		AAA() {} //디폴트 생성자
		int GetNum() {return num;}
}

<br><br><br>상술한 매개변수가 void형으로 선언되는 디폴트 생성자는, 생성자가 하나도 정의되어 있지 않을 때에만 삽입이 된다. 즉, 다음과 같이 정의된 클래스에는 디폴트 생성자가 삽입되지 않는다.<br>
class SoSimple
{
	private:
		int num;
	public:
		SoSimple(int n) : num(n) {}
}

<br>따라서 다음의 형태로는 객체 생성이 가능하지만,<br>
SoSimple simObj1(10);
SoSimple * simPtr1 = new SoSimple(2);

<br>다음의 형태로는 객체생성이 불가능하다. void 입력을 받는 생성자가 정의되지도, 자동으로 삽입되지도 않았기 때문이다.<br>
SoSimple simObj2;
SoSimple * simPtr2 = new SoSimple;

<br>따라서 위의 형태로 객체를 생성하기 원한다면, 다음의 형태로 생성자를 추가해야 한다.<br>SoSimple() : num(0) {}<br><br>동적으로 객체를 할당할 때, <a data-tooltip-position="top" aria-label="new &amp; delete" data-href="new &amp; delete" href="resource\language\c++\new-&amp;-delete.html" class="internal-link" target="_self" rel="noopener nofollow">new</a> 연산자를 사용하면 생성자가 호출된다.<br>
반면에, malloc은 단순히 클래스의 크기 정보만 바이트 단위로 전달받기 때문에 생성자가 호출될 수 없다. 그러므로 객체를 동적으로 할당하는 경우 반드시 new 연산자를 사용해야 한다.<br><br>참고자료<br><a href=".?query=tag:참고도서\윤성우의_열혈_cpp_프로그래밍" class="tag" target="_blank" rel="noopener nofollow">#참고도서/윤성우의_열혈_cpp_프로그래밍</a><br>]]></description><link>resource\language\c++\디폴트-생성자.html</link><guid isPermaLink="false">resource/Language/C++/디폴트 생성자.md</guid><pubDate>Sat, 22 Mar 2025 07:31:40 GMT</pubDate></item><item><title><![CDATA[디폴트 소멸자]]></title><description><![CDATA[<a class="tag" href="?query=tag:language/cpp" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#language/cpp</a> <a class="tag" href="?query=tag:참고도서/윤성우의_열혈_cpp_프로그래밍" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/윤성우의_열혈_cpp_프로그래밍</a> 
 <br><br><a href=".?query=tag:language\cpp" class="tag" target="_blank" rel="noopener nofollow">#language/cpp</a> <br>default destructor<br><br>클래스에 <a data-href="소멸자" href="resource\language\c++\소멸자.html" class="internal-link" target="_self" rel="noopener nofollow">소멸자</a>가 정의되어 있지 않을 떄 컴파일러가 자동으로 삽입하는, 아무런 기능도 하지 않는 소멸자.<br>첫번째 예제는 결과적으로 두번째 예제와 동일하다.<br>
class AAA
{
	//empty class
};

<br>
class AAA
{
	public :
		AAA() {}
		~AAA() {}
};

<br><br>참고자료<br><a href=".?query=tag:참고도서\윤성우의_열혈_cpp_프로그래밍" class="tag" target="_blank" rel="noopener nofollow">#참고도서/윤성우의_열혈_cpp_프로그래밍</a><br>]]></description><link>resource\language\c++\디폴트-소멸자.html</link><guid isPermaLink="false">resource/Language/C++/디폴트 소멸자.md</guid><pubDate>Sat, 22 Mar 2025 07:31:40 GMT</pubDate></item><item><title><![CDATA[리터럴]]></title><description><![CDATA[<a class="tag" href="?query=tag:language/cpp" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#language/cpp</a> <a class="tag" href="?query=tag:참고도서/포르잔_cpp_바이블" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/포르잔_cpp_바이블</a> 
 <br><br><a href=".?query=tag:language\cpp" class="tag" target="_blank" rel="noopener nofollow">#language/cpp</a><br>literal<br><br><br><a data-href="자료형" href="resource\language\c++\자료형.html" class="internal-link" target="_self" rel="noopener nofollow">자료형</a>을 가진 상수값을 의미한다.<br><br>정수 리터럴의 기본값은 부호가 있는 int(signed int)이다. short int는 리터럴로 사용하지 않는다. 만약 int의 범위를 넘는 숫자를 생성하면 long int로 생성된다. 컴파일러에게 명시적으로 우리가 원하는 자료형이 long int라고 알리려면 접미사 l 또는 L을 사용한다. 부호 없이 만들려면 접미사 u 또는 U를 사용한다.<br><br><br>문자 리터럴을 정의하는 방식은 작은 따옴표안에 ASCII 테이블에 정의된 글자를 넣는 것이다.<br>
char c = 'A';

<br>두 번째 방식은 ASCII 테이블에 정의된 정수 값을 사용하는 것이다. 하지만 이것은 엄연히 말하자면 문자 리터럴이 아니라 정수 리터럴이며, c++ 언어가 문자 또한 정수의 형태로 다루기 때문에 가능한 것이다.<br>
char c = 65;

<br>일부 특수한 문자를 정의할 때는 이스케이프 문자(역슬래시로 시작하는 기호)를 활용할 수 있다.<br><br><br>true 혹은 false 키워드로 표현한다.<br>
bool b1 = true;
bool b2 = false;

<br><br><br><br>참고자료<br><a href=".?query=tag:참고도서\포르잔_cpp_바이블" class="tag" target="_blank" rel="noopener nofollow">#참고도서/포르잔_cpp_바이블</a> <br>]]></description><link>resource\language\c++\리터럴.html</link><guid isPermaLink="false">resource/Language/C++/리터럴.md</guid><pubDate>Sat, 22 Mar 2025 07:31:40 GMT</pubDate></item><item><title><![CDATA[매개변수의 디폴트 값]]></title><description><![CDATA[<a class="tag" href="?query=tag:language/cpp" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#language/cpp</a> <a class="tag" href="?query=tag:참고도서/윤성우의_열혈_cpp_프로그래밍" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/윤성우의_열혈_cpp_프로그래밍</a> 
 <br><br><a href=".?query=tag:language\cpp" class="tag" target="_blank" rel="noopener nofollow">#language/cpp</a> <br>default value<br><br>c++ 언어에서는 함수의 매개변수의 기본값을 지정 가능하다. 함수를 호출할 때 인자를 전달하지 않으면, 컴파일러는 지정된 기본값으로 함수가 호출되었다고 간주한다. 여기서 기본값을 디폴트 값이라고 한다.<br>매개변수의 디폴트 값이 설정되어 있으면, 선언된 매개변수의 수보다 적은 수의 인자전달이 가능하다. 그리고 전달되는 인자는 왼쪽에서부터 채워져 나가고, 부족분은 디폴트 값으로 채워진다.<br>함수의 원형을 별도로 선언하는 경우, 매개변수의 디폴트 값은 함수의 원형 선언에만 위치시켜야 한다.<br>매개변수 중 일부에만 디폴트 값을 지정할 수도 있다. 이를 부분적 디폴트 값 설정이라고 한다. 단, 함수의 호출 시 인자는 왼쪽에서 오른쪽으로 전달되기 때문에 부분적 디폴트 값 설정 시 디폴트 값은 오른쪽 매개변수부터 차례대로 지정해야 한다.<br><br>참고자료<br><a href=".?query=tag:참고도서\윤성우의_열혈_cpp_프로그래밍" class="tag" target="_blank" rel="noopener nofollow">#참고도서/윤성우의_열혈_cpp_프로그래밍</a><br>]]></description><link>resource\language\c++\매개변수의-디폴트-값.html</link><guid isPermaLink="false">resource/Language/C++/매개변수의 디폴트 값.md</guid><pubDate>Sat, 22 Mar 2025 07:31:40 GMT</pubDate></item><item><title><![CDATA[멤버 이니셜라이저]]></title><description><![CDATA[<a class="tag" href="?query=tag:language/cpp" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#language/cpp</a> <a class="tag" href="?query=tag:참고도서/윤성우의_열혈_cpp_프로그래밍" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/윤성우의_열혈_cpp_프로그래밍</a> 
 <br><br><a href=".?query=tag:language\cpp" class="tag" target="_blank" rel="noopener nofollow">#language/cpp</a> <br>member initializer<br><br>함수의 몸체 부분을 사용하지 않고 멤버 변수의 초기화를 지원하는 문법적 요소.<br>
멤버 변수가 객체인 경우와 그렇지 않은 경우로 나뉜다.<br><br>클래스 A가 또 다른 클래스 B의 멤버 변수로 존재하는 경우가 있다고 가정하자. 멤버 이니셜라이저를 사용하여 B 객체를 생성할 때( 즉 B의 생성자를 호출할 때 ) 멤버 변수로서 존재하는 A 객체의 생성자를 동시에 호출할 수 있다.<br>아래와 같이 동작한다.<br>
class Point
{
	private :
		int x;
		int y;
	public :
		Point(const int &amp;xpos, const int &amp;ypos);
}

Point::Point(const int &amp;xpos, const int &amp;ypos)
{
	x=xpos;
	y=ypos;
}

class Rectangle
{
	private :
		Point upLeft;
		Point lowRight;
	public :
		Rectangle(const int &amp;x1, const int &amp;y1, const int &amp;x2, \
		const int &amp;y2);
}

Rectangle::Rectangle(const int &amp;x1, const int &amp;y1, const int &amp;x2, \
					 const int &amp;y2):upLeft(x1, y1), lowRight(x2, y2)
{
	//empty;
}

<br>위 예제에서 :upLeft(x1, y1), lowRight(x2, y2) 에 해당하는 부분이 멤버 이니셜라이저이다. 인자 x1, y1으로 upLeft의 생성자를 호출, 인자 x2, y2로 lowRight의 생성자를 호출하라는 의미를 가지고 있다.<br><br>아래와 같이 동작한다.<br>
class SoSimple
{
	private :
		int num1;
		int num2;
	public :
		SoSimple(int n1, int n2) : num1(n1), num2(n2)
		{
			//empty;
		}
}

<br>위의 예제는 결과적으로 아래와 동일하게 동작한다.<br>
class SoSimple
{
	private :
		int num1;
		int num2;
	public :
		SoSimple(int n1, int n2)
		{
			num1 = n1;
			num2 = n2;
		}
}

<br>즉 num1(n1)은 num1 = n1과 동일하게 동작한다.<br>멤버 이니셜라이저를 사용하여 멤버 변수를 초기화하는 방법은 함수의 몸체에서 멤버 변수를 초기화하는 방법과 비교해 아래의 이점이 있다.<br>
<br>초기화의 대상을 명확히 인식할 수 있다.
<br>이니셜라이저를 이용하면 선언과 동시에 초기화가 이뤄지는 형태로 바이너리 코드가 생성된다.

<br>이니셜라이저를 이용한 초기화는 다음의 형태로 바이너리 코드를 구성한다.<br>
num1(n1) //int num1 = n1;
<br>함수의 몸체에서 이뤄지는 초기화는 다음의 형태로 바이너리 코드를 구성한다.<br>
num1 = n1; //int num1; num1=n1;


<br>2.의 이유로, 선언과 동시에 초기화가 이뤄져야 하는 형식의 멤버변수(const, 참조자)는 이니셜라이저로만 초기화시킬 수 있다.
<br><br>참고자료<br><a href=".?query=tag:참고도서\윤성우의_열혈_cpp_프로그래밍" class="tag" target="_blank" rel="noopener nofollow">#참고도서/윤성우의_열혈_cpp_프로그래밍</a><br>]]></description><link>resource\language\c++\멤버-이니셜라이저.html</link><guid isPermaLink="false">resource/Language/C++/멤버 이니셜라이저.md</guid><pubDate>Sat, 22 Mar 2025 07:31:40 GMT</pubDate></item><item><title><![CDATA[범위지정 연산자]]></title><description><![CDATA[<a class="tag" href="?query=tag:language/cpp" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#language/cpp</a> <a class="tag" href="?query=tag:참고도서/윤성우의_열혈_cpp_프로그래밍" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/윤성우의_열혈_cpp_프로그래밍</a> 
 <br><br><a href=".?query=tag:language\cpp" class="tag" target="_blank" rel="noopener nofollow">#language/cpp</a> <br>::(scope resolution operator)<br><br>다음의 기능을 가진 연산자이다.<br>
<br>함수를 호출할 때 함수가 속한 이름공간을 지정.
<br>
std::cout &lt;&lt; "cpp";

<br>
<br>전역변수명과 지역변수명이 같을 경우, 범위지정 연산자를 사용해 전역변수와 지역변수를 구별할 수 있다. 이때, 범위지정 연산자가 붙어있는 변수가 전역변수이다.
<br>
int val=100; //전역변수

int SimpleFunc(void)
{
	int val=20; //지역변수
	val+=3; //지역변수 val의 값 3 증가
	::val+=7; //전역변수 val의 값 7 증가
}

<br><br>참고자료<br><a href=".?query=tag:참고도서\윤성우의_열혈_cpp_프로그래밍" class="tag" target="_blank" rel="noopener nofollow">#참고도서/윤성우의_열혈_cpp_프로그래밍</a><br>]]></description><link>resource\language\c++\범위지정-연산자.html</link><guid isPermaLink="false">resource/Language/C++/범위지정 연산자.md</guid><pubDate>Sat, 22 Mar 2025 07:31:40 GMT</pubDate></item><item><title><![CDATA[복사 생성자]]></title><description><![CDATA[<a class="tag" href="?query=tag:language/cpp" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#language/cpp</a> <a class="tag" href="?query=tag:참고도서/윤성우의_열혈_cpp_프로그래밍" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/윤성우의_열혈_cpp_프로그래밍</a> 
 <br><br><a href=".?query=tag:language\cpp" class="tag" target="_blank" rel="noopener nofollow">#language/cpp</a> <br>copy constructor<br><br>C++ 언어에서는 아래와 같은 형식으로 객체 간 복사가 가능하다.<br>
class SoSimple
{
	private :
		int num1;
		int num2;
	public :
		SoSimple(int n1, int n2) : num1(n1), num2(n2) { }
		void ShowSimpleData()
		{
			cout&lt;&lt;num1&lt;&lt;endl;
			cout&lt;&lt;num2&lt;&lt;endl;
		}
};

int main(void)
{
	SoSimple sim1(15, 20);
	SoSimple sim2 = sim1; //sim2 객체가 sim1 객체의 구성 요소(멤버 변수)를 복사
	
	sim2.ShowSimpleData();

	return (0);
}

<br>위 예제에서, 객체의 복사는 다음 구문에서 일어난다.<br>SoSimple sim2 = sim1;<br>이러한 형태의 구문은 묵시적 변환이 일어나 실제로는 다음의 형태로 해석된다. <a data-footref="1" href="about:blank#fn-1-d7709dc1a90a163e" class="footnote-link" target="_self" rel="noopener nofollow">[1]</a><br>SoSimple sim2(sim1);<br>이렇듯 객체 간 복사의 용도로 사용되는 생성자를 복사 생성자라고 한다. 그러나 위 예제에서는 복사 생성자가 생성되어 있지 않다. 그럼에도 복사가 정상적으로 이루어지는 이유는 디폴트 복사 생성자가 자동으로 삽입되기 때문이다.<br>디폴트 복사 생성자는 아래와 같은 형태를 띈다.<br>
SoSimple(const SoSimple &amp;copy) : num1(copy.num1), num2(copy.num2) {}

<br>대부분은 디폴트 복사 생성자만으로 객체 간 복사를 정상적으로 수행할 수 있지만, 개발자가 직접 복사 생성자의 동작을 정의해야하는 경우가 있다.<br><br>복사 생성자가 호출되는 시점은 크게 세가지로 구분할 수 있다.<br>
<br>case 1 : 기존에 생성된 객체를 이용해서 새로운 객체를 초기화하는 경우(앞서 보인 경우)
<br>case 2 : Call-by-value 방식의 함수 호출 과정에서 객체를 인자로 전달하는 경우
<br>case 3 : 객체를 반환하되, 참조형으로 반환하지 않는 경우
<br><br>참고자료<br><a href=".?query=tag:참고도서\윤성우의_열혈_cpp_프로그래밍" class="tag" target="_blank" rel="noopener nofollow">#참고도서/윤성우의_열혈_cpp_프로그래밍</a><br><br><br>
<br>
<br><a data-href="explicit 키워드" href="resource\language\c++\explicit-키워드.html" class="internal-link" target="_self" rel="noopener nofollow">explicit 키워드</a>를 사용하여 이러한 묵시적 변환이 일어나지 않게 할 수 있다.<a href="about:blank#fnref-1-d7709dc1a90a163e" class="footnote-backref footnote-link" target="_self" rel="noopener nofollow">↩︎</a>
]]></description><link>resource\language\c++\복사-생성자.html</link><guid isPermaLink="false">resource/Language/C++/복사 생성자.md</guid><pubDate>Sat, 22 Mar 2025 07:31:40 GMT</pubDate></item><item><title><![CDATA[상속]]></title><description><![CDATA[<a class="tag" href="?query=tag:language/cpp" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#language/cpp</a> <a class="tag" href="?query=tag:참고도서/윤성우의_열혈_cpp_프로그래밍" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/윤성우의_열혈_cpp_프로그래밍</a> 
 <br><br><a href=".?query=tag:language\cpp" class="tag" target="_blank" rel="noopener nofollow">#language/cpp</a> <br>inheritance<br><br>클래스가 다른 클래스에게 자신이 가지고 있는 멤버들을 물려주는 것을 상속이라고 한다.<br>상속을 하는 쪽과 상속을 받는 쪽을 각각 다음의 용어들로 정의한다.<br><br>예를 들러, UnivStudent 클래스가 Student 클래스를 상속받을 때, 다음과 같은 형식으로 상속받는다.<br>
#ifndef US_HPP
#define US_HPP

#include &lt;iostream&gt;
#include &lt;cstring&gt;

using namespace std;

//부모 클래스
class Person
{
	private :
		int age;
		char name[50];
	public :
		Person(int myage, char *myname);
		void WhatYourName() const;
		void HowOldAreYou() const;
};

//자식 클래스
class UnivStudent : public Person //UnivStudent가 Person을 'public' 상속함
{
	//부모 클래스로부터 물려받은 멤버에 더해 자신만의 독자적인 멤버를 추가로 선언한다.
	private :
		char major[50]; //전공과목
	public :
		UnivStudent(char *myname, int myage, char *mymajor);
		void WhoAreYou() const;
};

#endif

<br>상속은 다음과 같은 특성을 갖는다.<br>
<br>
<a data-href="접근제어 지시자" href="resource\language\c++\접근제어-지시자.html" class="internal-link" target="_self" rel="noopener nofollow">접근제어 지시자</a>의 접근제한 기준은 객체가 아닌 클래스이기 때문에 부모 클래스에서 private으로 선언한 멤버는 자식 클래스에서 접근이 불가능하다.

<br>따라서 자식 클래스에서 부모 클래스의 private멤버에 접근하기 위해서는 부모 클래스로부터 상속받은 public 함수를 사용하는 우회적인 방법을 사용해야 한다.
<br>이렇듯 정보의 은닉은 하나의 객체 안에서도 진행이 된다.


<br>
자식 클래스는 자신의 멤버 뿐만이 아니라 상속받은 멤버도 초기화하여야 한다.

<br>이를 위하여 생성자를 호출할 때 <a data-tooltip-position="top" aria-label="멤버 이니셜라이저" data-href="멤버 이니셜라이저" href="resource\language\c++\멤버-이니셜라이저.html" class="internal-link" target="_self" rel="noopener nofollow">이니셜라이저</a>를 사용하여 부모의 생성자를 호출한다.
<br>만약 부모의 생성자를 호출하지 않는 경우, 부모의 생성자 중 매개변수가 void인 생성자를 자동으로 호출한다 ( 없을 경우 error ).
<br>구체적인 생성자 호출 순서는 아래와 같다.

<br>자식 클래스 객체의 메모리 공간이 할당된다.
<br>자식 클래스의 생성자가 호출된다 ( 실행은 아직 되지 않은 상태 ).
<br>부모 클래스가 있는 지 확인 후, 있다면 부모 클래스의 생성자를 호출한다.
<br>부모 클래스 생성자를 실행하여 부모의 멤버변수를 초기화한다.
<br>자식 클래스 생성자를 실행한다 자식의 멤버변수를 초기화한다.




<br>
// 부모 클래스의 생성자
Person::Person(int myage, char *myname) : age(myage)
{
	strcpy(name, myname);
}

// 자식 클래스의 생성자
UnivStudent::UnivStudent(char *myname, int myage, char *mymajor) : Person(myage, myname) // -&gt; 이니셜라이저를 사용하여 부모의 생성자를 호출함
{
	strcpy(major, mymajor);
}

<br>
<br>
자식 클래스의 객체가 소멸될 때에는, 자식 클래스의 소멸자가 실행되고 난 다음에 기초 클래스의 소멸자가 실행된다.

<br>스택의 생성된 객체의 소멸 순서는 생성 순서와 반대이다.


<br>
<a data-href="접근제어 지시자" href="resource\language\c++\접근제어-지시자.html" class="internal-link" target="_self" rel="noopener nofollow">접근제어 지시자</a>는 멤버의 접근 범위를 제한하는 것 외에도 상속의 형태를 정의할 수 있다. 따라서 상속애는 public, protected, private 이렇게 3가지 형태의 상속이 있다.

<br>public 상속의 경우, private 멤버를 제외한 나머지(private 멤버는 자식에서 접근이 불가하므로) 그대로 상속한다.
<br>protected 상속의 경우, protected 보다 접근 범위가 넓은 멤버 ( 즉 public ) 의 접근 범위를 protected로 변환시켜 상속한다.
<br>private 상속의 경우, private 보다 접근 범위가 넓은 멤버의 접근 범위를 private으로 변환시켜 상속한다.


<br>
상속은 남용하지 않고 적절한 경우에만 사용되어야 한다. 상속을 사용하기 적합한 클래스와 클래스 사이 관계의 특징은 다음과 같다.

<br>
IS_A 관계.

<br>예를 들어 컴퓨터 정보를 나타내는 Computer 클래스가 있고, 노트북 정보를 나타내는 Notebook 클래스가 있으면 둘은 IS_A 관계라 할 수 있다. 다음의 문장이 성립하기 때문이다.<br>
노트북은 컴퓨터이다<br>
또는<br>
노트북은 컴퓨터의 일종이다.


<br>
HAS_A 관계.

<br>에를 들어 경찰을 나타내는 Police 클래스가 있고, 총을 나타내는 Gun 클래스가 있을 때 다음의 문장이 성립하므로 HAS_A 관계라 할 수 있다.<br>
경찰은 총을 가지고 있다.


<br>
다만 HAS_A 관계는 상속을 사용하기보다는 객체를 다른 객체의 멤버변수로 선언함으로서 표현하는 것이 일반적이다.



<br>
부모 클래스의 함수를 자식 클래스에서 <a data-tooltip-position="top" aria-label="함수 오버로딩" data-href="함수 오버로딩" href="resource\language\c++\함수-오버로딩.html" class="internal-link" target="_self" rel="noopener nofollow">오버로딩</a> 할 수 있다.

<br>
부모 클래스의 함수를 자식 클래스에서 재정의 할 수 있다. 이를 <a data-href="함수 오버라이딩" href="resource\language\c++\함수-오버라이딩.html" class="internal-link" target="_self" rel="noopener nofollow">함수 오버라이딩</a>이라 한다.

<br>
부모 클래스의 포인터로 자식 포인터의 객체를 가리킬 수 있다.

<br>그러나 컴파일러는 포인터 연산의 가능성 여부를 판단할 때, 실제 가리키는 객체의 자료형이 아닌, 포인터의 자료형을 기준으로 판단한다.

<br>따라서 부모 클래스의 포인터로 자식 포인터를 가리킬 경우 부모 포인터에서 정의되지 않은 함수를 사용할 수 없다 ( 이를 <a data-href="가상 함수" href="resource\language\c++\가상-함수.html" class="internal-link" target="_self" rel="noopener nofollow">가상 함수</a>를 통해 극복할 수 있다 ) .
<br>부모 클래스의 함수를 자식 클래스가 <a data-tooltip-position="top" aria-label="함수 오버라이딩" data-href="함수 오버라이딩" href="resource\language\c++\함수-오버라이딩.html" class="internal-link" target="_self" rel="noopener nofollow">오버라이딩</a> 한 경우, 가리키는 포인터의 자료형 클래스에서 선언된 함수가 호출된다.
<br>상술한 모든 특성은 <a data-href="참조자" href="resource\language\c++\참조자.html" class="internal-link" target="_self" rel="noopener nofollow">참조자</a>를 사용한 참조에도 모두 적용된다.




<br>
하나의 객체가 동시에 복수의 객체를 상속받는 것이 가능하다. 이를 <a data-href="다중 상속" href="resource\language\c++\다중-상속.html" class="internal-link" target="_self" rel="noopener nofollow">다중 상속</a>이라고 한다.

<br><br>참고자료<br><a href=".?query=tag:참고도서\윤성우의_열혈_cpp_프로그래밍" class="tag" target="_blank" rel="noopener nofollow">#참고도서/윤성우의_열혈_cpp_프로그래밍</a><br>]]></description><link>resource\language\c++\상속.html</link><guid isPermaLink="false">resource/Language/C++/상속.md</guid><pubDate>Sat, 22 Mar 2025 07:31:41 GMT</pubDate></item><item><title><![CDATA[생성자]]></title><description><![CDATA[<a class="tag" href="?query=tag:language/cpp" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#language/cpp</a> <a class="tag" href="?query=tag:참고도서/윤성우의_열혈_cpp_프로그래밍" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/윤성우의_열혈_cpp_프로그래밍</a> 
 <br><br><a href=".?query=tag:language\cpp" class="tag" target="_blank" rel="noopener nofollow">#language/cpp</a> <br>constructor<br><br>객체 생성 시 단 한번 호출되는 함수.<br>생성자는 다음의 형태를 띈다.<br>
<br>클래스의 이름과 함수의 이름이 동일하다.
<br>반환형이 선언되어 있지 않으며, 실제로 반환하지 않는다.
<br>생성자는 아래의 특성을 갖는다.<br>
<br>생성자도 함수의 일종이니 <a data-tooltip-position="top" aria-label="함수 오버로딩" data-href="함수 오버로딩" href="resource\language\c++\함수-오버로딩.html" class="internal-link" target="_self" rel="noopener nofollow">오버로딩</a>이 가능하다.
<br>생성자도 함수의 일종이니 매개변수에 <a data-tooltip-position="top" aria-label="매개변수의 디폴트 값" data-href="매개변수의 디폴트 값" href="resource\language\c++\매개변수의-디폴트-값.html" class="internal-link" target="_self" rel="noopener nofollow">디폴트 값</a>을 설정할 수 있다.
<br>아래는 생성자의 예시이다.<br>
#include &lt;iostream&gt;

using namespace std;

class SimpleClass
{
	private :
		int num1;
		int num2;

	public :
		SimpleClass()
		{
			num1=0;
			num2=0;
		}

		SimpleClass(int n)
		{
			num1=n;
			num2=0;
		}

		SimpleClass(int n1, int n2)
		{
			num1=n1;
			num2=n2;
		}

		/*

		//이 단락을 주석해제하고 SimpleClass sc2(100); 과 같이 객체 생성을 시도할 경우 컴파일 에러가 발생한다. SimpleClass(int n)과 이 단락의 생성자 중 뭘 호출해야 할 지 명확하지 않기 때문이다.

		SimpleClass(int n1=0;,int n2=0)
		{
			num1=n1;
			num2=n2;
		}
		*/

		void ShowData() const
		{
			cout&lt;&lt;num1&lt;&lt;' '&lt;&lt;num2&lt;&lt;endl;
		}
};

int main(void)
{
	//생성자를 정의한 경우 객체생성과정에서 자동으로 호출되는 생성자에게 전달할 인자의 정보를 다음과 같이 추가해야 한다.
	SimpleClass sc1;
	sc1.ShowData();
	SimpleClass sc2(100);
	sc2.ShowData();
	SimpleClass sc3(100, 200);
	sc3.ShowData();

	return (0);
}

/*
실행결과

0 0
100 0
100 200
*/

<br>생성자도 아래의 예제와 같이 private으로 선언될 수 있다. 이 경우, 클래스 내부의 객체를 초기화시키는 데에만 사용할 수 있다.<br>
//PrivateConstructor.cpp

#include &lt;iostream&gt;

using namespace std;

class AAA
{
	private :
		int num;

	public :
		AAA() : num(0) {}

		AAA &amp;CreateInitObj(int n) const
		{
			AAA *ptr = new AAA(n);
			return (*ptr);
		}

		void ShowNum() const { cout&lt;&lt;num&lt;&lt;endl; }

	private :
		AAA(int n) : num(n) {}
};

int main(void)
{
	AAA base;
	base.ShowNum();

	AAA &amp;obj1 = base.CreateInitObj(3);
	obj1.ShowNum();

	AAA &amp;obj2 = base.CreateInitObj(12);
	obj2.ShowNum();

	delete &amp;obj1;
	delete &amp;obj2;

	return (0);
}

<br>생성자를 정의하지 않으면, 컴파일러의 의해 <a data-href="디폴트 생성자" href="resource\language\c++\디폴트-생성자.html" class="internal-link" target="_self" rel="noopener nofollow">디폴트 생성자</a>가 자동으로 삽입된다.<br>
객체 내부의 멤버로서 존재하는 객체는 <a data-href="멤버 이니셜라이저" href="resource\language\c++\멤버-이니셜라이저.html" class="internal-link" target="_self" rel="noopener nofollow">멤버 이니셜라이저</a>를 통해 초기화될 수 있다.<br><br>참고자료<br><a href=".?query=tag:참고도서\윤성우의_열혈_cpp_프로그래밍" class="tag" target="_blank" rel="noopener nofollow">#참고도서/윤성우의_열혈_cpp_프로그래밍</a><br>]]></description><link>resource\language\c++\생성자.html</link><guid isPermaLink="false">resource/Language/C++/생성자.md</guid><pubDate>Sat, 22 Mar 2025 07:31:41 GMT</pubDate></item><item><title><![CDATA[소멸자]]></title><description><![CDATA[<a class="tag" href="?query=tag:language/cpp" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#language/cpp</a> <a class="tag" href="?query=tag:참고도서/윤성우의_열혈_cpp_프로그래밍" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/윤성우의_열혈_cpp_프로그래밍</a> 
 <br><br><a href=".?query=tag:language\cpp" class="tag" target="_blank" rel="noopener nofollow">#language/cpp</a> <br>destructor<br><br>소멸자는 객체가 소멸할 때 반드시 호출되는 함수이다.<br>소멸자는 다음의 형태를 갖는다.<br>
<br>클래스의 이름 앞에 ~가 붙은 형태의 이름을 갖는다.
<br>반환형이 선언되어 있지 않으며, 실제로 반환하지 않는다.
<br>매개변수는 void형으로 선언되어야 하기 때문에 오버로딩도, 디폴트 값 설정도 불가능하다.
<br>예시<br>~AAA() {//function body}<br>소멸자는 주로 객체의 소멸 전 객체 내에서 <a data-tooltip-position="top" aria-label="new &amp; delete" data-href="new &amp; delete" href="resource\language\c++\new-&amp;-delete.html" class="internal-link" target="_self" rel="noopener nofollow">new</a> 연산자를 이용해 동적으로 할당한 요소들을 <a data-tooltip-position="top" aria-label="new &amp; delete" data-href="new &amp; delete" href="resource\language\c++\new-&amp;-delete.html" class="internal-link" target="_self" rel="noopener nofollow">delete</a>를 이용해 없애는데 사용한다.<br><a data-href="디폴트 생성자" href="resource\language\c++\디폴트-생성자.html" class="internal-link" target="_self" rel="noopener nofollow">디폴트 생성자</a>와 마찬가지로, 클래스에 소멸자가 정의되어 있지 않으면 컴파일러에 의해 <a data-href="디폴트 소멸자" href="resource\language\c++\디폴트-소멸자.html" class="internal-link" target="_self" rel="noopener nofollow">디폴트 소멸자</a>가 삽입된다.<br><br>참고자료<br><a href=".?query=tag:참고도서\윤성우의_열혈_cpp_프로그래밍" class="tag" target="_blank" rel="noopener nofollow">#참고도서/윤성우의_열혈_cpp_프로그래밍</a><br>]]></description><link>resource\language\c++\소멸자.html</link><guid isPermaLink="false">resource/Language/C++/소멸자.md</guid><pubDate>Sat, 22 Mar 2025 07:31:41 GMT</pubDate></item><item><title><![CDATA[얕은 복사]]></title><description><![CDATA[<a class="tag" href="?query=tag:language/cpp" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#language/cpp</a> <a class="tag" href="?query=tag:참고도서/윤성우의_열혈_cpp_프로그래밍" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/윤성우의_열혈_cpp_프로그래밍</a> 
 <br><br><a href=".?query=tag:language\cpp" class="tag" target="_blank" rel="noopener nofollow">#language/cpp</a><br><br>객체 간 복사의 한 형태.<br>순수히 멤버 대 멤버 간 복사가 일어난다. <a data-tooltip-position="top" aria-label="복사 생성자" data-href="복사 생성자" href="resource\language\c++\복사-생성자.html" class="internal-link" target="_self" rel="noopener nofollow">디폴트 복사 생성자</a>는 얕은 복사의 형태로 객체 간 복사한다.<br><img alt="얕은 복사.png" src="lib\media\얕은-복사.png"><br>heap 영역에 할당된 공간을 가리키는 포인터를 복사할 경우, 복수의 객체가 heap 영역의 동일한 공간을 가리키는 형태가 된다.<br><img alt="얕은 복사 깊은 복사.png" src="lib\media\얕은-복사-깊은-복사.png"><br>따라서 원본 객체가 소멸할 경우(= heap 영역에 할당된 공간이 해제될 경우) 복사본 객체의 멤버 또한 공간을 참조할 수 없게 된다. 이러한 경우를 방지하고 싶다면 <a data-href="깊은 복사" href="resource\language\c++\깊은-복사.html" class="internal-link" target="_self" rel="noopener nofollow">깊은 복사</a>를 사용해야 한다.<br><br>참고자료<br><a href=".?query=tag:참고도서\윤성우의_열혈_cpp_프로그래밍" class="tag" target="_blank" rel="noopener nofollow">#참고도서/윤성우의_열혈_cpp_프로그래밍</a><br>]]></description><link>resource\language\c++\얕은-복사.html</link><guid isPermaLink="false">resource/Language/C++/얕은 복사.md</guid><pubDate>Sat, 22 Mar 2025 07:31:41 GMT</pubDate><enclosure url="lib\media\얕은-복사.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="lib\media\얕은-복사.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[연산자 오버로딩]]></title><description><![CDATA[<a class="tag" href="?query=tag:language/cpp" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#language/cpp</a> <a class="tag" href="?query=tag:참고도서/윤성우의_열혈_cpp_프로그래밍" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/윤성우의_열혈_cpp_프로그래밍</a> 
 <br><br><a href=".?query=tag:language\cpp" class="tag" target="_blank" rel="noopener nofollow">#language/cpp</a> <br>operator overloading<br><br><br>연산자 오버로딩이란, 기존의 연산자의 오버로딩을 통하여, 기존에 존재하던 연산자의 기본 기능 이외에 다른 기능을 추가할 수 있게끔 하는 문법적 요소이다.<br>연산자 오버로딩에 사용되는 함수명은 'operation' + '(연산자)' 의 형태를 띈다.<br>
연산자 오버로딩은 기본적으로 아래와 같이 사용된다.<br>
#include &lt;iostream&gt;
using namespace std;

class Point
{
	private :
		int xpos, ypos;
	public :
		Point(int x = 0, int y = 0) : xpos(x), ypos(y) {}
		void ShowPosition() const
		{
			cout&lt;&lt;'['&lt;&lt;xpos&lt;&lt;", "&lt;&lt;ypos&lt;&lt;']'&lt;&lt;endl;
		}
		Point operator+(const Point &amp;ref)
		{
			Point pos(xpos + ref.xpos, ypos + ref.ypos);
			return pos;
		}
};

/*
int main(void)
{
	Point pos1(3, 4);
	Point pos2(10, 20);
	//연산자 오버로딩을 사용하지 않으면 보통 이와 같이 코드를 작성한다.
	Point pos3 = pos1.operator+(pos2);

	pos1.ShowPosition();
	pos2.ShowPosition();
	pos3.ShowPosition();
	
	return (0);
}
*/

int main(void)
{
	Point pos1(3, 4);
	Point pos2(10, 20);
	//연산자 오버로딩을 사용하여 아래와 같이 코드를 축약할 수 있다.
	Point pos3 = pos1 + pos2;
	
	pos1.ShowPosition();
	pos2.ShowPosition();
	pos3.ShowPosition();
	
	return (0);
}

<br>다음은 위 예제에서 연산자 오버로딩이 적용된 문장이다.<br>pos1 + pos2;<br>이 문장은 아래와 같이 분해할 수 있다.<br>pos1<br>
+<br>
pos2<br>연산자 오버로딩은 위 문장의 각 구성요소를 다음과 같이 변환한다.<br>pos<br>
.operator+<br>
(pos2)<br>pos.operator+(pos2);<br><br><br>연산자를 오버로딩 하는 방법에는 다음 두 가지가 있다.<br>
<br>멤버함수에 의한 연산자 오버로딩
<br>전역함수에 의한 연산자 오버로딩
<br>개요에서 소개한 방법은 멤버함수에 의한 연산자 오버로딩이다.<br>
전역함수를 이용해서 오버로딩을 하면 pos1 + pos2는 다음과 같이 해석이 된다.<br>operator+(pos1, pos2);<br>아래 예제를 참조하자.<br>
#include &lt;iostream&gt;
using namespace std;

class Point
{
	private :
		int xpos, ypos;
	public :
		Point(int x = 0, int y = 0) : xpos(x), ypos(y) {}
		void ShowPosition() const
		{
			cout&lt;&lt;'['&lt;&lt;xpos&lt;&lt;", "&lt;&lt;ypos&lt;&lt;']'&lt;&lt;endl;
		}
		/*전역 함수에서 Point 객체의 멤버를 참조할 수 있도록 한다.*/
		friend Point operator+(const Point &amp;pos1, const Point &amp;pos2);
};

//연산자 오버로딩 전역 함수 버전
Point operator+(const Point &amp;pos1, const Point &amp;pos2)
{
	Point pos(pos1.xpos + pos2.xpos, pos1.ypos + pos2.ypos);
	return pos;
}

int main(void)
{
	Point pos1(3, 4);
	Point pos2(10, 20);
	Point pos3 = pos1 + pos2;

	pos1.ShowPosition();
	pos2.ShowPosition();
	pos3.ShowPosition();

	return (0);
}

<br>위 예제와 같이, 연산 대상이 private 멤버 변수인 경우, friend 선언을 통하여 전역 변수에게 멤버의 참조를 허용하여야 한다.<br>전역 함수를 이용한 연산자 오버로딩은 후술할 교환 법칙이 성립하는 연산자 오버로딩의 구현에 유용하게 사용된다.<br><br><br><br>이들 연산자에 대해서 오버로딩을 제한하는 이유는 C++의 문법 규칙을 보존하기 위해서다.<br>
만약 이들 연산자들까지 오버로딩을 허용해 버린다면, C++ 문법 규칙에 어긋나는 문장의 구성이 가능해진다.<br><br><br><br>이들은 객체를 대상으로 진행해야 의미가 통하는 연산자들이기 때문에, 멤버함수 기반으로만 연산자의 오버로딩을 허용한다.<br><br><br>
<br>연산자의 본래 정의를 벗어난 형태의 오버로딩은 좋지 않다.
<br>연산자의 우선 순위와 결합성은 바뀌지 않는다.
<br>매개변수의 디폴트 값 설정이 불가능하다.
<br>클래스가 아닌 일반 자료형 간의 연산을 재정의 할 수는 없다.

<br>부연 : 예를 들어 'int 형 변수 간의 덧셈'과 같은 동작을 재정의할 수는 없다는 말이다.


<br><br><br>피연산자가 두 개인 이항 연산자와 피연산자가 한 개인 단항 연산자의 가장 큰 차이점은 피연산자의 개수이다. 그리고 이에 따른 연산자 오버로딩의 차이점은 매개변수의 개수에서 발견된다.<br>대표적인 단항 연산자로는 다음의 두 가지가 있다.<br>
<br>++
<br>--
<br>단항 연산자는 연산 결과가 피연산자 객체 스스로에 적용되기 때문에 함수에 인자를 전달할 필요가 없다.<br>
따라서 멤버함수의 경우, 다음의 형태를 띈다.<br>
//전위 연산을 담당하는 함수의 형태
Obj &amp;operation++() { /* . . . */ }

<br>위의 연산자들이 피연산자의 앞에 위치하면 전위 연산자, 뒤에 위치하면 후위 연산자가 된다.<br>
둘을 구분하기 위하여, 후위 연산을 담당하는 함수에게만 키워드 int를 표시한다. int 키워드는 오로지 전위와 후위를 구분하기 위해 존재하며, int 형 인자를 전달하는 것이 아니다.<br>
//후위 연산을 담당하는 함수의 형태
Obj &amp;operation++( int ) { /* . . . */ } //키워드 int를 사용하여 전위와 후위를 구분한다.

<br>마찬가지로 전역함수로 단항 연산을 구현할 경우, 이항 연산과 달리 피연산자를 하나만 전달하면 된다.<br>
//전위 연산을 담당하는 함수의 형태
Obj &amp;operation++( Obj &amp;a) { /* . . . */ }
//후위 연산을 담당하는 함수의 형태
Obj &amp;operation++( Obj &amp;a, int ) { /* . . . */ } //키워드 int를 사용하여 전위와 후위를 구분한다.

<br><br><br>위 절의 예제에서 operation++()은 객체의 참조값을 반환한다. 사실 객체의 멤버 변수를 1 더하는 동작만을 정의한다면 다음과 같이 반환형을 void로 하여도 상관없다.<br>
void operation++()
{
	//var1과 var2는 객체의 멤버변수
	var1 += 1;
	var2 += 1;
}

<br>그러나 이러한 형식으로 함수를 정의하면 다음과 같은 형태의 연산이 불가능하다.<br>
<br>++(++obj) //obj에 ++연산을 연속적으로 2번 적용하고자 함
<br>operation++은 void를 반환하므로 위 연산은 다음과 동일하다.<br>
++(void) //error
<br>따라서 위와 같은 연산이 가능하게 하기 위해서는 반환형을 객체의 참조자로 하는 것이 좋다.<br>
Obj &amp;operation++()
{
	var1 += 1;
	var2 += 1;
	
	return (*this); //객체 스스로의 참조값을 반환
}

<br>
<br>++(++obj)를 연산하고자 함.
<br>operation++은 객체의 참조값을 반환하므로 위 연산은 다음과 동일하다.

<br>++(obj.operation++())
<br>++(obj 객체의 참조값)
<br>(obj 객체의 참조값).operation++()


<br><br><br>C++ 언어에서는 다음과 같은 연속적인 후위 연산을 금지하고 있다.<br>(obj--)--;<br>따라서 다음과 같이 operation--()의 반환형을 const 객체로 선언하면 연속적인 후위 연산을 제한할 수 있다.<br>
//전위 연산을 담당하는 함수의 형태
const Obj operation++( Obj &amp;a) { /* . . . */ }
//후위 연산을 담당하는 함수의 형태
const Obj operation++( Obj &amp;a, int ) { /* . . . */ } //키워드 int를 사용하여 전위와 후위를 구분한다.

<br>
<br>(obj--)--;를 연산하고자 함.
<br>operation--는 const 임시 객체를 반환하므로 위 연산은 다음과 동일하다.

<br>(obj.operation--())--
<br>(Obj 클래스의 const 임시 객체)--
<br>(Obj 클래스의 const 임시 객체).operation--() // error : const 임시 객체는 const 멤버 함수가 아닌 operation--()를 호출할 수 없다.


<br><br><br>곱셈과 같은 연산은 다음과 같이 피연산자 2개의 자료형이 서로 다를 수 있다.<br>
class Point
{
	private :
		int xpos, ypos;
	public :
		Point operation*(int n)
		{
			xpos *= n;
			ypos *= n;
			return (*this);
		}
}

int main(void)
{
	Point pos(1, 2);
	Point cpy;

	cpy = pos * 3;
	cpy = pos * 3 * 2;

	return (0);
}

<br>위 예제에서 cpy = pos * 3;은 cpy = 3 * pos;으로도 표현할 수 있어야 한다.<br>
하지만 cpy = 3 * pos;은 다음과 같이 해석될 수는 없기 때문에 연산자 오버로딩이 불가하다.<br>3.operator*(pos);<br>따라서 * 연산자의 교환법칙을 구현하려면 전역 함수를 사용하여 다음과 같이 정의해야 한다.<br>
class Point
{
	private :
		int xpos, ypos;
	public :
		Point operation*(int n)
		{
			xpos *= n;
			ypos *= n;
			return (*this);
		}
	friend Point operator*(int n, Point &amp;pos);
}

Point operator*(int n, Point &amp;pos)
{
	return ref * n;
}

int main(void)
{
	Point pos(1, 2);
	Point cpy;

	cpy = 3 * pos; //operator*(3, pos);로 해석됨.
	cpy = 3 * pos * 2; //operator*(3, pos).operator*(3);으로 해석됨.

	return (0);
}

<br><br><br>대입 연산자는 <a data-href="복사 생성자" href="resource\language\c++\복사-생성자.html" class="internal-link" target="_self" rel="noopener nofollow">복사 생성자</a>와 매우 유사한 성격을 가지고 있다.<br>복사 생성자의 특성<br>
<br>정의하지 않으면 디폴트 복사 생성자가 삽입된다.
<br>디폴트 복사 생성자는 멤버 대 멤버의 복사(얕은 복사)를 진행한다.
<br>생성자 내에서 동적 할당을 한다면, 그리고 깊은 복사가 필요하다면 직접 정의해야 한다.
<br>대입 연산자의 특성<br>
<br>정의하지 않으면 디폴트 대입 연산자가 삽입된다.
<br>디폴트 대입 연산자는 멤버 대 멤버의 복사(얕은 복사)를 진행한다.
<br>연산자 내에서 동적 할당을 한다면, 그리고 깊은 복사가 필요하다면 직접 정의해야 한다.
<br>참고로, 디폴트 대입 연산자는 다음과 같은 형식을 하고 있다.<br>
Obj &amp;operator=(const Obj obj)
{
	objVal1 = obj.objVal1;
	objVal2 = obj.objVal2;
	return *this;
}

<br>그러나 대입 연산자와 복사 생성자는 호출시점에 차이를 갖는다.<br>
<br>복사 생성자 : 새로 생성하는 객체의 초기화에 기존에 생성된 객체가 사용.

<br>ex) Point pos = pos1;


<br>대입 연산자 : 기존의 생성된 객체 사이에 대입 연산이 사용되었을 경우.

<br>ex) pos2 = pos1;


<br>또한 대입 연산자와 복사 생성자는 상속 구조에서의 호출에서 다음의 차이점을 갖는다.<br>
<br>복사 생성자 : 자식 클래스에서 아무런 명시를 하지 않아도 부모 클래스의 생성자가 호출.
<br>대입 연산자

<br>디폴트 대입 연산자 호출의 경우 : 디폴트 대입 연산자가 부모 클래스의 대입 연산자까지 호출한다.
<br>대입 연산자를 직접 정의하는 경우 : 자식 클래스의 대입 연산자에서 명시가 없으면, 부모 클래스의 대입 연산자가 호출되지 않는다. 다음의 형태를 사용하여 부모 클래스의 대입 연산자를 호출할 수 있다.

<br>Parent::operator=(ref); //부모 클래스명::operator=(매개인자);




<br>c++ 언어의 대입연산( =객체 간의 대입 연산 )은 c 언어의 구조체 간의 대입과 유사해 보이지만, 대입 연산자를 오버로딩하였다는 점에서 근본적으로 차이점이 있다.<br>객체 내에서 멤버를 동적 할당하는 경우, 디폴트 대입 연산자 사용 시 다음의 두 가지 문제가 발생한다.<br><img alt="디폴트 대입 연산자의 동작(얕은 복사).png" src="lib\media\디폴트-대입-연산자의-동작(얕은-복사).png"><br>
<br>기존에 가리키던 heap 영역의 공간에 대한 참조를 잃는다.
<br>얕은 복사로 인해서, 객체 소멸 과정에서 지워진 문자열을 중복 소멸하는 문제가 발생한다.
<br>따라서 다음의 원칙을 준수하여 직접 대입 연산자를 정의하여야 한다.<br>
<br>깊은 복사를 진행하도록 정의한다.
<br>메모리 누수가 발생하지 않도록, 깊은 복사에 앞서 메모리 해제의 과정을 거친다.
<br><br><br>앞서 언급했듯이, [] 연산자는 멤버함수 기반으로만 오버로딩 하도록 제한되어 있다.<br>
[] 연산자 오버로딩 함수는 아래와 같은 형식을 가지고 있다.<br>
int operator[](int idx) { . . . . } //int로 선언된 반환형은 임의로 결정한 것이다. 이는 반환하는 값의 자료형에 따라 달라진다.

<br>
/*아래 문장은 다음과 같이 해석된다*/
arrObject[2]; //arrObject는 객체
//arrObject.operator[](2);

<br>[] 연산자 오버로딩은 오류 발생, 잘못된 접근 등을 개발자가 사전에 제약할 수 있다는 장점이 있다. (ex. out of index).<br><br><br>new 연산자가 하는 일은 다음과 같다.<br>
<br>메모리 공간의 할당
<br>생성자의 호출
<br>할당하고자 하는 자료형에 맞게 반환된 주소 값의 형 변환 -&gt; malloc과 달리 반환하는 주소값을 형변환할 필요가 없음.
<br>이 세 가지 동작 중에서 개발자는 1번에 해당하는 메모리 공간의 할당만 오버로딩 할 수 있다. 나머지 두 가지 작업은 C++ 컴파일러에 의해서 진행이 되며, 오버로딩할 수 있는 대상도 아니다.<br>다음과 같은 형식으로 오버로딩하도록 사전에 약속되어 있다.<br>
/*아래의 기본적인 동작에 사용자가 원하는 동작을 추가적으로 정의한다.*/
void *operator new (size_t size)
{
	void *adr = new char[size];
	return (adr);
}

<br>delete 연산자가 호출되면 다음과 같이 동작한다.<br>
<br>다음의 문장으로 객체의 소멸을 명령하면 delete obj;
<br>컴파일러는 먼저 obj가 가리키는 객체의 소멸자를 호출한다.
<br>그 다음 다음의 형태로 정의된 함수에 ptr에 저장된 주소 값을 전달한다.
<br>
void operator delete (void *adr) { . . . . }

<br>따라서 delete 함수는 최소한 다음의 동작을 포함해야 하며, 그 의외에 필요한 추가적인 내용을 개발자가 추가한다.<br>
void operator delete (void *adr)
{
	delete []adr;
}

<br>참고로, 사용하는 컴파일러에서 void 포인터 형 대상의 delete 연산을 허용하지 않는다면, 위의 delete 문을 다음과 같이 작성하면 된다. 즉, char 포인터 형으로 변환해서 delete 연산을 진행하면 된다.<br>delete []((char *)adr);<br>new 연산자는 멤버함수의 형태로 오버로딩되지만, 아래와 같이 객체가 생성되기도 전에 호출할 수 있다.<br>
Obj *ptr = new Obj(3, 4);

<br>이는 operator new, operator delete 함수는 static 함수이기 때문이다. 멤버함수의 형태로 함수를 작성해도 두 함수는 static 함수로 간주되도록 약속이 되어있다.<br><br>new[], delete[] 함수는 배열 할당, 해제 시 호출되는 함수라는 점만 제외하고 new, delete 함수과 동일하다.<br>
void *operator new[] (size_t size) { . . . . }
void operator delete[] (void *adr) { . . . . }

<br><br><br>포인터를 기반으로 하는 연산자에는 다음이 있다.<br><br>그리고 이 두 연산자의 오버로딩은 아래의 예제와 같이 이루어진다.<br>
#include &lt;iostream&gt;
using namespace std;

class Number
{
	priate :
		int num;
	public :
		Number(int n) : num(n) { }
		void ShowData() {cout&lt;&lt;num&lt;&lt;endl;}
		
		/*객체 자신의 주소 값을 반환하도록 -&gt;연산자를 오버로딩 하고 있다. -&gt; 연산자를 다른 형태로 오버로딩 하는 것도 가능하지만, 이 연산자의 오버로딩을 허용하는 이유는 주소 값의 반환이 목적이기 따문에 다른 형태로는 오버로딩하지 않는 것이 좋다.*/
		Number *operator-&gt;()
		{
			return this;
		}
		/*이 함수는 객체 자신을 참조의 형태로 반환하도록 *연산자를 오버로딩하고 있다.*/
		Number &amp;operator*()
		{
			return *this;*
		}
};

int main(void)
{
	Number num(20);
	num.ShowData();
	
	/*객체 num이 포인터 변수인 것처럼 연산문이 구성되었다. 이는 *,-&gt; 연산자의 오버로딩 결과이다.*/
	(*num) = 30;
	num-&gt;ShowData();
	(*num).ShowData();

	return (0);
}

<br>포인터 연산자 오버로딩을 통해, 기존에 포인터 연산자의 기능에 사용자가 정의한 기능을 추가한 포인터 연산자를 만들 수 있다. 이러한 포인터는 객체의 형태로 구현되며, 스마트 포인터(Smart Pointer)라고 한다.<br><br><br>함수의 호출에 사용하는 () 또한 연산자이다. 때문에 이 역시 오버로딩이 가능하다. () 연산자 오버로딩의 목적은 객체를 함수처럼 사용하는 것이다.<br>() 연산자 오버로딩은 아래의 예제와 같이 이루어진다.<br>
class Functor
{
	public :
	//생략
		void operator()(int a, int b) { /*정의된 동작*/ }
}

int main()
{
	Functor obj;
	obj(2, 4); //obj.operator()(2, 4);와 동일하게 동작함.
}

<br>위와 같이 함수처럼 동작하는 클래스를 가리켜 펑터(functor), 또는 함수 오브젝트(Function Object)라고 한다.<br>펑터는 다음과 같이 응용할 수 있다.<br>
<br>부모 클래스에서 operator()()를 순수 가상함수로 선언한다.
<br>자식 클래스에서 operator()()의 동작을 정의한다.
<br>부모 클래스의 참조형으로 입력을 받는 함수가 있다고, 가정할 때, 다양한 기능을 구현한 자식 클래스들을 그 자리에 입력할 수 있으며, 어떤 자식을 입력하는 지에 따라 동작이 달라진다. 이것이 펑터의 이점이다.
<br><br><br>c++에서는 다음과 같은 코드의 실행이 가능한다.<br>
int main(void)
{
	Number num;
	num = 30; //서로 다른 자료형 간의 대입이 가능하다.
	num.ShowNumber();
	return (0);
}

<br>위 예제에서 num = 30;은 다음과 같이 변환되어 처리된다.<br>
num = Number(30); //1단계. 임시 객체의 생성
num.operator=(Number(30)); //2단계. 임시 객체를 대상으로 하는 대입 연산자의 호출

<br>c++에는 다음과 같은 문법적 기준이 존재한다.<br>A형 객체가 와야 할 위치에 B형 데이터(또는 객체)가 왔을 경우, B형 데이터를 인자로 전달받은 A형 클래스의 생성자 호출을 통해서 A형 임시객체를 생성한다.<br><br><br>형 변환 연산자는 객체가 다른 타입의 데이터와 연산이 일어난 때 호출되는 연산자이다.<br>
아래의 예제를 확인하자.<br>
int main(void)
{
	Number num1(30);
	
	Number num2 = num1 + 20; //서로 다른 자료형 간의 + 연산이 일어남.
	num2.ShowNumber();
	return 0;
}

<br>위의 예제가 실행 가능하려면 아래의 두 가지 방법 중 하나를 사용해야 한다.<br>
<br>int 타입 데이터와의 + 연산이 가능하도록 + 연산자를 오버로딩한다.
<br>Number 객체의 int 자료형으로의 형 변환을 구현한다.
<br>c++ 언어에서는 2번 방법을 구현하기 위해 형 변환 연산자의 오버로딩을 사용한다.<br>
아래와 같이 구현한다.<br>
operator int () // 형 변환 연산자의 오버로딩.
{
	return (num);
}

<br>형 변환 연산자 함수는 아래와 같은 특징을 가진다.<br>
<br>'operator + 형 변환하는 데이터 타입' 형식의 함수명을 가진다.
<br>정의된 데이터 타입으로 형 변환해야 하는 경우에 호출된다.
<br>반환형을 명시하지 않는다. 하지만 return을 사용한 반환은 가능하다. 이 때 return으로 반환되는 값은 정의된 데이터 타입으로 형 변환된다.
<br><br>참고자료<br><a href=".?query=tag:참고도서\윤성우의_열혈_cpp_프로그래밍" class="tag" target="_blank" rel="noopener nofollow">#참고도서/윤성우의_열혈_cpp_프로그래밍</a><br>]]></description><link>resource\language\c++\연산자-오버로딩.html</link><guid isPermaLink="false">resource/Language/C++/연산자 오버로딩.md</guid><pubDate>Sat, 22 Mar 2025 07:31:41 GMT</pubDate><enclosure url="lib\media\디폴트-대입-연산자의-동작(얕은-복사).png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="lib\media\디폴트-대입-연산자의-동작(얕은-복사).png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[예외 처리]]></title><description><![CDATA[<a class="tag" href="?query=tag:language/cpp" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#language/cpp</a> <a class="tag" href="?query=tag:참고도서/윤성우의_열혈_cpp_프로그래밍" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/윤성우의_열혈_cpp_프로그래밍</a> 
 <br><br><a href=".?query=tag:language\cpp" class="tag" target="_blank" rel="noopener nofollow">#language/cpp</a><br>exception handling<br><br><br>C++에서 말하는 예외의 정의는 다음과 같다.<br>프로그램 실행 도중에 발생하는 문제상황<br>
프로그램의 논리에 맞기 않는 상황<br>따라서 문법적인 에러는 예외의 범주에 포함되지 않는다.<br>C에서는 보통 if else문을 사용해 분기를 구성함으로서 이러한 예외들을 처리한다. 그러나 이러한 방식은 예외처리를 위한 코드와 프로그램의 흐름을 구성하는 코드를 쉽게 구분하지 못한다는 문제가 있다. C++은 이러한 문제를 해결하기 위해 별도의 예외 처리 매커니즘을 보유하고 있다.<br><br><br>C++에서 예외 처리를 위한 키워드는 아래의 3가지가 있다.<br><br>
<br>try 블록
<br>try 블록은 예외 발생에 대한 검사의 범위를 지정할 때 사용된다. 즉, try 블록 내에서 예외가 발생하면 이는 C++의 예외처리 매커니즘에 의해서 처리가 된다.<br>
try
{
	// 예외발생 예외지역
}

<br>
<br>catch 블록
<br>catch 블록은 try 블록에서 발생한 예외를 처리하는 코드가 담기는 영역으로서, 그 형태가 마치 반환형 없는 함수와 유사하다.<br>
catch(/*처리할 예외의 종류 명시*/)
{
	// 예외처리 코드의 삽입
}

<br>
<br>사실 try와 catch는 하나의 단위이다.

<br>따라서 항상 이어서 등장해야 하며, 중간에 다른 문장이 오면 안된다.


<br>종합적으로, try 블록 내에서 발생하는 예외는 이어서 등장하는 catch 블록에 의해 처리된다.<br>
<br>throw
<br>키워드 throw는 예외가 발생했음을 알리는 문장의 구성에 사용된다.<br>
throw expn;

<br>최종적으로 try, catch, throw는 다음과 같이 동작한다.<br>
<br>throw에 의해서 '예외 데이터'가 던져진다.
<br>'예외 데이터'를 감싸는 try 블록에 의해 감지된다.
<br>이어서 등장하는 catch 블록이 예외를 처리한다.
<br>구체적인 동작은 아래의 예제를 참고하자.<br>
/*HandlingExceptionTryCatch.cpp*/

#include &lt;iostream&gt;
using namespace std;

int main(void)
{
	int num1, num2;
	cout&lt;&lt;"두 개의 숫자 입력: ";
	cin&gt;&gt;num1&gt;&gt;num2;
	
	try //try 블록으로 에러 발생이 예상되는 영역을 묶는다.
	{
		if (num2 == 0) //에러의 조건
			throw num2; //에러 데이터를 던진다
		//만약 에러가 발생하면 발생 지점 이후의 try 블록은 건너뛴다.
		cout&lt;&lt;"나눗셈의 몫: "&lt;&lt;(num1 / num2)&lt;&lt;endl;
		cout&lt;&lt;"나눗셈의 나머지: "&lt;&lt;(num1 % num2)&lt;&lt;endl;
	}
	catch(int expn) //에러 데이터를 받아 블록 내에서 적절한 예외 처리를 한다.
	{
		cout&lt;&lt;"제수는 "&lt;&lt;expn&lt;&lt;"이 될 수 없습니다."&lt;&lt;endl;
		cout&lt;&lt;"프로그램을 다시 실행하세요."&lt;&lt;endl;
	}
	cout&lt;&lt;"end of main"&lt;&lt;endl;
	
	return (0);
}

<br>
<br>팁 : try 블록 내에서, 에러 발생 시점 이후의 문장들은 건너뛴다는 특성을 잘 활용하자. 에러와 직접적으로 관련이 없더라도 에러 발생 시 실행되면 안되는 문장들은 try 블록 안으로 집어넣는 것이 바람직하다.
<br><br><br>try 블록 내에서 직접적으로 catch가 실행되지 않고, try 내부에서 호출한 함수 내부에서 catch가 실행되는 경우가 있다.<br>
/*PassException.cpp*/

#include &lt;iostream&gt;
using namespace std;

void Divide(int num1, int num2)
{
	if (num2 == 0)
		throw num2; //throw는 try, catch 블록이 없다. 이러한 경우에는 함수를 호출한 곳으로 '예외 데이터'를 던진다.
	cout&lt;&lt;"나눗셈의 몫 : "&lt;&lt; num1 / num2 &lt;&lt;endl;
	cout&lt;&lt;"나눗셈의 나머지 : "&lt;&lt; num % num2 &lt;&lt;endl;
}

int main(void)
{
	int num1, num2;
	cout&lt;&lt;"두 개의 숫자 입력 : ";
	cin&gt;&gt;num1&gt;&gt;num2;
	
	try //try 블록 내에서 throw가 직접적으로 호출되지 않고, Divide 내에서 호출된다.
	{
		Divide(num1, num2);
		cout&lt;&lt;"나눗셈을 마쳤습니다."&lt;&lt;endl;
	}
	catch(int expn)
	{
		cout&lt;&lt;"제수는 "&lt;&lt;expn&lt;&lt;"이 될 수 없습니다."&lt;&lt;endl;
		cout&lt;&lt;"프로그램을 다시 실행하세요."&lt;&lt;endl;
	}
	return (0);
}

<br>위 예제에서 다음의 특성을 알 수 있다.<br>예외가 처리되지 않으면, 예외가 발생한 함수를 호출한 영역으로 예외 데이터가(더불어 예외처리에 대한 책임까지) 전달된다.<br>
함수 내에서 함수를 호출한 영역으로 예외 데이터를 전달하면, 해당 함수는 더 이상 실행되지 않고 종료가 된다.<br>다음과 같이 여러 개의 함수를 걸쳐 '예외 데이터'가 전달되는 케이스를 생각하여보자.<br>
/*StackUnwinding.cpp*/

#include &lt;iostream&gt;
using namespace std;

void SimpleFuncOne(void);
void SimpleFuncTwo(void);
void SimpleFuncThree(void);

int main(void)
{
	try
	{
		SimpleFuncOne();
	}
	catch (int expn)
	{
		cout&lt;&lt;"예외코드: "&lt;&lt;expn&lt;&lt;endl;
	}
	return (0);
}

void SimpleFuncOne(void)
{
	cout&lt;&lt;"SimpleFuncOne(void)"&lt;&lt;endl;
	SimpleFuncTwo();
}
void SimpleFuncTwo(void)
{
	cout&lt;&lt;"SimpleFuncTwo(void)"&lt;&lt;endl;
	SimpleFuncThree();
}
void SimpleFuncThree(void)
{
	cout&lt;&lt;"SimpleFuncThree(void)"&lt;&lt;endl;
	throw -1;
}

<br>만약 예외가 발생할 경우, try catch 문을 만날 때까지 호출된 함수의 역순으로 예외 데이터가 전달된다. 예외 데이터를 전달한 함수는 종료되기 때문에, 호출된 함수의 역순으로 함수의 스택은 반환된다.<br>
이를 스택 풀기(스택의 반환)이라고 명명한다.<br>만약 예외가 처리되지 않아서, 예외 데이터가 main 함수에까지 도달했는데, main 함수에서조차 예외를 처리하지 않으면, terminate 함수(프로그램을 종료시키는 함수)가 호출되면서 프로그램이 종료되어 버린다.<br>만약 throw로 던진 '예외 데이터'의 자료형과 catch 블록 인자의 자료형이 일치하지 않으면, catch 블록으로 예외가 전달되지 않는다. 예외 데이터를 던질 수 있는 다른 영역이 있으면 그 곳으로 예외를 던지고, 그렇지 않으면 terminate 함수로 인해 종료된다.<br><br>throw 키워드로 던질 수 있는 '예외 데이터'의 자료형은 복수일 수 있기 때문에, 다음과 같이 catch 문도 여러 개 존재할 수 있다.<br>
#include &lt;iostream&gt;
using namespace std;

int main()
{
	char c;

	cout&lt;&lt;"값 입력 : ";
	cin&gt;&gt;c;

	try
	{
		if (c == "1")
			throw 1; //int 형을 던짐
		else if(c == "a")
			throw "a"; //char 형을 덤짐
	}
	catch (int expn)
	{
		cout&lt;&lt;"입력값은 int type"&lt;&lt;endl;
	}
	catch (char expn)
	{
		cout&lt;&lt;"입력값은 char type"&lt;&lt;endl;
	}
	cout&lt;&lt;endl&lt;&lt;"end of main"&lt;&lt;endl;
}

<br><br><br>함수 내에서 발생할 수 있는 예외의 종류도 함수의 특징으로 간주된다. 따라서 이미 정의된 특정 함수의 호출을 위해서는 함수의 이름, 매개변수 선언, 반환형 정보에 더해서, 함수 내에서 전달될 수 있는 예외의 종류(예외 데이터의 자료형)과 그 상황도 알아야 한다. 따라서 함수를 정의할 때에는 함수 내에서 발생 가능한 예외의 종류를 다음과 같이 명시해 주는 것이 좋다.<br>
int ThrowFunc(int num) throw (int, char)
{
	// . . . .
}

<br>함수에 사전에 명시한 자료형 이외의 '예외 데이터'를 함수가 반환하면, 역시 terminate(unexpected) 함수의 호출로 인해서 프로그램은 종료된다.<br><br>클래스의 객체 또한 '예외 데이터'가 될 수 있다. 예외 발생을 알리는 데 사용되는 객체를 가리켜 '예외 객체'라 하며, 예외 객체의 생성을 위해 정의된 클래스를 '예외 클래스'라고 한다. 객체를 이용해서 예외 상황을 알리면, 예외가 발생한 원인에 대한 정보를 자세히 담을 수 있다는 장점이 있다.<br>또한, 예외클래스 또한 상속이 가능하며, 이를 통하여 예외의 처리를 더욱 단순화할 수 있다.<br><br><br>try 블록의 뒤를 이어서 등장하는 catch 블록이 둘 이상인 경우, 적절한 catch 블록을 찾는 과정은 다음과 같다.<br>
try
{
	//예외 발생
}
catch(type1 param) //1차 : 이 예외에 타당한 catch 블록인가?
{
	//예외 처리
}
//아니라면
catch(type2 param) //2차 : 이 예외에 타당한 catch 블록인가?
{
	//예외 처리
}
//그것도 아니라면
catch(type3 param) //3ck : 이 예외에 타당한 catch 블록인가?
{
	//예외 처리
}
//다 아니라면 다른 영역으로 전달

<br>따라서 클래스 A가 있고, 클래스 B와 C가 A를 상속한다면 다음과 같이 블록을 짜면 안된다. 첫번째 블록에서 걸리기 때문이다.<br>
try
{}
catch (A param) //B와 C도 A의 일종으로 간주되므로 여기서 걸린다.
{}
catch (B param)
{}
catch (C param)
{}

<br>다음과 같이 구성하는 것이 좋다.<br>
try
{}
catch (C param) //A, B는 여기서 걸리지 않음
{}
catch (B param) //A는 걸리지 않음
{}
catch (A param)
{}

<br><br><br>new 연산에 의한 메모리 공간의 할당이 실패하면 bad_alloc이라는 예외가 발생한다. bad_alloc은 헤더파일 &lt;new&gt;에 선언된 예외 클래스로서 메모리 공간의 할당이 실패헀음을 알리는 의도로 정의되었다. 그럼 이와 관련하여 다음 예제를 보자.<br>
/*BadAlloc.cpp*/

#include &lt;iostream&gt;
#include &lt;new&gt;
using namespace std;

int main(void)
{
	int num = 0;
	
	try
	{
		while (1)
		{
			num++;
			cout&lt;&lt;num&lt;&lt;"번째 할당 시도"&lt;&lt;endl;
			new int[10000][10000];
		}
	}
	catch(bad_alloc &amp;bad)
	{
		cout&lt;&lt;bad.what()&lt;&lt;endl;
		cout&lt;&lt;"더 이상 할당 불가!"&lt;&lt;endl;
	}
	return (0);
}

<br><br><br>catch 블록에 전달된 예외는 다시 던져질 수 있다. 그리고 이로 인해서 하나의 예외가 둘 이상의 catch 블록에 의해서 처리되게 할 수 있다.<br>
/*ReThrow.cpp*/

#include &lt;iostream&gt;
using namespace std;

void Divide(int num1, int num2)
{
	try
	{
		if (num2 == 0)
			throw (0);
		cout&lt;&lt;"몫: "&lt;&lt;(num1 / num2)&lt;&lt;endl;
		cout&lt;&lt;"나머지: "&lt;&lt;(num1 % num2)&lt;&lt;endl;
	}
	catch (int expn)
	{
		cout&lt;&lt;"first catch"&lt;&lt;endl;
		throw; //예외를 다시 던진다.
	}
}

int main(void)
{
	try
	{
		Divide(9, 2);
		Divide(4, 0);
	}
	catch (int expn)
	{
		cout&lt;&lt;"second catch"&lt;&lt;endl;
	}
	return (0);
} 

<br><br><br><a data-tooltip-position="top" aria-label="형 변환" data-href="형 변환" href="resource\language\c++\형-변환.html" class="internal-link" target="_self" rel="noopener nofollow">dynamic_cast</a>를 이용한 형 변환 중, 다음의 경우 bad_cast 예외가 발생한다.<br>
<br>변환 대상이 실제로 가리키는 객체의 자료형과, 변환 대상의 변환 후 자료형이 다를 경우
<br>변환 대상의 자료형이 포인터가 아니라 참조형이어서 dynamic_cast가 NULL을 반환할 수 없는 경우
<br>구체적인 동작은 아래의 예제를 참고하자<br>
/*DynamicBadCastRef.cpp*/

#include &lt;iostream&gt;
using namespace std;

class SoSimple
{
	public :
		virtual void ShowSimpleInfo()
		{
			cout&lt;&lt;"SoSimple Base Class"&lt;&lt;endl;
		}
};

class SoComplex : public SoSimple
{
	public :
		void ShowSimpleInfo()
		{
			cout&lt;&lt;"SoComplex Derived Class"&lt;&lt;endl;
		}
};

int main(void)
{
	SoSimple simObj;
	SoSimple &amp;ref = simObj;
	
	try
	{
		SoComplex &amp;comRef = dynamic_cast&lt;SoComplex &amp;&gt;(ref); //bad_cast 예외 발생
		comRef.ShowSimpleInfo();
	}
	catch(bad_cast expt)
	{
		cout&lt;&lt;expt.what()&lt;&lt;endl;
	}
	return (0);
}

<br><br>참고자료<br><a href=".?query=tag:참고도서\윤성우의_열혈_cpp_프로그래밍" class="tag" target="_blank" rel="noopener nofollow">#참고도서/윤성우의_열혈_cpp_프로그래밍</a><br>]]></description><link>resource\language\c++\예외-처리.html</link><guid isPermaLink="false">resource/Language/C++/예외 처리.md</guid><pubDate>Sat, 22 Mar 2025 07:31:42 GMT</pubDate></item><item><title><![CDATA[이름공간]]></title><description><![CDATA[<a class="tag" href="?query=tag:language/cpp" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#language/cpp</a> <a class="tag" href="?query=tag:참고도서/윤성우의_열혈_cpp_프로그래밍" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/윤성우의_열혈_cpp_프로그래밍</a> 
 <br><br><a href=".?query=tag:language\cpp" class="tag" target="_blank" rel="noopener nofollow">#language/cpp</a> <br>namespace<br><br>'이름공간'이란 특정 영역에 이름을 붙여주기 위한 문법적 요소이다.<br>이름공간의 등장 배경<br>여러 명이서 협업을 하는 규모가 큰 프로젝트가 있다고 가정하자. 만약 불운하게 개발자들이 만든 함수들의 이름이 서로 같다면 컴파일 에러가 날 것이다. 서로 같은 이름을 가진 함수라도 서로 다른 영역에 있음을 규정할 수 있다면 컴파일 에러를 막을 수 있을 것이다. 이러한 전제 하에 이름공간의 개념이 등장하게 되었다.<br>이름공간은 아래 예제와 같이 사용될 수 있다.<br>
#include &lt;iostream&gt;

namespace BestComImpl
{
	void SimpleFunc(void)
	{
		std::cout&lt;&lt;"BestCom이 정의한 함수"&lt;&lt;std::endl;
	}
}

namespace ProgComImpl
{
	void SimpleFunc(void)
	{
		std::cout&lt;&lt;"ProgCom이 정의한 함수"&lt;&lt;std::endl;
	}
}

int main(void)
{
	BestComImpl::SimpleFunc();
	ProgComImpl::SimpleFunc();

	return 0;
}

<br>함수를 호출할 때 <a data-href="범위지정 연산자" href="resource\language\c++\범위지정-연산자.html" class="internal-link" target="_self" rel="noopener nofollow">범위지정 연산자</a> ::을 사용해 어느 이름공간의 함수를 호출하는지 정의할 수 있다.<br>이름공간은 다음과 같은 특징을 지닌다.<br>
<br>이름공간에 속한 함수의 원형을 선언할 때는 아래와 같은 형식을 취한다.
<br>
#include &lt;iostream&gt;

namespace BestComImpl
{
	void SimpleFunc(void); //함수의 원형
}

namespace ProgComImpl
{
	void SimpleFunc(void);
}

int main(void)
{
	BestComImpl::SimpleFunc();
	ProgComImpl::SimpleFunc();
	
	return 0;
}

void BestComImpl::SimpleFunc(void) //함수의 정의
{
	std::cout&lt;&lt;"BestCom이 정의한 함수"&lt;&lt;std::endl;
}

void ProgComImpl::SimpleFunc(void)
{
	std::cout&lt;&lt;"ProgCom이 정의한 함수"&lt;&lt;std::endl;
}

<br>
<br>동일한 이름공간에 정의된 함수를 호출할 때는 이름공간을 명시할 필요가 없다.
<br>
#include &lt;iostream&gt;

namespace BestComImpl
{
	void SimpleFunc(void);
}

namespace BestComImpl
{
	void PrettyFunc(void);
}

namespace ProgComImpl
{
	void SimpleFunc(void);
}

int main(void)
{
	BestComImpl::SimpleFunc();
	return 0;
}

void BestComImpl::SimpleFunc(void)
{
	std::cout&lt;&lt;"BestCom이 정의한 함수"&lt;&lt;std::endl;
	PrettyFunc(); //동일한 이름공간의 함수를 호출할 떄는 범위 지정 연산자가 불필요
	ProgComImpl::SimpleFunc();
}

void BestComImpl::PrettyFunc(void)
{
	std::cout&lt;&lt;"So Pretty!!"&lt;&lt;std::endl;
}

void ProgComImpl::SimpleFunc(void)
{
	std::cout&lt;&lt;"ProgCom이 정의한 함수"&lt;&lt;std::endl;
}

<br>
<br>이름공간은 다른 이름공간 안에 삽입될 수 있다. 이러한 특성을 이름공간의 중첩이라 한다.
<br>
#include &lt;iostream&gt;

namespace Parent
{
	int num=2;

	namespace SubOne //이름 공간의 중첩
	{
		int num=3;
	}
	
	namespace SubTwo
	{
		int num=4;
	}
}

int main(void)
{
	//아래와 같은 형태로 호출한다.
	std::cout&lt;&lt;Parent::num&lt;&lt;std::endl;
	std::cout&lt;&lt;Parent::SubOne::num&lt;&lt;std::endl;
	std::cout&lt;&lt;Parent::SubTwo::num&lt;&lt;std::endl;
}

<br>
<br>이름공간이 과다하게 중첩되었을 때 별칭을 지정하여 코드를 축약할 수 있다.
<br>
#include &lt;iostream&gt;

using namespace std;

namespace AAA
{
	namespace BBB
	{
		namespace CCC
		{
			int num1;
			int num2;
		}
	}
}

int main(void)
{
	AAA::BBB::CCC::num1=20;
	AAA::BBB::CCC::num2=30;

	namespace ABC=AAA::BBB::CCC; //이와 같은 형식으로 축약할 수 있다.
	cout&lt;&lt;ABC::num1&lt;&lt;endl;
	cout&lt;&lt;ABC::num2&lt;&lt;endl;
	return 0;
}

<br>
<br>using 키워드를 사용하면 범위지정 연산자를 생략할 수 있다. 함수 안에서 사용된 using 키워드는 지역변수와 같이 함수 안에서만 효력을 가진다. 프로그램 전체에 영향을 끼치려면 전역변수와 마찬가지로 함수 밖에 선언을 해야 한다. using 키워드를 namespace 전체에 적용하면 해당 namespace의 요소 모두를 범위지정 연산자를 생략하여 사용할 수 있다. 하지만 이름충돌의 위험이 증가함으로 상황을 고려해 알맞게 사용해야 한다.
<br>
#include &lt;iostream&gt;

namespace Hybrid
{
	void HybFunc(void)
	{
		std::cout&lt;&lt;"So simple function!"&lt;&lt;std::endl;
		std::cout&lt;&lt;"In namespace Hybrid!"&lt;&lt;std::endl;
	}
}

int main(void)
{
	using Hybrid::HybFunc;
	HybFunc(); //using 키워드가 선언된 함수에 한하여 ::생략
	return 0;
}

<br>
#include &lt;iostream&gt;

using std::cin; //프로그램 전체에 using 키워드 적용
using std::cout;
using std::endl;

int main(void)
{
	int num=20;
	cout&lt;&lt;"Hello World!"&lt;&lt;endl;
	cout&lt;&lt;"Hello "&lt;&lt;"World!"&lt;&lt;endl;
	cout&lt;&lt;num&lt;&lt;' '&lt;&lt;'A';
	cout&lt;&lt;' '&lt;&lt;3.14&lt;&lt;endl;
	return 0;
}

<br>
#include &lt;iostream&gt;

using namespace std; //using 키워드를 이름공간 전체에 적용

int main(void)
{
	int num=20;
	cout&lt;&lt;"Hello World!"&lt;&lt;endl;
	cout&lt;&lt;"Hello "&lt;&lt;"World!"&lt;&lt;endl;
	cout&lt;&lt;num&lt;&lt;' '&lt;&lt;'A';
	cout&lt;&lt;' '&lt;&lt;3.14&lt;&lt;endl;
	return 0;
}

<br><br>참고자료<br><a href=".?query=tag:참고도서\윤성우의_열혈_cpp_프로그래밍" class="tag" target="_blank" rel="noopener nofollow">#참고도서/윤성우의_열혈_cpp_프로그래밍</a><br>]]></description><link>resource\language\c++\이름공간.html</link><guid isPermaLink="false">resource/Language/C++/이름공간.md</guid><pubDate>Sat, 22 Mar 2025 07:31:42 GMT</pubDate></item><item><title><![CDATA[인라인 함수]]></title><description><![CDATA[<a class="tag" href="?query=tag:language/cpp" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#language/cpp</a> <a class="tag" href="?query=tag:참고도서/윤성우의_열혈_cpp_프로그래밍" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/윤성우의_열혈_cpp_프로그래밍</a> 
 <br><br><a href=".?query=tag:language\cpp" class="tag" target="_blank" rel="noopener nofollow">#language/cpp</a> <br>inline function<br><br>인라인 함수를 의역하면, '프로그램 코드라인 안으로 들어가 버린 함수'라는 뜻이다. c 언어의 매크로 함수는 함수의 몸체 부분이 함수의 호출문을 완전히 대체하므로, 인라인 함수의 정의와 일맥상통하는 부분이 있다.<br>매크로 함수의 장점은 아래와 같다.<br>
<br>일반적인 함수에 비해 실행속도의 이점이 있다.
<br>자료형의 제한이 없다
<br>매크로 함수의 단점은 아래와 같다.<br>
<br>정의하기가 어렵다.
<br>복잡한 함수를 매크로의 형태로 정의하는 데 한계가 있다.
<br>인라인 함수는 매크로 함수의 장점을 취하고 단점은 제거하기 위해 만들어진 개념이다.<br>
인라인 함수는 키워드 inline을 사용해 아래와 같이 선언된다.<br>
#include &lt;iostream&gt;

inline int SQUARE(int x) //인라인 함수의 몸체 부분은 호출문을 대체한다.
{
	return x*x;
}

int main(void)
{
	std::cout&lt;&lt;SQUARE(5)&lt;&lt;std::endl;
	std::cout&lt;&lt;SQUARE(12)&lt;&lt;std::endl;

	return 0;
}

<br>단, 인라인 함수는 매개변수의 자료형을 정의해야 하므로 매크로 함수의 모든 장점을 가질 수는 없다. <a data-href="템플릿" href="resource\language\c++\템플릿.html" class="internal-link" target="_self" rel="noopener nofollow">템플릿</a>과 인라인 함수를 같이 사용하면 이러한 한계를 극복할 수 있다.<br>매크로를 이용한 함수의 인라인화는 전처리기에 의해 처리되지만, 키워드 inline을 이용한 함수의 인라인화는 컴파일러에 의해 처리된다. 따라서 함수의 인라인화가 오히려 성능에 해가 된다고 판단할 경우, 컴파일러는 이 키워드를 무시해버리기도 한다. 또한 컴파일러는 필요한 경우 일부 함수를 임의로 인라인 처리하기도 한다.<br>또한 키워드 inline을 이용한 함수의 인라인화는 컴파일러에 의해 처리되기 때문에, 인라인 함수의 원형 선언과 정의는 같은 파일 안에 위치하여 컴파일러가 동시에 참조할 수 있게 해야 한다.<br><br>참고자료<br><a href=".?query=tag:참고도서\윤성우의_열혈_cpp_프로그래밍" class="tag" target="_blank" rel="noopener nofollow">#참고도서/윤성우의_열혈_cpp_프로그래밍</a><br>]]></description><link>resource\language\c++\인라인-함수.html</link><guid isPermaLink="false">resource/Language/C++/인라인 함수.md</guid><pubDate>Sat, 22 Mar 2025 07:31:42 GMT</pubDate></item><item><title><![CDATA[임시 객체]]></title><description><![CDATA[<a class="tag" href="?query=tag:language/cpp" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#language/cpp</a> <a class="tag" href="?query=tag:참고도서/윤성우의_열혈_cpp_프로그래밍" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/윤성우의_열혈_cpp_프로그래밍</a> 
 <br><br><a href=".?query=tag:language\cpp" class="tag" target="_blank" rel="noopener nofollow">#language/cpp</a> <br>temporary object<br><br>함수의 반환형이 <a data-href="클래스" href="resource\language\c++\클래스.html" class="internal-link" target="_self" rel="noopener nofollow">클래스</a>이고, 함수가 값을 반환할 때, 메모리 공간에 임시로 객체를 생성하여 반환을 받는 쪽이 참조할 수 있도록 한다. 이를 임시 객체라고 한다.<br>임시 객체는 개발자가 다음과 같은 형식으로 직접 선언할 수도 있다.<br>
Temporary(200); //클래스명(생성자에게 전달할 인자); 형식

<br>외부에서 객체의 멤버함수를 호출하기 위해 필요한 것은 다음 세 가지 중 하나이다.<br>
<br>객체에 붙여진 이름
<br>객체의 참조 값(객체 참조에 사용되는 정보)
<br>객체의 주소 값
<br>임시객체가 생성된 위치에는 임시객체의 참조 값이 반환되므로, 다음과 같이 임시객체의 멤버함수에 접근할 수 있다.<br>
Temporart(200).ShowTempInfo(); //(임시객체의 참조 값).ShowTempInfo();

<br>
//SimpleFuncObj는 객체를 반환 -&gt; 해당 위치에 임시 객체의 참조값을 생성

SimpleFuncObj(obj).AddNum(30);

<br>임시 객체는 다음과 같은 특징을 가진다.<br>
<br>임시 객체는 다음 행으로 넘어가면 바로 소멸되어 버린다. 이후에 임시 객체를 참조할 수단이 없기 때문이다.
<br>참조자에 의해 참조되는 임시객체는 바로 소멸하지 않는다.
<br>2번 특성에 의하여, 아래 예제는 다음과 같이 해석된다.<br>
SoSimple tempRef = SimpleFuncObj(obj);

<br>위 예제는 다음과 같이 오인되기 쉽다.
-&gt; tempRef라는 새로운 객체를 생성해서, 반환되는 객체를 가지고 대입연산(복사)를 진행한다.
하지만 실제 구문은 다음과 같이 해석된다.
-&gt; 추가로 객체를 생성하지 않고, 반환되는 임시 객체에 tempRef라는 이름을 할당한다. 이는 객체의 생성 수를 하나 줄여서 효율성을 높이기 위해서이다.
<br><br>참고자료<br><a href=".?query=tag:참고도서\윤성우의_열혈_cpp_프로그래밍" class="tag" target="_blank" rel="noopener nofollow">#참고도서/윤성우의_열혈_cpp_프로그래밍</a><br>]]></description><link>resource\language\c++\임시-객체.html</link><guid isPermaLink="false">resource/Language/C++/임시 객체.md</guid><pubDate>Sat, 22 Mar 2025 07:31:42 GMT</pubDate></item><item><title><![CDATA[자료형]]></title><description><![CDATA[<a class="tag" href="?query=tag:language/cpp" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#language/cpp</a> <a class="tag" href="?query=tag:참고도서/포르잔_cpp_바이블" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/포르잔_cpp_바이블</a> 
 <br><br><a href=".?query=tag:language\cpp" class="tag" target="_blank" rel="noopener nofollow">#language/cpp</a> <br>data types<br><br><br>c++ 프로그램은 데이터를 효율적으로 조작하고자 자료를 형태에 따라 구분하며 이렇게 구분해서 인식하는 자료의 형태를 자료형 data types라고 한다.<br>자료형은 크게 내장 자료형과 사용자 정의 자료형으로 나뉜다.<br>내장 자료형 built-in types은 프로그래밍 언어에 정의된 자료형이다. 내장 자료형은 기본 자료형 fundamentals과 복합 자료형 compound types으로 구분한다. 기본 자료형은 이름 그대로 기본적인 자료형이고, 복합 자료형은 기본 자료형을 기반으로 파생된 자료형이다.<br>사용자 정의 자료형 user-defined types은 열거형 enumerated과 클래스 class로 구분한다.<br><br>자료형의 범위는 플랫폼에 따라서 다르다. 예를 들어, long int는 어떤 시스템에서는 4 byte이고 어떤 시스템에서는 8 byte이다. 아래의 표는 일반적인 플랫폼에서의 정수 자료형 범위이다.<br><br><br>원래 c++에 정의되어 있는 문자 자료형의 크기는 1바이트이며 부호가 없다. 하지만 현대에는 1, 2, 4바이트이거나 부호 있는 문자도 있다. 이는 c++ 언어가 세계의 여러 문자를 지원하기 위해 변경된  것이다.<br>이 문서에서는 문자 자료형이 ASCII 인코딩 시스템을 기반으로 하는 1바이트 정수 자료형이라고 가정한다. ASCII 인코딩 시스템은 0 ~ 127 범위의 정수를 사용해서 128개의 글자를 정의한다.<br><br>참 true 또는 거짓 false을 나타내기 위한 1바이트 자료형.<br>c++ 언어는 불 또한 정수를 이용해서 다룬다. 0은 false, 0이 아닌 값은 true로 취급한다.<br><br>소수점을 갖는 숫자를 다루는 자료형.<br><br>void 자료형은 값이 없음을 나타내는 특별한 자료형이다. 주로 '함수가 어떠한 값도 반환하지 않는다'를 나타내기 위해 사용한다.<br><br>참고자료<br><a href=".?query=tag:참고도서\포르잔_cpp_바이블" class="tag" target="_blank" rel="noopener nofollow">#참고도서/포르잔_cpp_바이블</a> <br>]]></description><link>resource\language\c++\자료형.html</link><guid isPermaLink="false">resource/Language/C++/자료형.md</guid><pubDate>Sat, 22 Mar 2025 07:31:42 GMT</pubDate></item><item><title><![CDATA[접근제어 지시자]]></title><description><![CDATA[<a class="tag" href="?query=tag:language/cpp" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#language/cpp</a> <a class="tag" href="?query=tag:참고도서/윤성우의_열혈_cpp_프로그래밍" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/윤성우의_열혈_cpp_프로그래밍</a> 
 <br><br><a href=".?query=tag:language\cpp" class="tag" target="_blank" rel="noopener nofollow">#language/cpp</a> <br>access control modifier<br><br>c++ 언어는 구조체 및 클래스의 멤버 변수 및 멤버 함수의 접근 허용범위를 접근제어 지시자를 통해 별도로 지정할 수 있다.<br>접근제어 지시자는 다음과 같이 총 세가지가 존재한다.<br><br><br>참고자료<br><a href=".?query=tag:참고도서\윤성우의_열혈_cpp_프로그래밍" class="tag" target="_blank" rel="noopener nofollow">#참고도서/윤성우의_열혈_cpp_프로그래밍</a><br>]]></description><link>resource\language\c++\접근제어-지시자.html</link><guid isPermaLink="false">resource/Language/C++/접근제어 지시자.md</guid><pubDate>Sat, 22 Mar 2025 07:31:42 GMT</pubDate></item><item><title><![CDATA[정보은닉]]></title><description><![CDATA[<a class="tag" href="?query=tag:language/cpp" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#language/cpp</a> <a class="tag" href="?query=tag:참고도서/윤성우의_열혈_cpp_프로그래밍" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/윤성우의_열혈_cpp_프로그래밍</a> 
 <br><br><a href=".?query=tag:language\cpp" class="tag" target="_blank" rel="noopener nofollow">#language/cpp</a> <br><br><a data-href="클래스" href="resource\language\c++\클래스.html" class="internal-link" target="_self" rel="noopener nofollow">클래스</a> 또는 <a data-href="구조체" href="resource\language\c++\구조체.html" class="internal-link" target="_self" rel="noopener nofollow">구조체</a>의 멤버변수를 <a data-tooltip-position="top" aria-label="접근제어 지시자" data-href="접근제어 지시자" href="resource\language\c++\접근제어-지시자.html" class="internal-link" target="_self" rel="noopener nofollow">private</a>으로 선언하고, 해당 변수에 접근하는 함수를 별도로 정의해서, 안전한 형태로 멤버변수의 접근을 유도하는 것.<br><br>참고자료<br><a href=".?query=tag:참고도서\윤성우의_열혈_cpp_프로그래밍" class="tag" target="_blank" rel="noopener nofollow">#참고도서/윤성우의_열혈_cpp_프로그래밍</a><br>]]></description><link>resource\language\c++\정보은닉.html</link><guid isPermaLink="false">resource/Language/C++/정보은닉.md</guid><pubDate>Sat, 22 Mar 2025 07:31:42 GMT</pubDate></item><item><title><![CDATA[조정자]]></title><description><![CDATA[<a class="tag" href="?query=tag:language/cpp" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#language/cpp</a> <a class="tag" href="?query=tag:참고도서/포르잔_cpp_바이블" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/포르잔_cpp_바이블</a> 
 <br><br><a href=".?query=tag:language\cpp" class="tag" target="_blank" rel="noopener nofollow">#language/cpp</a><br>manipulator<br><br><br>일반적으로 c++ 언어에서 데이터 입출력 시 표준 형식 standard format으로 값을 입출력한다.<br>하지만 상황에 따라서 이러한 입출력 형식을 바꿔야 할 때가 있다. 이를 위해 조정자 manipulator라는 객체를 사용한다. 조정자는 크게 데이터 출력을 위한 조정자와 데이터 입력을 위한 조정자로 구분할 수 있다.<br><br>출력 조정자는 크게 매개변수가 없는 조정자와 매개변수가 있는 조정자로 나뉜다.<br><br>매개변수가 필요 없는 조정자는 &lt;iostream&gt;에 정의되어있다.<br>endl을 제와한 모든 조정자는 출력 스트림의 상태를 변경해서 1회 사용하면 이후에 다른 조정자를 사용하기 전까지 계속해서 조정자가 적용된다. 즉, 1회만 지정하면 계속해서 적용된다.<br><br>endl 조정자를 사용하면 개행을 추가하여 출력한다.<br><br>기본값 : noboolalpha<br>noboolalpha 조정자는 불 값을 정수(0 또는 1)로 출력한다. boolalpha는 불 값을 리터럴(false 또는 true)로 출력한다.<br><br>기본값 : dec<br>정수를 몇 진법으로 출력할지 결정하는 조정자이다.<br>
<br>dec : 10진법
<br>oct : 8진법
<br>hex : 16진법
<br><br>기본값 : noshowbase<br>숫자를 다른 진법으로 출력할 때, 어떤 진법으로 출력하고 있는지 나타내는 접두사를 지정하는 조정자이다. 10진수는 아무 것도 붙지 않고, 8진수는 0, 16진수는 0x가 접두사로 붙어서 각각의 진법을 나타낸다.<br><br>기본값 : fixed<br>부동 소수점 자료형을 출력할 때는 고정 소수점 fixed format을 사용하는 방법과 과학 scientific 표기법을 사용하는 2가지 방법이 있다.<br><br>기본값: showpoint<br>c++는 기본적으로 소수점 아래 부분이 0일 때 소수점 아래 부분을 출력하지 않는다. 하지만 showpoint 조정자를 사용하면 소수점 아래 부분이 0일 때에도 출력한다.<br><br>기본값 : noshowpos<br>c++는 숫자가 양수일 때 양수 부호(+)를 출력하지 않는다. 음수 부호만 출력된다. showpos 조정자를 사용하면 양수일 때도 양수 기호를 출력한다.<br><br>기본값 :  nouppercase<br>16진수로 정수를 출력할 때 알파벳(a, b, c, d, e, f) 등이 출력되고 부동 소수정의 과학 표기법 때도 알파벳 e가 출력된다. 이러한 문자는 기본적으로 소문자로 출력된다. 이를 대문자로 변경할 때는 uppercase 조정자를 사용한다.<br><br>후술할 매개변수가 있는 조정자를 사용하여 정해진 크기의 영역 field에 값을 출력하는 방법을 다룬다. 정해진 크기의 영역을 잡고 나면 left, right, internal 조정자를 사용해서 숫자를 배치하는 형식을 정할 수 있다.<br><br>매개변수가 있는 조정자의 경우 사용하기 위해 &lt;iomanip&gt; 헤더를 읽어들여야 한다.<br><br>setprecision 조정자는 고정 소수점 출력 방식(과학 표기법 출력 방식 제외)에서만 사용한다. 괄호 안의 정수(n)로 소수점 뒤의 몇 자리까지 출력할지를 지정한다.<br><br>setw 조정자도 고정 소수점 출력 방식(과학 표기법 출력 방식 제외)에서만 사용된다. 괄호 안의 정수(n)은 전체 필드 크기를 의미하고, 이때 필드 크기는 정수 부분, 소수점, 소수점 아래 부분을 모두 합친 길이이다. 참고로 setw 조정자는 출력 스트림의 상태를 변경하지 않는다. 따라서 필요할 때마다 사용해야 한다. setw 조정자를 제외하고 매개변수가 있는 조정자는 출력스트림의 상태를 변경한다.<br><br>setfill 조정자는 필드의 크기가 실제 출력되는 내용보다 클 때 발생하는 패딩을 어떤 문자로 채울지 지정할 때 사용한다. 괄호 안에는 리터럴 문자를 넣는다. 이전에 설명한 조정자(left, interval, right, setw)들과 조합하여 사용한다.<br><br><br>기본값 : noboolalpha<br>불을 0과 1이 아니라, true와 false 문자열로 입력할 수 있는 조정자이다.<br><br>기본값 : dec<br>정수 입력을 10진법, 8진법, 16진법으로 입력할 수 있게 설정하는 조정자이다.<br><br>참고자료<br><a href=".?query=tag:참고도서\포르잔_cpp_바이블" class="tag" target="_blank" rel="noopener nofollow">#참고도서/포르잔_cpp_바이블</a> <br>]]></description><link>resource\language\c++\조정자.html</link><guid isPermaLink="false">resource/Language/C++/조정자.md</guid><pubDate>Sat, 22 Mar 2025 07:31:42 GMT</pubDate></item><item><title><![CDATA[참조자]]></title><description/></item><item><title><![CDATA[obsidian]]></title><description><![CDATA[ 
 <br><br>옵시디언 동기화를 위한 저장소]]></description><link>readme.html</link><guid isPermaLink="false">README.md</guid><pubDate>Sat, 22 Mar 2025 07:44:34 GMT</pubDate></item></channel></rss>