<rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><parsererror xmlns="http://www.w3.org/1999/xhtml" style="display: block; white-space: pre; border: 2px solid #c77; padding: 0 1em 0 1em; margin: 1em; background-color: #fdd; color: black"><h3>This page contains the following errors:</h3><div style="font-family:monospace;font-size:12px">error on line 2736 at column 431: Invalid bytes in character encoding
</div><h3>Below is a rendering of the page up to the first error.</h3></parsererror><channel><title><![CDATA[obsidian]]></title><description><![CDATA[Obsidian digital garden]]></description><link>http://github.com/dylang/node-rss</link><image><url>lib\media\favicon.png</url><title>obsidian</title><link/></image><generator>Webpage HTML Export plugin for Obsidian</generator><lastBuildDate>Wed, 28 May 2025 17:15:48 GMT</lastBuildDate><atom:link href="lib\rss.xml" rel="self" type="application/rss+xml"/><pubDate>Wed, 28 May 2025 17:15:12 GMT</pubDate><ttl>60</ttl><dc:creator/><item><title><![CDATA[2FA]]></title><description><![CDATA[<a class="tag" href="?query=tag:security" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#security</a> <a class="tag" href="?query=tag:web" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#web</a> 
 <br><br><a href=".?query=tag:security" class="tag" target="_blank" rel="noopener nofollow">#security</a> <a href=".?query=tag:web" class="tag" target="_blank" rel="noopener nofollow">#web</a><br>2단계 인증<br><br><a data-tooltip-position="top" aria-label="https://www.entrust.com/ko/resources/learn/what-is-two-factor-authentication" rel="noopener nofollow" class="external-link" href="https://www.entrust.com/ko/resources/learn/what-is-two-factor-authentication" target="_blank">참고 링크 1</a><br>
<a data-tooltip-position="top" aria-label="https://www.microsoft.com/ko-kr/security/business/security-101/what-is-two-factor-authentication-2fa" rel="noopener nofollow" class="external-link" href="https://www.microsoft.com/ko-kr/security/business/security-101/what-is-two-factor-authentication-2fa" target="_blank">참고 링크 2</a><br>
<a data-tooltip-position="top" aria-label="https://80000coding.oopy.io/bf6a038e-9f4b-43a7-96dd-c9ee22d9d9f6" rel="noopener nofollow" class="external-link" href="https://80000coding.oopy.io/bf6a038e-9f4b-43a7-96dd-c9ee22d9d9f6" target="_blank">트센 프로젝트 관련 자료</a>]]></description><link>public\2fa.html</link><guid isPermaLink="false">public/2FA.md</guid><pubDate>Mon, 20 Jan 2025 10:10:19 GMT</pubDate></item><item><title><![CDATA[42 innercirle 정리]]></title><description><![CDATA[<a class="tag" href="?query=tag:42Seoul" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#42Seoul</a> 
 <br><a href=".?query=tag:42Seoul" class="tag" target="_blank" rel="noopener nofollow">#42Seoul</a> <br><br>그동안 수행했던 개발자 교육과정 42 서울의 공통 과정 과제들을  정리한 저장소입니다.<br><br><br>
<br>각 폴더마다 컴파일을 위한 Makefile이 존재하지만, 이미 make된 상태로 푸시하였으므로 별도로 Makefile을 실행시키지 않아도 됩니다.
<br>NetPractice, Born2beroot는 42 서울의 인트라넷에서만 테스트 가능한 과제이므로 별도의 실행 가능한 파일을 올리지 않은 점 양해 바랍니다다.
<br><br>C 기초<br>strlcpy, strlcat 같은 c 라이브러리의 함수들을 직접 구현해보는 과제<br><br>파일 입출력, static 변수<br>다음의 기능과 형식을 가진 get_next_line이라는 함수를 만드는 과제<br>
// 입력값 : 파일 디스크립터
// 반환값 : 파일로부터 문장 하나를 추출하여 반환.
// n번째로 get_next_line을 호출하면 파일의 n번째 문장을 반환한다.
char *get_next_line(int fd);

<br>/42_innercircle_course/get_next_line/ 경로의 tester.c 파일을 참조하여 tester 파일을 실행시키면 get_next_line의 동작을 확인할 수 있다.<br><br>가변 인자<br>VA_ARG를 활용하여 c 라이브러리의 printf의 기능을 제한적으로(type, flag, precision의 가짓수가 제한되어 있음) 구현하는 과제<br>/42_innercircle_course/ft_printf/ 경로의 tester.c 파일을 참조하여 tester 파일을 실행시키면 ft_printf의 동작을 확인할 수 있다.<br><br>가상 머신, 리눅스 기초<br>VirtualBox를 사용하여 linux 가상 환경을 띄운 후, 그 환경에서 여러 서비스들을 설정하는 과제<br><br>멀티 프로세싱, 프로세스 간 통신<br>fork, pipe 시스템 콜을 활용하여 쉘의 파이프 기능을 구현해보는 과제<br>
&lt; infile ls -l | wc -l &gt; outfile

<br>위와 같은 쉘의 파이프 기능을 아래와 같은 형식으로 구현한다.<br>
./pipex infile "ls -l" "wc -l" outfile

<br>2개 이상의 명령어를 이을 수도 있다.<br>
&lt; infile cmd1 | cmd2 | cmd3 | ... | cmdn &gt; outfile

<br>
./pipex infile cmd1 cmd2 cmd3 ... cmdn outfile

<br>heredoc 기능을 사용할 수도 있다.<br>
cmd &lt;&lt; LIMITER | cmd1 &gt;&gt; file

<br>
./pipex here_doc LIMITER cmd cmd1 file

<br><br>자료구조, 알고리즘<br>두 개의 스택을 사용하여 뒤섞인 숫자 배열을 정렬하는 과제<br>다음과 같은 조건 하에 문제를 해결해야 한다.<br>
<br>스택 a, 스택 b 총 두 개의 스택이 있다.
<br>입력받은 뒤섞인 숫자 배열은 스택 a에 위치한다.
<br>후술할 스택의 동작들을 활용하여 최종적으로 스택 a에 숫자들이 정렬되도록 한다.
<br>이 과제에서 제시하는 스택은 일반적인 스택과 달리 다음의 추가적인 동작들을 적용할 수 있다(사실 말이 스택이지 별도의 자료구조라 보는 게 무방하다).<br>
<br>sa (swap a): 스택 a의 맨 위 두 개 요소를 바꾼다. 요소가 하나 이하일 때는 아무것도 하지 않는다.
<br>sb (swap b): 스택 b의 맨 위 두 개 요소를 바꾼다. 요소가 하나 이하일 때는 아무것도 하지 않는다.
<br>ss: sa와 sb를 동시에 한다.
<br>pa (push a): 스택 b의 맨 위 요소를 꺼내서 스택 a의 맨 위에 넣는다. 만약 스택 b가 비어 있으면 아무것도 하지 않는다.
<br>pb (push b): 스택 a의 맨 위 요소를 꺼내서 스택 b의 맨 위에 넣는다. 만약 스택 a가 비어 있으면 아무것도 하지 않는다.
<br>ra (rotate a): 스택 a의 모든 요소를 위로 1칸씩 이동시킨다. 첫 번째 요소가 마지막 요소가 된다.
<br>rb (rotate b): 스택 b의 모든 요소를 위로 1칸씩 이동시킨다. 첫 번째 요소가 마지막 요소가 된다.
<br>rr: ra와 rb를 동시에 한다.
<br>rra (reverse rotate a): 스택 a의 모든 요소를 아래로 1칸씩 이동시킨다. 마지막 요소가 첫 번째 요소가 된다.
<br>rrb (reverse rotate b): 스택 b의 모든 요소를 아래로 1칸씩 이동시킨다. 마지막 요소가 첫 번째 요소가 된다.
<br>rrr: rra와 rrb를 동시에 한다.
<br>push_swap에 뒤섞인 숫자 배열을 입력하면 숫자들을 정렬하기 위한 명령어의 나열을 출력한다.<br>
참고로 입력하는 숫자 배열의 숫자들은 서로 중복되지 않아야 한다.<br>
./push_swap 5 2 1 4 7 6 3

sa
pb
rra
pb
sa
pb
rb
sa
pb
pb
sa
pb
pb
pa
pa
pa
pa
pa
pa
pa

<br><a data-tooltip-position="top" aria-label="https://windowdong11.github.io/push_swap_visualizer/" rel="noopener nofollow" class="external-link" href="https://windowdong11.github.io/push_swap_visualizer/" target="_blank">push swap visualizer</a>를 활용하면 push_swap의 동작을 시각적으로 확인할 수 있다. 단, 이 저장소를 사용하는 사람들은 WSL 환경에서 push_swap을 실행시킬 것이므로 push_swap [뒤섞인 숫자 나열] | clip, push_swap [뒤섞인 숫자 나열] | pbcopy가 아닌 push_swap [뒤섞인 숫자 나열] | xclip -selection clipboard를 사용해야 한다.<br><br>그래픽스 기초<br>아래와 같은 형태의 map 파일을 사용하여<br>
cat 42.fdf

0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 10 10 0 0 10 10 0 0 0 10 10 10 10 10 0 0 0
0 0 10 10 0 0 10 10 0 0 0 0 0 0 0 10 10 0 0
0 0 10 10 0 0 10 10 0 0 0 0 0 0 0 10 10 0 0
0 0 10 10 10 10 10 10 0 0 0 0 10 10 10 10 0 0 0
0 0 0 10 10 10 10 10 0 0 0 10 10 0 0 0 0 0 0
0 0 0 0 0 0 10 10 0 0 0 10 10 0 0 0 0 0 0
0 0 0 0 0 0 10 10 0 0 0 10 10 10 10 10 10 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0

<br>아래의 예시와 같이 3차원의 형상(wire frame이긴 하지만)으로 투사하는 과제이다.<br><img alt="FdF.png" src="lib\media\fdf.png"><br>map 파일의 숫자들은 다음과 같이 해석된다.<br>
<br>숫자의 열 위치 : x축 좌표값
<br>숫자의 행 위치 : y축 좌표값
<br>숫자의 값 : z축 좌표값
<br>과제 수행을 위하여 행렬을 통한 공간 변환, 브레젠험 알고리즘 같은 지식을 배우게 된다.<br>fdf를 실행하기 전 의존성 문제를 해결하기 위해 다음의 명령어를 실행해야한다.<br>
sudo apt-get update &amp;&amp; sudo apt-get install xorg libxext-dev zlib1g-dev libbsd-dev

<br>아래와 같은 명령어를 통해 테스트 해볼 수 있다. 예제 map 파일들은 test_maps 경로에 위치해 있다.<br>
./fdf ./test_maps/42.fdf

<br>창을 띄우는 데까지 성공했다면, 다음의 키들을 활용하여 추가 기능을 테스트할 수 있다.<br>scale<br>
<br>위 화살표 : 확대
<br>아래 화살표 : 축소
<br>rotate<br>
<br>A, D : y 축 회전
<br>W, S : x 축 회전
<br>Q, E : z 축 회전
<br>translate<br>
<br>I, K : x 축 이동
<br>J, L :  y 축 이동
<br>U, E : z 축 이동
<br>기타<br>
<br>space : 투영법 변환(등각 투영 &lt;-&gt; 캐비넷 투영)
<br>esc : 나가기
<br><br>파일 입출력, 멀티 프로세스, 시그널 심화<br>제한된 기능의 bash shell을 구현하는 과제<br>minishell 실행 파일은 readline 라이브러리에 의존성을 가지므로 아래의 명령어를 실행시킨 후 실행시켜야 한다.<br>
sudo apt-get install libreadline-dev

<br>microshell은 아래와 같은 기능을 가지고 있다.<br>
<br>히스토리 : 위, 아래 화살표를 이용해 과거에 사용했던 명령어를 편리하게 조회, 재사용할 수 있다.
<br>쌍따옴표, 따옴표 파싱
<br>괄호 파싱
<br>&lt;, &gt;, &lt;&lt;, &gt;&gt;, &amp;&amp;, || 연산자
<br>파이프라인(|)
<br>환경변수 관리
<br>$?를 통한 exit status 조회
<br>ctrl-C, ctrl-D, ctrl-\ 입력이 bash shell과 동일한 동작을 보장함
<br>와일드 카드(*)
<br><br>멀티 스레드<br>pthread, mutex_lock 등을 사용하여 식사하는 철학자 문제(dining philosophers problem)를 구현, 멀티 스레딩, 데이터 레이스(data race), 데드 락(dead lock)을 공부하는 과제<br>각 철학자(스레드)는 제한된 숫자의 포크(공유 자원)을 사용하여 굶어죽지 않고 무사히 식사를 마칠 수 있어야 한다.<br>philo 실행 파일은 다음의 인자를 받아 실행된다.<br>
<br>철학자 인원
<br>죽는 데 걸리는 시간
<br>먹는 데 걸리는 시간
<br>자는 데 걸리는 시간
<br>각 철학자가 먹어야 하는 횟수(없어도 무방하며, 입력하지 않을 시 철학자들은 무한히 식사하게 된다)
<br>즉, 아래와 같이 사용된다.<br>
./philo 2 450 200 200 4

<br>philo_bonus 실행 파일은 멀티 스레드 대신 멀티 프로세스, 세마포어를 사용하여 구현한 철학자 모델이다.<br>phlio 또는 philo_bonus 파일의 실행결과를 <a data-tooltip-position="top" aria-label="https://nafuka11.github.io/philosophers-visualizer/" rel="noopener nofollow" class="external-link" href="https://nafuka11.github.io/philosophers-visualizer/" target="_blank">philosopher visualizer</a>에 붙여넣기 하면 보다 시각적으로 결과를 확인할 수 있다.<br><br>ray tracing<br>phong lighting model을 구현하는 과제이다.<br>miniRR 실행 파일은 환경광(ambient lighting), 카메라, 광원, 구체, 평면, 원기둥 정보가 담겨 있는 .rt 파일을 파싱하여 3차원으로 렌더링할 수 있어야 한다. FdF의 wire frame 렌더링이 아닌, 보다 현실감 있는 3차원 렌더링으로 말이다.<br>아래와 같이 사용한다.<br>
./miniRT rtFileName.rt

<br>예제 rt 파일은 maps 경로에 위치한다.<br><br>네트워크 기초<br>NetPractice는 가상의 네트워크 망이 서로 잘 통신할 수 있도록 빈 칸에 알맞은 ip 주소를 채워넣는 퍼즐 문제이다.<br>공인 ip, 사설 ip, LAN, WAN, 서브넷 마스킹 등을 공부하게 된다.<br><br>C++ 기초<br>CPP Module은 cpp 언어의 기초를 학습하기 위한 과제이다. 각 모듈은 다음의 주제를 다룬다.<br>
<br>모듈 0 : Namespaces, classes, member functions, stdio streams, initialization lists, static, const
<br>모듈 1 : Memory allocation, pointers to members, references, switch statement
<br>모듈 2 : Ad-hoc polymorphism, operator overloading and Orthodox Canonical class form
<br>모듈 3 : Inheritance
<br>모듈 4 : Subtype polymorphism, abstract classes, interfaces
<br>모듈 5 : Repetition and Exceptions
<br>모듈 6 : C++ casts
<br>모듈 7 : C++ templates
<br>모듈 8 : Templated containers, iterators, algorithms
<br>모듈 9 : STL
<br><br>socket programming<br>C++ 언어를 사용하여 irc 서버를 만드는 과제이다.<br>
irc란, 채팅 서버를 만들기 위한 프로토콜이다. 물론 irc 서버를 온전히 구현하는 것은 너무 벅찬 일이므로, 일부 기능을 제외하고 구현하였다(ex. 서버 간 통신).<br>클라이언트와 통신하는 기능을 만들기 위해 소켓 프로그래밍 socket programming을, 정해진 프로토콜 대로 서버를 만들기 위해 rfc 문서를 보는 방법을 배우게 된다.<br>nc(netcat) 같은 간단한 클라이언트 프로그램으로도 서버를 테스트할 수 있지만, 사용자 친화적이지 못하므로 제대로 된 irc 클라이언트를 설치하여 테스트하는 것을 권장한다.<br>
sudo apt install irssi

<br>그리고 먼저 서버를 실행시킨다. 첫번째 인자는 서버가 통신에 사용할 포트 번호, 두번째 인자는 서버에 연결하는데 사용할 비밀번호이다.<br>
./ircserv 4242 4242

<br>그리고 irssi 클라이언트를 실행시킨다.<br>
./irssi

<br>화면에 irssi 윈도우가 띄워지면, 다음의 명령어를 사용하여 서버에 접속한다.<br>
/connect -nocap localhost 4242 4242 nickname

<br>연결에 성공하였다면 <a data-tooltip-position="top" aria-label="https://www.rfc-editor.org/rfc/rfc2812.html" rel="noopener nofollow" class="external-link" href="https://www.rfc-editor.org/rfc/rfc2812.html" target="_blank">rfc 2812</a> 문서를 참고하여 irc 프로토콜의 다양한 명령어를 테스트하여보자.<br><br>Docker<br>도커를 사용하여 wordpress 페이지를 서비스하기 위한 MSA(micro service architecture)를 띄우는 과제.<br>이 과제를 테스트하기 위해선 리눅스에 docker가 설치되어 있어야 한다.<br>
sudo apt install docker

<br>sudo make build로 MSA를 올릴 수 있고 호스트에서 https://localhost로 접속할 수 있다. sudo make fclean으로 MSA를 내릴 수 있다.<br><br>웹 프로그래밍 기초<br>플레이어들이 서로 ping pong 게임을 즐길 수 있는 웹페이지를 만드는 과제<br>
다음의 스택을 사용한다.<br>
<br>프론트엔드 : pure vanila javascript, html, css, bootstrap, socket.io, three.js
<br>백엔드 : Django
<br>과제를 테스트하기 위해서는 backend 경로로 이동하여 sudo make하고 호스트에서 chrome을 사용하여 https://localhost로 접속하면 된다.<br>sudo make fclean으로 MSA를 내릴 수 있다.]]></description><link>public\42-innercirle-정리.html</link><guid isPermaLink="false">public/42 innercirle 정리.md</guid><pubDate>Wed, 28 May 2025 15:50:42 GMT</pubDate><enclosure url="lib\media\fdf.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="lib\media\fdf.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[가상 상속]]></title><description><![CDATA[<a class="tag" href="?query=tag:language/cpp" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#language/cpp</a> <a class="tag" href="?query=tag:참고도서/윤성우의_열혈_cpp_프로그래밍" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/윤성우의_열혈_cpp_프로그래밍</a> 
 <br><br><a href=".?query=tag:language\cpp" class="tag" target="_blank" rel="noopener nofollow">#language/cpp</a><br><br>
#include &lt;iostream&gt;
using namespace std;

class Base
{
	public :
		Base() { cout&lt;&lt;"Base Constructor"&lt;&lt;endl; }
		void SimpleFunc() { cout&lt;&lt;"BaseOne"&lt;&lt;endl; }
};

class MiddleDerivedOne : virtual public Base
{
	public :
		MiddleDerivedOne() : Base()
		{
			cout&lt;&lt;"MiddleDerivedOne Constructor"&lt;&lt;endl;
		}
		void MiddleFuncOne()
		{
			SimpleFunc();
			cout&lt;&lt;"MiddleDerivedOne"&lt;&lt;endl;
		}
};

class MiddleDerivedTwo : virtual public Base
{
	public :
		MiddleDerivedTwo() : Base()
		{
			cout&lt;&lt;"MiddleDerivedTwo Constructor"&lt;&lt;endl;
		}
		void MiddleFuncTwo()
		{
			SimpleFunc();
			cout&lt;&lt;"MiddleDerivedTwo"&lt;&lt;endl;
		}
};

class LastDerived : public MiddleDerivedOne, public MiddleDerivedTwo
{
	public :
		LastDerived() : MiddleDerivedOne(), MiddleDerivedTwo()
		{
			cout&lt;&lt;"LastDerived Constructor"&lt;&lt;endl;
		}
		void ComplexFunc()
		{
			MiddleFuncOne();
			MiddleFuncTwo();
			SimpleFunc();
		}
};

  

int main(void)
{
	cout&lt;&lt;"객체 생성 전 ..... "&lt;&lt;endl;
	
	LastDerived ldr;

	cout&lt;&lt;"객체 생성 후 ..... "&lt;&lt;endl;

	ldr.ComplexFunc();

	return (0);
}

<br><a data-href="다중 상속" href="public\다중-상속.html" class="internal-link" target="_self" rel="noopener nofollow">다중 상속</a>에서 하나의 클래스가 다른 클래스를 간접적으로 여러 번 상속받는 경우, 부모 클래스의 생성자, 소멸자를 여러 번 호출하며, 멤버 변수도 복제되어 여러 번 상속받는다는 문제가 존재한다.<br><a data-href="virtual 키워드" href="public\virtual-키워드.html" class="internal-link" target="_self" rel="noopener nofollow">virtual 키워드</a>를 사용하여 가상으로 클래스를 상속할 수 있으며, 가상 상속하면 생성자, 소멸자가 여러 번 호출되지 않으며, 멤버 변수도 복제되어 상속받지 않는다.<br><br>참고자료<br><a href=".?query=tag:참고도서\윤성우의_열혈_cpp_프로그래밍" class="tag" target="_blank" rel="noopener nofollow">#참고도서/윤성우의_열혈_cpp_프로그래밍</a><br>]]></description><link>public\가상-상속.html</link><guid isPermaLink="false">public/가상 상속.md</guid><pubDate>Fri, 20 Dec 2024 13:55:24 GMT</pubDate></item><item><title><![CDATA[가상 소멸자]]></title><description><![CDATA[<a class="tag" href="?query=tag:language/cpp" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#language/cpp</a> <a class="tag" href="?query=tag:참고도서/윤성우의_열혈_cpp_프로그래밍" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/윤성우의_열혈_cpp_프로그래밍</a> 
 <br><br><a href=".?query=tag:language\cpp" class="tag" target="_blank" rel="noopener nofollow">#language/cpp</a><br>virtual destructor<br><br>자식 클래스 객체를 부모 포인터로 가리킬 경우, 부모 포인터에서 정의된 함수만 호출할 수 있다.1<br>
이는 소멸자의 경우에도 마찬가지여서, 자식 클래스의 소멸자가 호출되지 않아 할당 해제해야 할 멤버를 해체하지 못하는 등의 문제가 발생한다.<br><a data-href="virtual 키워드" href="public\virtual-키워드.html" class="internal-link" target="_self" rel="noopener nofollow">virtual 키워드</a>를 사용하여 소멸자를 가상 소멸자로 선언할 수 있으며, 부모 클래스가 가상 소멸자를 보유하고 있으면 자식 클래스의 소멸자들도 모두 가상 소멸자가 된다. 그리고 가상 소멸자가 호출되면, 상속의 계층 구조상 맨 아래에 존재하는 자식 클래스의 소멸자가 대신 호출되면서, 부모 클래스의 소멸자가 순차적으로 호출된다.<br><br>참고자료<br><a href=".?query=tag:참고도서\윤성우의_열혈_cpp_프로그래밍" class="tag" target="_blank" rel="noopener nofollow">#참고도서/윤성우의_열혈_cpp_프로그래밍</a><br><br>[^]: <a data-href="상속" href="public\상속.html" class="internal-link" target="_self" rel="noopener nofollow">상속</a> 참조]]></description><link>public\가상-소멸자.html</link><guid isPermaLink="false">public/가상 소멸자.md</guid><pubDate>Fri, 20 Dec 2024 13:55:25 GMT</pubDate></item><item><title><![CDATA[가상 함수]]></title><description><![CDATA[<a class="tag" href="?query=tag:language/cpp" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#language/cpp</a> <a class="tag" href="?query=tag:참고도서/윤성우의_열혈_cpp_프로그래밍" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/윤성우의_열혈_cpp_프로그래밍</a> 
 <br><br><a href=".?query=tag:language\cpp" class="tag" target="_blank" rel="noopener nofollow">#language/cpp</a> <br>virtual function<br><br><br>부모 클래스 포인터는 자식 관계에 있는 클래스들의 객체를 가리킬 수 있지만, 이 경우 부모 클래스에서 정의된 함수만 호출할 수 있다. <a data-footref="1" href="about:blank#fn-1-1949966cec18b821" class="footnote-link" target="_self" rel="noopener nofollow">[1]</a><br>
<a data-href="virtual 키워드" href="public\virtual-키워드.html" class="internal-link" target="_self" rel="noopener nofollow">virtual 키워드</a>를 사용하여  가상 함수를 선언함으로서 이러한 문제를 해결할 수 있다.<br>virtual 키워드는 다음과 같은 특징을 가진다.<br>
<br>가상 함수를 오버라이딩하는 함수는 자동으로 가상 함수가 된다 ( 하지만 코드의 명확성을 위해 virtual 키워드를 사용하여 명시하는 것이 좋다 ).
<br>가상 함수는 해당 함수 호출 시, 포인터의 자료형을 기반으로 호출 대상을 결정하지 않고 포인터의 변수가 실제로 가리키는 객체를 참조하여 호출의 대상을 결정한다.
<br>하나 이상의 가상 함수를 포함한 클래스를 'Polymorphic class'라고 한다.<br>가상 함수의 구체적인 작동 원리는 <a data-href="가상 함수 테이블" href="public\가상-함수-테이블.html" class="internal-link" target="_self" rel="noopener nofollow">가상 함수 테이블</a>을 참고하자.<br><br>클래스 중에서는 객체생성이 목적이 아닌, 순수히 상속을 목적으로 정의된 클래스도 존재한다.<br>
이러한 클래스를 객체로 선언하는 것은 바람직하지 않지만, 문법적으로는 아무런 이상이 없기 떄문에 고치기 쉽지 않다.<br>가상 함수를 순수 가상 함수로 선언하면 이러한 객체의 생성을 문법적으로 막을 수 있다.<br>순수 가상 함수란 함수의 몸체가 정의되어 있지 않은 함수를 의미한다. 이를 표현하기 위해서 함수의 몸체를 작성하지 않고 그 자리에 '0의 대입'을 표시한다.<br>
virtual int GetPay() const = 0;

<br>순수 가상 함수는 아래와 같은 이점을 가진다.<br>
<br>순수 가상 함수를 가진 클래스는 완전하지 않은 클래스로 간주되기 떄문에 객체를 생성하려 하면 컴파일 에러가 발생한다. 이를 이용해 잘못된 객체의 생성을 문법적으로 막는다.
<br>순수히 상속만을 위한 클래스가 존재하는 것처럼, 함수를 순수 가상 함수로 선언함으로서 순수히 오버라이딩만을 위한 함수를 만들 수 있다.
<br>하나 이상의 멤버 함수를 순수 가상 함수로 선언한 클래스를 가리켜 <a data-href="추상 클래스" href="public\추상-클래스.html" class="internal-link" target="_self" rel="noopener nofollow">추상 클래스</a>라 한다.<br><br>참고자료<br><a href=".?query=tag:참고도서\윤성우의_열혈_cpp_프로그래밍" class="tag" target="_blank" rel="noopener nofollow">#참고도서/윤성우의_열혈_cpp_프로그래밍</a><br><br><br>
<br>
<br><a data-href="상속" href="public\상속.html" class="internal-link" target="_self" rel="noopener nofollow">상속</a> 문서를 참고할 것.<a href="about:blank#fnref-1-1949966cec18b821" class="footnote-backref footnote-link" target="_self" rel="noopener nofollow">↩︎</a>
]]></description><link>public\가상-함수.html</link><guid isPermaLink="false">public/가상 함수.md</guid><pubDate>Fri, 20 Dec 2024 13:55:28 GMT</pubDate></item><item><title><![CDATA[가상 함수 테이블]]></title><description><![CDATA[<a class="tag" href="?query=tag:language/cpp" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#language/cpp</a> <a class="tag" href="?query=tag:참고도서/윤성우의_열혈_cpp_프로그래밍" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/윤성우의_열혈_cpp_프로그래밍</a> 
 <br><br><a href=".?query=tag:language\cpp" class="tag" target="_blank" rel="noopener nofollow">#language/cpp</a><br>virtual function table<br><br>본 문서는 가상 함수의 구체적인 작동 방법에 관하여 다룬다.<br>한 개 이상의 가상 함수를 포함하는 클래스에 대해서는 컴파일러가 다음 그림과 같은 형태의 가상 함수 테이블이라는 것을 만든다. 간단히 'V-Table(Virtual Table)'이라고도 하는데, 이는 실제 호출되어야 할 함수의 위치 정보를 담고 있는 테이블이다.<br>클래스의 객체가 생성되면 객체는 클래스의 가상 함수를 참조할 수 있는 주소 값을 저장한다. <br>
#include &lt;iostream&gt;
using namespace std;

class AAA
{
	private :
		int num;
	public :
		virtual void Func1() { cout&lt;&lt;"Func1"&lt;&lt;endl; }
		virtual void Func2() { cout&lt;&lt;"Func2"&lt;&lt;endl; }
};

class BBB : public AAA
{
	private :
		int num2;
	public :
		virtual void Func1() { cout&lt;&lt;"BBB::Func1"&lt;&lt;endl; }
		void Func3() { cout&lt;&lt;"Func3"&lt;&lt;endl; }
};

int main(void)
{
	AAA *aptr = new AAA();
	aptr-&gt;Func1();

	AAA *bptr = new BBB();
	bptr-&gt;Func1();

	return (0);
}

<br><img alt="가상 함수 테이블.png" src="lib\media\가상-함수-테이블.png"><br>가상 함수 테이블에는 key가 있고 value가 있다. 여기서 key는 호출하고자 하는 함수를 구분지어주는 구분자의 역할을 한다. 그리고 value는 구분자에 해당하는 함수의 주소정보를 알려주는 역할을 한다. 그래서 AAA 객체의 Func1 함수를 호출해야 하는 경우, 위의 테이블에 첫 번째 행의 정보를 참조하여 0x1024번지에 등록되어 있는 Func1 함수를 호출하게 되는 것이다.<br>가상 함수의 중요한 특징은 자식 클래스의 가상 함수 테이블에는 부모 함수의 오버라이딩 되기 전 가상 함수의 정보가 포함되지 않는다는 것이다. 그래서 오버라이딩 된 가상 함수를 호출하면, 무조건 가장 마지막에 오버라이딩을 한 자식 클래스의 멤버 함수가 호출된다.<br><br>참고자료<br><a href=".?query=tag:참고도서\윤성우의_열혈_cpp_프로그래밍" class="tag" target="_blank" rel="noopener nofollow">#참고도서/윤성우의_열혈_cpp_프로그래밍</a><br>]]></description><link>public\가상-함수-테이블.html</link><guid isPermaLink="false">public/가상 함수 테이블.md</guid><pubDate>Fri, 20 Dec 2024 13:55:30 GMT</pubDate><enclosure url="lib\media\가상-함수-테이블.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="lib\media\가상-함수-테이블.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[게이트웨이]]></title><description><![CDATA[<a class="tag" href="?query=tag:network" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#network</a> <a class="tag" href="?query=tag:참고도서/그림으로_이해하는_네트워크_용어" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/그림으로_이해하는_네트워크_용어</a> 
 <br><br><a href=".?query=tag:network" class="tag" target="_blank" rel="noopener nofollow">#network</a> <br>gateway<br><br>서로 다른 두 개의 네트워크를 연결하여 서로 통신하기 위해 필요한 기기나 시스템. <a data-href="OSI 참조 모델" href="public\osi-참조-모델.html" class="internal-link" target="_self" rel="noopener nofollow">OSI 참조 모델</a>의 전체 계층을 인식하여 통신 매체나 전송 방식 등의 차이를 흡수하고 이기종 간에 접속할 수 있도록 한다.<br>게이트웨이는 전용 기기인 경우도 있고 컴퓨터 상 동작하는 소프트웨어인 경우도 있다.<br>보통은 <a data-href="라우터" href="public\라우터.html" class="internal-link" target="_self" rel="noopener nofollow">라우터</a>가 게이트웨이 역할을 맡으며, 이 경우 LAN에서 외부 네트워크에 엑세스할 떄의 출입구라는 의미를 가진다. 표준으로 사용되는 게이트웨이를 디폴트 게이트웨이라 하며, LAN 밖으로 송신되는 패킷은 일단 이 디폴트 게이트웨이로 전송된 후에 외부 네트워크로 전송된다.<br><br>참고자료<br><a href=".?query=tag:참고도서\그림으로_이해하는_네트워크_용어" class="tag" target="_blank" rel="noopener nofollow">#참고도서/그림으로_이해하는_네트워크_용어</a><br>]]></description><link>public\게이트웨이.html</link><guid isPermaLink="false">public/게이트웨이.md</guid><pubDate>Sat, 22 Mar 2025 07:31:44 GMT</pubDate></item><item><title><![CDATA[공인 IP 주소]]></title><description><![CDATA[<a class="tag" href="?query=tag:network" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#network</a> <a class="tag" href="?query=tag:참고도서/그림으로_이해하는_네트워크_용어" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/그림으로_이해하는_네트워크_용어</a> <a class="tag" href="?query=tag:참고도서/후니의_쉽게_쓴_시스코_네트워킹" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/후니의_쉽게_쓴_시스코_네트워킹</a> 
 <br><br><a href=".?query=tag:network" class="tag" target="_blank" rel="noopener nofollow">#network</a> <br>public IP address<br><br>컴퓨터는 <a data-href="IP 주소" href="public\ip-주소.html" class="internal-link" target="_self" rel="noopener nofollow">IP 주소</a>를 통해 서로를 식별하므로, 각각의 IP 주소는 중복되지 않고 고유해야 한다.<br>전 세계에서 유일한 번호라는 것을 보장하는 IP 주소를 공인 IP 주소라 한다.<br>공인 IP 주소는 개인이 마음대로 할당할 수 없으며, 나라마다 이를 위한 전문 기관이 있고, 기관의 관리하에 할당받게 되어 있다.<br>IP 주소는 32비트의 정수로 표현하기 때문에 중복되지 않는 번호의 수가 유한하다. 따라서 LAN의 내부와 같이 제한된 범위 안에서는 별도로 <a data-href="사설 IP 주소" href="public\사설-ip-주소.html" class="internal-link" target="_self" rel="noopener nofollow">사설 IP 주소</a>를 할당하여 사용하는 것이 일반적이다.<br>공인 IP 주소는 네트워크 규격에 의해 다섯 클래스로 나누어진다. 각각의 클래스에서 사용할 수 있는 IP 주소는 다음과 같이 정해져 있다.<br>
<br>클래스 A : 첫 번째 옥텟이 1 ~ 126으로 시작하는 네트워크. 이진법으로 나타내면 아래와 같다.
<br>0nnnnnnn.hhhhhhhh.hhhhhhhh.hhhhhhhh
0 : 클래스 A에서 첫번째 비트는 무조건 0으로 시작함.
n : 첫번째 옥텟을 사용하여 네트워크 주소를 나타냄
h : 나머지는 호스트 주소

디폴트 서브넷 마스크는 255.0.0.0
<br>
<br>클래스 B : 첫 번째 옥텟이 128 ~ 191로 시작하는 네트워크. 이진법으로 나타내면 아래와 같다.
<br>10nnnnnn.nnnnnnnn.hhhhhhhh.hhhhhhhh
10 : 클래스 A에서 첫번째 비트는 무조건 1, 두번째 비트는 0이다.
n : 첫번째, 두번째 옥텟을 사용하여 네트워크 주소를 나타냄
h : 나머지는 호스트 주소

디폴트 서브넷 마스크는 255.255.0.0
<br>
<br>클래스 C : 첫 번째 옥텟이 192 ~ 223로 시작하는 네트워크. 이진법으로 나타내면 아래와 같다.
<br>110nnnnn.nnnnnnnn.nnnnnnnn.hhhhhhhh
10 : 클래스 A에서 첫번째와 두번째 비트는 무조건 1, 세번째 비트는 0이다.
n : 첫번째, 두번째, 세번째 옥텟을 사용하여 네트워크 주소를 나타냄
h : 나머지는 호스트 주소

디폴트 서브넷 마스크는 255.255.255.0
<br>
<br>클래스 D : 첫 번째 옥텟이 224 ~ 239로 시작하는 네트워크. 멀티캐스트용 주소.
<br>클래스 E : 첫 번째 옥텟이 240 ~ 255로 시작하는 네트워크. 연구용 주소.
<br><br>참고자료<br><a href=".?query=tag:참고도서\그림으로_이해하는_네트워크_용어" class="tag" target="_blank" rel="noopener nofollow">#참고도서/그림으로_이해하는_네트워크_용어</a><br>
<a href=".?query=tag:참고도서\후니의_쉽게_쓴_시스코_네트워킹" class="tag" target="_blank" rel="noopener nofollow">#참고도서/후니의_쉽게_쓴_시스코_네트워킹</a><br>]]></description><link>public\공인-ip-주소.html</link><guid isPermaLink="false">public/공인 IP 주소.md</guid><pubDate>Sat, 22 Mar 2025 07:31:44 GMT</pubDate></item><item><title><![CDATA[구조체]]></title><description><![CDATA[<a class="tag" href="?query=tag:language/cpp" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#language/cpp</a> <a class="tag" href="?query=tag:참고도서/윤성우의_열혈_cpp_프로그래밍" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/윤성우의_열혈_cpp_프로그래밍</a> 
 <br><br><a href=".?query=tag:language\cpp" class="tag" target="_blank" rel="noopener nofollow">#language/cpp</a> <br>struct<br><br>본 문서는 c의 구조체와 c++ 구조체의 차이점을 중점으로 설명한다.
<br>구조체의 의의는 서로 연관이 있는 데이터를 하나의 구조체에 넣어 관리할 수 있다는 것이다.<br>경우를 하나 가정해보자.<br>
2차원 좌표계의 정점을 저장하는 Point 구조체가 있고, 정점을 이동시키는 기능을 가진 vertexMove 함수가 있다.<br>
typedef struct Point
{
	int x;
	int y;
} Point;

Point vertexMove(Point vertex1, int moveX, int moveY)
{
	Point movedVertex = {vertex1.x + moveX, vertex1.y + moveY};
	return (movedVertex);
}

<br>vertexMove 함수는 Point 구조체에 종속적이라고 할 수 있다. 그러나 c 언어는 구조체 내부의 함수 선언을 허용하지 않는다는 한계가 있다.<br>하지만 c++ 힘수에서는 구조체 내부 함수 선언을 아래와 같이 허용한다.<br>
struct Point
{
	//멤버변수
	int x;
	int y;

	//멤버함수
	void vertexMove(int moveX, int moveY)
	{
		x + moveX;
		y + moveY;
		return ;
	}
};

<br>c++에서 구조체 내부에 함수선언을 할 때, 다음과 같은 특징이 있다.<br>
<br>구조체의 변수를 멤버변수, 구조체의 함수를 멤버함수라고 한다.
<br>멤버함수는 매개변수에 멤버변수를 전달하지 않아도 멤버함수에 접근할 수 있다.
<br>멤버함수의 원형선언과 함수의 정의를 아래와 같은 형식으로 분리할 수 있다.
<br>
struct Car
{
	//. . .
	//함수의 원형선언
	void ShowCarStat();
	void Accel();
	//. . .
};

//함수의 정의
//structName::functionName의 형식으로 어느 구조체의 멤버함수인지를 지정해야 한다.
void Car::ShowCarState()
{
	//. . .
}

void Car::Accel()
{
	//. . .
}

<br>
<br>멤버함수는 기본적으로 <a data-tooltip-position="top" aria-label="인라인 함수" data-href="인라인 함수" href="public\인라인-함수.html" class="internal-link" target="_self" rel="noopener nofollow">인라인</a>으로 처리된다. 그러나 함수의 선언과 정의를 분리하면 인라인 처리되지 않는다. 키워드 inline을 이용해서 선언과 정의를 분리하고도 함수가 인라인 처리되도록 할 수 있다.
<br>
inline void Car::ShowCarState() { . . . . . }

<br>
<br>멤버 함수는 객체 외부의 별도의 공간에 선언된다 ( 객체가 아직 생성되지 않은 시점에서도 그러하다 ). 객체는 외부에 있는 멤버 함수의 주소를 참조한다.
<br>별도의 <a data-href="접근제어 지시자" href="public\접근제어-지시자.html" class="internal-link" target="_self" rel="noopener nofollow">접근제어 지시자</a>가 없을 경우, 구조체의 멤버함수와 멤버변수는 기본적으로 public으로 선언된다.
<br><br>참고자료<br><a href=".?query=tag:참고도서\윤성우의_열혈_cpp_프로그래밍" class="tag" target="_blank" rel="noopener nofollow">#참고도서/윤성우의_열혈_cpp_프로그래밍</a><br>]]></description><link>public\구조체.html</link><guid isPermaLink="false">public/구조체.md</guid><pubDate>Fri, 20 Dec 2024 13:55:32 GMT</pubDate></item><item><title><![CDATA[그래프]]></title><description><![CDATA[<a class="tag" href="?query=tag:algorithm" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#algorithm</a> <a class="tag" href="?query=tag:graph" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#graph</a> 
 <br><br><a href=".?query=tag:algorithm" class="tag" target="_blank" rel="noopener nofollow">#algorithm</a> <a href=".?query=tag:graph" class="tag" target="_blank" rel="noopener nofollow">#graph</a><br>graph<br><br><br>그래프는 노드 vertex와 간선 edge을 이용한 비선형 데이터 구조이다. 보통 그래프는 데이터 간의 관계를 표현하는 데 사용한다. 데이터를 노드로, 노드 간의 관계나 흐름을 간선으로 표현한다.<br><br>그래프는 방향성 가중치, 순환 특성에 따라 종류를 구분할 수 있다.<br><br>간선은 방향을 가질 수도 있고 없을 수도 있다.<br>방향이 있는 간선을 포함하면 방향 그래프 directed graph, 방향이 없는 간선을 포함하면 무방향 그래프 undirected graph라고 한다.<br>이때 방향 그래프는 어느 한쪽으로만 간선이 있는 것이 아니라 서로 반대를 가리키는 간선이 있을 수 있다.<br><br>두 번째 특성은 가중치이다. 어떤 데이터는 흐름의 방향뿐 아니라 양도 중요할 수 있다. 그런 정도를 간선에 표현할 때 이를 가중치라고 한다.<br>가중치가 있는 그래프를 가중치 그래프 weight graph라고 한다.<br><br>마지막 특성은 순환이다. 순환은 특정 노드에서 시작해 간선을 따라 다시 돌아오는 경로가 있는 것을 말한다.<br>순환이 존재하는 그래프를 순환 그래프 cycle graph라 하고, 순환이 존재하지 않는 그래프를 비순환 그래프 acyclic graph라고 한다.<br><br>그래프의 구현 방식에는 인접 행렬 adjacency matrix과 인접 리스트 adjacency list가 있다.<br><br>인접 행렬은 이중 배열을 활용하여 구현하는 경우가 많다.<br>이때의 배열의 인덱스는 노드, 배열의 값은 노드의 가중치로 생각하고, 인덱스의 세로 방향을 출발 노드, 가로 방향을 도착 노드로 생각하면 자연스럽게 그래프를 표현할 수 있다.<br>예를 들어 아래의 그래프는<br>
서울(0) - 400(km) -&gt; 부산(1)

<br>다음과 같이 표현할 수 있다.<br><br><br>인접 리스트로 그래프를 표현하려면 우선 적절한 노드를 정의해야 한다. 정점(v), 가중치(w)를 묶어 관리한다.<br>인접 리스트 그래프 표현 방식은 다음과 같은 과정으로 동작한다.<br>
<br>우선은 노드 개수만큼 배열을 준비한다.
<br>배열의 인덱스는 각 시작 노드를 의미하며 배열의 값에는 해당 노드를 시작 노드로 하는 노드들을 추가한다. 이때, v가 도착 노드를 의미한다.
<br><br>참고자료<br><br>]]></description><link>public\그래프.html</link><guid isPermaLink="false">public/그래프.md</guid><pubDate>Tue, 18 Mar 2025 07:02:40 GMT</pubDate></item><item><title><![CDATA[그리드]]></title><description><![CDATA[<a class="tag" href="?query=tag:language/css" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#language/css</a> <a class="tag" href="?query=tag:web" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#web</a> <a class="tag" href="?query=tag:참고링크/생활코딩" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고링크/생활코딩</a> 
 <br><br><a href=".?query=tag:language\css" class="tag" target="_blank" rel="noopener nofollow">#language/css</a> <a href=".?query=tag:web" class="tag" target="_blank" rel="noopener nofollow">#web</a><br>grid<br><br><br>참고자료<br><a href=".?query=tag:참고링크\생활코딩" class="tag" target="_blank" rel="noopener nofollow">#참고링크/생활코딩</a> <br>]]></description><link>public\그리드.html</link><guid isPermaLink="false">public/그리드.md</guid><pubDate>Wed, 22 Jan 2025 02:43:16 GMT</pubDate></item><item><title><![CDATA[깊은 복사]]></title><description><![CDATA[<a class="tag" href="?query=tag:language/cpp" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#language/cpp</a> <a class="tag" href="?query=tag:참고도서/윤성우의_열혈_cpp_프로그래밍" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/윤성우의_열혈_cpp_프로그래밍</a> 
 <br><br><a href=".?query=tag:language\cpp" class="tag" target="_blank" rel="noopener nofollow">#language/cpp</a><br><br>객체 간 복사의 한 형태이다.<br>heap 영역의 공간을 가리키는 포인터를 멤버 변수로 삼는 객체를 복사할 때, <a data-href="얕은 복사" href="public\얕은-복사.html" class="internal-link" target="_self" rel="noopener nofollow">얕은 복사</a>의 형태로 복사할 경우 원본 객체와 복사본 객체가 동일한 공간을 가리켜, 원본 객체가 소멸할 경우 ( = heap에 할당된 공간이 해제될 경우 ) 복사본 객체 또한 heap 영역에 대한 참조를 상실한다는 문제가 있다.<br>이러한 문제를 방지하기 위하여, heap에 할당된 공간을 복사하여 복사본 객체에 할당하는 방식의 복사 형태를 깊은 복사라 한다.<br><img alt="얕은 복사 깊은 복사.png" src="lib\media\얕은-복사-깊은-복사.png"><br><br>참고자료<br><a href=".?query=tag:참고도서\윤성우의_열혈_cpp_프로그래밍" class="tag" target="_blank" rel="noopener nofollow">#참고도서/윤성우의_열혈_cpp_프로그래밍</a><br>]]></description><link>public\깊은-복사.html</link><guid isPermaLink="false">public/깊은 복사.md</guid><pubDate>Fri, 20 Dec 2024 13:55:39 GMT</pubDate><enclosure url="lib\media\얕은-복사-깊은-복사.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="lib\media\얕은-복사-깊은-복사.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[네트워크 바이트 순서]]></title><description><![CDATA[<a class="tag" href="?query=tag:network" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#network</a> <a class="tag" href="?query=tag:language/c" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#language/c</a> <a class="tag" href="?query=tag:socket_programming" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#socket_programming</a> <a class="tag" href="?query=tag:참고도서/윤성우의_열혈_TCP_IP_소켓_프로그래밍" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/윤성우의_열혈_TCP_IP_소켓_프로그래밍</a> 
 <br><br><a href=".?query=tag:network" class="tag" target="_blank" rel="noopener nofollow">#network</a> <a href=".?query=tag:language\c" class="tag" target="_blank" rel="noopener nofollow">#language/c</a> <a href=".?query=tag:socket_programming" class="tag" target="_blank" rel="noopener nofollow">#socket_programming</a><br>network byte order<br><br>CPU가 어떤 <a data-href="호스트 바이트 순서" href="public\호스트-바이트-순서.html" class="internal-link" target="_self" rel="noopener nofollow">호스트 바이트 순서</a>를 따르냐에 따라 데이터를 방식이 다르다.<br>
만약 빅 엔디안을 채택하는 시스템이 아무런 조치 없이 리틀 엔디안 시스템에 데이터를 송신한다면 데이터를 거꾸로 읽게 되어 문제가 발생할 것이다.<br>이러한 문제를 해결하기 위하여 네트워크를 통하여 데이터를 전송할 때에는 빅 엔디안 방식으로 기준을 통일하여 데이터를 전송하기로 약속하였으며, 이 약속을 가리켜 네트워크 바이트 순서(Network Byte Order)라 한다.<br><br>참고자료<br><a href=".?query=tag:참고도서\윤성우의_열혈_TCP_IP_소켓_프로그래밍" class="tag" target="_blank" rel="noopener nofollow">#참고도서/윤성우의_열혈_TCP_IP_소켓_프로그래밍</a><br>]]></description><link>public\네트워크-바이트-순서.html</link><guid isPermaLink="false">public/네트워크 바이트 순서.md</guid><pubDate>Sat, 22 Mar 2025 07:31:45 GMT</pubDate></item><item><title><![CDATA[네트워크 토폴로지]]></title><description><![CDATA[<a class="tag" href="?query=tag:network" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#network</a> <a class="tag" href="?query=tag:참고도서/그림으로_이해하는_네트워크_용어" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/그림으로_이해하는_네트워크_용어</a> 
 <br><br><a href=".?query=tag:network" class="tag" target="_blank" rel="noopener nofollow">#network</a> <br>Network Topology<br><br>컴퓨터를 네트워크에 연결할 때의 형태를 의미한다.<br>대표적인 네트워크 토폴로지는 아래의 세가지이다.<br><br><br>참고자료<br><a href=".?query=tag:참고도서\그림으로_이해하는_네트워크_용어" class="tag" target="_blank" rel="noopener nofollow">#참고도서/그림으로_이해하는_네트워크_용어</a><br>]]></description><link>public\네트워크-토폴로지.html</link><guid isPermaLink="false">public/네트워크 토폴로지.md</guid><pubDate>Sat, 22 Mar 2025 07:31:44 GMT</pubDate></item><item><title><![CDATA[네트워크 프로토콜]]></title><description><![CDATA[<a class="tag" href="?query=tag:network" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#network</a> <a class="tag" href="?query=tag:참고도서/그림으로_이해하는_네트워크_용어" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/그림으로_이해하는_네트워크_용어</a> 
 <br><br><a href=".?query=tag:network" class="tag" target="_blank" rel="noopener nofollow">#network</a> <br>네트워크를 통해 컴퓨터끼리 정보를 주고받는 절차를 칭한다.<br><br>같은 언어를 가진 사람끼리만 소통할 수 있는 것처럼, 서로 다른 pc가 통신하기 위해선 통신하기 위한 절차를 규정해야 한다. 이러한 절차를 네트워크 프로토콜이라 한다.<br><br>참고자료<br><a href=".?query=tag:참고도서\그림으로_이해하는_네트워크_용어" class="tag" target="_blank" rel="noopener nofollow">#참고도서/그림으로_이해하는_네트워크_용어</a><br>]]></description><link>public\네트워크-프로토콜.html</link><guid isPermaLink="false">public/네트워크 프로토콜.md</guid><pubDate>Sat, 22 Mar 2025 07:31:44 GMT</pubDate></item><item><title><![CDATA[다중 상속]]></title><description><![CDATA[<a class="tag" href="?query=tag:language/cpp" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#language/cpp</a> <a class="tag" href="?query=tag:참고도서/윤성우의_열혈_cpp_프로그래밍" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/윤성우의_열혈_cpp_프로그래밍</a> 
 <br><br><a href=".?query=tag:language\cpp" class="tag" target="_blank" rel="noopener nofollow">#language/cpp</a><br><br>하나의 클래스가 복수의 클래스를 상속받는 것이 가능하다. 이를 다중 상속이라고 한다.<br>
다중 상속은 다음과 같이 선언된다.<br>
class Parent1
{ /* 생략 */ };

class Parent2
{ /* 생략 */ };

class child : public Parent1, protected Parent2
{ /* 생략 */ };


<br>그러나 다중 상속은 대부분의 경우 아예 사용되지 않거나, 특수한 상황에서만 매우 제한적으로 사용된다 ( 이러한 경우에도 다중 상속을 사용하지 않고 처리할 수 있다. 다중 상속을 사용해야만 하는 케이스는 없다. ).<br>다중 상속이 잘 사용되지 않는 이유는 아래와 같은 단점, 모호함들을 가졌기 때문이다.<br>
<br>
부모 클래스 1과 2가 서로 같은 함수명, 매개변수를 가진 함수를 보유한 경우, 컴파일러가 어느 함수를 호출해야 할지 알 수 없어 에러가 발생한다.<br>
-&gt; 아래와 같은 형식으로 어느 클래스의 함수인지 명시하여 해결할 수 있다.<br>
Parent1::Func(); Parent2::Func(); //부모클래스명::함수명()

<br>
아래와 같이 하나의 클래스가 간접적으로 같은 클래스를 2번 상속받을 수 있다.

<br>Parent 클래스를 선언한다.
<br>Child1, Child2 클래스를 선언한다. 이 클래스들은 모두 Parent를 상속받는다.
<br>GrandChild 클래스를 선언한다. 이 클래스는 Child1, Child2 클래스들을 다중 상속한다.
<br>결과적으로 GrandChild 클래스는 간접적으로 Parent 함수를 2번 상속 받는다.


<br>GrandChild 함수는 결과적으로 Parent 클래스의 생성자도 2번, 소멸자도 2번 호출되며, 멤버 변수도 복제되어 2배로 상속받는다. 대부분의 경우에서 이는 의도되지 않은 현상이며, 코드의 직관성을 해친다는 문제가 있다.<br>
-&gt; <a data-href="가상 상속" href="public\가상-상속.html" class="internal-link" target="_self" rel="noopener nofollow">가상 상속</a>을 사용하여 이러한 문제를 해결할 수 있다.


<br><br>참고자료<br><a href=".?query=tag:참고도서\윤성우의_열혈_cpp_프로그래밍" class="tag" target="_blank" rel="noopener nofollow">#참고도서/윤성우의_열혈_cpp_프로그래밍</a><br>]]></description><link>public\다중-상속.html</link><guid isPermaLink="false">public/다중 상속.md</guid><pubDate>Sat, 22 Mar 2025 07:31:40 GMT</pubDate></item><item><title><![CDATA[다중 접속 서버]]></title><description><![CDATA[<a class="tag" href="?query=tag:network" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#network</a> <a class="tag" href="?query=tag:language/c" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#language/c</a> <a class="tag" href="?query=tag:socket_programming" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#socket_programming</a> <a class="tag" href="?query=tag:참고도서/윤성우의_열혈_TCP_IP_소켓_프로그래밍" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/윤성우의_열혈_TCP_IP_소켓_프로그래밍</a> 
 <br><br><a href=".?query=tag:network" class="tag" target="_blank" rel="noopener nofollow">#network</a> <a href=".?query=tag:language\c" class="tag" target="_blank" rel="noopener nofollow">#language/c</a> <a href=".?query=tag:socket_programming" class="tag" target="_blank" rel="noopener nofollow">#socket_programming</a><br>multi user server<br><br>서버는 꺼지지 않고 무한히 클라이언트의 요청에 응답해야 한다.<br>이러한 특성 때문에 서버를 이루는 코드는 일반적으로 무한 루프를 포함한다.<br>
그리고 그 무한 루프는 대충 아래와 같은 구조를 띈다.<br>
새로운 클라이언트의 연결을 수락(accept()) -&gt; 클라이언트로부터 요청이 있는지 체크(read()) -&gt; 응답(write()) -&gt; 반복...

<br>문제는 accept(), read(), write() 모두 blocking 될 수 있는 함수라는 것이다.<br>accept()는 클라이언트의 연결 요청이 없을 경우 새로운 요청이 도착할 때까지 대기한다.<br>
read()의 경우 버퍼에 읽을 데이터가 없을 때 새로운 데이터가 도착할 때까지 대기한다.<br>
write()의 경우 버퍼에 데이터를 작성할 공간이 없을 때 작성할 공간이 생길 때까지 대기한다.<br>문제는 서버에서 이러한 blocking이 발생할 경우 다음 로직의 실행에 지연이 발생하기 때문에 여러 개의 클라이언트의 요청을 동시에 처리하는 것이 아닌 순차적으로 처리하게 된다는 문제점이 있다.<br>
새로운 클라이언트의 연결을 수락하기 위해 accept()에서 대기 -&gt; 클라이언트로부터 요청을 받기 위해 read()에서 대기 -&gt; 응답을 위해 write()에서 대기(다만 write()에서 대기가 발생하는 경우는 드물다) -&gt; 반복...

<br>이러한 문제점을 해결하여(즉, blocking으로부터 발생하는 지연을 최대한 없애버림으로서) 접속하고 있는 클라이언트에게 동시에 서비스를 제공하는 서버를 다중 접속 서버라 칭한다.<br>다중 접속 서버는 다음의 수단을 사용하여 구현할 수 있다.<br>
<br><a data-href="멀티 프로세스 기반 서버" href="public\멀티-프로세스-기반-서버.html" class="internal-link" target="_self" rel="noopener nofollow">멀티 프로세스 기반 서버</a>
<br><a data-href="멀티 쓰레딩 기반 서버" href="public\멀티-쓰레딩-기반-서버.html" class="internal-link" target="_self" rel="noopener nofollow">멀티 쓰레딩 기반 서버</a>
<br><a data-href="멀티 플렉싱 기반 서버" href="public\멀티-플렉싱-기반-서버.html" class="internal-link" target="_self" rel="noopener nofollow">멀티 플렉싱 기반 서버</a>
<br><a data-href="fcntl" href="fcntl" class="internal-link" target="_self" rel="noopener nofollow">fcntl</a>이나 <a data-href="set_socket" href="set_socket" class="internal-link" target="_self" rel="noopener nofollow">set_socket</a> 등의 시스템 콜을 사용하여 소켓이 가리키는 fd가 non-blocking으로 동작하도록 설정한다.
<br>위의 방법 중 4번은 <a data-href="시스템 콜" href="시스템 콜" class="internal-link" target="_self" rel="noopener nofollow">시스템 콜</a>을 호출하는 빈도가 매우 증가하여 성능 상의 불이익이 있으므로 사용하지 않는 것이 좋다.<br><br><img alt="다중 접속 서버 구현 방식.jpg" src="lib\media\다중-접속-서버-구현-방식.jpg"><br>
<a data-tooltip-position="top" aria-label="https://velog.io/@appti/%EB%8B%A4%EC%A4%91-%EC%A0%91%EC%86%8D-%EC%84%9C%EB%B2%84-%EA%B5%AC%ED%98%84-%EB%B0%A9%EC%8B%9D" rel="noopener nofollow" class="external-link" href="https://velog.io/@appti/%EB%8B%A4%EC%A4%91-%EC%A0%91%EC%86%8D-%EC%84%9C%EB%B2%84-%EA%B5%AC%ED%98%84-%EB%B0%A9%EC%8B%9D" target="_blank">원본 링크</a><br><br><br>참고자료<br><a href=".?query=tag:참고도서\윤성우의_열혈_TCP_IP_소켓_프로그래밍" class="tag" target="_blank" rel="noopener nofollow">#참고도서/윤성우의_열혈_TCP_IP_소켓_프로그래밍</a> <br>]]></description><link>public\다중-접속-서버.html</link><guid isPermaLink="false">public/다중 접속 서버.md</guid><pubDate>Sat, 22 Mar 2025 07:31:46 GMT</pubDate><enclosure url="lib\media\다중-접속-서버-구현-방식.jpg" length="0" type="image/jpeg"/><content:encoded>&lt;figure&gt;&lt;img src="lib\media\다중-접속-서버-구현-방식.jpg"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[다형성]]></title><description><![CDATA[<a class="tag" href="?query=tag:language/cpp" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#language/cpp</a> <a class="tag" href="?query=tag:참고도서/윤성우의_열혈_cpp_프로그래밍" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/윤성우의_열혈_cpp_프로그래밍</a> 
 <br><br><a href=".?query=tag:language\cpp" class="tag" target="_blank" rel="noopener nofollow">#language/cpp</a> <br>polymorphism<br><br>다형성은 객체지향 언어의 특징 중 하나이다.<br>다형성은 사전적으로 다음을 의미한다.<br>동질이상(同質異像)<br>
모습은 같은데 형태는 다르다.<br>이를 컴퓨터의 관점으로 생각하면 다음으로 해석할 수 있다.<br>문장은 같은데 결과가 다르다.<br>
class First
{
	public :
		virtual void SimpleFunc() { cout&lt;&lt;"First"&lt;&lt;endl; }
};

class Second : public First
{
	public :
		virtual void SimpleFunc() { cout&lt;&lt;"Second"&lt;&lt;endl; }
};

int main(void)
{
	First *ptr = new First();
	ptr -&gt; SimpleFunc(); // 아래에 동일한 문장이 존재한다.
	delete ptr;

	ptr = new Second();
	ptr -&gt; SimpleFunc(); // 위에 동일한 문장이 존재한다.
	delete ptr;

	return (0);
}

<br>위 예제에서 ptr은 동일한 포인터 변수이지만, ptr이 참조하는 객체의 자료형이 다르기 때문에 다른 결과를 출력한다. 이것이 '다형성'의 예이다.<br><br>참고자료<br><a href=".?query=tag:참고도서\윤성우의_열혈_cpp_프로그래밍" class="tag" target="_blank" rel="noopener nofollow">#참고도서/윤성우의_열혈_cpp_프로그래밍</a><br>]]></description><link>public\다형성.html</link><guid isPermaLink="false">public/다형성.md</guid><pubDate>Sat, 22 Mar 2025 07:31:40 GMT</pubDate></item><item><title><![CDATA[단방향 암호화]]></title><description><![CDATA[<a class="tag" href="?query=tag:security" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#security</a> <a class="tag" href="?query=tag:cryptograph" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#cryptograph</a> <a class="tag" href="?query=tag:참고링크/생활코딩" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고링크/생활코딩</a> 
 <br><br><a href=".?query=tag:security" class="tag" target="_blank" rel="noopener nofollow">#security</a> <a href=".?query=tag:cryptograph" class="tag" target="_blank" rel="noopener nofollow">#cryptograph</a><br>hash<br><br><br>단방향 암호화는 암호화만 지원하고 복호화는 지원하지 않는 암호화 방식을 일컫는다.<br>
다른 말로 hash(다지다)라고도 하는데, 무언가를 다지면 원형을 알아볼 수 없는 것을 암호화에 빗댄 것이다.<br>단방향 암호화는 무결성 특성을 극대화하는 방식이다.<br>복호화를 할 수 없는데 어떻게 원본과 암호화된 내용이 동일함을 확인할 수 있을까? 다음과 같은 상황을 가정해보자.<br>A라는 사람이 B라는 사람에게 특정한 파일을 전송받기로 했다. A는 B를 신뢰하지만, 전송되는 과정에서 파일이 조작되었을 가능성을 배제할 수 없다.<br>따라서 B는 A에게 파일을 전송하는 동시에 파일에 hash 알고리즘을 적용하여 얻은 문자열을 같이 보낸다. md5를 이용하여 hash 했다고 가정하자.<br>A는 파일을 전송받은 후, 해당 파일을 md5로 hash한 뒤 그 값을 B가 보낸 문자열과 비교한다. 문자열이 같다면 B가 보낸 파일과 A가 보낸 파일이 동일함을 알 수 있다.<br>hash는 또한 다음과 같은 목적을 위해 사용된다.<br>
<br>무결성 검증 Verifying the integrity of messages and files
<br>전자 서명을 하는 경우 Signature generation and verification
<br>파일 또는 데이터의 신뢰할만한 식별자가 필요할 때 File or data identifier
<br>사용자의 비밀번호를 서버에 안전하게 저장할 때 Password verification
<br>암호 화폐 채굴 시 작업 증명을 위하여 Proof-of-work
<br><br>참고자료<br><a href=".?query=tag:참고링크\생활코딩" class="tag" target="_blank" rel="noopener nofollow">#참고링크/생활코딩</a> <br>]]></description><link>public\단방향-암호화.html</link><guid isPermaLink="false">public/단방향 암호화.md</guid><pubDate>Thu, 13 Feb 2025 02:35:03 GMT</pubDate></item><item><title><![CDATA[데이터베이스란]]></title><description><![CDATA[<a class="tag" href="?query=tag:database" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#database</a> <a class="tag" href="?query=tag:참고링크/생활코딩" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고링크/생활코딩</a> 
 <br><br><a href=".?query=tag:database" class="tag" target="_blank" rel="noopener nofollow">#database</a><br>database<br><br><br><br>대규모의 데이터를 편리하게 저장, 관리, 열람할 수 있게 해주는 소프트웨어.<br><br><br>데이터베이스의 가장 본질적인 기능은 입력 Input과 출력 Output이다.<br>
입력 기능은 다시 생성 Create, 갱신 Update, 삭제 Delete으로 세분화할 수 있고 출력 기능은 읽기 Read 기능을 포함한다.<br>데이터베이스에서 가장 본질적인 이 네가지 기능을 통틀어 CRUD라고 한다.<br><br><br>굳이 공들여 데이터베이스를 공부해야하는 이유를 제시하기 위해선 사람들이 보편적으로 데이터를 관리하기 위해 사용하는 수단인 파일에 비교했을 때 데이터베이스가 확실한 강점을 보유하고 있어야 한다.<br>데이터베이스의 대표적인 장점으로 다음을 제시할 수 있다.<br>
<br>정보를 구조화하여 저장한다.

<br>예를 들어, 정보를 여러 개의 속성(ex. 주제, 제목, 내용, 작성자, 프로필 등등)으로 나누어 저장할 수 있고, 특정 속성을 기준으로 정렬할 수 있고, 특정 속성만 표시하거나 숨길 수 있고, 특정 속성의 값을 사용하여 검색하는 등의 일을 할 수 있다.


<br>프로그래밍 언어를 사용하여 이러한 작업을 자동화 할 수 있다.

<br>1의 작업을 사람이 수동으로 명령어를 입력하는 것이 아닌, 프로그래밍 언어를 사용하여 자동화 로직을 구성할 수 있다.


<br><br><br>주의 : 위 가이드는 2018년 기준으로 작성되었으므로 현 시류와 맞지 않는 부분이 있을 수 있습니다 (그런데 2024년 기준으로 검색해봐도 통계가 비슷한게 함정)<br><br>참고자료<br><a href=".?query=tag:참고링크\생활코딩" class="tag" target="_blank" rel="noopener nofollow">#참고링크/생활코딩</a> <br>]]></description><link>public\데이터베이스.html</link><guid isPermaLink="false">public/데이터베이스.md</guid><pubDate>Sat, 22 Mar 2025 07:31:38 GMT</pubDate></item><item><title><![CDATA[도커]]></title><description><![CDATA[<a class="tag" href="?query=tag:docker" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#docker</a> <a class="tag" href="?query=tag:참고도서/그림과_실습으로_배우는_도커_쿠버네티스" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/그림과_실습으로_배우는_도커_쿠버네티스</a> 
 <br><br><a href=".?query=tag:docker" class="tag" target="_blank" rel="noopener nofollow">#docker</a><br>virtual machine과 비슷하지만 좀 더 가볍다.<br><br>도커란 데이터 또는 프로그램을 격리시키는 기능을 하는 소프트웨어이다.<br><br><img alt="도커의 구조.jpeg" src="lib\media\도커의-구조.jpeg"><br>일반적인 도커의 구조.<br><img alt="윈도우에서의 도커의 구조.png" src="lib\media\윈도우에서의-도커의-구조.png" style="width: 700px; max-width: 100%;"><br>윈도우에서의 도커의 구조. 도커는 리눅스용으로 설계되었기 때문에, 윈도우용 도커 패키지에는 리눅스를 윈도우 상에 올리기 위한 하이퍼바이저와 가상 머신이 포함되어 있다. 즉, 윈도우 -&gt; (가상 머신 위의) 리눅스 -&gt; 도커 형식.<br><br><br>
<br>환경이 독립되어 있다.

<br>동일한 프로그램을 한 컴퓨터에 여러 개 설치, 실행할 수 있다 (일반적으로는 불가능).
<br>예를 들어 A 프로그램은 아파지 5.0 버전으로만 실행가능하고, B 프로그램은 아파치 8.0 버전으로만 실행 가능한 경우, 도커를 사용하면 서로 다른 컨테이너에 각각 5.0, 8.0 버전을 설치함으로서 간단하게 해결할 수 있다.
<br>프로그램 간의 충돌, 간섭을 예방할 수 있다.


<br>이미지를 만들 수 있다.

<br>그렇게 만든 <a data-href="이미지" href="public\이미지.html" class="internal-link" target="_self" rel="noopener nofollow">이미지</a>를 <a data-href="도커 허브" href="public\도커-허브.html" class="internal-link" target="_self" rel="noopener nofollow">도커 허브</a>에 올릴 수 있다( = 배포가 용이하다)
<br>반대로 도커 허브로부터 필요한 이미지를 쉽게 다운로드 받을 수도 있다.
<br>이미지를 통해 간단하게 컨테이너를 만들 수 있으므로 교체 및 업데이트가 용이하다.
<br>컨테이너를 자유자재로 옮길 수 있다 (정확히는 이미지의 형태로 컨테이너를 추출한 다음 해당 이미지를 기반으로 다른 환경에서 컨테이너를 복원할 수 있다).


<br>컨테이너에 '커널'을 포함시지 않으며, 운영체제의 주변 영역만을 포함한다.

<br>따라서 가볍다.
<br>또한 컨테이너에 올라가는 운영체제의 배포판을 자유자재로 바꿀 수 있다.


<br><br>
<br>리눅스 운영체제를 사용하는 것을 전제로 만들어졌기 때문에 리눅스용 소프트웨어 밖에 지원하지 않는다.
<br>물리 장치 하나에 여러 개의 컨테이너를 띄우는 형태이기 때문에 호스트 서버에 문제가 생기면 여러 컨테이너에 영향이 미친다. 따라서 물리 장치의 이상에 확실한 대책을 세워야 한다.
<br>애초에 컨테이너 여러 개를 사용하는 형태를 가정하여 만든 기술이므로 컨테이너 하나를 장시간에 걸쳐 사용할 때는 큰 장점을 느끼기 어렵다. 도커를 사용하려면 반드시 도커 엔진을 구동해야 하는데, 컨테이너를 하나밖에 사용하지 않으면 도커 엔진이 단순한 오버헤드에 지나지 않는다.
<br><br>
<br>리눅스에서 사용되는 것을 전제로 만들어졌기 때문에 리눅스 운영체제가 필요하다.
<br>따라서, 도커의 <a data-href="컨테이너" href="public\컨테이너.html" class="internal-link" target="_self" rel="noopener nofollow">컨테이너</a>에서 동작할 수 있는 프로그램도 리눅스용 프로그램으로 한정된다.
<br>본격적인 도커 사용법은 <a data-href="도커 명령어" href="public\도커-명령어.html" class="internal-link" target="_self" rel="noopener nofollow">도커 명령어</a>를 참고.<br><br>참고자료<br><a href=".?query=tag:참고도서\그림과_실습으로_배우는_도커_쿠버네티스" class="tag" target="_blank" rel="noopener nofollow">#참고도서/그림과_실습으로_배우는_도커_쿠버네티스</a> <br>]]></description><link>public\도커.html</link><guid isPermaLink="false">public/도커.md</guid><pubDate>Fri, 20 Dec 2024 13:58:24 GMT</pubDate><enclosure url="lib\media\도커의-구조.jpeg" length="0" type="image/jpeg"/><content:encoded>&lt;figure&gt;&lt;img src="lib\media\도커의-구조.jpeg"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[도커 네트워크]]></title><description><![CDATA[<a class="tag" href="?query=tag:docker" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#docker</a> <a class="tag" href="?query=tag:참고도서/그림과_실습으로_배우는_도커_쿠버네티스" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/그림과_실습으로_배우는_도커_쿠버네티스</a> <a class="tag" href="?query=tag:참고도서/시작하세요_도커_쿠버네티스" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/시작하세요_도커_쿠버네티스</a> 
 <br><br><a href=".?query=tag:docker" class="tag" target="_blank" rel="noopener nofollow">#docker</a><br>docker network<br><br><a data-href="컨테이너" href="public\컨테이너.html" class="internal-link" target="_self" rel="noopener nofollow">컨테이너</a>를 다루다 보면 하나가 아닌 여러 개의 프로그램을 연동해 사용해야 하는 경우가 있다.<br>
예를 들어, 간단한 웹사이트를 만드는 데에도 워드프레스 + php 런타임 + apache + mysql 콤보가 필요하다.<br>
이러한 프로그램들을 하나의 컨테이너에 때려넣을 수도 있지만, 그러면 프로그램을 격리해 관리한다는 <a data-href="도커" href="public\도커.html" class="internal-link" target="_self" rel="noopener nofollow">도커</a>의 목적이 퇴색된다.<br>따라서 각각의 프로그램을 별도의 컨테이너에 보관하는 것이 바람직한데, 앞서 말했듯이 컨테이너는 격리되어 있기 때문에 프로그램 간 연동이 안된다는 문제가 있다.<br>컨테이너는 가상 ip 주소를 할당받는다. 컨테이너 안에서 ifconfig 명령어를 사용한 후 출력되는 목록 중에서 eth0(도커의 NAT IP) 부분이 컨테이너가 할당받은 가상 ip 주소이다.<br>따라서 이 가상 ip를 통해 접근하면 다른 컨테이너와 통신할 수 있다. 예를 들어, B 컨테이너의 ip가 172.17.0.3이라면 A 컨테이너는 이 ip를 써서 B 컨테이너에 접근할 수 있다. 그러나 도커 엔진은 컨테이너가 시작할 때마다 가상 ip를 재할당하므로 매번 변경되는 컨테이너의 ip로 접근하기는 어렵다.<br><br>--link 옵션은 컨테이너에 별명(alias)를 붙인 후 그 컨테이너에 ip가 아닌 별명으로 접근하게 해주는 설정이다. --link 옵션을 사용할 때 --link에 입력된 컨테이너가 실행 중이지 않거나 존재하지 않는다면 --link를 적용한 컨테이너 또한 실행할 수 없다는 점을 주의해야 한다.<br>이처럼 --link 옵션은 컨테이너 간에 이름으로 서로를 찾을 수 있게 도와주지만, 현재 deprecated 된 옵션이며 추후 삭제될 수 있다. 따라서 얌전히 후술할 도커 네트워크를 쓰는 편이 좋다.<br><br>도커는 컨테이너끼리 연결할 수 있는 가상 네트워크를 제공한다. 이를 도커 네트워크라고 한다.<br>토커는 컨테이너를 생성할 때마다 veth(virtual eth)라는 가상 네트워크 인터페이스를 생성한다. docker0이라는 브릿지는 각 veth 인터페이스와 바인딩되어 호스트의 eth0 인터페이스와 이어주는 역할을 한다. 즉, 컨테이너와 호스트의 네트워크는 아래의 그림과 같은 구조를 띈다.<br><img alt="도커 네트워크 구조.png" src="lib\media\도커-네트워크-구조.png"><br>아무런 설정을 하지 않고 컨테이너를 생성하면 컨테이너는 자동으로 docker0을 사용한다.<br>
docker0 브릿지 이외에도 사용자의 선택에 따라 여러 네트워크 드라이브를 사용할 수 있다.<br>
<br>브리지 bridge
<br>호스트 host
<br>논 none
<br>컨테이너 container
<br>오버레이 overlay
<br>사용자 정의 네트워크는 컨테이너에 유동적으로 연결하고 분리할 수 있다.<br>#분리
docker network disconnect &lt;네트워크 이름&gt; &lt;컨테이너 이름&gt;

#연결
docker network connect &lt;컨테이너 이름&gt; &lt;네트워크 이름&gt;
<br>네트워크의 서브넷, 게이트웨이, ip 할당 범위 등을 임의로 설정하려면 네트워크를 생성할 때 아래와 같이 --subnet, --ip-range, --gateway 옵션을 추가한다. 단, --subnet과 --ip-range는 같은 대역이여야 한다.<br>ex)<br>
docker network create --driver=&lt;network type&gt; --subnet=172.72.0.0/16 --ip-range=172.72.0.0/24 --gateway=172.72.0.1 &lt;network_name&gt;<br><br>브리지 네트워크는 docker0이 아닌 사용자 정의 브릿지를 새로 생성해 각 컨테이너에 연결하는 네트워크 구조이다.<br>컨테이너는 연결된 브릿지를 통해 외부와 통신할 수 있다.<br>
아래와 같은 명령어를 통해 생성한다.<br>docker network create --driver=&lt;네트워크 타입. 브리지 네트워크를 만들고 싶다면 bridge가 들어간다.&gt; &lt;만들고자 하는 네트워크 이름&gt;<br><br>docker run에 --net host 인자를 붙이면 컨테이너의 네트워크를 호스트로 설정할 수 있다.<br>네트워크를 호스트로 설정하면 호스트의 네트워크 환경을 그대로 쓸 수 있다.<br>
즉, 별도의 포트 포워딩 없이 외부와 통신할 수 있다.<br><br>docker run에 --net none 인자를 붙이면 컨테이너의 네트워크를 논으로 설정할 수 있다.<br>논 none은 말 그대로 아무런 네트워크를 쓰지 않는 것을 뜻한다. 논 네트워크로 컨테이너를 설정하면 해당 컨테이너는 외부와 단절된다. <br><br>docker run에 --net container:&lt;다른 컨테이너의 id&gt;와 인자를 붙이면 해당 컨테이너 네트워크의 네임스페이스 환경을 공유할 수 있다. 공유되는 속성은 내부 ip, 네트워크 인터페이스의 맥(MAC) 주소 등이다.<br><br>참고자료<br><a href=".?query=tag:참고도서\그림과_실습으로_배우는_도커_쿠버네티스" class="tag" target="_blank" rel="noopener nofollow">#참고도서/그림과_실습으로_배우는_도커_쿠버네티스</a><br>
<a href=".?query=tag:참고도서\시작하세요_도커_쿠버네티스" class="tag" target="_blank" rel="noopener nofollow">#참고도서/시작하세요_도커_쿠버네티스</a><br>]]></description><link>public\도커-네트워크.html</link><guid isPermaLink="false">public/도커 네트워크.md</guid><pubDate>Fri, 20 Dec 2024 13:58:19 GMT</pubDate><enclosure url="lib\media\도커-네트워크-구조.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="lib\media\도커-네트워크-구조.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[도커 명령어]]></title><description><![CDATA[<a class="tag" href="?query=tag:docker" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#docker</a> <a class="tag" href="?query=tag:참고도서/그림과_실습으로_배우는_도커_쿠버네티스" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/그림과_실습으로_배우는_도커_쿠버네티스</a> <a class="tag" href="?query=tag:참고도서/시작하세요_도커_쿠버네티스" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/시작하세요_도커_쿠버네티스</a> 
 <br><br><a href=".?query=tag:docker" class="tag" target="_blank" rel="noopener nofollow">#docker</a><br>docker command는 상위 커맨드와 하위 커맨드로 이루어져 있다.<br><br><a data-href="도커" href="public\도커.html" class="internal-link" target="_self" rel="noopener nofollow">도커</a>는 도커 명령어를 사용하여 조작한다.<br>도커 명령어는 일반적으로 아래의 형식을 취한다.<br>docker &lt;상위 커맨드&gt;&lt;하위 커맨드&gt; &lt;옵션&gt; &lt;대상&gt; &lt;인자&gt;<br><br>상위 커맨드는 원칙적으로 삭제될 수 없으나 상위 커맨드가 container인 경우, 그리고 version 같은 특수한 커맨드를 사용하는 경우엔 예외로 한다.<br><br><br>
<br>대상이 id를 가지고 있을 경우, 대상의 이름 대신 id를 입력하여 커맨드를 입력할 수 있다. 보통 2~3 글자만 입력하여도 된다.
<br>아래 서술에서 옵션, 인자에 대한 설명이 없는 커맨드는 옵션, 인자를 거의 활용하지 않거나, 아예 없는 커맨드이다.
<br><br><br>컨테이너를 생성해 실행하는 커맨드이다. docker image pull, docker container create, docker container start의 기능을 하나로 합친 것과 같다. 현재 해당 이미지를 내려받은 상태가 아니라면 먼저 이미지를 내려받는다.<br>기본적으로 다음의 형식을 가진다.<br>docker run &lt;옵션&gt; &lt;대상 : 컨테이너를 만드는데 사용할 이미지의 이름&gt; &lt;인자&gt;<br><br>-d를 붙이지 않고 컨테이너를 실행하면 실행된 컨테이너가 프로그램의 실행을 마칠 때까지 터미널의 제어를 차지하므로 그다음 명령을 입력할 수 없는 상태가 된다.<br>
또한 -it 옵션을 붙이지 않으면 컨테이너 안의 파일 시스템에 접근할 수 없다.<br>

docker run = docker pull(이미지가 없을 때 한정) -&gt; docker create -&gt; docker start -&gt; docker attach(-it 옵션을 사용했을 때 한정)<br>
docker create = docker pull(이미지가 없을 때 한정) -&gt; docker create
<br><br>컨테이너의 목록을 출력하는 커맨드.<br>docker ps는 현재 실행 중인 컨테이너의 목록을 출력한다.<br>
docker ps -a는 모든 컨테이너의 목록을 출력한다.<br>
docker ps -q는 컨테이너의 id만을 출력한다. 이를 이용하여<br>docker stop $(docker ps -a -q)
docker rm $(docker ps -a -q)
<br>와 같이 모든 컨테이너를 정지 및 삭제할 수 있다.<br><br>호스트의 파일을 컨테이너에, 또는 컨테이너의 파일을 호스트에 복사하기 위하여 사용하는 명령어.<br>
아래와 같이 원본경로 복사할경로 순서로 인자를 기재하면 된다.<br>컨테이너로 파일을 복사하는 커맨드 사용 예(호스트 -&gt; 컨테이너)<br>
docker cp 호스트_경로 컨테이너_이름:컨테이너_경로<br>호스트로 파일을 복사하는 커맨드 사용 예(컨테이너 -&gt; 호스트)<br>
docker cp 컨테이너_이름:컨테이너_경로 호스트 경로<br><br>기존에 존재하는 컨테이너를 이미지로 변환.<br>
기존 컨테이너를 복제하거나 이동해야 할 때 편리하다.<br>docker commit &lt;컨테이너_이름&gt; &lt;새로운 이미지 이름&gt;<br><br>컨테이너의 내부로 들어가는 명령어. docker exec -it &lt;container id&gt; /bin/bash 명령어와 유사하다.<br>docker attach &lt;container_name&gt;<br>이 명령어의 반대로, ctrl + P, Q로 컨테이너에서 빠져나올 수 있다. exit과 달리 컨테이너를 정지시키지 않고 빠져나올 수 있다는 장점이 있다.<br><br><br><br><br><br>이미지를 대상으로 하는 명령어는 버전을 지정하지 않아도 아래와 같이 동작한다.<br>`docker run --name ubuntoCont -it ubuntu'<br>그러면 이미지의 최신 버전(latest tag)을 내려받는다.<br>
하지만 특정 버전을 사용해야 할 때도 있다. 그런 경우에는 아래와 같은 형식으로 버전을 지정할 수 있다.<br>image:image_version<br><br>docker image --filter "label=..."은 특정 <a data-tooltip-position="top" aria-label="Dockerfile > ^c135e6" data-href="Dockerfile#^c135e6" href="public\dockerfile.html#^c135e6" class="internal-link" target="_self" rel="noopener nofollow">라벨</a>만을 가진 이미지만들 출력한다.<br><br><br><br><br><br>build는 도커의 일반적인 명령어와 달리 상위 커맨드와 하위 커맨드의 구분이 존재하지 않는 독립된 특수한 명령어이다.<br><a data-href="Dockerfile" href="public\dockerfile.html" class="internal-link" target="_self" rel="noopener nofollow">Dockerfile</a>과 재료 파일들이 들어 있는 재료 폴더를 대상으로 사용해 새로운 이미지를 만드는 명령어이다.<br>docker build -t &lt;생성할 이미지 이름&gt; &lt;재료 폴더 경로&gt;<br>-t 인자는 생성할 이미지의 이름을 지정하기 위한 옵션이다.<br><br>참고자료<br><a href=".?query=tag:참고도서\그림과_실습으로_배우는_도커_쿠버네티스" class="tag" target="_blank" rel="noopener nofollow">#참고도서/그림과_실습으로_배우는_도커_쿠버네티스</a><br>
<a href=".?query=tag:참고도서\시작하세요_도커_쿠버네티스" class="tag" target="_blank" rel="noopener nofollow">#참고도서/시작하세요_도커_쿠버네티스</a> <br>]]></description><link>public\도커-명령어.html</link><guid isPermaLink="false">public/도커 명령어.md</guid><pubDate>Fri, 20 Dec 2024 13:58:29 GMT</pubDate></item><item><title><![CDATA[도커 컴포즈]]></title><description><![CDATA[<a class="tag" href="?query=tag:docker" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#docker</a> 
 <br><br><a href=".?query=tag:docker" class="tag" target="_blank" rel="noopener nofollow">#docker</a><br>docker compose<br><br>도커 컴포즈는 다음과 같이 정의할 수 있다. <br>
<br>시스템 구축과 관련된 명령어를 하나의 텍스트 파일(정의 파일)에 기재해 명령어 한번에 시스템 전체를 실행하고 종료와 폐기까지 한 번에 하도록 도와주는 도구.
<br>시스템 구축에 필요한 설정을 YAML(YAML Ain't a Markup Language) 포맷으로 기재한 정의 파일을 이용해 전체 시스템을 일괄 실행(run) 또는 일괄 종료 및 삭제(down)할 수 있는 도구다.
<br>본래 도커 엔진과 별개의 프로그램으로 존재했지만(구버전. docker-compose로 실행) 도커 측에서 도커 엔진을 설치할 때 도커 컴포즈도 패키지로 같이 설치되도록 방침을 바꾸었다(신버전. docker compose로 실행). 따라서 별도의 파일을 설치할 필요는 없다.<br><br>컴포즈 파일의 이름은 미리 정해진 docker-compose.yml이라는 이름을 사용해야 한다.<br>정의 파일은 한 폴더에 하나만 있을 수 있다.<br><br>정의 파일은 YAML 형식을 따른다.<br>
정의 파일에는 services와 networks, volumes를 기재할 수 있다.<br>

도커 컴포즈에서는 컨테이너가 모인 것을 '서비스'라고 부른다.<br>
공식 참조 문서에서는 컨테이너와 서비스라는 두 가지 용어가 함께 사용되는데, 그냥 모두 컨테이너로 이해하면 되므로 큰 문제는 없다.
<br><br><br><br><br>
<br>depends_on : 은 다른 서비스에 대한 의존 관계를 나타낸다. 컨테이너를 생성하는 순서를 정의할 수 있다. 예를 들어, penguin 컨테이너의 정의에 
depends_on
  - namgeuk


<br>라는 내용이 포함되어 있다면 namgeuk 컨테이너를 생성한 다음에 penguin 컨테이너를 만든다.
<br>restart : 컨테이너 종료 시 재시작 여부를 설정한다.
<br>
restart 설정 옵션

<br><br><br><br>build 항목에 정의된 컨텍스트 디렉토리에서 이미지를 빌드해 서비스의 컨테이너를 생성하도록 설정한다. image 항목을 기재한다면, build한 이미지의 이름은 image 항목에 기재된 것이 된다. 만약 image 항목을 기재하지 않는다면, 이미지의 이름은 [프로젝트 이름]:[서비스 이름]이 된다.<br>또한 build 항목에서는 도커 파일에 사용될 컨텍스트나 도커 파일의 이름, 도커 파일에서 사용될 인자 값을 설정할 수 있다.<br>services:
  web:
    build: ./composetest
    context: ./composetest
    dockerfile: myDockerfile
    args:
      HOST_NAME: web
      HOST_CONFIG: self_config
<br><br><br><br>도커 컴포즈는 생성된 컨테이너를 위해 기본적으로 브리지 타입의 네트워크를 생성한다. 그러나 YAML 파일에서 driver 항목을 정의해 서비스의 컨테이너가 브리지 네트워크가 아닌 다른 네트워크를 사용하도록 설정할 수 있다. 특정 드라이버에 필요한 옵션은 하위 항목인 driver_ops로 전달할 수 있다.<br>다음 예제는 docker-compose up -d 명령어로 컨테이너를 생성할 때 mynetwork라는 overlay 타입의 네트워크도 함께 생성하고, myservice 서비스의 네트워크가 mynetwork 네트워크를 사용하도록 설정한다. 단, overlay 타입의 네트워크는 스웜 모드나 주키퍼를 사용하는 환경이어야만 생성할 수 있다.<br>services:
  myservice:
    image: nginx
    networks:
      - mynetwork
networks:
  mynetwork:
    driver: overlay
    driver_opts:
      subnet: "255.255.255.0"
      IPAdress: "10.0.0.2"
<br><br><br><br><br><br>도커 컴포즈는 YAML 파일에서 volume, volumes-from 옵션 등을 사용하면 프로젝트마다 볼륨을 생성한다. 이때 external 옵션을 설정하면 볼륨을 프로젝트를 생성할 때마다 매번 생성하지 않고 기존 볼륨을 사용하도록 설정한다.<br>다음 예제에서 myvolume이라는 이름의 외부 볼륨을 web서비스의 컨테이너에 마운트한다.<br>volumes:
  myvolume:
    external: true
<br><br>
services:
  mysql000ex11:
    image: mysql:5.7
    networks:
      - wordpress000net1
    volumes:
	  - mysql000vol11:/var/lib/mysql
	restart: always
	environment:
	  MYSQL_ROOT_PASSWORD: myrootpass
	  MYSQL_DATABASE: wordpress000db
	  MYSQL_USER: wordpress000kun
	  MYSQL_PASSWORD: kunpass
	wordpress000ex12:
	  depends_on:
	    - mysql000ex11
	  image: wordpress
	  networks:
	    - wordpress000net1
	  volumes:
	    - wordpress000vol12:/var/www/html
	  ports:
	    - 8080:80
	  restart: always
	  environment:
	    WORDPRESS_DB_HOST: mysql1000ex11
	    WORDPRESS_DB_NAME: wordpress000db
	    WORDPRESS_DB_USER: wordpress000kun
	    WORDPRESS_DB_PASSWORD: wkunpass
networks:
  wordpress000net1:
volumes:
  mysql000vol11:
  wordpress000vol12:

<br><br>모든 docker compose 커맨드는 docker compose로 시작한다.<br>현재 작업 디렉토리에 도커 컴포즈 파일이 있다면 그냥 사용한다.<br>
그렇지 않다면, -f 옵션으로 컴포즈 파일의 경로를 지정하여야 한다.<br>docker-compose -f &lt;도커 컴포즈 파일 경로&gt; command &lt;옵션 ...&gt;<br><br><a data-tooltip-position="top" aria-label="도커 명령어 > ^8a9da8" data-href="도커 명령어#^8a9da8" href="public\도커-명령어.html#^8a9da8" class="internal-link" target="_self" rel="noopener nofollow">docker run 커맨드</a>와 유사하다.<br>정의 파일에 기재된 내용대로 이미지를 내려받고 컨테이너를 생성 및 실행한다. 정의 파일에는 네트워크나 볼륨에 대한 정의도 기재할 수 있어서 주변 환경을 한꺼번에 생성할 수 있다.<br><br>docker compose up 명령어의 끝에 서비스의 이름을 입력해 docker-compose.yml 파일에 명시된 특정 서비스의 컨테이너만 생성할 수 있다.<br>docker compose up &lt;도커 컴포즈에서 정의된 서비스 이름&gt;<br><br>docker compose run 명령어로 컨테이너를 생성할 수도 있다. docker compose up과의 차이점은 Interactive 셸을 사용할 수 있다는 것이다.<br><br>정의 파일에 기재된 컨테이너와 네트워크를 정지 및 삭제한다. 볼륨과 이미지는 삭제하지 않는다. 컨테이너와 네트워크 삭제 없이 종료만 하고 싶다면 stop 커맨드를 사용한다.<br><br><br>정의 파일에 기재된 컨테이너를 정지한다.<br><br>docker-compose.yml 파일의 포맷이 적절한지 검사한다.<br>
기본적으로 현재 디렉토리의 docker-compose.yml 파일을 검사한다.<br>docker compose config<br>아래와 같이  검사할 파일의 경로를 설정할 수 있다.<br> docker compose -f &lt;yml 파일 경로&gt; config<br><br>도커 컴포즈 파일에 기재된 서비스를 여러 개 복제하는 명령어이다.<br>docker compose scale &lt;도커 컴포즈 파일에 명시된 서비스 이름&gt;=&lt;복제하고자 하는 개수&gt;<br>예를 들어 도커 컴포즈 파일에 mysql이라는 서비스가 정의되어 있다면, 다음의 명령어를 통해 mysql 컨테이너 4개를 한 번에 만들 수 있다.<br>docker compose scale mysql=4<br><br>YAML 파일에 네트워크 항목을 정의하지 않으면 도커 컴포즈는 프로젝트 별로 브리지 타입의 네트워크를 생성한다. 생성된 네트워크의 이름은 {프로젝트 이름}_default로 설정되며, docker compose up 명령어로 생성되고 docker-compose down 명령어로 삭제된다.<br>서비스 내의 컨테이너는 --net-alias가 서비스의 이름을 갖도록 자동으로 설정되므로 이 네트워크에 속한 컨테이너는 서비스의 이름으로 서비스 내의 컨테이너에 접근할 수 있다.<br>예를 들어, web 서비스와 mysql 서비스가 각기 존재할 때 web 서비스의 컨테이너가 mysql이라는 호스트 이름으로 접근하면 mysql이라는 호스트 이름으로 접근하면 mysql 서비스의 컨테이너 중 하나의 IP로 변환(resolve)되며, 컨테이너가 여러 개 존재할 경우 라운드 로빈으로 연결을 분산한다.<br><br>도커 컴포즈는 컨테이너를 프로젝트 및 서비스 단위로 구분하므로 컨테이너의 이름은 일반적으로 다음과 같은 형식으로 정해진다.<br>[프로젝트 이름]_[서비스 이름]_[서비스 내에서 컨테이너의 번호]<br>도커 컴포즈는 기본적으로 docker-compose.yml 파일이 위치한 디렉터리의 이름을 프로젝트 이름으로 사용한다. 하지만 다음과 같이 -p 옵션을 사용해 프로젝트의 이름을 명시하고 명령어를 적용할 대상(=프로젝트)를 지정할 수 있다<br>docker compose -p &lt;project_name&gt; &lt;cmd&gt; &lt;option&gt;<br>하나의 프로젝트는 여러 개의 서비스로 구성되고, 각 서비스는 여러 개의 컨테이너로 구성된다. 더 나아가, 하나의 서비스에는 컨테이너의 복사본 여러 개가 포함되어 있을 수 있으므로(ex. 서버 컨테이너를 여러 개 올려 부하를 분산한다던가) 차례대로 증가하는 컨테이너의 번호를 붙여 서비스 내의 컨테이너를 구별한다.<br>ubuntu_mysql_1, ubuntu_mysql_2, ..., ubuntu_mysql_n<br>컨테이너의 복제품을 만드는 방법은 앞선 <a data-tooltip-position="top" aria-label="도커 컴포즈 > ^c5d140" data-href="도커 컴포즈#^c5d140" href="public\도커-컴포즈.html#^c5d140" class="internal-link" target="_self" rel="noopener nofollow">도커 컴포즈 커맨드</a> 단락에 기술되어 있다.<br><br>참고자료<br>]]></description><link>public\도커-컴포즈.html</link><guid isPermaLink="false">public/도커 컴포즈.md</guid><pubDate>Sat, 22 Mar 2025 07:31:39 GMT</pubDate></item><item><title><![CDATA[도커 허브]]></title><description><![CDATA[<a class="tag" href="?query=tag:docker" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#docker</a> <a class="tag" href="?query=tag:참고도서/그림과_실습으로_배우는_도커_쿠버네티스" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/그림과_실습으로_배우는_도커_쿠버네티스</a> 
 <br><br><a href=".?query=tag:docker" class="tag" target="_blank" rel="noopener nofollow">#docker</a><br>docker hub<br><br>도커 허브란 공식적으로 운영되는 도커 레지스트리(도커 이미지를 배포하는 서비스)의 이름이다.<br>
도커 허브에는 공개된 <a data-href="이미지" href="public\이미지.html" class="internal-link" target="_self" rel="noopener nofollow">이미지</a>들이 모여 있으며 이중에서 원하는 것을 다운로드 받을 수 있다.<br>
반대로 사용자가 자신이 만든 이미지를 도커 허브에 업로드하는 것도 가능하다.<br>도커 허브에 등록된 이미지는 공식 이미지와 그렇지 않은 이미지로 나뉜다.<br><br>도커에서 직접 배포하거나 해당 소프트웨어를 개발 및 관리하는 기업이나 조직에서 제공하는 이미지를 일컫는다.<br>
이미지 선택이 쉬우며 보안도 챙길 수 있다는 장점이 있다.<br>공식 이미지가 아니더라도 유용하고 안전한 이미지도 많지만 경험이 쌓이지 않으면 신중하게 이미지를 선택하는 것이 좋다.<br><br>참고자료<br><a href=".?query=tag:참고도서\그림과_실습으로_배우는_도커_쿠버네티스" class="tag" target="_blank" rel="noopener nofollow">#참고도서/그림과_실습으로_배우는_도커_쿠버네티스</a> <br>]]></description><link>public\도커-허브.html</link><guid isPermaLink="false">public/도커 허브.md</guid><pubDate>Sat, 22 Mar 2025 07:31:39 GMT</pubDate></item><item><title><![CDATA[동적 라우팅]]></title><description><![CDATA[<a class="tag" href="?query=tag:network" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#network</a> 
 <br><br><a href=".?query=tag:network" class="tag" target="_blank" rel="noopener nofollow">#network</a> <br>dynamic routing<br><br>라우터가 주변의 라우터와 교류하여 목적지에 도달하기 위한 최적의 경로를 스스로 탐색하는 방식. 탐색된 경로는 라우팅 테이블에 저장된다.<br>네트워크 환경의 변화에 지속적으로 대응할 수 있다는 장점이 있지만, 경로 정보를 수집하고 관리하는 작업이 추가로 필요하기 때문에 네트워크에 부하를 가하여 성능에 부정적인 영향을 끼친다.<br><br>참고자료<br><a data-tooltip-position="top" aria-label="https://terms.naver.com/entry.naver?docId=2271886&amp;cid=51207&amp;categoryId=51207" rel="noopener nofollow" class="external-link" href="https://terms.naver.com/entry.naver?docId=2271886&amp;cid=51207&amp;categoryId=51207" target="_blank">네이버 지식백과</a><br>]]></description><link>public\동적-라우팅.html</link><guid isPermaLink="false">public/동적 라우팅.md</guid><pubDate>Sat, 22 Mar 2025 07:31:44 GMT</pubDate></item><item><title><![CDATA[디스트럭처링]]></title><description><![CDATA[<a class="tag" href="?query=tag:language/JavaScript" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#language/JavaScript</a> <a class="tag" href="?query=tag:참고도서/모던_자바스크립트_핵심_가이드" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/모던_자바스크립트_핵심_가이드</a> 
 <br><br><a href=".?query=tag:language\JavaScript" class="tag" target="_blank" rel="noopener nofollow">#language/JavaScript</a> <br>destructuring 비구조화<br><br>디스트럭처링 할당 문법은 배열의 값 또는 객체의 속성을 풀어서 별개의 변수로 쓸 수 있게 해주는 자바스크립트 표현식이다.<br><br>
const person = {
	first: "Alberto",
	last: "Montalesi",
};

const {first, last} = person;

<br>디스트럭처링을 이용하여 person이 가진 속성에 접근함과 동시에 해당 속성 이름으로 변수 선언이 가능함을 알 수 있다.<br>변수의 이름을 객체의 속성과 동일하게 지정하는 데 그치지 않고, 다음과 같이 변수 이름을 바꿀 수도 있다.<br>
// person.links.social.facebook 프로퍼티를 찾아 fb라는 변수로 명명함
const {facebook: fb} = person.links.social;

console.log(fb);        // https://www.facebook.com/alberto.montalesi
console.log(facebook);  // ReferenceError: facebook is not defined

<br>다음과 같이 기본값을 전달할 수도 있다.<br>
// 변수를 fb로 다시 명명하고 기본값을 설정한다.
const {facebook: fb = "https://www.facebook.com"} = person.links.social;

<br><br>
const person = ["Alberto", "Montalesi", 25];
const [name, surname, age] = person;

<br>생성하려는 변수의 수가 배열의 수보다 적다면 오른쪽에서부터 남는 원소를 버린다.<br>나머지 모든 값을 얻고 싶다면 레스트 연산자 rest operator를 사용하면 된다.<br>
const person = ["Alberto", "Montalesi", "pizza", "ice cream", "cheese cake"];
// 레스트 연산자를 사용하여 나머지 값 전체를 얻는다.
const [name, surname, ...food] = person;
// ["pizza", "ice cream", "cheese cake"]
console.log(food);

<br>이 예에서 배열의 처음 두 값은 name과 surname에 할당되고 나머지 rest는 food 배열에 할당된다.<br><br>디스트럭처링 할당을 사용하면 변수의 값을 매우 쉽게 서로 교체할 수 있다.<br>
let hungry = "yes";
let full = "no";

[hungry, full] = [full, hungry];
// no, yes
console.log(hungry, full);

<br><br>참고자료<br><a href=".?query=tag:참고도서\모던_자바스크립트_핵심_가이드" class="tag" target="_blank" rel="noopener nofollow">#참고도서/모던_자바스크립트_핵심_가이드</a> <br>]]></description><link>public\디스트럭처링.html</link><guid isPermaLink="false">public/디스트럭처링.md</guid><pubDate>Mon, 13 Jan 2025 06:56:28 GMT</pubDate></item><item><title><![CDATA[디폴트 생성자]]></title><description><![CDATA[<a class="tag" href="?query=tag:language" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#language</a> <a class="tag" href="?query=tag:참고도서/윤성우의_열혈_cpp_프로그래밍" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/윤성우의_열혈_cpp_프로그래밍</a> 
 <br><br><a href=".?query=tag:language" class="tag" target="_blank" rel="noopener nofollow">#language</a><br>default constructor<br><br>c++ 언어에서 모든 객체는 생성될 때 하나의 생성자가 호출되어야 한다는 규칙이 있다.<br>이러한 기준에 예외를 두지 않기 위해 생성자가 정의되지 않은 클래스가 있다면 c++ 컴파일러는 디폴트 생성자를 삽입한다. 디폴트 생성자는 아무런 인자도 받지 않으며 아무런 기능도 하지 않는다.<br>그러므로 아래의 첫번째 예제의 클래스 정의는 두번째 예제의 클래스 정의와 완전히 동일하다.<br>
class AAA
{
	private :
		int num;
	public :
		int GetNum() {return num;}
}

<br>
class AAA
{
	private :
		int num;
	public :
		AAA() {} //디폴트 생성자
		int GetNum() {return num;}
}

<br><br><br>상술한 매개변수가 void형으로 선언되는 디폴트 생성자는, 생성자가 하나도 정의되어 있지 않을 때에만 삽입이 된다. 즉, 다음과 같이 정의된 클래스에는 디폴트 생성자가 삽입되지 않는다.<br>
class SoSimple
{
	private:
		int num;
	public:
		SoSimple(int n) : num(n) {}
}

<br>따라서 다음의 형태로는 객체 생성이 가능하지만,<br>
SoSimple simObj1(10);
SoSimple * simPtr1 = new SoSimple(2);

<br>다음의 형태로는 객체생성이 불가능하다. void 입력을 받는 생성자가 정의되지도, 자동으로 삽입되지도 않았기 때문이다.<br>
SoSimple simObj2;
SoSimple * simPtr2 = new SoSimple;

<br>따라서 위의 형태로 객체를 생성하기 원한다면, 다음의 형태로 생성자를 추가해야 한다.<br>SoSimple() : num(0) {}<br><br>동적으로 객체를 할당할 때, <a data-tooltip-position="top" aria-label="new &amp; delete" data-href="new &amp; delete" href="public\new-&amp;-delete.html" class="internal-link" target="_self" rel="noopener nofollow">new</a> 연산자를 사용하면 생성자가 호출된다.<br>
반면에, malloc은 단순히 클래스의 크기 정보만 바이트 단위로 전달받기 때문에 생성자가 호출될 수 없다. 그러므로 객체를 동적으로 할당하는 경우 반드시 new 연산자를 사용해야 한다.<br><br>참고자료<br><a href=".?query=tag:참고도서\윤성우의_열혈_cpp_프로그래밍" class="tag" target="_blank" rel="noopener nofollow">#참고도서/윤성우의_열혈_cpp_프로그래밍</a><br>]]></description><link>public\디폴트-생성자.html</link><guid isPermaLink="false">public/디폴트 생성자.md</guid><pubDate>Wed, 28 May 2025 15:54:26 GMT</pubDate></item><item><title><![CDATA[디폴트 소멸자]]></title><description><![CDATA[<a class="tag" href="?query=tag:language/cpp" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#language/cpp</a> <a class="tag" href="?query=tag:참고도서/윤성우의_열혈_cpp_프로그래밍" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/윤성우의_열혈_cpp_프로그래밍</a> 
 <br><br><a href=".?query=tag:language\cpp" class="tag" target="_blank" rel="noopener nofollow">#language/cpp</a> <br>default destructor<br><br>클래스에 <a data-href="소멸자" href="public\소멸자.html" class="internal-link" target="_self" rel="noopener nofollow">소멸자</a>가 정의되어 있지 않을 떄 컴파일러가 자동으로 삽입하는, 아무런 기능도 하지 않는 소멸자.<br>첫번째 예제는 결과적으로 두번째 예제와 동일하다.<br>
class AAA
{
	//empty class
};

<br>
class AAA
{
	public :
		AAA() {}
		~AAA() {}
};

<br><br>참고자료<br><a href=".?query=tag:참고도서\윤성우의_열혈_cpp_프로그래밍" class="tag" target="_blank" rel="noopener nofollow">#참고도서/윤성우의_열혈_cpp_프로그래밍</a><br>]]></description><link>public\디폴트-소멸자.html</link><guid isPermaLink="false">public/디폴트 소멸자.md</guid><pubDate>Sat, 22 Mar 2025 07:31:40 GMT</pubDate></item><item><title><![CDATA[라우터]]></title><description><![CDATA[<a class="tag" href="?query=tag:network" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#network</a> <a class="tag" href="?query=tag:참고도서/그림으로_이해하는_네트워크_용어" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/그림으로_이해하는_네트워크_용어</a> 
 <br><br><a href=".?query=tag:network" class="tag" target="_blank" rel="noopener nofollow">#network</a> <br>router<br><br><a data-href="OSI 참조 모델" href="public\osi-참조-모델.html" class="internal-link" target="_self" rel="noopener nofollow">OSI 참조 모델</a> 3계층(네트워크 계층)의 중계 기능을 제공하는 장치.<br>
LAN과 LAN, LAN과 인터넷처럼 서로 다른 네트워크를 상호 연결하기 위해 사용한다.<br>라우터는 네트워크 프로토콜 수준에서 경로 정보(라우팅 테이블)를 관리한다. 그리고 이 경로 정보를 기반으로 수신지의 네트워크로 통신 데이터를 중계한다.<br>라우터가 수신받은 패킷을 아래의 규칙에 따라 송신한다.<br>
<br>만약 수신한 패킷의 목적지가 LAN 내부라면 외부로 송신하지 않고 그대로 전달한다.
<br>수신한 패킷의 목적지가 다른 네트워크라면 해당 네트워크를 담당하는 라우터에 전송을 의뢰한다.
<br>목적지 네트워크가 먼 곳에 있어서 직접 주고받을 수 없는 경우에는 좀 더 가까운 라우터에 전송한다.
<br><br>참고자료<br><a href=".?query=tag:참고도서\그림으로_이해하는_네트워크_용어" class="tag" target="_blank" rel="noopener nofollow">#참고도서/그림으로_이해하는_네트워크_용어</a><br>]]></description><link>public\라우터.html</link><guid isPermaLink="false">public/라우터.md</guid><pubDate>Sat, 22 Mar 2025 07:31:44 GMT</pubDate></item><item><title><![CDATA[라우팅]]></title><description><![CDATA[<a class="tag" href="?query=tag:network" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#network</a> 
 <br><br><a href=".?query=tag:network" class="tag" target="_blank" rel="noopener nofollow">#network</a> <br>routing<br><br>전달받은 패킷을 어느 출력 경로를 통해 다음 호스트로 전달해야 가장 최적일지 결정하는 것.<br>최적의 기준은 상황마다 다를 수 있다. 단순히 빠른 경로가 최적의 경로일 수 있고, 다소 느리더라도 보안성이 높은 경로가 최적의 경로일 수 있다. 따라서 주어진 상황에 따라 다른 정책을 사용해야 한다.<br>라우팅은 <a data-href="정적 라우팅" href="public\정적-라우팅.html" class="internal-link" target="_self" rel="noopener nofollow">정적 라우팅</a>과 <a data-href="동적 라우팅" href="public\동적-라우팅.html" class="internal-link" target="_self" rel="noopener nofollow">동적 라우팅</a>으로 나눌 수 있다.<br><br>참고자료<br><a data-tooltip-position="top" aria-label="https://terms.naver.com/entry.naver?docId=2271886&amp;cid=51207&amp;categoryId=51207" rel="noopener nofollow" class="external-link" href="https://terms.naver.com/entry.naver?docId=2271886&amp;cid=51207&amp;categoryId=51207" target="_blank">네이버 지식백과</a><br>]]></description><link>public\라우팅.html</link><guid isPermaLink="false">public/라우팅.md</guid><pubDate>Sat, 22 Mar 2025 07:31:44 GMT</pubDate></item><item><title><![CDATA[리터럴]]></title><description><![CDATA[<a class="tag" href="?query=tag:language/cpp" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#language/cpp</a> <a class="tag" href="?query=tag:참고도서/포르잔_cpp_바이블" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/포르잔_cpp_바이블</a> 
 <br><br><a href=".?query=tag:language\cpp" class="tag" target="_blank" rel="noopener nofollow">#language/cpp</a><br>literal<br><br><br><a data-href="자료형" href="public\자료형.html" class="internal-link" target="_self" rel="noopener nofollow">자료형</a>을 가진 상수값을 의미한다.<br><br>정수 리터럴의 기본값은 부호가 있는 int(signed int)이다. short int는 리터럴로 사용하지 않는다. 만약 int의 범위를 넘는 숫자를 생성하면 long int로 생성된다. 컴파일러에게 명시적으로 우리가 원하는 자료형이 long int라고 알리려면 접미사 l 또는 L을 사용한다. 부호 없이 만들려면 접미사 u 또는 U를 사용한다.<br><br><br>문자 리터럴을 정의하는 방식은 작은 따옴표안에 ASCII 테이블에 정의된 글자를 넣는 것이다.<br>
char c = 'A';

<br>두 번째 방식은 ASCII 테이블에 정의된 정수 값을 사용하는 것이다. 하지만 이것은 엄연히 말하자면 문자 리터럴이 아니라 정수 리터럴이며, c++ 언어가 문자 또한 정수의 형태로 다루기 때문에 가능한 것이다.<br>
char c = 65;

<br>일부 특수한 문자를 정의할 때는 이스케이프 문자(역슬래시로 시작하는 기호)를 활용할 수 있다.<br><br><br>true 혹은 false 키워드로 표현한다.<br>
bool b1 = true;
bool b2 = false;

<br><br><br><br>참고자료<br><a href=".?query=tag:참고도서\포르잔_cpp_바이블" class="tag" target="_blank" rel="noopener nofollow">#참고도서/포르잔_cpp_바이블</a> <br>]]></description><link>public\리터럴.html</link><guid isPermaLink="false">public/리터럴.md</guid><pubDate>Sat, 22 Mar 2025 07:31:40 GMT</pubDate></item><item><title><![CDATA[리피터]]></title><description><![CDATA[<a class="tag" href="?query=tag:network" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#network</a> <a class="tag" href="?query=tag:참고도서/그림으로_이해하는_네트워크_용어" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/그림으로_이해하는_네트워크_용어</a> 
 <br><br><a href=".?query=tag:network" class="tag" target="_blank" rel="noopener nofollow">#network</a> <br>repeater<br><br><a data-href="OSI 참조 모델" href="public\osi-참조-모델.html" class="internal-link" target="_self" rel="noopener nofollow">OSI 참조 모델</a> 1계층(물리 계층)의 중계 기능을 제공하는 장치이다.<br>네트워크는 LAN 케이블에 전기 신호를 보내서 통신 데이터를 전송한다. 그러나 케이블이 길어지면 그 안에 흐르는 전기 신호가 감쇠하여 결국 해석할 수 없는 신호가 된다. 리피터는 이렇게 감쇠한 신호를 다시 정렬하고 증폭하여 송출함으로서 LAN의 총 연장 거리를 늘릴 수 있도록 한다.<br><a data-href="이더넷" href="public\이더넷.html" class="internal-link" target="_self" rel="noopener nofollow">이더넷</a>에서는 동일한 경로에 리피터를 네 개 까지 사용하여 총 연장 거기를 늘릴 수 있다. 상한이 정해져 있는 이유는 몇 단계씩 리피터를 경유하면 신호가 왜곡되어 해석할 수 없게 되고, 총 연장 거리가 너무 길어지면 콜리전(신호 충돌) 감지가 잘 동작하지 않기 때문이다.<br>리피터를 여러 개 묶어서 멀티 포트로 사용하는 것을 <a data-href="허브" href="public\허브.html" class="internal-link" target="_self" rel="noopener nofollow">허브</a>라고 한다.<br><br>참고자료<br><a href=".?query=tag:참고도서\그림으로_이해하는_네트워크_용어" class="tag" target="_blank" rel="noopener nofollow">#참고도서/그림으로_이해하는_네트워크_용어</a><br>]]></description><link>public\리피터.html</link><guid isPermaLink="false">public/리피터.md</guid><pubDate>Sat, 22 Mar 2025 07:31:44 GMT</pubDate></item><item><title><![CDATA[마운트]]></title><description><![CDATA[<a class="tag" href="?query=tag:docker" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#docker</a> <a class="tag" href="?query=tag:참고도서/그림과_실습으로_배우는_도커_쿠버네티스" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/그림과_실습으로_배우는_도커_쿠버네티스</a> <a class="tag" href="?query=tag:참고도서/시작하세요_도커_쿠버네티스" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/시작하세요_도커_쿠버네티스</a> 
 <br><br><a href=".?query=tag:docker" class="tag" target="_blank" rel="noopener nofollow">#docker</a><br>mount<br><br>마운트란 '연결하다'라는 의미 그대로 대상을 연결해 운영체제 또는 소프트웨어의 관리하에 두는 일을 말한다.<br><a data-href="컨테이너" href="public\컨테이너.html" class="internal-link" target="_self" rel="noopener nofollow">컨테이너</a>는 그 특성상 폐기가 빈번하고(<a data-tooltip-position="top" aria-label="컨테이너 > ^66906a" data-href="컨테이너#^66906a" href="public\컨테이너.html#^66906a" class="internal-link" target="_self" rel="noopener nofollow">컨테이너의 생애 주기 참고</a>), 폐기 시 내부 데이터도 함께 소멸하기 때문에 보존되어야 하는 데이터를 외부로 대피시켜야 한다는 번거로움이 있다.<br>이러한 문제를 해결하기 위해 도커는 컨테이너와 호스트의 스토리지에 마운트하는 기능을 제공한다.<br>보통 운영체제나 스택 같이 주기적으로 업데이트되는 부분은 컨테이너 형태로 만들어 변경 사항이 있을 때마다 최신 컨테이너로 갈아끼우고(<a data-tooltip-position="top" aria-label="컨테이너 > ^66906a" data-href="컨테이너#^66906a" href="public\컨테이너.html#^66906a" class="internal-link" target="_self" rel="noopener nofollow">컨테이너의 생애 주기 참고</a>) 사용자 정보 같은 보존되어야 하는 데이터는 마운트된 공간에 보존한다.<br>이를 데이터 퍼시스턴시 data persistency라고 한다.<br>도커의 마운트는 볼륨 마운트와 바인드 마운트로 나뉜다.<br><br><br>볼륨이란 스토리지의 한 영역을 분할한 것을 말한다.<br>도커에서는 <a data-tooltip-position="top" aria-label="도커 명령어" data-href="도커 명령어" href="public\도커-명령어.html" class="internal-link" target="_self" rel="noopener nofollow">docker volume 명령어</a>로 볼륨을 만들 수 있으며, 이렇게 만들어진 볼륨은 도커 엔진이 관리하는 영역 내에 만들어지게 된다. 볼륨 마운트란 도커가 관리하는 볼륨에 마운트하는 방식이다.<br>이름만으로 관리가 가능하므로 다루기 쉽지만 볼륨에 비해 직접 조작하기 어려우므로 '임시 목적의 사용'이나 '자주 쓰지는 않지만 지우면 안되는 파일'을 두는 목적으로 많이 사용한다.<br>
<br>
장점

<br>도커 엔지의 관리 하에 있으므로 사용자가 파일 위치를 신경 쓸 필요가 없다.
<br>운영체제에 따른 의존성 문제가 일어나지 않는다.


<br>
단점

<br>도커 컨테이너를 경유하지 않고 직접 볼륨에 접근할 방법이 없다.
<br>백업을 하기 위해 복잡한 절차가 필요하다.


<br><br>어느 마운트 방식을 사용하든 스토리지 마운트는 <a data-tooltip-position="top" aria-label="도커 명령어 > ^8a9da8" data-href="도커 명령어#^8a9da8" href="public\도커-명령어.html#^8a9da8" class="internal-link" target="_self" rel="noopener nofollow">run 커맨드</a>의 옵션 형태로 지정한다. 마운트하려는 스토리지의 경로가 컨테이너 속 특정 경로와 연결되도록 설정하는 형태이다.<br>볼륨 마운트의 경우 마운트와 동시에 볼륨을 만들 수도 있지만 이 방법은 권장하지 않는다. 마운트 전에 별도로 볼륨을 먼저 생성하는 것이 좋다.<br>구체적인 커맨드는 아래와 같다.<br>docker run (생략) -v &lt;볼륨 이름:컨테이너_마운트_경로&gt; (생략)<br>만약 -v 옵션을 입력할 때 -v /root와 같이 볼륨의 이름을 기입하지 않으면 컨테이너가 자동으로 생성한다.<br><br>상술했듯이 컨테이너를 거치지 않으면 볼륨을 확인할 수 있는 방법이 없다.<br>따라서 <a data-tooltip-position="top" aria-label="도커 명령어 > ^d619a1" data-href="도커 명령어#^d619a1" href="public\도커-명령어.html#^d619a1" class="internal-link" target="_self" rel="noopener nofollow">docker volume inspect</a>나 <a data-tooltip-position="top" aria-label="도커 명령어" data-href="도커 명령어" href="public\도커-명령어.html" class="internal-link" target="_self" rel="noopener nofollow">docker container inspect</a> 같이 간접적으로 확인하는 방법이 아닌, 직접적으로 볼륨 내부를 확인하고 싶다면 아래와 같은 절차를 거쳐야 한다.<br>
<br>해당 볼륨에 마운트된 컨테이너가 -it 옵션으로 실행되어 docker exec -it &lt;container_name&gt; /bin/bash로 외부에서 조작이 가능한 경우, 그 컨테이너를 통해 볼륨을 확인한다.
<br>그렇지 않다면, -it 옵션, linux 운영체제 이미지를 사용하여, 관찰하고자 하는 볼륨에 마운트하여 컨테이너를 새로 만든다. 그리고 해당 컨테이너에 docker exec -it &lt;container_name&gt; /bin/bash를 사용하여 볼륨을 확인할 수 있다.
<br><br>볼륨 자체를 복사하는 것은 불가능하다.<br>따라서 볼륨을 확인할 때처럼 별도의 리눅스 컨테이너를 연결하여 볼륨의 내용을 압축해 저장하여야 한다.<br>아래는 볼륨 백업 커맨드의 예시이다.<br>docker run --rm -v &lt;백업할 볼륨명:/source&gt; -v &lt;백업_저장_폴더명:/target&gt; busybox tar cvzf /target/ 백업파일이름.tar.gz -C /source<br>
<br>run 커맨드로 리눅스 운영체제(busybox) 컨테이너를 실행한다.
<br>--rm : 이 컨테이너는 실행 후 바로 삭제할 예정이므로 옵션에 --rm을 추가했다.
<br>-v &lt;백업할 볼륨명:/source&gt; : 백업할 볼륨을 컨테이너의 /source에 마운트한다.
<br>-v &lt;백업_저장_폴더명:/target&gt; : 압축된 백업 파일을 저장할 호스트의 디렉토리를 마운트한다.
<br>tar cvzf /target/백업파일이름.tar.gz -C /source

<br>tar은 tar 압축을 사용하는 명령어이다.
<br>czvf : 압축 옵션
<br>-C /source : 압축 대상을 /source로 지정
<br>/target/백업파일이름.tar.gz : 압축 결과물을 /target/의 백업파일이름.tar.gz 파일로 저장


<br><br>바인드 마운트는 도커가 설치된 컴퓨터의 문서 폴더 또는 바탕화면 폴더 등 도커에서 관리하지 않는 영역의 기존 디렉터리를 컨테이너에 마운트하는 방식이다. 디렉터리가 아닌 파일 단위로도 마운트가 가능하다.<br>폴더(디렉토리) 속에 파일을 직접 두거나 열어볼 수 있기 떄문에 자주 사용하는 파일을 두는 데 사용한다.<br>
<br>장점

<br>도커가 관리하지 않는 어디라도 파일을 둘 수 있다.
<br>기존과 동일한 방식으로 파일을 사용할 수 있으므로 다른 소프트웨어를 사용해 쉽게 편집할 수 있다.


<br><br>아래와 같은 커맨드로 사용한다.<br>docker run (생략) -v &lt;호스트의 마운트하고자하는 디렉토리 경로:컨테이너 마운트 경로&gt; (생략)<br><br>컨테이너를 생성할 때 --volumes-from 옵션을 설정하면 -v 또는 --volume 옵션을 적용한 컨테이너의 볼륨 디렉토리를 공유할 수 있다. 이는 직접 볼륨을 공유하는 것이 아닌 -v 옵션을 적용한 컨테이너를 통해 공유하는 것이다.<br>docker run -it --name &lt;볼륨을 공유받을 컨테이너의 이름&gt; --volumes-from &lt;볼륨을 공유해 줄 컨테이너의 이름&gt; &lt;image name&gt;<br><br>컨테이너 안의 파일이 마운트된 디렉토리로 복사되는 것이 아닌, 아예 같은 디렉토리로 처리된다는 점에 유의해야 한다.<br>-v 옵션에 존재하지 않는 호스트의 디렉토리를 전달하면 해당 디렉토리가 생성되며 컨테이너 상의 파일이 옮겨온다.<br>만약 호스트와 컨테이너 모두에 디렉토리가 존재하고 해당 컨테이너 안에 파일이 있다면 컨테이너의 디렉토리가 호스트의 디렉토리로 덮어씌워진다(즉, 호스트의 경로가 우선권을 가진다).<br><br>디스크가 아닌 주 메모리 영역을 마운트한다. 디스크보다 훨씬 빠른 속도로 읽고 쓰기가 가능하기 때문에 접근 속도를 높일 목적으로 사용하지만 도커 엔진이 정지되거나 호스트가 재부팅하면 소멸한다.<br><br>두 가지 마운트 방식의 차이점은<br>
<br>간단한지 복잡한지
<br>호스트 컴퓨터에서 파일을 다룰 필요가 있는지
<br>환경의 의존성을 배제해야 하는지
<br>이다.<br>보통 파일을 직접 편집해야 할 일이 많다면 바인드 마운트, 그렇지 않다면 볼륨 마운트를 사용한다.<br><br>스테이트리스 stateless : 컨테이너가 아닌 외부에 데이터를 저장하고 컨테이너는 그 데이터로 동작하도록 설계하는 것. 다르게 말하자면, 컨테이너 자체는 상태가 없고 상태를 결정하는 데이터는 외부로부터 제공받는다.<br>스테이트 풀 stateful : 컨테이너 자체가 데이터를 포함하고 있어 상태가 존재하는 경우<br><br>--mount 옵션은 -v 옵션을 대체하여 사용할 수 있는 옵션이다.<br>
<br>
볼륨 마운트의 경우<br>
docker run -it --name &lt;컨테이너의 이름&gt; --mount type=volume,source=&lt;볼륨의 이름&gt;,target=&lt;마운트할 컨테이너의 경로&gt; &lt;이미지 이름&gt;

<br>
바인드 마운트의 경우<br>
docker run -it --name &lt;컨테이너의 이름&gt; --mount type=bind,source=&lt;호스트의 디렉토리&gt;,target=&lt;마운트할 컨테이너의 경로&gt; &lt;이미지 이름&gt;

<br><br>참고자료<br><a href=".?query=tag:참고도서\그림과_실습으로_배우는_도커_쿠버네티스" class="tag" target="_blank" rel="noopener nofollow">#참고도서/그림과_실습으로_배우는_도커_쿠버네티스</a><br>
<a href=".?query=tag:참고도서\시작하세요_도커_쿠버네티스" class="tag" target="_blank" rel="noopener nofollow">#참고도서/시작하세요_도커_쿠버네티스</a> <br>]]></description><link>public\마운트.html</link><guid isPermaLink="false">public/마운트.md</guid><pubDate>Sat, 22 Mar 2025 07:31:39 GMT</pubDate></item><item><title><![CDATA[마이크로서비스]]></title><description><![CDATA[ 
 <br><br>microservice<br><br>마이크로서비스 아키텍처는 하나의 애플리케이션 내에 있는 각 핵심 기능이 독립적으로 존재할 수 있도록 소프트웨어를 구축하는 클라우드 네이티브 접근 방식이다.<br><br>애플리케이션 빌드의 전통적인 방식은 모눌리식 위주이다. 모눌리식 아키텍처에서는 애플리케이션 내의 모든 기능과 서비스가 함께 맞물려 단일 유닛으로 운영된다. 애플리케이션이 어떤 방식으로든 추가되면 아키텍처는 더 복잡해진다. 그 결과 전체 애플리케이션을 분리하지 않고는 애플리케이션 내의 단일 기능을 최적화하기가 더 어려워지고, 만약 애플리케이션 내의 하나의 프로세스가 확장되어야 할 때는 전체 애플리케이션도 확장되어야 한다.<br>마이크로서비스 아키텍처에서 애플리케이션은 애플리케이션 내의 각 핵심 기능이 독립적으로 작동하도록 빌드된다. 따라서 개발 팀은 애플리케이션 전체를 중단하지 않고 변화하는 비즈니스 요구 사항을 충족하기 위한 새로운 구성 요소를 구축하고 업데이트할 수 있다.<br><br>마이크로서비스는 분산형 개발을 통해 팀의 역량과 일상적인 업무 능력을 향상시킨다. 또한, 여러 마이크로서비스를 동시에 개발하는 것도 가능하다. 따라서 동일한 애플리케이션 개발에 더 많은 개발자들이 동시 참여할 수 있으므로 개발에 소요되는 시간을 단축할 수 있다.<br><br>더 자세한 정보를 원한다면 아래로<br><a data-tooltip-position="top" aria-label="https://www.redhat.com/ko/topics/microservices/what-are-microservices" rel="noopener nofollow" class="external-link" href="https://www.redhat.com/ko/topics/microservices/what-are-microservices" target="_blank">redhat 홈페이지</a><br>]]></description><link>public\마이크로서비스.html</link><guid isPermaLink="false">public/마이크로서비스.md</guid><pubDate>Sat, 22 Mar 2025 07:43:56 GMT</pubDate></item><item><title><![CDATA[매개변수의 디폴트 값]]></title><description><![CDATA[<a class="tag" href="?query=tag:language/cpp" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#language/cpp</a> <a class="tag" href="?query=tag:참고도서/윤성우의_열혈_cpp_프로그래밍" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/윤성우의_열혈_cpp_프로그래밍</a> 
 <br><br><a href=".?query=tag:language\cpp" class="tag" target="_blank" rel="noopener nofollow">#language/cpp</a> <br>default value<br><br>c++ 언어에서는 함수의 매개변수의 기본값을 지정 가능하다. 함수를 호출할 때 인자를 전달하지 않으면, 컴파일러는 지정된 기본값으로 함수가 호출되었다고 간주한다. 여기서 기본값을 디폴트 값이라고 한다.<br>매개변수의 디폴트 값이 설정되어 있으면, 선언된 매개변수의 수보다 적은 수의 인자전달이 가능하다. 그리고 전달되는 인자는 왼쪽에서부터 채워져 나가고, 부족분은 디폴트 값으로 채워진다.<br>함수의 원형을 별도로 선언하는 경우, 매개변수의 디폴트 값은 함수의 원형 선언에만 위치시켜야 한다.<br>매개변수 중 일부에만 디폴트 값을 지정할 수도 있다. 이를 부분적 디폴트 값 설정이라고 한다. 단, 함수의 호출 시 인자는 왼쪽에서 오른쪽으로 전달되기 때문에 부분적 디폴트 값 설정 시 디폴트 값은 오른쪽 매개변수부터 차례대로 지정해야 한다.<br><br>참고자료<br><a href=".?query=tag:참고도서\윤성우의_열혈_cpp_프로그래밍" class="tag" target="_blank" rel="noopener nofollow">#참고도서/윤성우의_열혈_cpp_프로그래밍</a><br>]]></description><link>public\매개변수의-디폴트-값.html</link><guid isPermaLink="false">public/매개변수의 디폴트 값.md</guid><pubDate>Sat, 22 Mar 2025 07:31:40 GMT</pubDate></item><item><title><![CDATA[멀티 쓰레딩 기반 서버]]></title><description><![CDATA[<a class="tag" href="?query=tag:socket_programming" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#socket_programming</a> <a class="tag" href="?query=tag:network" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#network</a> <a class="tag" href="?query=tag:server" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#server</a> <a class="tag" href="?query=tag:참고도서/윤성우의_열혈_TCP_IP_소켓_프로그래밍" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/윤성우의_열혈_TCP_IP_소켓_프로그래밍</a> 
 <br><br><a href=".?query=tag:socket_programming" class="tag" target="_blank" rel="noopener nofollow">#socket_programming</a> <a href=".?query=tag:network" class="tag" target="_blank" rel="noopener nofollow">#network</a> <a href=".?query=tag:server" class="tag" target="_blank" rel="noopener nofollow">#server</a> <br>**<br><br><br>참고자료<br><a href=".?query=tag:참고도서\윤성우의_열혈_TCP_IP_소켓_프로그래밍" class="tag" target="_blank" rel="noopener nofollow">#참고도서/윤성우의_열혈_TCP_IP_소켓_프로그래밍</a> <br>]]></description><link>public\멀티-쓰레딩-기반-서버.html</link><guid isPermaLink="false">public/멀티 쓰레딩 기반 서버.md</guid><pubDate>Sat, 22 Mar 2025 07:31:46 GMT</pubDate></item><item><title><![CDATA[멀티 프로세스 기반 서버]]></title><description><![CDATA[<a class="tag" href="?query=tag:socket_programming" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#socket_programming</a> <a class="tag" href="?query=tag:network" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#network</a> <a class="tag" href="?query=tag:server" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#server</a> <a class="tag" href="?query=tag:참고도서/윤성우의_열혈_TCP_IP_소켓_프로그래밍" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/윤성우의_열혈_TCP_IP_소켓_프로그래밍</a> 
 <br><br><a href=".?query=tag:socket_programming" class="tag" target="_blank" rel="noopener nofollow">#socket_programming</a> <a href=".?query=tag:network" class="tag" target="_blank" rel="noopener nofollow">#network</a> <a href=".?query=tag:server" class="tag" target="_blank" rel="noopener nofollow">#server</a> <br>multi process server<br><br>멀티 프로세스 기반 서버는 다음과 같은 과정을 통해 non-blocking한(즉, <a data-href="다중 접속 서버" href="public\다중-접속-서버.html" class="internal-link" target="_self" rel="noopener nofollow">다중 접속 서버</a>를) 구현한다.<br>
<br>서버(부모 프로세스)는 accept 함수 호출을 통해서 연결 요청을 수락한다.
<br>이때 얻게 되는 소켓의 파일 디스크립터를 자식 프로세스를 생성해서 넘겨준다.
<br>자식 프로세스는 전달받은 파일 디스크립터를 바탕으로 서비스를 제공한다.
<br>부모 프로세스는 1의 과정을 되풀이하며 지속적으로 클라이언트의 연결 요청을 수락한다. 이후 반복.
<br>
// echo_mpserv.c

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;unistd.h&gt;
#include &lt;signal.h&gt;
#include &lt;sys/wait.h&gt;
#include &lt;arpa/inet.h&gt;
#include &lt;sys/socket.h&gt;

#define BUF_SIZE 30

void error_handling(char *message);
void read_childproc(int sig);

int main(int argc, char *argv[])
{
	if (argc != 2) {
		printf("Usage : %s &lt;port&gt;\n", argv[0]);
		exit(1);
	}
	
	int serv_sock, clnt_sock;
	struct sockaddr_in serv_adr, clnt_adr;

	pid_t pid;
	struct sigaction act;
	socklen_t adr_sz;
	int str_len, state;
	char buf[BUF_SIZE];

	// SIGCHLD가 발생하면 좀비를 회수하도록 처리한다.
	act.sa_handler = read_childproc;
	sigemptyset(&amp;act.sa_mask);
	act.sa_flags = 0;
	state = sigaction(SIGCHLD, &amp;act, 0);

	// tcp 서버 소켓을 만든다.
	serv_sock = socket(PF_INET, SOCK_STREAM, 0);
	memset(&amp;serv_adr, 0, sizeof(serv_adr));
	serv_adr.sin_family = AF_INET;
	serv_adr.sin_addr.s_addr = htonl(INADDR_ANY);
	serv_adr.sin_port = htons(atoi(argv[1]));
	
	if (bind(serv_sock, (struct sockaddr *)&amp;serv_adr, sizeof(serv_adr)) == -1)
		error_handling("bind() error");
	if (listen(serv_sock, 5) == -1)
		error_handling("listen() error");

	while (1)
	{
		// 클라이언트의 연결 요청을 수락한다.
		adr_sz = sizeof(clnt_adr);
		clnt_sock = accept(serv_sock, (struct sockaddr *)&amp;clnt_adr, &amp;adr_sz);
		if (clnt_sock == -1)
			continue ;
		else
			puts("new client connected...");

		// fork()하여 자식 프로세스에게 클라이언트에게 서비스 제공하는 작업을 전담한다.
		// 이때, 자식 프로세스는 부모 프로세스의 메모리 공간을 복사하여 생성되므로 별도의 전달 작업
		// 없이 클라이언트와 연결된 소켓을 사용할 수 있다.
		pid = fork();
		if (pid == -1)
		{
			close(clnt_sock);
			continue;
		}
		if (pid == 0)
		{
			close(serv_sock);
			while ((str_len = read(clnt_sock, buf, BUF_SIZE)) != 0)
				write(clnt_sock, buf, str_len);

			close(clnt_sock);
			puts("client disconnected...");

			return (0);
		}
		else
			close(clnt_sock);
	}
	close(serv_sock);
	return (0);
}

void read_childproc(int sig)
{
	sig = 0;
	
	pid_t pid;
	int status;
	pid = waitpid(-1, &amp;status, WNOHANG);
	printf("removed proc id: %d \n", pid);
}

void error_handling(char *message)
{
	fputs(message, stderr);
	fputc('\n', stderr);
	exit(1);
}

<br><br>멀티 프로세스 기반으로 서버를 작성하면 기능 별로 코드를 분할하기 용이하다. 특히 데이터를 송신하는 부분과 데이터를 수신하는 부분을 분할하여 작성하면 코드의 가독성이 크게 증대된다.<br>입출력 루틴 분할의 또 다른 장점은, 데이터 송수신이 잦은 프로그램의 성능향상을 들 수 있다.<br><img alt="tcp 입출력 루틴 분할.png" src="lib\media\tcp-입출력-루틴-분할.png" style="width: 600px; max-width: 100%;"><br>위 그림의 왼쪽은 이전 에코 클라이언트의 데이터 송수신 방식을, 그리고 오른쪽은 입출력 루틴을 분리시킨 에코 클라이언트의 데이터 송수신 방식을 보여준다. 일단 서버에서의 차이는 없다. 차이가 나는 부분은 클라이언트 영역이다. 입출력 루틴이 분리된 클라이언트는 데이터의 수신 여부에 상관없이 데이터 전송이 가능하기 떄문에 연속해서 데이터의 전송이 가능하다. 따라서 동일한 시간 내에서의 데이터 송수신 분량이 상대적으로 많을 수밖에 없다. 그리고 이러한 성능적 차이는 데이터의 전송 속도가 느린 환경에서 더 확실히 드러난다.<br>
// echo_mpclient.c

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;unistd.h&gt;
#include &lt;arpa/inet.h&gt;
#include &lt;sys/socket.h&gt;

#define BUF_SIZE 30

void error_handling(char *message);
void read_routine(int sock, char *buf);
void write_routine(int sock, char *buf);

int main(int argc, char *argv[])
{
	// 인자 개수 체크
	if (argc != 3)
	{
		printf("Usage : %s &lt;IP&gt; &lt;port&gt;\n", argv[0]);
		exit(1);
	}
	
	int sock;
	pid_t pid;
	char buf[BUF_SIZE];
	struct sockaddr_in serv_adr;

	// 소켓을 만들어 서버에 접속
	sock = socket(PF_INET, SOCK_STREAM, 0);
	memset(&amp;serv_adr, 0, sizeof(serv_adr));
	serv_adr.sin_family = AF_INET;
	serv_adr.sin_addr.s_addr = inet_addr(argv[1]);
	serv_adr.sin_port = htons(atoi(argv[2]));

	if (connect(sock, (struct sockaddr *)&amp;serv_adr, sizeof(serv_adr)) == -1)
		error_handling("connect() error!");

	// 입력 루틴과 출력 루틴을 분할
	// 입력은 부모에서, 출력은 자식에서 실행한다.
	pid = fork();
	if (pid == 0)
		write_routine(sock, buf);
	else
		read_routine(sock, buf);

	close(sock);
	return (0);
}

// 입력 루틴 : 서버에서 연결을 끊을 때까지 전달받은 명령을 표준 출력으로 보낸다.
void read_routine(int sock, char *buf)
{
	while (1)
	{
		int str_len = read(sock, buf, BUF_SIZE);
		if (str_len == 0)
			return ;

		buf[str_len] = 0;
		printf("Message from server: %s", buf);
	}
}

// 출력 루틴 : 표준 입력으로부터 입력받아 서버에 보낸다.
// q 또는 Q라는 입력을 받으면 shutdown 시스템콜을 사용하여
// write 버퍼를 닫는 동시에 서버에 EOF를 보낸다.
// 서버 측은 EOF를 전달받으면 close()를 통하여 클라이언트와의 연결을 끊는다고 기대할 수 있다.
// 그러면 부모에서 동작하고 있는 read_routine에서도 read()가 0을 반환함을 통해
// 연결이 끊겼음을 인지한다.
void write_routine(int sock, char *buf)
{
	while (1)
	{
		fgets(buf, BUF_SIZE, stdin);
		if (!strcmp(buf, "q\n") || !strcmp(buf, "Q\n"))
		{
			shutdown(sock, SHUT_WR);
			// 연결이 끊기면 바로 return 하므로 별도로 좀비를 회수할 필요가 없다.
			return ;
		}
		write(sock, buf, strlen(buf));
	}
}

void error_handling(char *message)
{
	fputs(message, stderr);
	fputc('\n', stderr);
	exit(1);
}

<br><br>참고자료<br><a href=".?query=tag:참고도서\윤성우의_열혈_TCP_IP_소켓_프로그래밍" class="tag" target="_blank" rel="noopener nofollow">#참고도서/윤성우의_열혈_TCP_IP_소켓_프로그래밍</a> <br>]]></description><link>public\멀티-프로세스-기반-서버.html</link><guid isPermaLink="false">public/멀티 프로세스 기반 서버.md</guid><pubDate>Sat, 22 Mar 2025 07:31:46 GMT</pubDate><enclosure url="lib\media\tcp-입출력-루틴-분할.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="lib\media\tcp-입출력-루틴-분할.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[멀티 플렉싱 기반 서버]]></title><description><![CDATA[<a class="tag" href="?query=tag:socket_programming" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#socket_programming</a> <a class="tag" href="?query=tag:network" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#network</a> <a class="tag" href="?query=tag:server" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#server</a> <a class="tag" href="?query=tag:참고도서/윤성우의_열혈_TCP_IP_소켓_프로그래밍" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/윤성우의_열혈_TCP_IP_소켓_프로그래밍</a> 
 <br><br><a href=".?query=tag:socket_programming" class="tag" target="_blank" rel="noopener nofollow">#socket_programming</a> <a href=".?query=tag:network" class="tag" target="_blank" rel="noopener nofollow">#network</a> <a href=".?query=tag:server" class="tag" target="_blank" rel="noopener nofollow">#server</a> <br>multiplexing server<br><br>멀티 플렉싱이란 <a data-href="다중 접속 서버" href="public\다중-접속-서버.html" class="internal-link" target="_self" rel="noopener nofollow">다중 접속 서버</a>를 구현하는 방법 중의 하나이다.<br>
멀티 플렉싱의 원리를 거칠게 설명하면 아래와 같다.<br>
<br>서버가 소켓을 열고 <a data-href="listen" href="public\listen.html" class="internal-link" target="_self" rel="noopener nofollow">listen</a>한다.
<br>여러 클라이언트가 서버에 연결 요청을 한다.
<br>서버는 요청한 모든 클라이언트와의 연결을 수락하고, 연결된 소켓을 별도의 관리 테이블에 저장한다.
<br>서버는 내부적으로 연결된 소켓에서 발생하는 이벤트를 무한 반복문을 통해 감시한다.

<br>이 때의 이벤트는, 클라이언트에서 데이터를 소켓에 전송해 커널 영역에 데이터가 세팅되어 서버와 연결된 소켓이 read가 가능해진 상태가 되는 이벤트를 의미한다.
<br>서버는 <a data-href="select" href="public\select.html" class="internal-link" target="_self" rel="noopener nofollow">select</a> 등의 시스템 콜을 사용하여 이벤트를 감지한다.


<br>클라이언트가 연결된 소켓에게 데이터를 전송한다.

<br>데이터가 커널 영역에 저장되어 read 호출이 가능해지면 이벤트가 발생한다.
<br>서버는 계속 무한 반복문을 통해 이벤트를 감시한다.


<br>서버에서 무한 루프를 통해 관리 테이블에 저장한 소켓의 이벤트를 감시하다가, 이벤트가 발생한 것을 감지하고 클라이언트의 요청을 처리한다.
<br>서버에서 요청을 처리한 이후 클라이언트와 연결된 소켓을 해당 클라이언트에게 응답을 반환한다.
<br>이후 멀티 플렉싱에 관련된 자세한 기술은 <a data-href="select" href="public\select.html" class="internal-link" target="_self" rel="noopener nofollow">select</a> 문서를 참고하자.<br><br>참고자료<br><a href=".?query=tag:참고도서\윤성우의_열혈_TCP_IP_소켓_프로그래밍" class="tag" target="_blank" rel="noopener nofollow">#참고도서/윤성우의_열혈_TCP_IP_소켓_프로그래밍</a> <br>]]></description><link>public\멀티-플렉싱-기반-서버.html</link><guid isPermaLink="false">public/멀티 플렉싱 기반 서버.md</guid><pubDate>Sat, 22 Mar 2025 07:31:46 GMT</pubDate></item><item><title><![CDATA[멀티캐스트]]></title><description><![CDATA[<a class="tag" href="?query=tag:network" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#network</a> <a class="tag" href="?query=tag:참고도서/후니의_쉽게_쓴_시스코_네트워킹" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/후니의_쉽게_쓴_시스코_네트워킹</a> 
 <br><br><a href=".?query=tag:network" class="tag" target="_blank" rel="noopener nofollow">#network</a> <br>Multicast<br><br>LAN을 구성하는 구성원 중 특정 그룹에만 송신할 수 있는 기능. <a data-href="유니캐스트" href="public\유니캐스트.html" class="internal-link" target="_self" rel="noopener nofollow">유니캐스트</a>와 <a data-href="브로드캐스트" href="public\브로드캐스트.html" class="internal-link" target="_self" rel="noopener nofollow">브로드캐스트</a>의 장점을 합쳤다고 볼 수 있다.<br>만약 100개의 pc 중 50개의 pc에만 메시지를 전달하는 상황이라 가정할 때, 유니캐스트는 메시지를 50번 송신해야 한다는 단점이 있고, 브로드캐스트는 나머지 50개의 pc에도 불필요하게 메시지를 송신해야 한다는 단점이 있다. 멀티캐스트를 사용하면 1번의 송신으로 지정된 pc들에게만 메시지를 보낼 수 있다. <br>단, 멀티캐스트는 <a data-href="스위칭 허브" href="public\스위칭-허브.html" class="internal-link" target="_self" rel="noopener nofollow">스위칭 허브</a>나 <a data-href="라우터" href="public\라우터.html" class="internal-link" target="_self" rel="noopener nofollow">라우터</a>가 멀티캐스트를 지원해야 사용할 수 있다는 제약이 있다. 스위칭 허브나 라우터가 멀티캐스트를 지원하지 않을 경우, 멀티캐스트를 브로드캐스트와 같이 취급한다.<br><br>참고자료<br><a href=".?query=tag:참고도서\후니의_쉽게_쓴_시스코_네트워킹" class="tag" target="_blank" rel="noopener nofollow">#참고도서/후니의_쉽게_쓴_시스코_네트워킹</a><br>]]></description><link>public\멀티캐스트.html</link><guid isPermaLink="false">public/멀티캐스트.md</guid><pubDate>Sat, 22 Mar 2025 07:31:44 GMT</pubDate></item><item><title><![CDATA[멤버 이니셜라이저]]></title><description><![CDATA[<a class="tag" href="?query=tag:language/cpp" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#language/cpp</a> <a class="tag" href="?query=tag:참고도서/윤성우의_열혈_cpp_프로그래밍" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/윤성우의_열혈_cpp_프로그래밍</a> 
 <br><br><a href=".?query=tag:language\cpp" class="tag" target="_blank" rel="noopener nofollow">#language/cpp</a> <br>member initializer<br><br>함수의 몸체 부분을 사용하지 않고 멤버 변수의 초기화를 지원하는 문법적 요소.<br>
멤버 변수가 객체인 경우와 그렇지 않은 경우로 나뉜다.<br><br>클래스 A가 또 다른 클래스 B의 멤버 변수로 존재하는 경우가 있다고 가정하자. 멤버 이니셜라이저를 사용하여 B 객체를 생성할 때( 즉 B의 생성자를 호출할 때 ) 멤버 변수로서 존재하는 A 객체의 생성자를 동시에 호출할 수 있다.<br>아래와 같이 동작한다.<br>
class Point
{
	private :
		int x;
		int y;
	public :
		Point(const int &amp;xpos, const int &amp;ypos);
}

Point::Point(const int &amp;xpos, const int &amp;ypos)
{
	x=xpos;
	y=ypos;
}

class Rectangle
{
	private :
		Point upLeft;
		Point lowRight;
	public :
		Rectangle(const int &amp;x1, const int &amp;y1, const int &amp;x2, \
		const int &amp;y2);
}

Rectangle::Rectangle(const int &amp;x1, const int &amp;y1, const int &amp;x2, \
					 const int &amp;y2):upLeft(x1, y1), lowRight(x2, y2)
{
	//empty;
}

<br>위 예제에서 :upLeft(x1, y1), lowRight(x2, y2) 에 해당하는 부분이 멤버 이니셜라이저이다. 인자 x1, y1으로 upLeft의 생성자를 호출, 인자 x2, y2로 lowRight의 생성자를 호출하라는 의미를 가지고 있다.<br><br>아래와 같이 동작한다.<br>
class SoSimple
{
	private :
		int num1;
		int num2;
	public :
		SoSimple(int n1, int n2) : num1(n1), num2(n2)
		{
			//empty;
		}
}

<br>위의 예제는 결과적으로 아래와 동일하게 동작한다.<br>
class SoSimple
{
	private :
		int num1;
		int num2;
	public :
		SoSimple(int n1, int n2)
		{
			num1 = n1;
			num2 = n2;
		}
}

<br>즉 num1(n1)은 num1 = n1과 동일하게 동작한다.<br>멤버 이니셜라이저를 사용하여 멤버 변수를 초기화하는 방법은 함수의 몸체에서 멤버 변수를 초기화하는 방법과 비교해 아래의 이점이 있다.<br>
<br>초기화의 대상을 명확히 인식할 수 있다.
<br>이니셜라이저를 이용하면 선언과 동시에 초기화가 이뤄지는 형태로 바이너리 코드가 생성된다.

<br>이니셜라이저를 이용한 초기화는 다음의 형태로 바이너리 코드를 구성한다.<br>
num1(n1) //int num1 = n1;
<br>함수의 몸체에서 이뤄지는 초기화는 다음의 형태로 바이너리 코드를 구성한다.<br>
num1 = n1; //int num1; num1=n1;


<br>2.의 이유로, 선언과 동시에 초기화가 이뤄져야 하는 형식의 멤버변수(const, 참조자)는 이니셜라이저로만 초기화시킬 수 있다.
<br><br>참고자료<br><a href=".?query=tag:참고도서\윤성우의_열혈_cpp_프로그래밍" class="tag" target="_blank" rel="noopener nofollow">#참고도서/윤성우의_열혈_cpp_프로그래밍</a><br>]]></description><link>public\멤버-이니셜라이저.html</link><guid isPermaLink="false">public/멤버 이니셜라이저.md</guid><pubDate>Sat, 22 Mar 2025 07:31:40 GMT</pubDate></item><item><title><![CDATA[모듈]]></title><description><![CDATA[<a class="tag" href="?query=tag:language/JavaScript" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#language/JavaScript</a> <a class="tag" href="?query=tag:web" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#web</a> <a class="tag" href="?query=tag:참고도서/모던_자바스크립트_Deep_Dive" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/모던_자바스크립트_Deep_Dive</a> 
 <br><br><a href=".?query=tag:language\JavaScript" class="tag" target="_blank" rel="noopener nofollow">#language/JavaScript</a> <a href=".?query=tag:web" class="tag" target="_blank" rel="noopener nofollow">#web</a> <br>module<br><br><br>모듈 module이란 애플리케이션을 구성하는 개별적 요소로서 재사용 가능한 코드 조각을 말한다. 일반적으로 모듈은 기능을 기준으로 파일 단위로 분리한다. 이때 모듈이 성립하려면 모듈은 자신만의 파일 스코프(모듈 스코프)를 가질 수 있어야 한다.<br>자신만의 파일 스코프를 갖는 모듈의 자산(모듈에 포함되어 있는 변수, 함수, 객체 등)은 기본적으로 비공개 상태다. 다시 말해, 자신만의 파일 스코프를 갖는 모듈의 모든 자산은 캡슐화되어 다른 모듈에서 접근할 수 없다. 즉, 모듈은 개별적 존재로서 애플리케이션과 분리되어 존재한다.<br>하지만 애플리케이션과 완전히 분리되어 개별적으로 존재하는 모듈은 재사용이 불가능하므로 존재의 의미가 없다. 모듈은 애플리케이션이나 다른 모듈에 의해 재사용되어야 의미가 있다. 따라서 모듈은 공개가 필요한 자산에 한정하여 명시적으로 선택적 공개가 가능하다. 이를 export라 한다.<br>공개 export된 모듈의 자산은 다른 모듈에서 재사용할 수 있다. 이때 공개된 모듈의 자산을 사용하는 모듈을 모듈 사용자 module comsumer라 한다. 모듈 사용자는 모듈이 공개 export한 자산 중 일부 또는 전체를 선택해 자신의 스코프 내로 불러들여 재사용할 수 있다. 이를 import라 한다.<br>이처럼 모듈은 애플리케이션과 분리되어 개별적으로 존재하다가 필요에 따라 다른 모듈에 의해 재사용된다. 모듈은 기능별로 분리되어 개별적인 파일로 작성된다. 따라서 코드의 단위를 명확히 분리하여 애플리케이션을 구성할 수 있고, 재사용성이 좋아서 개발 효율성과 유지보수성을 높일 수 있다.<br><br>클라이어트 사이드 자바스크립트는 script 태그를 사용하여 외부의 자바스크립트 파일을 로드할 수 있지만 파일마다 독립적인 파일 스코프를 갖지 않는다.<br>다시 말해, 자바스크립트 파일을 여러 개의 파일로 분리하여 script 태그로 로드해도 분리된 자바스크립트 파일들은 결국 하나의 자바스크립트 파일 내에 있는 것처럼 동작한다. 즉, 모든 자바스크립트 파일은 하나의 전역을 공유한다. 따라서 분리된 자바스크립트 파일들의 전역 변수가 중복되는 등의 문제가 발생할 수 있다.<br>이것으로는 모듈을 구현할 수 있다.<br><br>자바스크립트 런타임 환경인  Node.js는 모듈 시스템의 사실상 표준 de taco standard인 CommonJS라는 모듈 시스템을 채택하여 이러한 문제를 해결하였다.<br>웹 브라우저 환경에 대해서는, ES6에서는 클라이언트 사이트 자바스크립트에서도 동작하는 모듈 기능을 추가했다.<br>ES6 모듈(앞으로 ESM이라 부른다)의 사용법은 간단하다. script 태그에 type="module" 어트리뷰트를 추가하면 로드된 자바스크립트 파일은 모듈로서 동작한다. 일반적인 자바스크립트 파일이 아닌 ESM임을 명확히 하기 위해 ESM의 파일 확장자는 mjs를 사용할 것을 권장한다.<br>
&lt;script type="module" src="app.mjs"&gt;&lt;/script&gt;

<br>ESM에는 클래스와 마찬가지로 기본적으로 strict.mode가 적용된다.<br><br>모듈 내부에서 선언한 식별자를 외부에 공개하여 다른 모듈들이 재사용할 수 있게 하려면 export 키워드를 사용한다.<br>export 키워드는 선언문 앞에 사용한다. 이로서 변수, 함수, 클래스 등 모든 식별자를 export할 수 있다.<br>
// 변수의 공개
export const pi = Math.PI;

// 함수의 공개
export function square(x) {
    return x * x;
}

// 클래스의 공개
export class Person {
    constructor(name) {
        this.name = name;
    }
}

/* 객체의 형태로 한 번에 export 할 수 있다.

const pi = Math.PI;

// 함수의 공개
function square(x) {
    return x * x;
}

// 클래스의 공개
class Person {
    constructor(name) {
        this.name = name;
    }
}

// 변수, 함수 클래스를 하나의 객체로 구성하여 공개
export { pi, square, Person };

*/

<br><br>다른 모듈에서 공개 export한 식별자를 자신의 모듈 스코프 내부로 로드하려면 import 키워드를 사용한다. 다른 모듈이 export한 식별자 이름으로 import해야 하며 ESM의 경우 파일 확장자를 생략할 수 없다.<br>
// import.mjs

import { pi, square, Person } from './export.mjs'

console.log(pi);
console.log(square);
console.log(new Person('Lee'));

<br>
&lt;!DOCTYPE html&gt;
&lt;html&gt;
    &lt;body&gt;
        &lt;script typ="module" src="./import.mjs"&gt;&lt;/script&gt;
    &lt;/body&gt;
&lt;/html&gt;

<br>위 예제의 import..mjs는 애플리케이션의 진입점 entry point이므로 반드시 script 태그로 로드해야 한다. 하지만 export.mjs는 import.mjs의 import 문에 의해 로드되는 의존성 dependency이다. 따라서 export.mjs는 script 태그로 로드하지 않아도 된다.<br>모듈이 export한 식별자 이름을 일일히 지정하지 않고 하나의 이름으로 한 번에 import할 수도 있다. 이때 import되는 식별자는 as 뒤에 지정한 객체에 프로퍼티로 할당된다.<br>
// 모듈이 export한 모든 식별자를 lib 객체의 프로퍼티로 모아 import한다.
import * as lib from './export.mjs'

console.log(lib.pi);
console.log(lib.square);
console.log(new lib.Person('Lee'));

<br>모듈이 export한 식별자 이름을 변경하여 import 할 수도 있다.<br>
// 모듈이 export한 식별자 이름을 변경하여 import한다.
import { pi as PI, square as sq, Person as P } from './export.mjs'

console.log(PI);
console.log(sq);
console.log(new P('Lee'));

<br>모듈에서 하나의 export한다면 default 키워드를 사용할 수 있다. default 키워드를 사용하는 경우 기본적으로 이름 없이 하나의 값을 export한다.<br>default 키워드를 사용하는 경우 var, let, const 키워드는 사용할 수 없다.<br>
// export.mjs

export default x =&gt; x * x;

<br>default 키워드와 함께 export한 모듈은 {} 없이 임의의 이름으로 import한다.<br>
import square from './export.mjs';

console.log(square(3)); // 9

<br><br>참고자료<br><a href=".?query=tag:참고도서\모던_자바스크립트_Deep_Dive" class="tag" target="_blank" rel="noopener nofollow">#참고도서/모던_자바스크립트_Deep_Dive</a> <br>]]></description><link>public\모듈.html</link><guid isPermaLink="false">public/모듈.md</guid><pubDate>Sat, 18 Jan 2025 16:59:30 GMT</pubDate></item><item><title><![CDATA[모듈러 산술]]></title><description><![CDATA[<a class="tag" href="?query=tag:math/number_theory" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#math/number_theory</a> 
 <br><br><a href=".?query=tag:math\number_theory" class="tag" target="_blank" rel="noopener nofollow">#math/number_theory</a><br>modular arithmetic<br><br><br>정수론에서 모듈러 산술 또는 합동 산술은 정수의 합과 곱을 어떤 주어진 수의 나머지에 대하여 정의하는 방법이다.<br><br>모듈러 연산에는 다음과 같은 성질들이 존재한다.<br>
<br>덧셈 : (A + B) mod C = (A mod C + B mod C) mod C
<br>뺄셈 : (A - B) mod C = (A mod C - B mod C) mod C
<br>곱셈 : (A  B) mod C = (A mod C  B mod C) mod C
<br>거듭제곱 : (A^B) mod C = ((A mod C)^B) mod C
<br>프로그래밍에서 종종 매우 큰 수를 처리하게 되는데, 모듈러 거듭제곱 연산의 최적화를 통해 큰 수를 효율적으로 계산할 수 있다.]]></description><link>public\모듈러-산술.html</link><guid isPermaLink="false">public/모듈러 산술.md</guid><pubDate>Thu, 06 Mar 2025 04:19:27 GMT</pubDate></item><item><title><![CDATA[범위지정 연산자]]></title><description><![CDATA[<a class="tag" href="?query=tag:language/cpp" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#language/cpp</a> <a class="tag" href="?query=tag:참고도서/윤성우의_열혈_cpp_프로그래밍" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/윤성우의_열혈_cpp_프로그래밍</a> 
 <br><br><a href=".?query=tag:language\cpp" class="tag" target="_blank" rel="noopener nofollow">#language/cpp</a> <br>::(scope resolution operator)<br><br>다음의 기능을 가진 연산자이다.<br>
<br>함수를 호출할 때 함수가 속한 이름공간을 지정.
<br>
std::cout &lt;&lt; "cpp";

<br>
<br>전역변수명과 지역변수명이 같을 경우, 범위지정 연산자를 사용해 전역변수와 지역변수를 구별할 수 있다. 이때, 범위지정 연산자가 붙어있는 변수가 전역변수이다.
<br>
int val=100; //전역변수

int SimpleFunc(void)
{
	int val=20; //지역변수
	val+=3; //지역변수 val의 값 3 증가
	::val+=7; //전역변수 val의 값 7 증가
}

<br><br>참고자료<br><a href=".?query=tag:참고도서\윤성우의_열혈_cpp_프로그래밍" class="tag" target="_blank" rel="noopener nofollow">#참고도서/윤성우의_열혈_cpp_프로그래밍</a><br>]]></description><link>public\범위지정-연산자.html</link><guid isPermaLink="false">public/범위지정 연산자.md</guid><pubDate>Sat, 22 Mar 2025 07:31:40 GMT</pubDate></item><item><title><![CDATA[복사 생성자]]></title><description><![CDATA[<a class="tag" href="?query=tag:language/cpp" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#language/cpp</a> <a class="tag" href="?query=tag:참고도서/윤성우의_열혈_cpp_프로그래밍" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/윤성우의_열혈_cpp_프로그래밍</a> 
 <br><br><a href=".?query=tag:language\cpp" class="tag" target="_blank" rel="noopener nofollow">#language/cpp</a> <br>copy constructor<br><br>C++ 언어에서는 아래와 같은 형식으로 객체 간 복사가 가능하다.<br>
class SoSimple
{
	private :
		int num1;
		int num2;
	public :
		SoSimple(int n1, int n2) : num1(n1), num2(n2) { }
		void ShowSimpleData()
		{
			cout&lt;&lt;num1&lt;&lt;endl;
			cout&lt;&lt;num2&lt;&lt;endl;
		}
};

int main(void)
{
	SoSimple sim1(15, 20);
	SoSimple sim2 = sim1; //sim2 객체가 sim1 객체의 구성 요소(멤버 변수)를 복사
	
	sim2.ShowSimpleData();

	return (0);
}

<br>위 예제에서, 객체의 복사는 다음 구문에서 일어난다.<br>SoSimple sim2 = sim1;<br>이러한 형태의 구문은 묵시적 변환이 일어나 실제로는 다음의 형태로 해석된다. <a data-footref="1" href="about:blank#fn-1-1949966cec18b821" class="footnote-link" target="_self" rel="noopener nofollow">[1]</a><br>SoSimple sim2(sim1);<br>이렇듯 객체 간 복사의 용도로 사용되는 생성자를 복사 생성자라고 한다. 그러나 위 예제에서는 복사 생성자가 생성되어 있지 않다. 그럼에도 복사가 정상적으로 이루어지는 이유는 디폴트 복사 생성자가 자동으로 삽입되기 때문이다.<br>디폴트 복사 생성자는 아래와 같은 형태를 띈다.<br>
SoSimple(const SoSimple &amp;copy) : num1(copy.num1), num2(copy.num2) {}

<br>대부분은 디폴트 복사 생성자만으로 객체 간 복사를 정상적으로 수행할 수 있지만, 개발자가 직접 복사 생성자의 동작을 정의해야하는 경우가 있다.<br><br>복사 생성자가 호출되는 시점은 크게 세가지로 구분할 수 있다.<br>
<br>case 1 : 기존에 생성된 객체를 이용해서 새로운 객체를 초기화하는 경우(앞서 보인 경우)
<br>case 2 : Call-by-value 방식의 함수 호출 과정에서 객체를 인자로 전달하는 경우
<br>case 3 : 객체를 반환하되, 참조형으로 반환하지 않는 경우
<br><br>참고자료<br><a href=".?query=tag:참고도서\윤성우의_열혈_cpp_프로그래밍" class="tag" target="_blank" rel="noopener nofollow">#참고도서/윤성우의_열혈_cpp_프로그래밍</a><br><br><br>
<br>
<br><a data-href="explicit 키워드" href="public\explicit-키워드.html" class="internal-link" target="_self" rel="noopener nofollow">explicit 키워드</a>를 사용하여 이러한 묵시적 변환이 일어나지 않게 할 수 있다.<a href="about:blank#fnref-1-1949966cec18b821" class="footnote-backref footnote-link" target="_self" rel="noopener nofollow">↩︎</a>
]]></description><link>public\복사-생성자.html</link><guid isPermaLink="false">public/복사 생성자.md</guid><pubDate>Sat, 22 Mar 2025 07:31:40 GMT</pubDate></item><item><title><![CDATA[브로드캐스트]]></title><description><![CDATA[<a class="tag" href="?query=tag:network" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#network</a> <a class="tag" href="?query=tag:참고도서/후니의_쉽게_쓴_시스코_네트워킹" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/후니의_쉽게_쓴_시스코_네트워킹</a> 
 <br><br><a href=".?query=tag:network" class="tag" target="_blank" rel="noopener nofollow">#network</a> <br>Broadcast<br><br>LAN의 모든 네트워크 장비에게 보내는 통신. 브로드캐스트를 수신한 <a data-href="NIC" href="public\nic.html" class="internal-link" target="_self" rel="noopener nofollow">NIC</a>는 무조건 패킷을 cpu로 올린다. 따라서 브로드캐스트가 잦은 네트워크 환경은 pc 성능을 떨어뜨린다.<br><br>참고자료<br><a href=".?query=tag:참고도서\후니의_쉽게_쓴_시스코_네트워킹" class="tag" target="_blank" rel="noopener nofollow">#참고도서/후니의_쉽게_쓴_시스코_네트워킹</a><br>]]></description><link>public\브로드캐스트.html</link><guid isPermaLink="false">public/브로드캐스트.md</guid><pubDate>Sat, 22 Mar 2025 07:31:44 GMT</pubDate></item><item><title><![CDATA[브로드캐스트 도메인]]></title><description><![CDATA[<a class="tag" href="?query=tag:network" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#network</a> <a class="tag" href="?query=tag:참고도서/후니의_쉽게_쓴_시스코_네트워킹" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/후니의_쉽게_쓴_시스코_네트워킹</a> 
 <br><br><a href=".?query=tag:network" class="tag" target="_blank" rel="noopener nofollow">#network</a> <br>broadcast domain<br><br><a data-href="브로드캐스트" href="public\브로드캐스트.html" class="internal-link" target="_self" rel="noopener nofollow">브로드캐스트</a> 시 메시지를 수신하는 영역을 일컫는다.<br><a data-href="라우터" href="public\라우터.html" class="internal-link" target="_self" rel="noopener nofollow">라우터</a>는 브로드캐스트를 차단하는 특성이 있다.<br>브로드캐스트 도메인이 너무 크면 컴퓨터가 과도하게 많은 브로드캐스트를 수신하여 성능이 저하되기 때문에, 라우터를 이용하여 브로드캐스트 영역을 적절한 크기로 분할한다.<br><br>참고자료<br><a href=".?query=tag:참고도서\후니의_쉽게_쓴_시스코_네트워킹" class="tag" target="_blank" rel="noopener nofollow">#참고도서/후니의_쉽게_쓴_시스코_네트워킹</a><br>]]></description><link>public\브로드캐스트-도메인.html</link><guid isPermaLink="false">public/브로드캐스트 도메인.md</guid><pubDate>Sat, 22 Mar 2025 07:31:44 GMT</pubDate></item><item><title><![CDATA[브루트 포스]]></title><description><![CDATA[<a class="tag" href="?query=tag:algorithm" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#algorithm</a> 
 <br><br><a href=".?query=tag:algorithm" class="tag" target="_blank" rel="noopener nofollow">#algorithm</a><br>brute force<br><br><br>brute : 짐승 같은, 난폭한<br>
force : 힘<br>즉  브루트 포스는 직역하자면 (정제되지 않은) 난폭한 힘, 폭력이라는 뜻이다.<br>브루트 포스의 실질적으로 가능한 모든 경우의 수를 시도하여 문제를 해결하는 방식을 칭하는 표현이다. 얼핏 보면 우격다짐 식으로 보여 이러한 명칭이 붙었지만, 컴퓨팅 파워가 충분하다면 가장 단순하면서도 확실한 방법이기도 하다.<br>원래는 보안 분야에서 유래한 표현이다. 예를 들어, 가능한 모든 경우의 수를 암호에 대입하여 보안 요소를 무력화하는 것을 브루트 포스 공격이라고 한다.<br>키 전수조사(exhaustive key search), 무차별 대입 공격이라 칭하기도 한다.<br><br>브루트 포스 방식은 문제의 복잡도(Complexity)에 매우 민감하다는 단점이 있다.<br>이 때문에 실제로 브루트 포스는 문제의 규모가 현재의 자원으로 충분히 커버가 가능한 경우에만 쓰이고, 대부분은 <a data-href="동적 계획법" href="동적 계획법" class="internal-link" target="_self" rel="noopener nofollow">동적 계획법</a> 등으로 많이 우회하는 편이다. 정확도를 조금 희생하더라도 어떻게든 '이론상 가능한' 자원으로 해결할 수 있게 알고리즘을 설계하기도 한다.]]></description><link>public\브루트-포스.html</link><guid isPermaLink="false">public/브루트 포스.md</guid><pubDate>Thu, 06 Mar 2025 04:10:04 GMT</pubDate></item><item><title><![CDATA[브리지]]></title><description><![CDATA[<a class="tag" href="?query=tag:network" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#network</a> <a class="tag" href="?query=tag:참고도서/그림으로_이해하는_네트워크_용어" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/그림으로_이해하는_네트워크_용어</a> 
 <br><br><a href=".?query=tag:network" class="tag" target="_blank" rel="noopener nofollow">#network</a> <br>bridge<br><br><a data-href="OSI 참조 모델" href="public\osi-참조-모델.html" class="internal-link" target="_self" rel="noopener nofollow">OSI 참조 모델</a> 2계층(데이터 링크 계층)의 중계 기능을 제공하는 장치.<br>브리지는 그 이름처럼 다리를 의미하며 서로 다른 세그먼트 사이를 연결하는 역할을 한다. 세그먼트란 네트워크 상의 단일 기기로부터 송출된 패킷이 무조건 도달할 수 있는 범위를 말한다. <br>브리지는 수신된 패킷을 검사하여 발신지와 수신지의 <a data-href="MAC 주소" href="public\mac-주소.html" class="internal-link" target="_self" rel="noopener nofollow">MAC 주소</a>를 기억한다. 이를 바탕으로 주소 테이블을 작성하여 이후에 중계되는 세그먼트 중 어디에 수신지 주소가 있는지 파악한다.<br>주소 테이블에 수신 패킷의 수신지가 있으면 브리지는 주소가 속해 있는 세그먼트에만 패킷을 전달한다. 이렇게 네트워크 상의 패킷 흐름을 제어하여 네트워크 효율을 높일 수 있다.<br>브리지는 전송된 패킷을 중계하고 재송출하므로, 라피터와 마찬가지로 LAN의 총 연장 거리를 늘릴 수 있다. 또한, 브리지는 불필요한 패킷을 다른 세그먼트로 전달하는 일도 없기 때문에 콜리전 감지에 대한 문제도 발생하지 않고, <a data-href="리피터" href="public\리피터.html" class="internal-link" target="_self" rel="noopener nofollow">리피터</a>에서 발생하던 다단 접속의 제한도 없다.<br>브리지를 여러 개 묶어서 멀티 포트화한 것을 <a data-href="스위칭 허브" href="public\스위칭-허브.html" class="internal-link" target="_self" rel="noopener nofollow">스위칭 허브</a>라고 한다.<br><br>참고자료<br><a href=".?query=tag:참고도서\그림으로_이해하는_네트워크_용어" class="tag" target="_blank" rel="noopener nofollow">#참고도서/그림으로_이해하는_네트워크_용어</a><br>]]></description><link>public\브리지.html</link><guid isPermaLink="false">public/브리지.md</guid><pubDate>Sat, 22 Mar 2025 07:31:44 GMT</pubDate></item><item><title><![CDATA[사설 IP 주소]]></title><description><![CDATA[<a class="tag" href="?query=tag:network" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#network</a> <a class="tag" href="?query=tag:참고도서/그림으로_이해하는_네트워크_용어" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/그림으로_이해하는_네트워크_용어</a> 
 <br><br><a href=".?query=tag:network" class="tag" target="_blank" rel="noopener nofollow">#network</a> <br>private IP address<br><br><a data-href="IP 주소" href="public\ip-주소.html" class="internal-link" target="_self" rel="noopener nofollow">IP 주소</a>는 32비트 정수로 표현하기 때문에 중복되지 않는 번호의 수는 한정되어 있다.<br>
따라서 전 세계의 모든 컴퓨터에 개별 IP를 부여하는 것은 현실적으로 가능하지 않다.<br>그렇기 때문에 IP 주소는 전 세계에서 유일한 번호가 보장되는 <a data-href="공인 IP 주소" href="public\공인-ip-주소.html" class="internal-link" target="_self" rel="noopener nofollow">공인 IP 주소</a>와 제한된 범위 안에서 사용하는 사설 IP 주소로 나뉜다. <br>LAN처럼 제한된 작은 범위의 네트워크에서는 사설 IP 주소를 할당하는 것이 일반적이다.<br>사설 IP 주소는 지정된 범위 안에서만 유효하며, 공용 공간인 외부 세계와 통신하려면 NAT나 IP 마스커레이드 같은 수단을 사용해 주소를 변환해야 한다.<br>사설 IP 주소는 네트워크 규격에 의해 세 클래스로 나누어진다. 각각의 클래스에서 사용할 수 있는 IP 주소는 다음과 같이 정해져 있다.<br><br><br>참고자료<br><a href=".?query=tag:참고도서\그림으로_이해하는_네트워크_용어" class="tag" target="_blank" rel="noopener nofollow">#참고도서/그림으로_이해하는_네트워크_용어</a><br>]]></description><link>public\사설-ip-주소.html</link><guid isPermaLink="false">public/사설 IP 주소.md</guid><pubDate>Fri, 28 Feb 2025 14:17:29 GMT</pubDate></item><item><title><![CDATA[상속]]></title><description><![CDATA[<a class="tag" href="?query=tag:language/cpp" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#language/cpp</a> <a class="tag" href="?query=tag:참고도서/윤성우의_열혈_cpp_프로그래밍" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/윤성우의_열혈_cpp_프로그래밍</a> 
 <br><br><a href=".?query=tag:language\cpp" class="tag" target="_blank" rel="noopener nofollow">#language/cpp</a> <br>inheritance<br><br>클래스가 다른 클래스에게 자신이 가지고 있는 멤버들을 물려주는 것을 상속이라고 한다.<br>상속을 하는 쪽과 상속을 받는 쪽을 각각 다음의 용어들로 정의한다.<br><br>예를 들러, UnivStudent 클래스가 Student 클래스를 상속받을 때, 다음과 같은 형식으로 상속받는다.<br>
#ifndef US_HPP
#define US_HPP

#include &lt;iostream&gt;
#include &lt;cstring&gt;

using namespace std;

//부모 클래스
class Person
{
	private :
		int age;
		char name[50];
	public :
		Person(int myage, char *myname);
		void WhatYourName() const;
		void HowOldAreYou() const;
};

//자식 클래스
class UnivStudent : public Person //UnivStudent가 Person을 'public' 상속함
{
	//부모 클래스로부터 물려받은 멤버에 더해 자신만의 독자적인 멤버를 추가로 선언한다.
	private :
		char major[50]; //전공과목
	public :
		UnivStudent(char *myname, int myage, char *mymajor);
		void WhoAreYou() const;
};

#endif

<br>상속은 다음과 같은 특성을 갖는다.<br>
<br>
<a data-href="접근제어 지시자" href="public\접근제어-지시자.html" class="internal-link" target="_self" rel="noopener nofollow">접근제어 지시자</a>의 접근제한 기준은 객체가 아닌 클래스이기 때문에 부모 클래스에서 private으로 선언한 멤버는 자식 클래스에서 접근이 불가능하다.

<br>따라서 자식 클래스에서 부모 클래스의 private멤버에 접근하기 위해서는 부모 클래스로부터 상속받은 public 함수를 사용하는 우회적인 방법을 사용해야 한다.
<br>이렇듯 정보의 은닉은 하나의 객체 안에서도 진행이 된다.


<br>
자식 클래스는 자신의 멤버 뿐만이 아니라 상속받은 멤버도 초기화하여야 한다.

<br>이를 위하여 생성자를 호출할 때 <a data-tooltip-position="top" aria-label="멤버 이니셜라이저" data-href="멤버 이니셜라이저" href="public\멤버-이니셜라이저.html" class="internal-link" target="_self" rel="noopener nofollow">이니셜라이저</a>를 사용하여 부모의 생성자를 호출한다.
<br>만약 부모의 생성자를 호출하지 않는 경우, 부모의 생성자 중 매개변수가 void인 생성자를 자동으로 호출한다 ( 없을 경우 error ).
<br>구체적인 생성자 호출 순서는 아래와 같다.

<br>자식 클래스 객체의 메모리 공간이 할당된다.
<br>자식 클래스의 생성자가 호출된다 ( 실행은 아직 되지 않은 상태 ).
<br>부모 클래스가 있는 지 확인 후, 있다면 부모 클래스의 생성자를 호출한다.
<br>부모 클래스 생성자를 실행하여 부모의 멤버변수를 초기화한다.
<br>자식 클래스 생성자를 실행한다 자식의 멤버변수를 초기화한다.




<br>
// 부모 클래스의 생성자
Person::Person(int myage, char *myname) : age(myage)
{
	strcpy(name, myname);
}

// 자식 클래스의 생성자
UnivStudent::UnivStudent(char *myname, int myage, char *mymajor) : Person(myage, myname) // -&gt; 이니셜라이저를 사용하여 부모의 생성자를 호출함
{
	strcpy(major, mymajor);
}

<br>
<br>
자식 클래스의 객체가 소멸될 때에는, 자식 클래스의 소멸자가 실행되고 난 다음에 기초 클래스의 소멸자가 실행된다.

<br>스택의 생성된 객체의 소멸 순서는 생성 순서와 반대이다.


<br>
<a data-href="접근제어 지시자" href="public\접근제어-지시자.html" class="internal-link" target="_self" rel="noopener nofollow">접근제어 지시자</a>는 멤버의 접근 범위를 제한하는 것 외에도 상속의 형태를 정의할 수 있다. 따라서 상속애는 public, protected, private 이렇게 3가지 형태의 상속이 있다.

<br>public 상속의 경우, private 멤버를 제외한 나머지(private 멤버는 자식에서 접근이 불가하므로) 그대로 상속한다.
<br>protected 상속의 경우, protected 보다 접근 범위가 넓은 멤버 ( 즉 public ) 의 접근 범위를 protected로 변환시켜 상속한다.
<br>private 상속의 경우, private 보다 접근 범위가 넓은 멤버의 접근 범위를 private으로 변환시켜 상속한다.


<br>
상속은 남용하지 않고 적절한 경우에만 사용되어야 한다. 상속을 사용하기 적합한 클래스와 클래스 사이 관계의 특징은 다음과 같다.

<br>
IS_A 관계.

<br>예를 들어 컴퓨터 정보를 나타내는 Computer 클래스가 있고, 노트북 정보를 나타내는 Notebook 클래스가 있으면 둘은 IS_A 관계라 할 수 있다. 다음의 문장이 성립하기 때문이다.<br>
노트북은 컴퓨터이다<br>
또는<br>
노트북은 컴퓨터의 일종이다.


<br>
HAS_A 관계.

<br>에를 들어 경찰을 나타내는 Police 클래스가 있고, 총을 나타내는 Gun 클래스가 있을 때 다음의 문장이 성립하므로 HAS_A 관계라 할 수 있다.<br>
경찰은 총을 가지고 있다.


<br>
다만 HAS_A 관계는 상속을 사용하기보다는 객체를 다른 객체의 멤버변수로 선언함으로서 표현하는 것이 일반적이다.



<br>
부모 클래스의 함수를 자식 클래스에서 <a data-tooltip-position="top" aria-label="함수 오버로딩" data-href="함수 오버로딩" href="public\함수-오버로딩.html" class="internal-link" target="_self" rel="noopener nofollow">오버로딩</a> 할 수 있다.

<br>
부모 클래스의 함수를 자식 클래스에서 재정의 할 수 있다. 이를 <a data-href="함수 오버라이딩" href="public\함수-오버라이딩.html" class="internal-link" target="_self" rel="noopener nofollow">함수 오버라이딩</a>이라 한다.

<br>
부모 클래스의 포인터로 자식 포인터의 객체를 가리킬 수 있다.

<br>그러나 컴파일러는 포인터 연산의 가능성 여부를 판단할 때, 실제 가리키는 객체의 자료형이 아닌, 포인터의 자료형을 기준으로 판단한다.

<br>따라서 부모 클래스의 포인터로 자식 포인터를 가리킬 경우 부모 포인터에서 정의되지 않은 함수를 사용할 수 없다 ( 이를 <a data-href="가상 함수" href="public\가상-함수.html" class="internal-link" target="_self" rel="noopener nofollow">가상 함수</a>를 통해 극복할 수 있다 ) .
<br>부모 클래스의 함수를 자식 클래스가 <a data-tooltip-position="top" aria-label="함수 오버라이딩" data-href="함수 오버라이딩" href="public\함수-오버라이딩.html" class="internal-link" target="_self" rel="noopener nofollow">오버라이딩</a> 한 경우, 가리키는 포인터의 자료형 클래스에서 선언된 함수가 호출된다.
<br>상술한 모든 특성은 <a data-href="참조자" href="public\참조자.html" class="internal-link" target="_self" rel="noopener nofollow">참조자</a>를 사용한 참조에도 모두 적용된다.




<br>
하나의 객체가 동시에 복수의 객체를 상속받는 것이 가능하다. 이를 <a data-href="다중 상속" href="public\다중-상속.html" class="internal-link" target="_self" rel="noopener nofollow">다중 상속</a>이라고 한다.

<br><br>참고자료<br><a href=".?query=tag:참고도서\윤성우의_열혈_cpp_프로그래밍" class="tag" target="_blank" rel="noopener nofollow">#참고도서/윤성우의_열혈_cpp_프로그래밍</a><br>]]></description><link>public\상속.html</link><guid isPermaLink="false">public/상속.md</guid><pubDate>Sat, 22 Mar 2025 07:31:41 GMT</pubDate></item><item><title><![CDATA[생성자]]></title><description><![CDATA[<a class="tag" href="?query=tag:language/cpp" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#language/cpp</a> <a class="tag" href="?query=tag:참고도서/윤성우의_열혈_cpp_프로그래밍" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/윤성우의_열혈_cpp_프로그래밍</a> 
 <br><br><a href=".?query=tag:language\cpp" class="tag" target="_blank" rel="noopener nofollow">#language/cpp</a> <br>constructor<br><br>객체 생성 시 단 한번 호출되는 함수.<br>생성자는 다음의 형태를 띈다.<br>
<br>클래스의 이름과 함수의 이름이 동일하다.
<br>반환형이 선언되어 있지 않으며, 실제로 반환하지 않는다.
<br>생성자는 아래의 특성을 갖는다.<br>
<br>생성자도 함수의 일종이니 <a data-tooltip-position="top" aria-label="함수 오버로딩" data-href="함수 오버로딩" href="public\함수-오버로딩.html" class="internal-link" target="_self" rel="noopener nofollow">오버로딩</a>이 가능하다.
<br>생성자도 함수의 일종이니 매개변수에 <a data-tooltip-position="top" aria-label="매개변수의 디폴트 값" data-href="매개변수의 디폴트 값" href="public\매개변수의-디폴트-값.html" class="internal-link" target="_self" rel="noopener nofollow">디폴트 값</a>을 설정할 수 있다.
<br>아래는 생성자의 예시이다.<br>
#include &lt;iostream&gt;

using namespace std;

class SimpleClass
{
	private :
		int num1;
		int num2;

	public :
		SimpleClass()
		{
			num1=0;
			num2=0;
		}

		SimpleClass(int n)
		{
			num1=n;
			num2=0;
		}

		SimpleClass(int n1, int n2)
		{
			num1=n1;
			num2=n2;
		}

		/*

		//이 단락을 주석해제하고 SimpleClass sc2(100); 과 같이 객체 생성을 시도할 경우 컴파일 에러가 발생한다. SimpleClass(int n)과 이 단락의 생성자 중 뭘 호출해야 할 지 명확하지 않기 때문이다.

		SimpleClass(int n1=0;,int n2=0)
		{
			num1=n1;
			num2=n2;
		}
		*/

		void ShowData() const
		{
			cout&lt;&lt;num1&lt;&lt;' '&lt;&lt;num2&lt;&lt;endl;
		}
};

int main(void)
{
	//생성자를 정의한 경우 객체생성과정에서 자동으로 호출되는 생성자에게 전달할 인자의 정보를 다음과 같이 추가해야 한다.
	SimpleClass sc1;
	sc1.ShowData();
	SimpleClass sc2(100);
	sc2.ShowData();
	SimpleClass sc3(100, 200);
	sc3.ShowData();

	return (0);
}

/*
실행결과

0 0
100 0
100 200
*/

<br>생성자도 아래의 예제와 같이 private으로 선언될 수 있다. 이 경우, 클래스 내부의 객체를 초기화시키는 데에만 사용할 수 있다.<br>
//PrivateConstructor.cpp

#include &lt;iostream&gt;

using namespace std;

class AAA
{
	private :
		int num;

	public :
		AAA() : num(0) {}

		AAA &amp;CreateInitObj(int n) const
		{
			AAA *ptr = new AAA(n);
			return (*ptr);
		}

		void ShowNum() const { cout&lt;&lt;num&lt;&lt;endl; }

	private :
		AAA(int n) : num(n) {}
};

int main(void)
{
	AAA base;
	base.ShowNum();

	AAA &amp;obj1 = base.CreateInitObj(3);
	obj1.ShowNum();

	AAA &amp;obj2 = base.CreateInitObj(12);
	obj2.ShowNum();

	delete &amp;obj1;
	delete &amp;obj2;

	return (0);
}

<br>생성자를 정의하지 않으면, 컴파일러의 의해 <a data-href="디폴트 생성자" href="public\디폴트-생성자.html" class="internal-link" target="_self" rel="noopener nofollow">디폴트 생성자</a>가 자동으로 삽입된다.<br>
객체 내부의 멤버로서 존재하는 객체는 <a data-href="멤버 이니셜라이저" href="public\멤버-이니셜라이저.html" class="internal-link" target="_self" rel="noopener nofollow">멤버 이니셜라이저</a>를 통해 초기화될 수 있다.<br><br>참고자료<br><a href=".?query=tag:참고도서\윤성우의_열혈_cpp_프로그래밍" class="tag" target="_blank" rel="noopener nofollow">#참고도서/윤성우의_열혈_cpp_프로그래밍</a><br>]]></description><link>public\생성자.html</link><guid isPermaLink="false">public/생성자.md</guid><pubDate>Sat, 22 Mar 2025 07:31:41 GMT</pubDate></item><item><title><![CDATA[서브넷 마스크]]></title><description><![CDATA[<a class="tag" href="?query=tag:network" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#network</a> <a class="tag" href="?query=tag:참고도서/그림으로_이해하는_네트워크_용어" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/그림으로_이해하는_네트워크_용어</a> 
 <br><br><a href=".?query=tag:network" class="tag" target="_blank" rel="noopener nofollow">#network</a> <br>subnet mask<br><br>대규모 네트워크의 관리를 용이하게 하기 위해 작은 단위의 네트워크로 분할할 수 있다. 이것을 서브넷(subnet)이라 한다.<br>서브넷 마스크는 이러한 서브넷을 표현하기 위한 값으로, <a data-href="IP 주소" href="public\ip-주소.html" class="internal-link" target="_self" rel="noopener nofollow">IP 주소</a>의 앞에서부터 몇 비트까지 네트워크 주소로 사용할지 정의하기 위해 사용한다. 서브넷 마스크에 의해 호스트 주소 부분 중 몇 개의 비트를 네트워크 주소로 재정의하여, 단일 네트워크를 서브넷으로 구분할 수 있다.<br>ex) 172.16.0.0의 네트워크 주소 부분이 16비트일 때, 호스트 부분 중 8비트를 재정의하여 256개의 서브넷으로 분할할 수 있다.<br>172.16.0.0을 이진법으로 표현했을 때 서브넷 마스크의 적용

10101100.00010000.00000000.00000000
nnnnnnnn.nnnnnnnn.ssssssss.hhhhhhhh

n : 네트워크 주소 부분
s : 서브넷으로 재정의된 부분
h : 호스트 부분
<br><br>참고자료<br><a href=".?query=tag:참고도서\그림으로_이해하는_네트워크_용어" class="tag" target="_blank" rel="noopener nofollow">#참고도서/그림으로_이해하는_네트워크_용어</a><br>]]></description><link>public\서브넷-마스크.html</link><guid isPermaLink="false">public/서브넷 마스크.md</guid><pubDate>Sat, 22 Mar 2025 07:31:45 GMT</pubDate></item><item><title><![CDATA[소멸자]]></title><description><![CDATA[<a class="tag" href="?query=tag:language/cpp" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#language/cpp</a> <a class="tag" href="?query=tag:참고도서/윤성우의_열혈_cpp_프로그래밍" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/윤성우의_열혈_cpp_프로그래밍</a> 
 <br><br><a href=".?query=tag:language\cpp" class="tag" target="_blank" rel="noopener nofollow">#language/cpp</a> <br>destructor<br><br>소멸자는 객체가 소멸할 때 반드시 호출되는 함수이다.<br>소멸자는 다음의 형태를 갖는다.<br>
<br>클래스의 이름 앞에 ~가 붙은 형태의 이름을 갖는다.
<br>반환형이 선언되어 있지 않으며, 실제로 반환하지 않는다.
<br>매개변수는 void형으로 선언되어야 하기 때문에 오버로딩도, 디폴트 값 설정도 불가능하다.
<br>예시<br>~AAA() {//function body}<br>소멸자는 주로 객체의 소멸 전 객체 내에서 <a data-tooltip-position="top" aria-label="new &amp; delete" data-href="new &amp; delete" href="public\new-&amp;-delete.html" class="internal-link" target="_self" rel="noopener nofollow">new</a> 연산자를 이용해 동적으로 할당한 요소들을 <a data-tooltip-position="top" aria-label="new &amp; delete" data-href="new &amp; delete" href="public\new-&amp;-delete.html" class="internal-link" target="_self" rel="noopener nofollow">delete</a>를 이용해 없애는데 사용한다.<br><a data-href="디폴트 생성자" href="public\디폴트-생성자.html" class="internal-link" target="_self" rel="noopener nofollow">디폴트 생성자</a>와 마찬가지로, 클래스에 소멸자가 정의되어 있지 않으면 컴파일러에 의해 <a data-href="디폴트 소멸자" href="public\디폴트-소멸자.html" class="internal-link" target="_self" rel="noopener nofollow">디폴트 소멸자</a>가 삽입된다.<br><br>참고자료<br><a href=".?query=tag:참고도서\윤성우의_열혈_cpp_프로그래밍" class="tag" target="_blank" rel="noopener nofollow">#참고도서/윤성우의_열혈_cpp_프로그래밍</a><br>]]></description><link>public\소멸자.html</link><guid isPermaLink="false">public/소멸자.md</guid><pubDate>Sat, 22 Mar 2025 07:31:41 GMT</pubDate></item><item><title><![CDATA[소켓의 타입]]></title><description><![CDATA[<a class="tag" href="?query=tag:network" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#network</a> <a class="tag" href="?query=tag:language/c" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#language/c</a> <a class="tag" href="?query=tag:socket_programming" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#socket_programming</a> <a class="tag" href="?query=tag:linux" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#linux</a> <a class="tag" href="?query=tag:참고도서/윤성우의_열혈_TCP_IP_소켓_프로그래밍" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/윤성우의_열혈_TCP_IP_소켓_프로그래밍</a> 
 <br><br><a href=".?query=tag:network" class="tag" target="_blank" rel="noopener nofollow">#network</a> <a href=".?query=tag:language\c" class="tag" target="_blank" rel="noopener nofollow">#language/c</a> <a href=".?query=tag:socket_programming" class="tag" target="_blank" rel="noopener nofollow">#socket_programming</a> <a href=".?query=tag:linux" class="tag" target="_blank" rel="noopener nofollow">#linux</a><br>type<br><br><a data-tooltip-position="top" aria-label="socket" data-href="socket" href="public\socket.html" class="internal-link" target="_self" rel="noopener nofollow">소켓</a>의 <a data-href="프로토콜 체계" href="public\프로토콜-체계.html" class="internal-link" target="_self" rel="noopener nofollow">프로토콜 체계</a>를 결정한 후에는, 해당 프로토콜 체계 내에서 어떠한 방식으로 데이터를 전송할 것인지 결정해야 한다. 예를 들어서 PF_INET에 해당하는 프로토콜 체계에는 둘 이상의 데이터 전송방식이 존재한다.<br><br><br>연결 지향형 소켓은 TCP 방식으로 연결을 지원하며 특징은 아래와 같다.<br>
<br>중간에 데이터가 소멸되지 않고 목적지로 전송된다.
<br>전송 순서대로 데이터가 수신된다.
<br>전송되는 데이터의 경계(Boundary)가 존재하지 않는다(중요)
<br>소켓 대 소켓의 연결은 반드시 1대 1이어야 한다.
<br>1, 2번의 특성은 우리가 익히 알던 TCP의 특성이다. 그리고 4번은 그리 이해하기 어렵지 않다. 그러므로 3번에 대해 좀 더 자세히 알아보자.<br>데이터를 송수신하는 소켓은 내부적으로 버퍼(buffer), 쉽게 말해서 바이트 배열을 지니고 있다. 그리고 소켓을 통해 전송되는 데이터는 일단 이 배열에 저장된다. 때문에 데이터가 수신되었다고 해서 바로 read()를 통해 호출해야 하는 것은 아니다. 버퍼의 용량을 초과하지 않는 한, 여러 번에 걸쳐 데이터가 채워진 후에 한 번의 read() 호출을 통해서 데이터 전부를 읽어 들일수도 있고, 반대로 한번의 write() 호출로 전송된 데이터를 여러 번의 read() 호출을 통해 읽어들일 수도 있다. 즉, read()의 호출횟수와 write() 함수의 호출횟수는 연결지향형 소켓의 경우 큰 의미를 갖지 못한다. 때문에 연결지향형 소켓은 데이터의 경계가 존재하지 않는다고 말하는 것이다.<br><br>
<br>전송된 순서에 상관없이 가장 빠른 전송을 지향한다.
<br>전송된 데이터는 손실의 우려가 있고, 파손의 우려가 있다.
<br>전송되는 데이터의 경계(Boundary)가 존재한다.
<br>한 번에 전송할 수 있는 데이터의 크기가 제한된다.
<br>연결이라는 개념이 존재하지 않는다.
<br>마찬가지로 1, 2번의 특성은 우리가 익히 알던 UDP의 그것이다. 3,4 번은 연결지향형 소켓과 반대의 특성을 지니고 있다. 전송되는 데이터의 경계가 존재한다는 것은 아래와 같은 의미를 가진다.<br>
<br>연결지향형 소켓의 경우, 첫 번째 write()로 50 byte의 데이터를 송신하고 두 번째 write()로 50 byte의 데이터를 송신한 후에, 한 번에 read()만으로 100 byte의 데이터를 한꺼번에 수신할 수 있다.
<br>반면에, 비연결지향형 소켓의 경우 두 번의 read()를 사용하여 데이터를 50 byte 씩 나눠서 수신해야 한다. 데이터의 경계가 정해져 있기 때문이다.
<br>4, 5번 특성에 대해서는 차후 부연한다.<br><br><a data-href="socket" href="public\socket.html" class="internal-link" target="_self" rel="noopener nofollow">socket</a> 시스템콜에는 protocol이라는 세번째 인자가 존재한다.<br>
첫번째 인자로 <a data-href="프로토콜 체계" href="public\프로토콜-체계.html" class="internal-link" target="_self" rel="noopener nofollow">프로토콜 체계</a>를 정의하고, 두번째 인자로 <a data-href="소켓의 타입" href="public\소켓의-타입.html" class="internal-link" target="_self" rel="noopener nofollow">소켓의 타입</a>을 지정하였으므로 이미 프로토콜 결정에 충분한 정보를 전달하였다고 판단할 수 있다. 하지만 다음과 같은 상황 때문에 세번째 인자는 필요하다.<br>하나의 프로토콜 체계 안에 데이터의 전송방식이 동일한 프로토콜이 둘 이상 존재하는 경우<br>예를 들어 첫번째 인자로 PF_INET을 넘기고, 두번째 인자로 SOCK_STREAM을 넘기는 것은 다음을 의미한다.<br>IPv4 인터넷 프로토콜 체계에서 동작하는 연결지향형 데이터 전송 소켓<br>위 조건을 충족하는 프로토콜은 IPPROTO_TCP 하나이기 때문에 세번째 인자로 0을 전달하여도 정상적으로 소켓은 생성된다. 하지만 좀 더 명시적으로 코드를 작성하고 싶다면 아래와 같이 작성하면 된다. 아래와 같이 생성되는 소켓을 가리켜 TCP 소켓이라 한다.<br>int tcp_socket = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP);
<br>UDP 소켓은 아래와 같은 정의를 가지고 있다.<br>IPv4 인터넷 프로토콜 체계에서 동작하는 비 연결지향형 데이터 전송 소켓<br>위 조건을 만족하는 프로토콜은 IPPROTO_UDP 하나이기 때문에 세번째 인자로 0을 전달하여도 되고, 명시적으로 인자를 전달하여도 된다.<br>int udp_socket = socket(PF_INET , SOCK_DGRAM, IPPROTO_UDP);
<br><br>참고자료<br><a href=".?query=tag:참고도서\윤성우의_열혈_TCP_IP_소켓_프로그래밍" class="tag" target="_blank" rel="noopener nofollow">#참고도서/윤성우의_열혈_TCP_IP_소켓_프로그래밍</a><br>]]></description><link>public\소켓의-타입.html</link><guid isPermaLink="false">public/소켓의 타입.md</guid><pubDate>Sat, 22 Mar 2025 07:31:46 GMT</pubDate></item><item><title><![CDATA[스위칭 허브]]></title><description><![CDATA[<a class="tag" href="?query=tag:network" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#network</a> <a class="tag" href="?query=tag:참고도서/그림으로_이해하는_네트워크_용어" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/그림으로_이해하는_네트워크_용어</a> 
 <br><br><a href=".?query=tag:network" class="tag" target="_blank" rel="noopener nofollow">#network</a> <br>switching hub<br><br>스위칭 기능을 가진 허브로, 일반적인 허브와 마찬가지로 여러 개의 LAN 케이블을 연결하기 위한 집선 장치다. 스위칭 기능은 허브가 가진 여러 포트 중에 실제로 통신이 발생한 포트만 연결하여 다른 포트에는 불필요한 패킷을 전송하지 않도록 한 것이다.<br>리피터의 집합체인 허브와 달리 스위칭 허브는 <a data-href="브리지" href="public\브리지.html" class="internal-link" target="_self" rel="noopener nofollow">브리지</a>를 멀티 포트화한 것으로, 멀티 포트 브리지라고도 불린다. 수신 패킷을 모든 포트에 전송하는 리피터 허브와 달리 스위칭 허브는 실체로 통신을 실시하는 포트에만 패킷을 보낸다. 따라서 다른 포트는 동시에 다른 통신을 할 수 있다. 이처럼 패킷 충돌을 억제하기 때문에 네트워크 효율성을 향상시킬 수 있다. 또한 브리지의 특성을 계승하기 때문에 계단식 접속에 대한 제한도 없다.<br>스위칭 허브는 패킷을 수신했을 때 그 패킷을 보낸 포트와 패킷에 기록된 수신지의 <a data-href="MAC 주소" href="public\mac-주소.html" class="internal-link" target="_self" rel="noopener nofollow">MAC 주소</a>를 연결한 테이블을 만든다. 이 테이블을 가지고 어떤 포트에 어떤 MAC 주소를 가진 기기가 접속되어 있는지 관리하여 포트 분배를 실시한다.<br><br>참고자료<br><a href=".?query=tag:참고도서\그림으로_이해하는_네트워크_용어" class="tag" target="_blank" rel="noopener nofollow">#참고도서/그림으로_이해하는_네트워크_용어</a><br>]]></description><link>public\스위칭-허브.html</link><guid isPermaLink="false">public/스위칭 허브.md</guid><pubDate>Sat, 22 Mar 2025 07:31:45 GMT</pubDate></item><item><title><![CDATA[스타형 LAN]]></title><description><![CDATA[<a class="tag" href="?query=tag:network" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#network</a> <a class="tag" href="?query=tag:참고도서/그림으로_이해하는_네트워크_용어" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/그림으로_이해하는_네트워크_용어</a> 
 <br><br><a href=".?query=tag:network" class="tag" target="_blank" rel="noopener nofollow">#network</a> <br><br><a data-href="네트워크 토폴로지" href="public\네트워크-토폴로지.html" class="internal-link" target="_self" rel="noopener nofollow">네트워크 토폴로지</a>의 하나로, 허브라는 집선 장치를 중심으로 각 컴퓨터를 연결하는 방식을 스타형 LAN이라고 한다. <a data-href="허브" href="public\허브.html" class="internal-link" target="_self" rel="noopener nofollow">허브</a>를 중심으로 해서 선이 별 모양으로 퍼져나가기 때문에 이런 이름이 붙었다.<br>스타형 LAN은 아래와 같은 특징을 같는다.<br>
<br>허브가 통신을 중개하는 역할을 하므로 네트워크에 접속된 컴퓨터가 고장 나도 다른 컴퓨터에 영향을 미치지 않는다.
<br>하지만 허브가 고장난 경우에는 중앙의 통신 경로가 차단되므로 네트워크 전체가 통신 불능 상태가 된다.
<br>배선의 자유도가 높다.
<br>허브끼리 서로 연결하여 계층 구조를 만들 수 있다.
<br><br>참고자료<br><a href=".?query=tag:참고도서\그림으로_이해하는_네트워크_용어" class="tag" target="_blank" rel="noopener nofollow">#참고도서/그림으로_이해하는_네트워크_용어</a><br>]]></description><link>public\스타형-lan.html</link><guid isPermaLink="false">public/스타형 LAN.md</guid><pubDate>Sat, 22 Mar 2025 07:31:45 GMT</pubDate></item><item><title><![CDATA[암호학]]></title><description><![CDATA[<a class="tag" href="?query=tag:security" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#security</a> <a class="tag" href="?query=tag:cryptograph" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#cryptograph</a> <a class="tag" href="?query=tag:참고링크/생활코딩" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고링크/생활코딩</a> 
 <br><br><a href=".?query=tag:security" class="tag" target="_blank" rel="noopener nofollow">#security</a> <a href=".?query=tag:cryptograph" class="tag" target="_blank" rel="noopener nofollow">#cryptograph</a><br>cryptograph<br><br><br>감추어진 정보가 조작되지 않고 허가된 사람에게만 공개되도록 하는 방법을 암호학 cryptograph라고 한다.<br>암호는 다음의 3가지 원칙을 지켜야 한다.<br>
<br>기밀성 Confidentiality : 암호화된 내용이 무엇인지 알 수 없어야 한다.
<br>무결성 Integrity : 암호화된 내용이 원본과 동일함을 보장하여야 한다.
<br>인증 authentication : 권한이 있는 자만 암호화된 내용에 접근할 수 있어야 한다.
<br>보호되고 있지 않은 데이터를 평문 plain text라고 한다.<br>
암호화된 내용을 암호문 cipher text라고 한다.<br>평문을 암호화하여 암호문으로 만들기 위하여 암호 알고리즘 cryptography algorithm을 사용한다.<br>평문을 암호문으로 만드는 과정을 암호화 encryption이라고 한다.<br>
암호문을 평문으로 만드는 과정을 복호화 decryption이라고 한다.<br>예전에는 암호 알고리즘 자체를 비밀로 하여 기밀성을 지켰지만, 요즘에는 트렌드가 바뀌어 암호 알고리즘을 공개하여 성능을 검증받는다. 대신 암호 알고리즘이 비밀 정보를 사용하도록 하고, 이 비밀 정보가 없으면 복호화 할 수 없도록 한다. 이 비밀 정보를 키 key라고 한다.<br>암호화에는 <a data-href="양방향 암호화" href="public\양방향-암호화.html" class="internal-link" target="_self" rel="noopener nofollow">양방향 암호화</a> 방식과 <a data-href="단방향 암호화" href="public\단방향-암호화.html" class="internal-link" target="_self" rel="noopener nofollow">단방향 암호화</a> 방식이 있다.<br>양방향 암호화 방식은 암호화와 복호화를 모두 지원한다.<br>
양방향 암호화 방식은 대칭키 방식과 비대칭키 방식으로 나뉜다.<br>
대칭키 방식은 암호화와 복호화에 모두 같은 키를 사용한다. 대표적으로 AES, Twofish 같은 알고리즘이 있다.<br>
비대칭키 방식은 암호화와 복호화에 각자 다른 키를 사용한다. 대표적으로 RSA 같은 것들이 있다.<br>반면에 단방향 암호화 방식은 암호화만 지원한다.<br>
대표적으로 md5, sha 같은 것들이 있다.<br><br>참고자료<br><a href=".?query=tag:참고링크\생활코딩" class="tag" target="_blank" rel="noopener nofollow">#참고링크/생활코딩</a><br>]]></description><link>public\암호학.html</link><guid isPermaLink="false">public/암호학.md</guid><pubDate>Mon, 20 Jan 2025 08:13:08 GMT</pubDate></item><item><title><![CDATA[양방향 암호화]]></title><description><![CDATA[<a class="tag" href="?query=tag:security" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#security</a> <a class="tag" href="?query=tag:cryptograph" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#cryptograph</a> <a class="tag" href="?query=tag:참고링크/생활코딩" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고링크/생활코딩</a> 
 <br><br><a href=".?query=tag:security" class="tag" target="_blank" rel="noopener nofollow">#security</a> <a href=".?query=tag:cryptograph" class="tag" target="_blank" rel="noopener nofollow">#cryptograph</a> <br>__<br><br><br><br>대칭키 방식이란 하나의 키를 암호화와 복호화 모두에 사용하는 방식을 말한다.<br><br>B가 A에게 특정 자료를 암호화하여 전송한다고 가정할 때, A가 자료를 복호화하여 열람하기 위해서는 암호화된 자료와 키를 둘 다 보내야만 한다. 만약에 전송 중 자료를 갈취당한다면 키 또한 같이 갈취당했을 것이므로 아주 쉽게 보안이 뚫리게 된다.<br>그러므로 대칭키 방식은 자료를 암호화하여 자기 혼자만 볼 때는 유효할 수 있으나, 타인과 그 자료를 공유해야 하는 상황에서는 부적합하다.<br><br><br><br>비대칭키 또는 공개키 방식은 2개의 키를 사용하여 암호화와 복호화에 사용되는 키를 달리 하는 방식을 말한다. 이때 이 2개의 키를 각각 공개키 public key와 비공개키 private key라고 한다.<br>만약 암호화에 공개키를 사용했다면 복호화를 위해서는 무조건 비공개키를 사용해야만 한다.<br>
반대로 암호화에 비공개키를 사용했다면 복호화를 위해 무조건 공개키를 사용해야만 한다.<br>위의 절에서 대칭키 방식의 한계를 보았다. 비대칭키 방식은 다음과 같이 이러한 한계를 극복할 수 있다.<br>마찬가지로 B가 A에게 어떠한 자료를 공유하고자 하는 가정을 가정해보자. 쉬운 이해를 위해, 전송되는 모든 것은 크래커에게 갈취당한다는 극단적인 가정을 추가해보자. 다음과 같은 절차를 거친다.<br>
<br>A가 공개키와 비공개키를 만든다. 그리고 공개키만 B에게 보낸다.
<br>B는 공개키를 이용하여 자료를 암호화하여 A에게 보낸다.
<br>크래커는 공개키와 공개키로 암호화된 자료를 갈취하였다.
<br>하지만 A는 비공개키는 자신만이 보유하고 어딘가로 전송한 적이 없으므로 자료는 A, B, 크래커 중 A만이 복호화할 수 있다. 
<br><br><br>전자서명이란 어떠한 내용이 특정인에 의하여 작성되었다는 것을 보증하기 위한 보안적 장치이다. 비대칭키를 사용하면 다음과 같이 전자서명을 구현할 수 있다.<br>
<br>A가 자신의 공개 키를 웹상에 공개한다. 그리고 B에게 자료를 보낼 때 원문과 원문을 비공개키로 암호화한 암호문을 같이 보낸다. 이때, 암호문이 전자서명에 해당한다.
<br>이때 크래커는 B에게 혼선을 주고자 조작된 자료와 위조한 전자서명을 B에게 보낸다. B는 받은 2개의 자료 중 어느 것이 A가 보낸 것인지 검증해야 한다.
<br>웹상에 공개된 공개 키로 두 개의 전자 서명을 모두 복호화한다. 이때, 원문과 복호화한 전자서명이 일치하는 자료가 A가 보낸 것이라고 B는 확신할 수 있다.
<br><br>참고자료<br><a href=".?query=tag:참고링크\생활코딩" class="tag" target="_blank" rel="noopener nofollow">#참고링크/생활코딩</a> <br>]]></description><link>public\양방향-암호화.html</link><guid isPermaLink="false">public/양방향 암호화.md</guid><pubDate>Mon, 20 Jan 2025 08:53:27 GMT</pubDate></item><item><title><![CDATA[얕은 복사]]></title><description><![CDATA[<a class="tag" href="?query=tag:language/cpp" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#language/cpp</a> <a class="tag" href="?query=tag:참고도서/윤성우의_열혈_cpp_프로그래밍" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/윤성우의_열혈_cpp_프로그래밍</a> 
 <br><br><a href=".?query=tag:language\cpp" class="tag" target="_blank" rel="noopener nofollow">#language/cpp</a><br><br>객체 간 복사의 한 형태.<br>순수히 멤버 대 멤버 간 복사가 일어난다. <a data-tooltip-position="top" aria-label="복사 생성자" data-href="복사 생성자" href="public\복사-생성자.html" class="internal-link" target="_self" rel="noopener nofollow">디폴트 복사 생성자</a>는 얕은 복사의 형태로 객체 간 복사한다.<br><img alt="얕은 복사.png" src="lib\media\얕은-복사.png"><br>heap 영역에 할당된 공간을 가리키는 포인터를 복사할 경우, 복수의 객체가 heap 영역의 동일한 공간을 가리키는 형태가 된다.<br><img alt="얕은 복사 깊은 복사.png" src="lib\media\얕은-복사-깊은-복사.png"><br>따라서 원본 객체가 소멸할 경우(= heap 영역에 할당된 공간이 해제될 경우) 복사본 객체의 멤버 또한 공간을 참조할 수 없게 된다. 이러한 경우를 방지하고 싶다면 <a data-href="깊은 복사" href="public\깊은-복사.html" class="internal-link" target="_self" rel="noopener nofollow">깊은 복사</a>를 사용해야 한다.<br><br>참고자료<br><a href=".?query=tag:참고도서\윤성우의_열혈_cpp_프로그래밍" class="tag" target="_blank" rel="noopener nofollow">#참고도서/윤성우의_열혈_cpp_프로그래밍</a><br>]]></description><link>public\얕은-복사.html</link><guid isPermaLink="false">public/얕은 복사.md</guid><pubDate>Sat, 22 Mar 2025 07:31:41 GMT</pubDate><enclosure url="lib\media\얕은-복사.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="lib\media\얕은-복사.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[연산자 오버로딩]]></title><description><![CDATA[<a class="tag" href="?query=tag:language/cpp" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#language/cpp</a> <a class="tag" href="?query=tag:참고도서/윤성우의_열혈_cpp_프로그래밍" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/윤성우의_열혈_cpp_프로그래밍</a> 
 <br><br><a href=".?query=tag:language\cpp" class="tag" target="_blank" rel="noopener nofollow">#language/cpp</a> <br>operator overloading<br><br><br>연산자 오버로딩이란, 기존의 연산자의 오버로딩을 통하여, 기존에 존재하던 연산자의 기본 기능 이외에 다른 기능을 추가할 수 있게끔 하는 문법적 요소이다.<br>연산자 오버로딩에 사용되는 함수명은 'operation' + '(연산자)' 의 형태를 띈다.<br>
연산자 오버로딩은 기본적으로 아래와 같이 사용된다.<br>
#include &lt;iostream&gt;
using namespace std;

class Point
{
	private :
		int xpos, ypos;
	public :
		Point(int x = 0, int y = 0) : xpos(x), ypos(y) {}
		void ShowPosition() const
		{
			cout&lt;&lt;'['&lt;&lt;xpos&lt;&lt;", "&lt;&lt;ypos&lt;&lt;']'&lt;&lt;endl;
		}
		Point operator+(const Point &amp;ref)
		{
			Point pos(xpos + ref.xpos, ypos + ref.ypos);
			return pos;
		}
};

/*
int main(void)
{
	Point pos1(3, 4);
	Point pos2(10, 20);
	//연산자 오버로딩을 사용하지 않으면 보통 이와 같이 코드를 작성한다.
	Point pos3 = pos1.operator+(pos2);

	pos1.ShowPosition();
	pos2.ShowPosition();
	pos3.ShowPosition();
	
	return (0);
}
*/

int main(void)
{
	Point pos1(3, 4);
	Point pos2(10, 20);
	//연산자 오버로딩을 사용하여 아래와 같이 코드를 축약할 수 있다.
	Point pos3 = pos1 + pos2;
	
	pos1.ShowPosition();
	pos2.ShowPosition();
	pos3.ShowPosition();
	
	return (0);
}

<br>다음은 위 예제에서 연산자 오버로딩이 적용된 문장이다.<br>pos1 + pos2;<br>이 문장은 아래와 같이 분해할 수 있다.<br>pos1<br>
+<br>
pos2<br>연산자 오버로딩은 위 문장의 각 구성요소를 다음과 같이 변환한다.<br>pos<br>
.operator+<br>
(pos2)<br>pos.operator+(pos2);<br><br><br>연산자를 오버로딩 하는 방법에는 다음 두 가지가 있다.<br>
<br>멤버함수에 의한 연산자 오버로딩
<br>전역함수에 의한 연산자 오버로딩
<br>개요에서 소개한 방법은 멤버함수에 의한 연산자 오버로딩이다.<br>
전역함수를 이용해서 오버로딩을 하면 pos1 + pos2는 다음과 같이 해석이 된다.<br>operator+(pos1, pos2);<br>아래 예제를 참조하자.<br>
#include &lt;iostream&gt;
using namespace std;

class Point
{
	private :
		int xpos, ypos;
	public :
		Point(int x = 0, int y = 0) : xpos(x), ypos(y) {}
		void ShowPosition() const
		{
			cout&lt;&lt;'['&lt;&lt;xpos&lt;&lt;", "&lt;&lt;ypos&lt;&lt;']'&lt;&lt;endl;
		}
		/*전역 함수에서 Point 객체의 멤버를 참조할 수 있도록 한다.*/
		friend Point operator+(const Point &amp;pos1, const Point &amp;pos2);
};

//연산자 오버로딩 전역 함수 버전
Point operator+(const Point &amp;pos1, const Point &amp;pos2)
{
	Point pos(pos1.xpos + pos2.xpos, pos1.ypos + pos2.ypos);
	return pos;
}

int main(void)
{
	Point pos1(3, 4);
	Point pos2(10, 20);
	Point pos3 = pos1 + pos2;

	pos1.ShowPosition();
	pos2.ShowPosition();
	pos3.ShowPosition();

	return (0);
}

<br>위 예제와 같이, 연산 대상이 private 멤버 변수인 경우, friend 선언을 통하여 전역 변수에게 멤버의 참조를 허용하여야 한다.<br>전역 함수를 이용한 연산자 오버로딩은 후술할 교환 법칙이 성립하는 연산자 오버로딩의 구현에 유용하게 사용된다.<br><br><br><br>이들 연산자에 대해서 오버로딩을 제한하는 이유는 C++의 문법 규칙을 보존하기 위해서다.<br>
만약 이들 연산자들까지 오버로딩을 허용해 버린다면, C++ 문법 규칙에 어긋나는 문장의 구성이 가능해진다.<br><br><br><br>이들은 객체를 대상으로 진행해야 의미가 통하는 연산자들이기 때문에, 멤버함수 기반으로만 연산자의 오버로딩을 허용한다.<br><br><br>
<br>연산자의 본래 정의를 벗어난 형태의 오버로딩은 좋지 않다.
<br>연산자의 우선 순위와 결합성은 바뀌지 않는다.
<br>매개변수의 디폴트 값 설정이 불가능하다.
<br>클래스가 아닌 일반 자료형 간의 연산을 재정의 할 수는 없다.

<br>부연 : 예를 들어 'int 형 변수 간의 덧셈'과 같은 동작을 재정의할 수는 없다는 말이다.


<br><br><br>피연산자가 두 개인 이항 연산자와 피연산자가 한 개인 단항 연산자의 가장 큰 차이점은 피연산자의 개수이다. 그리고 이에 따른 연산자 오버로딩의 차이점은 매개변수의 개수에서 발견된다.<br>대표적인 단항 연산자로는 다음의 두 가지가 있다.<br>
<br>++
<br>--
<br>단항 연산자는 연산 결과가 피연산자 객체 스스로에 적용되기 때문에 함수에 인자를 전달할 필요가 없다.<br>
따라서 멤버함수의 경우, 다음의 형태를 띈다.<br>
//전위 연산을 담당하는 함수의 형태
Obj &amp;operation++() { /* . . . */ }

<br>위의 연산자들이 피연산자의 앞에 위치하면 전위 연산자, 뒤에 위치하면 후위 연산자가 된다.<br>
둘을 구분하기 위하여, 후위 연산을 담당하는 함수에게만 키워드 int를 표시한다. int 키워드는 오로지 전위와 후위를 구분하기 위해 존재하며, int 형 인자를 전달하는 것이 아니다.<br>
//후위 연산을 담당하는 함수의 형태
Obj &amp;operation++( int ) { /* . . . */ } //키워드 int를 사용하여 전위와 후위를 구분한다.

<br>마찬가지로 전역함수로 단항 연산을 구현할 경우, 이항 연산과 달리 피연산자를 하나만 전달하면 된다.<br>
//전위 연산을 담당하는 함수의 형태
Obj &amp;operation++( Obj &amp;a) { /* . . . */ }
//후위 연산을 담당하는 함수의 형태
Obj &amp;operation++( Obj &amp;a, int ) { /* . . . */ } //키워드 int를 사용하여 전위와 후위를 구분한다.

<br><br><br>위 절의 예제에서 operation++()은 객체의 참조값을 반환한다. 사실 객체의 멤버 변수를 1 더하는 동작만을 정의한다면 다음과 같이 반환형을 void로 하여도 상관없다.<br>
void operation++()
{
	//var1과 var2는 객체의 멤버변수
	var1 += 1;
	var2 += 1;
}

<br>그러나 이러한 형식으로 함수를 정의하면 다음과 같은 형태의 연산이 불가능하다.<br>
<br>++(++obj) //obj에 ++연산을 연속적으로 2번 적용하고자 함
<br>operation++은 void를 반환하므로 위 연산은 다음과 동일하다.<br>
++(void) //error
<br>따라서 위와 같은 연산이 가능하게 하기 위해서는 반환형을 객체의 참조자로 하는 것이 좋다.<br>
Obj &amp;operation++()
{
	var1 += 1;
	var2 += 1;
	
	return (*this); //객체 스스로의 참조값을 반환
}

<br>
<br>++(++obj)를 연산하고자 함.
<br>operation++은 객체의 참조값을 반환하므로 위 연산은 다음과 동일하다.

<br>++(obj.operation++())
<br>++(obj 객체의 참조값)
<br>(obj 객체의 참조값).operation++()


<br><br><br>C++ 언어에서는 다음과 같은 연속적인 후위 연산을 금지하고 있다.<br>(obj--)--;<br>따라서 다음과 같이 operation--()의 반환형을 const 객체로 선언하면 연속적인 후위 연산을 제한할 수 있다.<br>
//전위 연산을 담당하는 함수의 형태
const Obj operation++( Obj &amp;a) { /* . . . */ }
//후위 연산을 담당하는 함수의 형태
const Obj operation++( Obj &amp;a, int ) { /* . . . */ } //키워드 int를 사용하여 전위와 후위를 구분한다.

<br>
<br>(obj--)--;를 연산하고자 함.
<br>operation--는 const 임시 객체를 반환하므로 위 연산은 다음과 동일하다.

<br>(obj.operation--())--
<br>(Obj 클래스의 const 임시 객체)--
<br>(Obj 클래스의 const 임시 객체).operation--() // error : const 임시 객체는 const 멤버 함수가 아닌 operation--()를 호출할 수 없다.


<br><br><br>곱셈과 같은 연산은 다음과 같이 피연산자 2개의 자료형이 서로 다를 수 있다.<br>
class Point
{
	private :
		int xpos, ypos;
	public :
		Point operation*(int n)
		{
			xpos *= n;
			ypos *= n;
			return (*this);
		}
}

int main(void)
{
	Point pos(1, 2);
	Point cpy;

	cpy = pos * 3;
	cpy = pos * 3 * 2;

	return (0);
}

<br>위 예제에서 cpy = pos * 3;은 cpy = 3 * pos;으로도 표현할 수 있어야 한다.<br>
하지만 cpy = 3 * pos;은 다음과 같이 해석될 수는 없기 때문에 연산자 오버로딩이 불가하다.<br>3.operator*(pos);<br>따라서 * 연산자의 교환법칙을 구현하려면 전역 함수를 사용하여 다음과 같이 정의해야 한다.<br>
class Point
{
	private :
		int xpos, ypos;
	public :
		Point operation*(int n)
		{
			xpos *= n;
			ypos *= n;
			return (*this);
		}
	friend Point operator*(int n, Point &amp;pos);
}

Point operator*(int n, Point &amp;pos)
{
	return ref * n;
}

int main(void)
{
	Point pos(1, 2);
	Point cpy;

	cpy = 3 * pos; //operator*(3, pos);로 해석됨.
	cpy = 3 * pos * 2; //operator*(3, pos).operator*(3);으로 해석됨.

	return (0);
}

<br><br><br>대입 연산자는 <a data-href="복사 생성자" href="public\복사-생성자.html" class="internal-link" target="_self" rel="noopener nofollow">복사 생성자</a>와 매우 유사한 성격을 가지고 있다.<br>복사 생성자의 특성<br>
<br>정의하지 않으면 디폴트 복사 생성자가 삽입된다.
<br>디폴트 복사 생성자는 멤버 대 멤버의 복사(얕은 복사)를 진행한다.
<br>생성자 내에서 동적 할당을 한다면, 그리고 깊은 복사가 필요하다면 직접 정의해야 한다.
<br>대입 연산자의 특성<br>
<br>정의하지 않으면 디폴트 대입 연산자가 삽입된다.
<br>디폴트 대입 연산자는 멤버 대 멤버의 복사(얕은 복사)를 진행한다.
<br>연산자 내에서 동적 할당을 한다면, 그리고 깊은 복사가 필요하다면 직접 정의해야 한다.
<br>참고로, 디폴트 대입 연산자는 다음과 같은 형식을 하고 있다.<br>
Obj &amp;operator=(const Obj obj)
{
	objVal1 = obj.objVal1;
	objVal2 = obj.objVal2;
	return *this;
}

<br>그러나 대입 연산자와 복사 생성자는 호출시점에 차이를 갖는다.<br>
<br>복사 생성자 : 새로 생성하는 객체의 초기화에 기존에 생성된 객체가 사용.

<br>ex) Point pos = pos1;


<br>대입 연산자 : 기존의 생성된 객체 사이에 대입 연산이 사용되었을 경우.

<br>ex) pos2 = pos1;


<br>또한 대입 연산자와 복사 생성자는 상속 구조에서의 호출에서 다음의 차이점을 갖는다.<br>
<br>복사 생성자 : 자식 클래스에서 아무런 명시를 하지 않아도 부모 클래스의 생성자가 호출.
<br>대입 연산자

<br>디폴트 대입 연산자 호출의 경우 : 디폴트 대입 연산자가 부모 클래스의 대입 연산자까지 호출한다.
<br>대입 연산자를 직접 정의하는 경우 : 자식 클래스의 대입 연산자에서 명시가 없으면, 부모 클래스의 대입 연산자가 호출되지 않는다. 다음의 형태를 사용하여 부모 클래스의 대입 연산자를 호출할 수 있다.

<br>Parent::operator=(ref); //부모 클래스명::operator=(매개인자);




<br>c++ 언어의 대입연산( =객체 간의 대입 연산 )은 c 언어의 구조체 간의 대입과 유사해 보이지만, 대입 연산자를 오버로딩하였다는 점에서 근본적으로 차이점이 있다.<br>객체 내에서 멤버를 동적 할당하는 경우, 디폴트 대입 연산자 사용 시 다음의 두 가지 문제가 발생한다.<br><img alt="디폴트 대입 연산자의 동작(얕은 복사).png" src="lib\media\디폴트-대입-연산자의-동작(얕은-복사).png"><br>
<br>기존에 가리키던 heap 영역의 공간에 대한 참조를 잃는다.
<br>얕은 복사로 인해서, 객체 소멸 과정에서 지워진 문자열을 중복 소멸하는 문제가 발생한다.
<br>따라서 다음의 원칙을 준수하여 직접 대입 연산자를 정의하여야 한다.<br>
<br>깊은 복사를 진행하도록 정의한다.
<br>메모리 누수가 발생하지 않도록, 깊은 복사에 앞서 메모리 해제의 과정을 거친다.
<br><br><br>앞서 언급했듯이, [] 연산자는 멤버함수 기반으로만 오버로딩 하도록 제한되어 있다.<br>
[] 연산자 오버로딩 함수는 아래와 같은 형식을 가지고 있다.<br>
int operator[](int idx) { . . . . } //int로 선언된 반환형은 임의로 결정한 것이다. 이는 반환하는 값의 자료형에 따라 달라진다.

<br>
/*아래 문장은 다음과 같이 해석된다*/
arrObject[2]; //arrObject는 객체
//arrObject.operator[](2);

<br>[] 연산자 오버로딩은 오류 발생, 잘못된 접근 등을 개발자가 사전에 제약할 수 있다는 장점이 있다. (ex. out of index).<br><br><br>new 연산자가 하는 일은 다음과 같다.<br>
<br>메모리 공간의 할당
<br>생성자의 호출
<br>할당하고자 하는 자료형에 맞게 반환된 주소 값의 형 변환 -&gt; malloc과 달리 반환하는 주소값을 형변환할 필요가 없음.
<br>이 세 가지 동작 중에서 개발자는 1번에 해당하는 메모리 공간의 할당만 오버로딩 할 수 있다. 나머지 두 가지 작업은 C++ 컴파일러에 의해서 진행이 되며, 오버로딩할 수 있는 대상도 아니다.<br>다음과 같은 형식으로 오버로딩하도록 사전에 약속되어 있다.<br>
/*아래의 기본적인 동작에 사용자가 원하는 동작을 추가적으로 정의한다.*/
void *operator new (size_t size)
{
	void *adr = new char[size];
	return (adr);
}

<br>delete 연산자가 호출되면 다음과 같이 동작한다.<br>
<br>다음의 문장으로 객체의 소멸을 명령하면 delete obj;
<br>컴파일러는 먼저 obj가 가리키는 객체의 소멸자를 호출한다.
<br>그 다음 다음의 형태로 정의된 함수에 ptr에 저장된 주소 값을 전달한다.
<br>
void operator delete (void *adr) { . . . . }

<br>따라서 delete 함수는 최소한 다음의 동작을 포함해야 하며, 그 의외에 필요한 추가적인 내용을 개발자가 추가한다.<br>
void operator delete (void *adr)
{
	delete []adr;
}

<br>참고로, 사용하는 컴파일러에서 void 포인터 형 대상의 delete 연산을 허용하지 않는다면, 위의 delete 문을 다음과 같이 작성하면 된다. 즉, char 포인터 형으로 변환해서 delete 연산을 진행하면 된다.<br>delete []((char *)adr);<br>new 연산자는 멤버함수의 형태로 오버로딩되지만, 아래와 같이 객체가 생성되기도 전에 호출할 수 있다.<br>
Obj *ptr = new Obj(3, 4);

<br>이는 operator new, operator delete 함수는 static 함수이기 때문이다. 멤버함수의 형태로 함수를 작성해도 두 함수는 static 함수로 간주되도록 약속이 되어있다.<br><br>new[], delete[] 함수는 배열 할당, 해제 시 호출되는 함수라는 점만 제외하고 new, delete 함수과 동일하다.<br>
void *operator new[] (size_t size) { . . . . }
void operator delete[] (void *adr) { . . . . }

<br><br><br>포인터를 기반으로 하는 연산자에는 다음이 있다.<br><br>그리고 이 두 연산자의 오버로딩은 아래의 예제와 같이 이루어진다.<br>
#include &lt;iostream&gt;
using namespace std;

class Number
{
	priate :
		int num;
	public :
		Number(int n) : num(n) { }
		void ShowData() {cout&lt;&lt;num&lt;&lt;endl;}
		
		/*객체 자신의 주소 값을 반환하도록 -&gt;연산자를 오버로딩 하고 있다. -&gt; 연산자를 다른 형태로 오버로딩 하는 것도 가능하지만, 이 연산자의 오버로딩을 허용하는 이유는 주소 값의 반환이 목적이기 따문에 다른 형태로는 오버로딩하지 않는 것이 좋다.*/
		Number *operator-&gt;()
		{
			return this;
		}
		/*이 함수는 객체 자신을 참조의 형태로 반환하도록 *연산자를 오버로딩하고 있다.*/
		Number &amp;operator*()
		{
			return *this;*
		}
};

int main(void)
{
	Number num(20);
	num.ShowData();
	
	/*객체 num이 포인터 변수인 것처럼 연산문이 구성되었다. 이는 *,-&gt; 연산자의 오버로딩 결과이다.*/
	(*num) = 30;
	num-&gt;ShowData();
	(*num).ShowData();

	return (0);
}

<br>포인터 연산자 오버로딩을 통해, 기존에 포인터 연산자의 기능에 사용자가 정의한 기능을 추가한 포인터 연산자를 만들 수 있다. 이러한 포인터는 객체의 형태로 구현되며, 스마트 포인터(Smart Pointer)라고 한다.<br><br><br>함수의 호출에 사용하는 () 또한 연산자이다. 때문에 이 역시 오버로딩이 가능하다. () 연산자 오버로딩의 목적은 객체를 함수처럼 사용하는 것이다.<br>() 연산자 오버로딩은 아래의 예제와 같이 이루어진다.<br>
class Functor
{
	public :
	//생략
		void operator()(int a, int b) { /*정의된 동작*/ }
}

int main()
{
	Functor obj;
	obj(2, 4); //obj.operator()(2, 4);와 동일하게 동작함.
}

<br>위와 같이 함수처럼 동작하는 클래스를 가리켜 펑터(functor), 또는 함수 오브젝트(Function Object)라고 한다.<br>펑터는 다음과 같이 응용할 수 있다.<br>
<br>부모 클래스에서 operator()()를 순수 가상함수로 선언한다.
<br>자식 클래스에서 operator()()의 동작을 정의한다.
<br>부모 클래스의 참조형으로 입력을 받는 함수가 있다고, 가정할 때, 다양한 기능을 구현한 자식 클래스들을 그 자리에 입력할 수 있으며, 어떤 자식을 입력하는 지에 따라 동작이 달라진다. 이것이 펑터의 이점이다.
<br><br><br>c++에서는 다음과 같은 코드의 실행이 가능한다.<br>
int main(void)
{
	Number num;
	num = 30; //서로 다른 자료형 간의 대입이 가능하다.
	num.ShowNumber();
	return (0);
}

<br>위 예제에서 num = 30;은 다음과 같이 변환되어 처리된다.<br>
num = Number(30); //1단계. 임시 객체의 생성
num.operator=(Number(30)); //2단계. 임시 객체를 대상으로 하는 대입 연산자의 호출

<br>c++에는 다음과 같은 문법적 기준이 존재한다.<br>A형 객체가 와야 할 위치에 B형 데이터(또는 객체)가 왔을 경우, B형 데이터를 인자로 전달받은 A형 클래스의 생성자 호출을 통해서 A형 임시객체를 생성한다.<br><br><br>형 변환 연산자는 객체가 다른 타입의 데이터와 연산이 일어난 때 호출되는 연산자이다.<br>
아래의 예제를 확인하자.<br>
int main(void)
{
	Number num1(30);
	
	Number num2 = num1 + 20; //서로 다른 자료형 간의 + 연산이 일어남.
	num2.ShowNumber();
	return 0;
}

<br>위의 예제가 실행 가능하려면 아래의 두 가지 방법 중 하나를 사용해야 한다.<br>
<br>int 타입 데이터와의 + 연산이 가능하도록 + 연산자를 오버로딩한다.
<br>Number 객체의 int 자료형으로의 형 변환을 구현한다.
<br>c++ 언어에서는 2번 방법을 구현하기 위해 형 변환 연산자의 오버로딩을 사용한다.<br>
아래와 같이 구현한다.<br>
operator int () // 형 변환 연산자의 오버로딩.
{
	return (num);
}

<br>형 변환 연산자 함수는 아래와 같은 특징을 가진다.<br>
<br>'operator + 형 변환하는 데이터 타입' 형식의 함수명을 가진다.
<br>정의된 데이터 타입으로 형 변환해야 하는 경우에 호출된다.
<br>반환형을 명시하지 않는다. 하지만 return을 사용한 반환은 가능하다. 이 때 return으로 반환되는 값은 정의된 데이터 타입으로 형 변환된다.
<br><br>참고자료<br><a href=".?query=tag:참고도서\윤성우의_열혈_cpp_프로그래밍" class="tag" target="_blank" rel="noopener nofollow">#참고도서/윤성우의_열혈_cpp_프로그래밍</a><br>]]></description><link>public\연산자-오버로딩.html</link><guid isPermaLink="false">public/연산자 오버로딩.md</guid><pubDate>Sat, 22 Mar 2025 07:31:41 GMT</pubDate><enclosure url="lib\media\디폴트-대입-연산자의-동작(얕은-복사).png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="lib\media\디폴트-대입-연산자의-동작(얕은-복사).png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[예외 처리]]></title><description><![CDATA[<a class="tag" href="?query=tag:language/cpp" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#language/cpp</a> <a class="tag" href="?query=tag:참고도서/윤성우의_열혈_cpp_프로그래밍" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/윤성우의_열혈_cpp_프로그래밍</a> 
 <br><br><a href=".?query=tag:language\cpp" class="tag" target="_blank" rel="noopener nofollow">#language/cpp</a><br>exception handling<br><br><br>C++에서 말하는 예외의 정의는 다음과 같다.<br>프로그램 실행 도중에 발생하는 문제상황<br>
프로그램의 논리에 맞기 않는 상황<br>따라서 문법적인 에러는 예외의 범주에 포함되지 않는다.<br>C에서는 보통 if else문을 사용해 분기를 구성함으로서 이러한 예외들을 처리한다. 그러나 이러한 방식은 예외처리를 위한 코드와 프로그램의 흐름을 구성하는 코드를 쉽게 구분하지 못한다는 문제가 있다. C++은 이러한 문제를 해결하기 위해 별도의 예외 처리 매커니즘을 보유하고 있다.<br><br><br>C++에서 예외 처리를 위한 키워드는 아래의 3가지가 있다.<br><br>
<br>try 블록
<br>try 블록은 예외 발생에 대한 검사의 범위를 지정할 때 사용된다. 즉, try 블록 내에서 예외가 발생하면 이는 C++의 예외처리 매커니즘에 의해서 처리가 된다.<br>
try
{
	// 예외발생 예외지역
}

<br>
<br>catch 블록
<br>catch 블록은 try 블록에서 발생한 예외를 처리하는 코드가 담기는 영역으로서, 그 형태가 마치 반환형 없는 함수와 유사하다.<br>
catch(/*처리할 예외의 종류 명시*/)
{
	// 예외처리 코드의 삽입
}

<br>
<br>사실 try와 catch는 하나의 단위이다.

<br>따라서 항상 이어서 등장해야 하며, 중간에 다른 문장이 오면 안된다.


<br>종합적으로, try 블록 내에서 발생하는 예외는 이어서 등장하는 catch 블록에 의해 처리된다.<br>
<br>throw
<br>키워드 throw는 예외가 발생했음을 알리는 문장의 구성에 사용된다.<br>
throw expn;

<br>최종적으로 try, catch, throw는 다음과 같이 동작한다.<br>
<br>throw에 의해서 '예외 데이터'가 던져진다.
<br>'예외 데이터'를 감싸는 try 블록에 의해 감지된다.
<br>이어서 등장하는 catch 블록이 예외를 처리한다.
<br>구체적인 동작은 아래의 예제를 참고하자.<br>
/*HandlingExceptionTryCatch.cpp*/

#include &lt;iostream&gt;
using namespace std;

int main(void)
{
	int num1, num2;
	cout&lt;&lt;"두 개의 숫자 입력: ";
	cin&gt;&gt;num1&gt;&gt;num2;
	
	try //try 블록으로 에러 발생이 예상되는 영역을 묶는다.
	{
		if (num2 == 0) //에러의 조건
			throw num2; //에러 데이터를 던진다
		//만약 에러가 발생하면 발생 지점 이후의 try 블록은 건너뛴다.
		cout&lt;&lt;"나눗셈의 몫: "&lt;&lt;(num1 / num2)&lt;&lt;endl;
		cout&lt;&lt;"나눗셈의 나머지: "&lt;&lt;(num1 % num2)&lt;&lt;endl;
	}
	catch(int expn) //에러 데이터를 받아 블록 내에서 적절한 예외 처리를 한다.
	{
		cout&lt;&lt;"제수는 "&lt;&lt;expn&lt;&lt;"이 될 수 없습니다."&lt;&lt;endl;
		cout&lt;&lt;"프로그램을 다시 실행하세요."&lt;&lt;endl;
	}
	cout&lt;&lt;"end of main"&lt;&lt;endl;
	
	return (0);
}

<br>
<br>팁 : try 블록 내에서, 에러 발생 시점 이후의 문장들은 건너뛴다는 특성을 잘 활용하자. 에러와 직접적으로 관련이 없더라도 에러 발생 시 실행되면 안되는 문장들은 try 블록 안으로 집어넣는 것이 바람직하다.
<br><br><br>try 블록 내에서 직접적으로 catch가 실행되지 않고, try 내부에서 호출한 함수 내부에서 catch가 실행되는 경우가 있다.<br>
/*PassException.cpp*/

#include &lt;iostream&gt;
using namespace std;

void Divide(int num1, int num2)
{
	if (num2 == 0)
		throw num2; //throw는 try, catch 블록이 없다. 이러한 경우에는 함수를 호출한 곳으로 '예외 데이터'를 던진다.
	cout&lt;&lt;"나눗셈의 몫 : "&lt;&lt; num1 / num2 &lt;&lt;endl;
	cout&lt;&lt;"나눗셈의 나머지 : "&lt;&lt; num % num2 &lt;&lt;endl;
}

int main(void)
{
	int num1, num2;
	cout&lt;&lt;"두 개의 숫자 입력 : ";
	cin&gt;&gt;num1&gt;&gt;num2;
	
	try //try 블록 내에서 throw가 직접적으로 호출되지 않고, Divide 내에서 호출된다.
	{
		Divide(num1, num2);
		cout&lt;&lt;"나눗셈을 마쳤습니다."&lt;&lt;endl;
	}
	catch(int expn)
	{
		cout&lt;&lt;"제수는 "&lt;&lt;expn&lt;&lt;"이 될 수 없습니다."&lt;&lt;endl;
		cout&lt;&lt;"프로그램을 다시 실행하세요."&lt;&lt;endl;
	}
	return (0);
}

<br>위 예제에서 다음의 특성을 알 수 있다.<br>예외가 처리되지 않으면, 예외가 발생한 함수를 호출한 영역으로 예외 데이터가(더불어 예외처리에 대한 책임까지) 전달된다.<br>
함수 내에서 함수를 호출한 영역으로 예외 데이터를 전달하면, 해당 함수는 더 이상 실행되지 않고 종료가 된다.<br>다음과 같이 여러 개의 함수를 걸쳐 '예외 데이터'가 전달되는 케이스를 생각하여보자.<br>
/*StackUnwinding.cpp*/

#include &lt;iostream&gt;
using namespace std;

void SimpleFuncOne(void);
void SimpleFuncTwo(void);
void SimpleFuncThree(void);

int main(void)
{
	try
	{
		SimpleFuncOne();
	}
	catch (int expn)
	{
		cout&lt;&lt;"예외코드: "&lt;&lt;expn&lt;&lt;endl;
	}
	return (0);
}

void SimpleFuncOne(void)
{
	cout&lt;&lt;"SimpleFuncOne(void)"&lt;&lt;endl;
	SimpleFuncTwo();
}
void SimpleFuncTwo(void)
{
	cout&lt;&lt;"SimpleFuncTwo(void)"&lt;&lt;endl;
	SimpleFuncThree();
}
void SimpleFuncThree(void)
{
	cout&lt;&lt;"SimpleFuncThree(void)"&lt;&lt;endl;
	throw -1;
}

<br>만약 예외가 발생할 경우, try catch 문을 만날 때까지 호출된 함수의 역순으로 예외 데이터가 전달된다. 예외 데이터를 전달한 함수는 종료되기 때문에, 호출된 함수의 역순으로 함수의 스택은 반환된다.<br>
이를 스택 풀기(스택의 반환)이라고 명명한다.<br>만약 예외가 처리되지 않아서, 예외 데이터가 main 함수에까지 도달했는데, main 함수에서조차 예외를 처리하지 않으면, terminate 함수(프로그램을 종료시키는 함수)가 호출되면서 프로그램이 종료되어 버린다.<br>만약 throw로 던진 '예외 데이터'의 자료형과 catch 블록 인자의 자료형이 일치하지 않으면, catch 블록으로 예외가 전달되지 않는다. 예외 데이터를 던질 수 있는 다른 영역이 있으면 그 곳으로 예외를 던지고, 그렇지 않으면 terminate 함수로 인해 종료된다.<br><br>throw 키워드로 던질 수 있는 '예외 데이터'의 자료형은 복수일 수 있기 때문에, 다음과 같이 catch 문도 여러 개 존재할 수 있다.<br>
#include &lt;iostream&gt;
using namespace std;

int main()
{
	char c;

	cout&lt;&lt;"값 입력 : ";
	cin&gt;&gt;c;

	try
	{
		if (c == "1")
			throw 1; //int 형을 던짐
		else if(c == "a")
			throw "a"; //char 형을 덤짐
	}
	catch (int expn)
	{
		cout&lt;&lt;"입력값은 int type"&lt;&lt;endl;
	}
	catch (char expn)
	{
		cout&lt;&lt;"입력값은 char type"&lt;&lt;endl;
	}
	cout&lt;&lt;endl&lt;&lt;"end of main"&lt;&lt;endl;
}

<br><br><br>함수 내에서 발생할 수 있는 예외의 종류도 함수의 특징으로 간주된다. 따라서 이미 정의된 특정 함수의 호출을 위해서는 함수의 이름, 매개변수 선언, 반환형 정보에 더해서, 함수 내에서 전달될 수 있는 예외의 종류(예외 데이터의 자료형)과 그 상황도 알아야 한다. 따라서 함수를 정의할 때에는 함수 내에서 발생 가능한 예외의 종류를 다음과 같이 명시해 주는 것이 좋다.<br>
int ThrowFunc(int num) throw (int, char)
{
	// . . . .
}

<br>함수에 사전에 명시한 자료형 이외의 '예외 데이터'를 함수가 반환하면, 역시 terminate(unexpected) 함수의 호출로 인해서 프로그램은 종료된다.<br><br>클래스의 객체 또한 '예외 데이터'가 될 수 있다. 예외 발생을 알리는 데 사용되는 객체를 가리켜 '예외 객체'라 하며, 예외 객체의 생성을 위해 정의된 클래스를 '예외 클래스'라고 한다. 객체를 이용해서 예외 상황을 알리면, 예외가 발생한 원인에 대한 정보를 자세히 담을 수 있다는 장점이 있다.<br>또한, 예외클래스 또한 상속이 가능하며, 이를 통하여 예외의 처리를 더욱 단순화할 수 있다.<br><br><br>try 블록의 뒤를 이어서 등장하는 catch 블록이 둘 이상인 경우, 적절한 catch 블록을 찾는 과정은 다음과 같다.<br>
try
{
	//예외 발생
}
catch(type1 param) //1차 : 이 예외에 타당한 catch 블록인가?
{
	//예외 처리
}
//아니라면
catch(type2 param) //2차 : 이 예외에 타당한 catch 블록인가?
{
	//예외 처리
}
//그것도 아니라면
catch(type3 param) //3ck : 이 예외에 타당한 catch 블록인가?
{
	//예외 처리
}
//다 아니라면 다른 영역으로 전달

<br>따라서 클래스 A가 있고, 클래스 B와 C가 A를 상속한다면 다음과 같이 블록을 짜면 안된다. 첫번째 블록에서 걸리기 때문이다.<br>
try
{}
catch (A param) //B와 C도 A의 일종으로 간주되므로 여기서 걸린다.
{}
catch (B param)
{}
catch (C param)
{}

<br>다음과 같이 구성하는 것이 좋다.<br>
try
{}
catch (C param) //A, B는 여기서 걸리지 않음
{}
catch (B param) //A는 걸리지 않음
{}
catch (A param)
{}

<br><br><br>new 연산에 의한 메모리 공간의 할당이 실패하면 bad_alloc이라는 예외가 발생한다. bad_alloc은 헤더파일 &lt;new&gt;에 선언된 예외 클래스로서 메모리 공간의 할당이 실패헀음을 알리는 의도로 정의되었다. 그럼 이와 관련하여 다음 예제를 보자.<br>
/*BadAlloc.cpp*/

#include &lt;iostream&gt;
#include &lt;new&gt;
using namespace std;

int main(void)
{
	int num = 0;
	
	try
	{
		while (1)
		{
			num++;
			cout&lt;&lt;num&lt;&lt;"번째 할당 시도"&lt;&lt;endl;
			new int[10000][10000];
		}
	}
	catch(bad_alloc &amp;bad)
	{
		cout&lt;&lt;bad.what()&lt;&lt;endl;
		cout&lt;&lt;"더 이상 할당 불가!"&lt;&lt;endl;
	}
	return (0);
}

<br><br><br>catch 블록에 전달된 예외는 다시 던져질 수 있다. 그리고 이로 인해서 하나의 예외가 둘 이상의 catch 블록에 의해서 처리되게 할 수 있다.<br>
/*ReThrow.cpp*/

#include &lt;iostream&gt;
using namespace std;

void Divide(int num1, int num2)
{
	try
	{
		if (num2 == 0)
			throw (0);
		cout&lt;&lt;"몫: "&lt;&lt;(num1 / num2)&lt;&lt;endl;
		cout&lt;&lt;"나머지: "&lt;&lt;(num1 % num2)&lt;&lt;endl;
	}
	catch (int expn)
	{
		cout&lt;&lt;"first catch"&lt;&lt;endl;
		throw; //예외를 다시 던진다.
	}
}

int main(void)
{
	try
	{
		Divide(9, 2);
		Divide(4, 0);
	}
	catch (int expn)
	{
		cout&lt;&lt;"second catch"&lt;&lt;endl;
	}
	return (0);
} 

<br><br><br><a data-tooltip-position="top" aria-label="형 변환" data-href="형 변환" href="public\형-변환.html" class="internal-link" target="_self" rel="noopener nofollow">dynamic_cast</a>를 이용한 형 변환 중, 다음의 경우 bad_cast 예외가 발생한다.<br>
<br>변환 대상이 실제로 가리키는 객체의 자료형과, 변환 대상의 변환 후 자료형이 다를 경우
<br>변환 대상의 자료형이 포인터가 아니라 참조형이어서 dynamic_cast가 NULL을 반환할 수 없는 경우
<br>구체적인 동작은 아래의 예제를 참고하자<br>
/*DynamicBadCastRef.cpp*/

#include &lt;iostream&gt;
using namespace std;

class SoSimple
{
	public :
		virtual void ShowSimpleInfo()
		{
			cout&lt;&lt;"SoSimple Base Class"&lt;&lt;endl;
		}
};

class SoComplex : public SoSimple
{
	public :
		void ShowSimpleInfo()
		{
			cout&lt;&lt;"SoComplex Derived Class"&lt;&lt;endl;
		}
};

int main(void)
{
	SoSimple simObj;
	SoSimple &amp;ref = simObj;
	
	try
	{
		SoComplex &amp;comRef = dynamic_cast&lt;SoComplex &amp;&gt;(ref); //bad_cast 예외 발생
		comRef.ShowSimpleInfo();
	}
	catch(bad_cast expt)
	{
		cout&lt;&lt;expt.what()&lt;&lt;endl;
	}
	return (0);
}

<br><br>참고자료<br><a href=".?query=tag:참고도서\윤성우의_열혈_cpp_프로그래밍" class="tag" target="_blank" rel="noopener nofollow">#참고도서/윤성우의_열혈_cpp_프로그래밍</a><br>]]></description><link>public\예외-처리.html</link><guid isPermaLink="false">public/예외 처리.md</guid><pubDate>Sat, 22 Mar 2025 07:31:42 GMT</pubDate></item><item><title><![CDATA[유니캐스트]]></title><description><![CDATA[<a class="tag" href="?query=tag:network" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#network</a> <a class="tag" href="?query=tag:참고도서/후니의_쉽게_쓴_시스코_네트워킹" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/후니의_쉽게_쓴_시스코_네트워킹</a> 
 <br><br><a href=".?query=tag:network" class="tag" target="_blank" rel="noopener nofollow">#network</a> <br>Unicast<br><br>정보를 받을 대상을 지정하여 송신하는 방식. 수신하는 측은 지정된 대상과 자신의 <a data-href="MAC 주소" href="public\mac-주소.html" class="internal-link" target="_self" rel="noopener nofollow">MAC 주소</a>가 일치할 때만 패킷을 cpu로 전달한다. 자신이 지정된 대상이 아닐 시 패킷을 폐기하므로 컴퓨터 성능에 영향을 끼치지 않는다.<br><br>참고자료<br><a href=".?query=tag:참고도서\후니의_쉽게_쓴_시스코_네트워킹" class="tag" target="_blank" rel="noopener nofollow">#참고도서/후니의_쉽게_쓴_시스코_네트워킹</a><br>]]></description><link>public\유니캐스트.html</link><guid isPermaLink="false">public/유니캐스트.md</guid><pubDate>Sat, 22 Mar 2025 07:31:45 GMT</pubDate></item><item><title><![CDATA[이더넷]]></title><description><![CDATA[<a class="tag" href="?query=tag:network" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#network</a> <a class="tag" href="?query=tag:참고도서/그림으로_이해하는_네트워크_용어" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/그림으로_이해하는_네트워크_용어</a> 
 <br><br><a href=".?query=tag:network" class="tag" target="_blank" rel="noopener nofollow">#network</a> <br>이더넷(Ethernet)은 미국 제록스(Xerox) 사 팔로 알토 연구소(Palo Alto Research Center)의 로버트 맷칼프가 발명한 네트워크 규격이다.<br><br>현재 <a data-href="LAN" href="public\lan.html" class="internal-link" target="_self" rel="noopener nofollow">LAN</a> 환경에서 통용되는 네트워크 규격이다. 스타형 LAN, 버스형 LAN에서 주로 사용된다.<br>이더넷은 아래와 같은 특성을 가진다.<br>
<br>매체 사용 감지 Carrier Sense : 네트워크의 통신 상태를 감지하여, 다른 pc가 송신하지 않을 경우에 한해 데이터를 송신한다.
<br>CSMA/CD Carrier Sense Multriple Access/Collision Detection : 부득이하게 동시에 전송하여 패킷 충돌이 발생하면 임의의 시간 동안 대기 후 재전송한다.
<br><br>참고자료<br><a href=".?query=tag:참고도서\그림으로_이해하는_네트워크_용어" class="tag" target="_blank" rel="noopener nofollow">#참고도서/그림으로_이해하는_네트워크_용어</a><br>]]></description><link>public\이더넷.html</link><guid isPermaLink="false">public/이더넷.md</guid><pubDate>Sat, 22 Mar 2025 07:31:45 GMT</pubDate></item><item><title><![CDATA[이름공간]]></title><description><![CDATA[<a class="tag" href="?query=tag:language/cpp" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#language/cpp</a> <a class="tag" href="?query=tag:참고도서/윤성우의_열혈_cpp_프로그래밍" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/윤성우의_열혈_cpp_프로그래밍</a> 
 <br><br><a href=".?query=tag:language\cpp" class="tag" target="_blank" rel="noopener nofollow">#language/cpp</a> <br>namespace<br><br>'이름공간'이란 특정 영역에 이름을 붙여주기 위한 문법적 요소이다.<br>이름공간의 등장 배경<br>여러 명이서 협업을 하는 규모가 큰 프로젝트가 있다고 가정하자. 만약 불운하게 개발자들이 만든 함수들의 이름이 서로 같다면 컴파일 에러가 날 것이다. 서로 같은 이름을 가진 함수라도 서로 다른 영역에 있음을 규정할 수 있다면 컴파일 에러를 막을 수 있을 것이다. 이러한 전제 하에 이름공간의 개념이 등장하게 되었다.<br>이름공간은 아래 예제와 같이 사용될 수 있다.<br>
#include &lt;iostream&gt;

namespace BestComImpl
{
	void SimpleFunc(void)
	{
		std::cout&lt;&lt;"BestCom이 정의한 함수"&lt;&lt;std::endl;
	}
}

namespace ProgComImpl
{
	void SimpleFunc(void)
	{
		std::cout&lt;&lt;"ProgCom이 정의한 함수"&lt;&lt;std::endl;
	}
}

int main(void)
{
	BestComImpl::SimpleFunc();
	ProgComImpl::SimpleFunc();

	return 0;
}

<br>함수를 호출할 때 <a data-href="범위지정 연산자" href="public\범위지정-연산자.html" class="internal-link" target="_self" rel="noopener nofollow">범위지정 연산자</a> ::을 사용해 어느 이름공간의 함수를 호출하는지 정의할 수 있다.<br>이름공간은 다음과 같은 특징을 지닌다.<br>
<br>이름공간에 속한 함수의 원형을 선언할 때는 아래와 같은 형식을 취한다.
<br>
#include &lt;iostream&gt;

namespace BestComImpl
{
	void SimpleFunc(void); //함수의 원형
}

namespace ProgComImpl
{
	void SimpleFunc(void);
}

int main(void)
{
	BestComImpl::SimpleFunc();
	ProgComImpl::SimpleFunc();
	
	return 0;
}

void BestComImpl::SimpleFunc(void) //함수의 정의
{
	std::cout&lt;&lt;"BestCom이 정의한 함수"&lt;&lt;std::endl;
}

void ProgComImpl::SimpleFunc(void)
{
	std::cout&lt;&lt;"ProgCom이 정의한 함수"&lt;&lt;std::endl;
}

<br>
<br>동일한 이름공간에 정의된 함수를 호출할 때는 이름공간을 명시할 필요가 없다.
<br>
#include &lt;iostream&gt;

namespace BestComImpl
{
	void SimpleFunc(void);
}

namespace BestComImpl
{
	void PrettyFunc(void);
}

namespace ProgComImpl
{
	void SimpleFunc(void);
}

int main(void)
{
	BestComImpl::SimpleFunc();
	return 0;
}

void BestComImpl::SimpleFunc(void)
{
	std::cout&lt;&lt;"BestCom이 정의한 함수"&lt;&lt;std::endl;
	PrettyFunc(); //동일한 이름공간의 함수를 호출할 떄는 범위 지정 연산자가 불필요
	ProgComImpl::SimpleFunc();
}

void BestComImpl::PrettyFunc(void)
{
	std::cout&lt;&lt;"So Pretty!!"&lt;&lt;std::endl;
}

void ProgComImpl::SimpleFunc(void)
{
	std::cout&lt;&lt;"ProgCom이 정의한 함수"&lt;&lt;std::endl;
}

<br>
<br>이름공간은 다른 이름공간 안에 삽입될 수 있다. 이러한 특성을 이름공간의 중첩이라 한다.
<br>
#include &lt;iostream&gt;

namespace Parent
{
	int num=2;

	namespace SubOne //이름 공간의 중첩
	{
		int num=3;
	}
	
	namespace SubTwo
	{
		int num=4;
	}
}

int main(void)
{
	//아래와 같은 형태로 호출한다.
	std::cout&lt;&lt;Parent::num&lt;&lt;std::endl;
	std::cout&lt;&lt;Parent::SubOne::num&lt;&lt;std::endl;
	std::cout&lt;&lt;Parent::SubTwo::num&lt;&lt;std::endl;
}

<br>
<br>이름공간이 과다하게 중첩되었을 때 별칭을 지정하여 코드를 축약할 수 있다.
<br>
#include &lt;iostream&gt;

using namespace std;

namespace AAA
{
	namespace BBB
	{
		namespace CCC
		{
			int num1;
			int num2;
		}
	}
}

int main(void)
{
	AAA::BBB::CCC::num1=20;
	AAA::BBB::CCC::num2=30;

	namespace ABC=AAA::BBB::CCC; //이와 같은 형식으로 축약할 수 있다.
	cout&lt;&lt;ABC::num1&lt;&lt;endl;
	cout&lt;&lt;ABC::num2&lt;&lt;endl;
	return 0;
}

<br>
<br>using 키워드를 사용하면 범위지정 연산자를 생략할 수 있다. 함수 안에서 사용된 using 키워드는 지역변수와 같이 함수 안에서만 효력을 가진다. 프로그램 전체에 영향을 끼치려면 전역변수와 마찬가지로 함수 밖에 선언을 해야 한다. using 키워드를 namespace 전체에 적용하면 해당 namespace의 요소 모두를 범위지정 연산자를 생략하여 사용할 수 있다. 하지만 이름충돌의 위험이 증가함으로 상황을 고려해 알맞게 사용해야 한다.
<br>
#include &lt;iostream&gt;

namespace Hybrid
{
	void HybFunc(void)
	{
		std::cout&lt;&lt;"So simple function!"&lt;&lt;std::endl;
		std::cout&lt;&lt;"In namespace Hybrid!"&lt;&lt;std::endl;
	}
}

int main(void)
{
	using Hybrid::HybFunc;
	HybFunc(); //using 키워드가 선언된 함수에 한하여 ::생략
	return 0;
}

<br>
#include &lt;iostream&gt;

using std::cin; //프로그램 전체에 using 키워드 적용
using std::cout;
using std::endl;

int main(void)
{
	int num=20;
	cout&lt;&lt;"Hello World!"&lt;&lt;endl;
	cout&lt;&lt;"Hello "&lt;&lt;"World!"&lt;&lt;endl;
	cout&lt;&lt;num&lt;&lt;' '&lt;&lt;'A';
	cout&lt;&lt;' '&lt;&lt;3.14&lt;&lt;endl;
	return 0;
}

<br>
#include &lt;iostream&gt;

using namespace std; //using 키워드를 이름공간 전체에 적용

int main(void)
{
	int num=20;
	cout&lt;&lt;"Hello World!"&lt;&lt;endl;
	cout&lt;&lt;"Hello "&lt;&lt;"World!"&lt;&lt;endl;
	cout&lt;&lt;num&lt;&lt;' '&lt;&lt;'A';
	cout&lt;&lt;' '&lt;&lt;3.14&lt;&lt;endl;
	return 0;
}

<br><br>참고자료<br><a href=".?query=tag:참고도서\윤성우의_열혈_cpp_프로그래밍" class="tag" target="_blank" rel="noopener nofollow">#참고도서/윤성우의_열혈_cpp_프로그래밍</a><br>]]></description><link>public\이름공간.html</link><guid isPermaLink="false">public/이름공간.md</guid><pubDate>Sat, 22 Mar 2025 07:31:42 GMT</pubDate></item><item><title><![CDATA[이미지]]></title><description><![CDATA[<a class="tag" href="?query=tag:docker" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#docker</a> <a class="tag" href="?query=tag:참고도서/그림과_실습으로_배우는_도커_쿠버네티스" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/그림과_실습으로_배우는_도커_쿠버네티스</a> <a class="tag" href="?query=tag:참고도서/시작하세요_도커_쿠버네티스" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/시작하세요_도커_쿠버네티스</a> 
 <br><br><a href=".?query=tag:docker" class="tag" target="_blank" rel="noopener nofollow">#docker</a><br>container의 설계도<br><br><a data-href="도커" href="public\도커.html" class="internal-link" target="_self" rel="noopener nofollow">도커</a>의 <a data-href="컨테이너" href="public\컨테이너.html" class="internal-link" target="_self" rel="noopener nofollow">컨테이너</a>를 만들기 위해 사용되는 설정 파일이다. 이미지를 사용하면 컨테이너를 간편하게 만들 수 있기 때문에 배포에 용이하다.<br><a data-href="Dockerfile" href="public\dockerfile.html" class="internal-link" target="_self" rel="noopener nofollow">Dockerfile</a> 스크립트를 작성하고 이 스크립트를 빌드해 이미지를 직접 만들 수도 있다.<br>거꾸로, 컨테이너로부터 이미지를 추출할 수도 있다(<a data-tooltip-position="top" aria-label="도커 명령어 > ^1afd73" data-href="도커 명령어#^1afd73" href="public\도커-명령어.html#^1afd73" class="internal-link" target="_self" rel="noopener nofollow">도커 명령어의 commit 참조</a>). 이 방법을 사용하면<br>
<br>이미지로부터 컨테이너를 만듬 
<br>컨테이너에서 변경 사항을 적용
<br>해당 컨테이너로부터 이미지를 추출하면 이미지에도 변경사항이 적용
<br>따라서 변경 사항을 이미지의 형태로 편하게 배포 가능
<br>하다는 장점이 있다.<br><br>도커 이미지는 아래와 같은 구조를 가지고 있다.<br>&lt;저장소 이름&gt;/&lt;이미지 이름&gt;:&lt;태그&gt;<br>
<br>저장소(Repository) 이름 : 이미지가 저장된 장소. 저장소 이름이 명시되지 않은 이미지는 도커 허브의 공식 이미지를 뜻한다.
<br>이미지 이름 : 해당 이미지가 어떤 역할을 하는 지 나타낸다. 생략할 수 없다.
<br>태그 : 이미지의 버전 또는 리비전(Revision) 관리에 사용한다. 태그를 생략하면 도커 엔진은 이미지의 버전을 latest라고 인식한다.
<br><br>도커 이미지는 (직접 Dockerfile을 건드리거나 하지 않는다면) 수정이 불가능한 읽기 전용 레이어이다.<br>
반대로, 도커 컨테이너 레이어는 임의로 수정이 가능하다.<br>도커 컨테이너는 도커 이미지 레이어 위에 컨테이너 레이어가 올라간 구조이다.<br><br>참고자료<br><a href=".?query=tag:참고도서\그림과_실습으로_배우는_도커_쿠버네티스" class="tag" target="_blank" rel="noopener nofollow">#참고도서/그림과_실습으로_배우는_도커_쿠버네티스</a><br>
<a href=".?query=tag:참고도서\시작하세요_도커_쿠버네티스" class="tag" target="_blank" rel="noopener nofollow">#참고도서/시작하세요_도커_쿠버네티스</a><br>]]></description><link>public\이미지.html</link><guid isPermaLink="false">public/이미지.md</guid><pubDate>Sat, 22 Mar 2025 07:31:39 GMT</pubDate></item><item><title><![CDATA[인라인 함수]]></title><description><![CDATA[<a class="tag" href="?query=tag:language/cpp" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#language/cpp</a> <a class="tag" href="?query=tag:참고도서/윤성우의_열혈_cpp_프로그래밍" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/윤성우의_열혈_cpp_프로그래밍</a> 
 <br><br><a href=".?query=tag:language\cpp" class="tag" target="_blank" rel="noopener nofollow">#language/cpp</a> <br>inline function<br><br>인라인 함수를 의역하면, '프로그램 코드라인 안으로 들어가 버린 함수'라는 뜻이다. c 언어의 매크로 함수는 함수의 몸체 부분이 함수의 호출문을 완전히 대체하므로, 인라인 함수의 정의와 일맥상통하는 부분이 있다.<br>매크로 함수의 장점은 아래와 같다.<br>
<br>일반적인 함수에 비해 실행속도의 이점이 있다.
<br>자료형의 제한이 없다
<br>매크로 함수의 단점은 아래와 같다.<br>
<br>정의하기가 어렵다.
<br>복잡한 함수를 매크로의 형태로 정의하는 데 한계가 있다.
<br>인라인 함수는 매크로 함수의 장점을 취하고 단점은 제거하기 위해 만들어진 개념이다.<br>
인라인 함수는 키워드 inline을 사용해 아래와 같이 선언된다.<br>
#include &lt;iostream&gt;

inline int SQUARE(int x) //인라인 함수의 몸체 부분은 호출문을 대체한다.
{
	return x*x;
}

int main(void)
{
	std::cout&lt;&lt;SQUARE(5)&lt;&lt;std::endl;
	std::cout&lt;&lt;SQUARE(12)&lt;&lt;std::endl;

	return 0;
}

<br>단, 인라인 함수는 매개변수의 자료형을 정의해야 하므로 매크로 함수의 모든 장점을 가질 수는 없다. <a data-href="템플릿" href="public\템플릿.html" class="internal-link" target="_self" rel="noopener nofollow">템플릿</a>과 인라인 함수를 같이 사용하면 이러한 한계를 극복할 수 있다.<br>매크로를 이용한 함수의 인라인화는 전처리기에 의해 처리되지만, 키워드 inline을 이용한 함수의 인라인화는 컴파일러에 의해 처리된다. 따라서 함수의 인라인화가 오히려 성능에 해가 된다고 판단할 경우, 컴파일러는 이 키워드를 무시해버리기도 한다. 또한 컴파일러는 필요한 경우 일부 함수를 임의로 인라인 처리하기도 한다.<br>또한 키워드 inline을 이용한 함수의 인라인화는 컴파일러에 의해 처리되기 때문에, 인라인 함수의 원형 선언과 정의는 같은 파일 안에 위치하여 컴파일러가 동시에 참조할 수 있게 해야 한다.<br><br>참고자료<br><a href=".?query=tag:참고도서\윤성우의_열혈_cpp_프로그래밍" class="tag" target="_blank" rel="noopener nofollow">#참고도서/윤성우의_열혈_cpp_프로그래밍</a><br>]]></description><link>public\인라인-함수.html</link><guid isPermaLink="false">public/인라인 함수.md</guid><pubDate>Sat, 22 Mar 2025 07:31:42 GMT</pubDate></item><item><title><![CDATA[임시 객체]]></title><description><![CDATA[<a class="tag" href="?query=tag:language/cpp" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#language/cpp</a> <a class="tag" href="?query=tag:참고도서/윤성우의_열혈_cpp_프로그래밍" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/윤성우의_열혈_cpp_프로그래밍</a> 
 <br><br><a href=".?query=tag:language\cpp" class="tag" target="_blank" rel="noopener nofollow">#language/cpp</a> <br>temporary object<br><br>함수의 반환형이 <a data-href="클래스" href="public\클래스.html" class="internal-link" target="_self" rel="noopener nofollow">클래스</a>이고, 함수가 값을 반환할 때, 메모리 공간에 임시로 객체를 생성하여 반환을 받는 쪽이 참조할 수 있도록 한다. 이를 임시 객체라고 한다.<br>임시 객체는 개발자가 다음과 같은 형식으로 직접 선언할 수도 있다.<br>
Temporary(200); //클래스명(생성자에게 전달할 인자); 형식

<br>외부에서 객체의 멤버함수를 호출하기 위해 필요한 것은 다음 세 가지 중 하나이다.<br>
<br>객체에 붙여진 이름
<br>객체의 참조 값(객체 참조에 사용되는 정보)
<br>객체의 주소 값
<br>임시객체가 생성된 위치에는 임시객체의 참조 값이 반환되므로, 다음과 같이 임시객체의 멤버함수에 접근할 수 있다.<br>
Temporart(200).ShowTempInfo(); //(임시객체의 참조 값).ShowTempInfo();

<br>
//SimpleFuncObj는 객체를 반환 -&gt; 해당 위치에 임시 객체의 참조값을 생성

SimpleFuncObj(obj).AddNum(30);

<br>임시 객체는 다음과 같은 특징을 가진다.<br>
<br>임시 객체는 다음 행으로 넘어가면 바로 소멸되어 버린다. 이후에 임시 객체를 참조할 수단이 없기 때문이다.
<br>참조자에 의해 참조되는 임시객체는 바로 소멸하지 않는다.
<br>2번 특성에 의하여, 아래 예제는 다음과 같이 해석된다.<br>
SoSimple tempRef = SimpleFuncObj(obj);

<br>위 예제는 다음과 같이 오인되기 쉽다.
-&gt; tempRef라는 새로운 객체를 생성해서, 반환되는 객체를 가지고 대입연산(복사)를 진행한다.
하지만 실제 구문은 다음과 같이 해석된다.
-&gt; 추가로 객체를 생성하지 않고, 반환되는 임시 객체에 tempRef라는 이름을 할당한다. 이는 객체의 생성 수를 하나 줄여서 효율성을 높이기 위해서이다.
<br><br>참고자료<br><a href=".?query=tag:참고도서\윤성우의_열혈_cpp_프로그래밍" class="tag" target="_blank" rel="noopener nofollow">#참고도서/윤성우의_열혈_cpp_프로그래밍</a><br>]]></description><link>public\임시-객체.html</link><guid isPermaLink="false">public/임시 객체.md</guid><pubDate>Sat, 22 Mar 2025 07:31:42 GMT</pubDate></item><item><title><![CDATA[자료형]]></title><description><![CDATA[<a class="tag" href="?query=tag:language/cpp" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#language/cpp</a> <a class="tag" href="?query=tag:참고도서/포르잔_cpp_바이블" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/포르잔_cpp_바이블</a> 
 <br><br><a href=".?query=tag:language\cpp" class="tag" target="_blank" rel="noopener nofollow">#language/cpp</a> <br>data types<br><br><br>c++ 프로그램은 데이터를 효율적으로 조작하고자 자료를 형태에 따라 구분하며 이렇게 구분해서 인식하는 자료의 형태를 자료형 data types라고 한다.<br>자료형은 크게 내장 자료형과 사용자 정의 자료형으로 나뉜다.<br>내장 자료형 built-in types은 프로그래밍 언어에 정의된 자료형이다. 내장 자료형은 기본 자료형 fundamentals과 복합 자료형 compound types으로 구분한다. 기본 자료형은 이름 그대로 기본적인 자료형이고, 복합 자료형은 기본 자료형을 기반으로 파생된 자료형이다.<br>사용자 정의 자료형 user-defined types은 열거형 enumerated과 클래스 class로 구분한다.<br><br>자료형의 범위는 플랫폼에 따라서 다르다. 예를 들어, long int는 어떤 시스템에서는 4 byte이고 어떤 시스템에서는 8 byte이다. 아래의 표는 일반적인 플랫폼에서의 정수 자료형 범위이다.<br><br><br>원래 c++에 정의되어 있는 문자 자료형의 크기는 1바이트이며 부호가 없다. 하지만 현대에는 1, 2, 4바이트이거나 부호 있는 문자도 있다. 이는 c++ 언어가 세계의 여러 문자를 지원하기 위해 변경된  것이다.<br>이 문서에서는 문자 자료형이 ASCII 인코딩 시스템을 기반으로 하는 1바이트 정수 자료형이라고 가정한다. ASCII 인코딩 시스템은 0 ~ 127 범위의 정수를 사용해서 128개의 글자를 정의한다.<br><br>참 true 또는 거짓 false을 나타내기 위한 1바이트 자료형.<br>c++ 언어는 불 또한 정수를 이용해서 다룬다. 0은 false, 0이 아닌 값은 true로 취급한다.<br><br>소수점을 갖는 숫자를 다루는 자료형.<br><br>void 자료형은 값이 없음을 나타내는 특별한 자료형이다. 주로 '함수가 어떠한 값도 반환하지 않는다'를 나타내기 위해 사용한다.<br><br>참고자료<br><a href=".?query=tag:참고도서\포르잔_cpp_바이블" class="tag" target="_blank" rel="noopener nofollow">#참고도서/포르잔_cpp_바이블</a> <br>]]></description><link>public\자료형.html</link><guid isPermaLink="false">public/자료형.md</guid><pubDate>Sat, 22 Mar 2025 07:31:42 GMT</pubDate></item><item><title><![CDATA[접근제어 지시자]]></title><description><![CDATA[<a class="tag" href="?query=tag:language/cpp" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#language/cpp</a> <a class="tag" href="?query=tag:참고도서/윤성우의_열혈_cpp_프로그래밍" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/윤성우의_열혈_cpp_프로그래밍</a> 
 <br><br><a href=".?query=tag:language\cpp" class="tag" target="_blank" rel="noopener nofollow">#language/cpp</a> <br>access control modifier<br><br>c++ 언어는 구조체 및 클래스의 멤버 변수 및 멤버 함수의 접근 허용범위를 접근제어 지시자를 통해 별도로 지정할 수 있다.<br>접근제어 지시자는 다음과 같이 총 세가지가 존재한다.<br><br><br>참고자료<br><a href=".?query=tag:참고도서\윤성우의_열혈_cpp_프로그래밍" class="tag" target="_blank" rel="noopener nofollow">#참고도서/윤성우의_열혈_cpp_프로그래밍</a><br>]]></description><link>public\접근제어-지시자.html</link><guid isPermaLink="false">public/접근제어 지시자.md</guid><pubDate>Sat, 22 Mar 2025 07:31:42 GMT</pubDate></item><item><title><![CDATA[정보은닉]]></title><description><![CDATA[<a class="tag" href="?query=tag:language/cpp" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#language/cpp</a> <a class="tag" href="?query=tag:참고도서/윤성우의_열혈_cpp_프로그래밍" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/윤성우의_열혈_cpp_프로그래밍</a> 
 <br><br><a href=".?query=tag:language\cpp" class="tag" target="_blank" rel="noopener nofollow">#language/cpp</a> <br><br><a data-href="클래스" href="public\클래스.html" class="internal-link" target="_self" rel="noopener nofollow">클래스</a> 또는 <a data-href="구조체" href="public\구조체.html" class="internal-link" target="_self" rel="noopener nofollow">구조체</a>의 멤버변수를 <a data-tooltip-position="top" aria-label="접근제어 지시자" data-href="접근제어 지시자" href="public\접근제어-지시자.html" class="internal-link" target="_self" rel="noopener nofollow">private</a>으로 선언하고, 해당 변수에 접근하는 함수를 별도로 정의해서, 안전한 형태로 멤버변수의 접근을 유도하는 것.<br><br>참고자료<br><a href=".?query=tag:참고도서\윤성우의_열혈_cpp_프로그래밍" class="tag" target="_blank" rel="noopener nofollow">#참고도서/윤성우의_열혈_cpp_프로그래밍</a><br>]]></description><link>public\정보은닉.html</link><guid isPermaLink="false">public/정보은닉.md</guid><pubDate>Sat, 22 Mar 2025 07:31:42 GMT</pubDate></item><item><title><![CDATA[정적 라우팅]]></title><description><![CDATA[<a class="tag" href="?query=tag:network" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#network</a> 
 <br><br><a href=".?query=tag:network" class="tag" target="_blank" rel="noopener nofollow">#network</a> <br>Static Routing<br><br>송수신 호스트 사이에서 패킷 전송이 이루어지기 전에 경로 정보를 라우터에 미리 저장하여 중개하는 방식.<br>패킷을 중개하기 위한 최적의 경로 정보는 개별 라우터별로 저장하여 관리하는데, 운용 중인 네트워크 구성에 변화가 생기면 이에 적절하게 대처할 수 없다는 문제점이 있다. 즉, 라우터에 보관된 경로 정보가 고정되어 변화된 정보를 갱신하기가 용이하지 않으며, 특히 네트워크 내부의 혼잡도를 반영할 수 없다.<br>단, 동적 라우팅보다 비용이 적다는 장점이 있다. 따라서 동적 라우팅이 필요 없는 작은 규모의 LAN에서 사용될 수 있다.<br>디폴트 라우팅 default routing : 목적지에 상관없이 무조건 지정된 네트워크로 패킷을 전송한다. 주로 네트워크가 일직선으로 구성되어 있거나, 다음 라우터에 목적지까지 가는 데 필요한 경로 정보가 저장되어 있을 때 유용하다.<br><br>참고자료<br><a data-tooltip-position="top" aria-label="https://terms.naver.com/entry.naver?docId=2271886&amp;cid=51207&amp;categoryId=51207" rel="noopener nofollow" class="external-link" href="https://terms.naver.com/entry.naver?docId=2271886&amp;cid=51207&amp;categoryId=51207" target="_blank">네이버 지식백과</a><br>]]></description><link>public\정적-라우팅.html</link><guid isPermaLink="false">public/정적 라우팅.md</guid><pubDate>Sat, 22 Mar 2025 07:31:45 GMT</pubDate></item><item><title><![CDATA[정확도와 정밀도]]></title><description><![CDATA[<a class="tag" href="?query=tag:language/c" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#language/c</a> <a class="tag" href="?query=tag:cpp" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#cpp</a> <a class="tag" href="?query=tag:computer_science" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#computer_science</a> 
 <br><br> <a href=".?query=tag:language\c" class="tag" target="_blank" rel="noopener nofollow">#language/c</a> <a href=".?query=tag:cpp" class="tag" target="_blank" rel="noopener nofollow">#cpp</a> <a href=".?query=tag:computer_science" class="tag" target="_blank" rel="noopener nofollow">#computer_science</a> <br>accuracy and precision<br><br>정확도와 정밀도는 int와 float의 특징을 규정하는 개념이다. 정확도는 자료형이 나타내는 값이 실제 값과 일치하는 정도이고, 정밀도는 해당 값에 대해 얼마나 많은 정보를 갖고 있는지, 해당 정보를 얼마나 고유하게 고정하고 있는지와 관련이 있다.<br>예를 들어, integer 기반의 자료형은 완벽한 정확도를 가지고 있다. integer가 표현하는 값 2는 실제 정수 2와 완전히 일치한다. 하지만 integer 기반의 자료형은 정밀도가 부족하다. 5를 4로 나누면 원래 2.5가 되어야 하지만 2라는 결과를 반환한다. 값 자체는 일치하지만 정수가 가지는 특성을 완전히 표현하지 못한다.<br>float 기반의 자료형의 경우, 정확도가 부족하다. 컴퓨터가 저장할 수 있는 용량에는 한계가 있고, 지수부와 소수부를 나누어 저장하는 특성상 값에 오차가 존재할 수 있다. 하지만 float 기반 자료형은 높은 정밀도를 가진다. 예를 들어 int형과 달리 5 / 2 = 2.5를 정확히 출력화는 등 소수의 특성을 높은 정도로 재현한다.<br><br>참고자료<br><a data-tooltip-position="top" aria-label="https://www.cprogramming.com/tutorial/floating_point/understanding_floating_point.html" rel="noopener nofollow" class="external-link" href="https://www.cprogramming.com/tutorial/floating_point/understanding_floating_point.html" target="_blank">Cprogramming.com</a><br>]]></description><link>public\정확도와-정밀도.html</link><guid isPermaLink="false">public/정확도와 정밀도.md</guid><pubDate>Sat, 22 Mar 2025 07:32:00 GMT</pubDate></item><item><title><![CDATA[제너레이터]]></title><description><![CDATA[<a class="tag" href="?query=tag:language/JavaScript" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#language/JavaScript</a> <a class="tag" href="?query=tag:web" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#web</a> <a class="tag" href="?query=tag:참고도서/모던_자바스크립트_Deep_Dive" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/모던_자바스크립트_Deep_Dive</a> 
 <br><br><a href=".?query=tag:language\JavaScript" class="tag" target="_blank" rel="noopener nofollow">#language/JavaScript</a> <a href=".?query=tag:web" class="tag" target="_blank" rel="noopener nofollow">#web</a> <br>generator<br><br><br>ES6에서 도입된 제너레이터 generator는 코드 블록의 실행을 일시 중지했다가 필요한 시점에 재개할 수 있는 특수한 함수이다. 제너레이터와 일반 함수의 차이는 다음과 같다.<br><br>일반 함수를 호출하면 제어권이 함수에게 넘어가고 함수 코드를 일괄 실행한다. 즉, 함수 호출자 caller는 함수를 호출한 이후 함수 실행을 제어할 수 없다. 제너레이터 함수는 함수 실행을 함수 호출자가 제어할 수 있다. 다시 말해, 함수 호출자가 함수 실행을 일시 중지시키거나 재개시킬 수 있다. 이는 함수의 제어권을 함수가 독점하는 것이 아니라 함수 호출자에게 양도 yield할 수 있다는 것을 의미한다.<br><br>일반 함수를 호출하면 매개변수를 통해 함수 외부에서 값을 주입받고 함수 코드를 일괄 실행하여 결과값을 함수 외부로 반환한다. 즉, 함수가 실행되고 있는 동안에는 함수 외부에서 함수 내부로 값을 전달하여 함수의 상태를 변경할 수 없다. 제너레이터 함수는 함수 호출자와 양방향으로 함수의 상태를 주고받을 수 있다. 다시 말해, 제너레이터 함수는 함수 호출자에게 상태를 전달할 수 있고 함수 호출자로부터 상태를 전달받을 수도 있다.<br><br>일반 함수를 호출하면 함수 코드를 일괄 실행하고 값을 반환한다. 제너레이터 함수를 호출하면 함수 코드를 실행하는 것이 아니라 이터러블이면서 동시에 이터레이터인 제너레이터 객체를 반환한다.<br><br>제너레이터 함수는 function * 키워드로 선언한다. 그리고 하나 이상의 yield 표현식을 포함한다. 이것을 제외하면 일반 함수를 정의하는 방법과 같다.<br>
// 제너레이터 함수 선언문
function* getDecFunc() {
    yield 1;
}

// 제너레이터 함수 표현식
const genExpFunc = function* () {
    yield 1;
};

// 제너레이터 메서드
const obj = {
    * genObjMethod() {
        yield 1;
    }
};

// 제너레이터 클래스 메서드
class MyClass {
    * genClsMethod() {
        yield 1;
    }
}

<br>애스터리스크(*)의 위치는 function 키워드와 함수 이름 사이라면 어디든지 상관없다. 다음 예제의 제너레이터 함수는 모두 유효하다. 하지만 일관성을 유지하기 위해 function 키워드 바로 뒤에 붙이는 것이 좋다.<br>제너레이터 함수는 화살표 함수로 정의할 수 없다.<br>
제너레이터 함수는 new 연산자와 함께 생성자 함수로 호출할 수 없다.<br><br>제너레이터 함수를 호출하면 일반 함수처럼 함수 코드 블록을 실행하는 것이 아니라 제너레이터 객체를 생성해 반환한다. 제너레이터 함수가 반환한 제널레이터 객체는 이터러블 iterable이면서 동시에 iterator다.<br>다시 말해, 제너레이터 객체는 Symbol.iterator를 상속받는 이터러블이면서 value, done 프로퍼티를 갖는 이터레이터 리절트 객체를 반환하는 next 메서드를 소유하는 이터레이터다. 제너레이터 객체는 next 메서드를 가지는 이터레이터이므로 Symbol.iterator 메서드를 호출해서 별도로 이터레이터를 생성할 필요가 없다.<br>
// 제네레이터 함수
function* getFunc() {
    yield 1;
    yield 2;
    yield 3;
}

// 제너레이터 객체를 호출하면 제너레이터 객체를 반환한다.
const generator = getFunc();

// 제너레이터 객체는 이터러블이면서 동시에 이터레이터다.
// 이터러블은 Symbol.iterator 메서드를 직접 구현하거나 프로토타입 체인을 통해 상속받은 객체다.
console.log(Symbol.iterator in generator);  // true
// 이터레이터는 next 메서드를 갖는다.
console.log('next' in generator);   // true

<br>제너레이터 객체는 next 메서드를 갖는 이터레이터이지만 이터레이터에는 없는  return, throw 메서드를 갖는다. 제너레이터 객체의 세 개의 메서드를 호출하면 다음과 같이 동작한다.<br>
<br>next 메서드를 호출하면 제너레이터 함수의 yield 표현식까지 코드 블록을 실행하고 yield된 값을 value 프로퍼티 값으로, false를 done 프로퍼티 값으로 갖는 이터레이터 리절트 객체를 반환한다. next 메서드를 반복 호출하여 제너레이터 함수가 끝까지 실행되면 next 메서드가 반환하는 이터레이터 함수의 반환값이 할당되고 done 프로퍼티에는 제너레이터 함수가 끝까지 실행되었을을 나타내는 true가 할당된다.
<br>return 메서드를 호출하면 인수로 전달받은 값을 value 프로퍼티 값으로, true를 done 프로퍼티 값으로 갖는 이터레이터 리절트 객체를 반환한다.
<br>throw 메서드를 호출하면 인수로 전달받은 에러를 발생시키고 undefined를 value 프로퍼티 값으로, true를 done 프로퍼티값으로 갖는 이터레이터 리절트 객체를 반환한다.
<br>
function* genFunc()
{
    try
    {
        yield 1;
        yield 2;
        yield 3;
    } catch (e)
    {
        console.error(e);
    }
}

const generator = genFunc();

console.log(generator.next());

console.log(generator.return('End!'));
//console.log(generator.throw('Error!'));

<br><br>제너레이터는 yield 키워드와 next 메서드를 통해 실행을 일시 중지했다가 필요한 시점에 다시 재개할 수 있다. 일반 함수는 호출 이후 제어권을 함수가 독점하지만 제너레이터는 함수 호출자에게 제어권을 양도 yield하여 필요한 시점에 함수 실행을 재개할 수 있다.<br>제너레이터 객체의 next 메서드를 호출하면 제너레이터 함수의 코드 블록을 실행한다.<br>단, 일반 함수처럼 한 번에 코드 블록의 모든 코드를 일괄 실행하는 것이 아니라 yield 표현식까지만 실행한다. yield 키워드는 제너레이터 함수의 실행을 일시 중지시키거나 yield 키워드 뒤에 오는 표현식의 평가 결과를 제너레이터 함수 호출자에게 반환한다.<br>
function* genFunc()
{
    yield 1;
    yield 2;
    yield 3;
}

const generator = genFunc();

for (let i = 0; i &lt; 4; i++)
{
    console.log(generator.next());
}

<br>이터레이터의 next 메서드와는 달리 제너레이터 객체의 next 메서드에는 인수를 전달할 수 있다. 제너레이터 객체의 next 메서드에 전달한 인수는 제너레이터 함수의 yield 표현식을 할당하는 변수에  할당된다. yield 표현식을 할당받는 변수에 yield 표현식의 평과 결과가 할당되지 않는 것에 주의해야 한다.<br>
function* genFunc()
{
    const x = yield 1;
    const y = yield (x + 10);

    return (x + y);
}

const generator = genFunc(0);

let res = generator.next();
console.log(res);

res = generator.next(10);
console.log(res);

res = generator.next(20);
console.log(res);

<br>이처럼 제너레이터 함수는 next 메서드와 yield 표현식을 통해 함수 호출자와 함수의 상태를 주고받을 수 있다. 함수 호출자는 next 메서드를 통해 yield 표현식까지 함수를 실행시켜 제너레이터 객체를 관리하는 상태(yield된 값)을 꺼내올 수 있고, next 메서드에 인수를 전달해서 제너레이터 객체에 상태(yield 표현식을 할당받는 변수)를 밀어넣을 수 있다.<br>이러한 제너레이터의 특성을 활용하면 비동기 처리를 동기 처리처럼 구현할 수 있다.<br><br><br>(생략)<br><br>제너레이터의 특성을 활용하여 프로미스의 후속 처리 메서드 then/catch/finally 없이 비동기 처리 결과를 반환하도록 구현할 수 있다.<br>
// node-fetch는 Node.js 환경에서 window.fetch 함수를 사용하기 위한 패키지이다.
// 브라우저 환경에 이 예제를 실행한다면 아래 코드는 필요없다.
// https://github.com/node-fetch/node-fetch
const fetch = require('node-fetch');

// 제너레이터 실행기
const async = generatorFunc =&gt; {
    const generator = generatorFunc();  // 2

    const onResolved = arg =&gt; {
        const result = generator.next(arg); // 5

        return result.done
            ? result.value  // 9
            : result.value.then(res =&gt; onResolved(res));    // 7
        };
    return onResolved;  // 3
};

(async(function* fetchTodo() {
    const url = 'https://jsonplaceholder.typicode.com/todos/1';

    const response = yield fetch(url);  // 6
    const todo = yield response.json(); // 8
    console.log(todo);
})());

<br>(예제에 대한 설명은 생략 - 너무 어려워요 차라리 <a data-href="async await" href="public\async-await.html" class="internal-link" target="_self" rel="noopener nofollow">async await</a>을 참조합시다.)<br><br>참고자료<br><a href=".?query=tag:참고도서\모던_자바스크립트_Deep_Dive" class="tag" target="_blank" rel="noopener nofollow">#참고도서/모던_자바스크립트_Deep_Dive</a> <br>]]></description><link>public\제너레이터.html</link><guid isPermaLink="false">public/제너레이터.md</guid><pubDate>Sat, 18 Jan 2025 15:32:55 GMT</pubDate></item><item><title><![CDATA[조정자]]></title><description><![CDATA[<a class="tag" href="?query=tag:language/cpp" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#language/cpp</a> <a class="tag" href="?query=tag:참고도서/포르잔_cpp_바이블" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/포르잔_cpp_바이블</a> 
 <br><br><a href=".?query=tag:language\cpp" class="tag" target="_blank" rel="noopener nofollow">#language/cpp</a><br>manipulator<br><br><br>일반적으로 c++ 언어에서 데이터 입출력 시 표준 형식 standard format으로 값을 입출력한다.<br>하지만 상황에 따라서 이러한 입출력 형식을 바꿔야 할 때가 있다. 이를 위해 조정자 manipulator라는 객체를 사용한다. 조정자는 크게 데이터 출력을 위한 조정자와 데이터 입력을 위한 조정자로 구분할 수 있다.<br><br>출력 조정자는 크게 매개변수가 없는 조정자와 매개변수가 있는 조정자로 나뉜다.<br><br>매개변수가 필요 없는 조정자는 &lt;iostream&gt;에 정의되어있다.<br>endl을 제와한 모든 조정자는 출력 스트림의 상태를 변경해서 1회 사용하면 이후에 다른 조정자를 사용하기 전까지 계속해서 조정자가 적용된다. 즉, 1회만 지정하면 계속해서 적용된다.<br><br>endl 조정자를 사용하면 개행을 추가하여 출력한다.<br><br>기본값 : noboolalpha<br>noboolalpha 조정자는 불 값을 정수(0 또는 1)로 출력한다. boolalpha는 불 값을 리터럴(false 또는 true)로 출력한다.<br><br>기본값 : dec<br>정수를 몇 진법으로 출력할지 결정하는 조정자이다.<br>
<br>dec : 10진법
<br>oct : 8진법
<br>hex : 16진법
<br><br>기본값 : noshowbase<br>숫자를 다른 진법으로 출력할 때, 어떤 진법으로 출력하고 있는지 나타내는 접두사를 지정하는 조정자이다. 10진수는 아무 것도 붙지 않고, 8진수는 0, 16진수는 0x가 접두사로 붙어서 각각의 진법을 나타낸다.<br><br>기본값 : fixed<br>부동 소수점 자료형을 출력할 때는 고정 소수점 fixed format을 사용하는 방법과 과학 scientific 표기법을 사용하는 2가지 방법이 있다.<br><br>기본값: showpoint<br>c++는 기본적으로 소수점 아래 부분이 0일 때 소수점 아래 부분을 출력하지 않는다. 하지만 showpoint 조정자를 사용하면 소수점 아래 부분이 0일 때에도 출력한다.<br><br>기본값 : noshowpos<br>c++는 숫자가 양수일 때 양수 부호(+)를 출력하지 않는다. 음수 부호만 출력된다. showpos 조정자를 사용하면 양수일 때도 양수 기호를 출력한다.<br><br>기본값 :  nouppercase<br>16진수로 정수를 출력할 때 알파벳(a, b, c, d, e, f) 등이 출력되고 부동 소수정의 과학 표기법 때도 알파벳 e가 출력된다. 이러한 문자는 기본적으로 소문자로 출력된다. 이를 대문자로 변경할 때는 uppercase 조정자를 사용한다.<br><br>후술할 매개변수가 있는 조정자를 사용하여 정해진 크기의 영역 field에 값을 출력하는 방법을 다룬다. 정해진 크기의 영역을 잡고 나면 left, right, internal 조정자를 사용해서 숫자를 배치하는 형식을 정할 수 있다.<br><br>매개변수가 있는 조정자의 경우 사용하기 위해 &lt;iomanip&gt; 헤더를 읽어들여야 한다.<br><br>setprecision 조정자는 고정 소수점 출력 방식(과학 표기법 출력 방식 제외)에서만 사용한다. 괄호 안의 정수(n)로 소수점 뒤의 몇 자리까지 출력할지를 지정한다.<br><br>setw 조정자도 고정 소수점 출력 방식(과학 표기법 출력 방식 제외)에서만 사용된다. 괄호 안의 정수(n)은 전체 필드 크기를 의미하고, 이때 필드 크기는 정수 부분, 소수점, 소수점 아래 부분을 모두 합친 길이이다. 참고로 setw 조정자는 출력 스트림의 상태를 변경하지 않는다. 따라서 필요할 때마다 사용해야 한다. setw 조정자를 제외하고 매개변수가 있는 조정자는 출력스트림의 상태를 변경한다.<br><br>setfill 조정자는 필드의 크기가 실제 출력되는 내용보다 클 때 발생하는 패딩을 어떤 문자로 채울지 지정할 때 사용한다. 괄호 안에는 리터럴 문자를 넣는다. 이전에 설명한 조정자(left, interval, right, setw)들과 조합하여 사용한다.<br><br><br>기본값 : noboolalpha<br>불을 0과 1이 아니라, true와 false 문자열로 입력할 수 있는 조정자이다.<br><br>기본값 : dec<br>정수 입력을 10진법, 8진법, 16진법으로 입력할 수 있게 설정하는 조정자이다.<br><br>참고자료<br><a href=".?query=tag:참고도서\포르잔_cpp_바이블" class="tag" target="_blank" rel="noopener nofollow">#참고도서/포르잔_cpp_바이블</a> <br>]]></description><link>public\조정자.html</link><guid isPermaLink="false">public/조정자.md</guid><pubDate>Sat, 22 Mar 2025 07:31:42 GMT</pubDate></item><item><title><![CDATA[참고도서]]></title><description><![CDATA[<a class="tag" href="?query=tag:updating" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#updating</a> <a class="tag" href="?query=tag:참고도서" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서</a> <a class="tag" href="?query=tag:참고도서/그림으로_이해하는_네트워크_용어" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/그림으로_이해하는_네트워크_용어</a> <a class="tag" href="?query=tag:참고도서/후니의_쉽게_쓴_시스코_네트워킹" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/후니의_쉽게_쓴_시스코_네트워킹</a> <a class="tag" href="?query=tag:참고도서/윤성우의_열혈_cpp_프로그래밍" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/윤성우의_열혈_cpp_프로그래밍</a> <a class="tag" href="?query=tag:참고도서/윤성우의_열혈_TCP_IP_소켓_프로그래밍" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/윤성우의_열혈_TCP_IP_소켓_프로그래밍</a> <a class="tag" href="?query=tag:참고도서/이득우의_게임_수학" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/이득우의_게임_수학</a> <a class="tag" href="?query=tag:참고도서/그림과_실습으로_배우는_도커_쿠버네티스" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/그림과_실습으로_배우는_도커_쿠버네티스</a> <a class="tag" href="?query=tag:참고도서/시작하세요_도커_쿠버네티스" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/시작하세요_도커_쿠버네티스</a> <a class="tag" href="?query=tag:참고도서/모던_웹_디자인을_위한_HTML5_CSS3_입문" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/모던_웹_디자인을_위한_HTML5_CSS3_입문</a> <a class="tag" href="?query=tag:참고도서/혼자_공부하는_자바스크립트" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/혼자_공부하는_자바스크립트</a> <a class="tag" href="?query=tag:참고도서/모던_자바스크립트_핵심_가이드" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/모던_자바스크립트_핵심_가이드</a> <a class="tag" href="?query=tag:참고도서/모던_자바스크립트_Deep_Dive" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/모던_자바스크립트_Deep_Dive</a> <a class="tag" href="?query=tag:참고도서/포르잔_cpp_바이블" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고도서/포르잔_cpp_바이블</a> 
 <br><br><a href=".?query=tag:updating" class="tag" target="_blank" rel="noopener nofollow">#updating</a> <a href=".?query=tag:참고도서" class="tag" target="_blank" rel="noopener nofollow">#참고도서</a><br><br>]]></description><link>public\참고도서.html</link><guid isPermaLink="false">public/참고도서.md</guid><pubDate>Wed, 28 May 2025 14:28:24 GMT</pubDate></item><item><title><![CDATA[참고링크]]></title><description><![CDATA[<a class="tag" href="?query=tag:updating" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#updating</a> <a class="tag" href="?query=tag:참고링크" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고링크</a> <a class="tag" href="?query=tag:참고링크/후니의_IT_블로그" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고링크/후니의_IT_블로그</a> <a class="tag" href="?query=tag:참고링크/ANSI_escape_code_깃헙_정리자료" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고링크/ANSI_escape_code_깃헙_정리자료</a> <a class="tag" href="?query=tag:참고링크/nginx_org" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고링크/nginx_org</a> <a class="tag" href="?query=tag:참고링크/생활코딩" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고링크/생활코딩</a> <a class="tag" href="?query=tag:참고링크/php-fpm_org" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#참고링크/php-fpm_org</a> 
 <br><br><a href=".?query=tag:updating" class="tag" target="_blank" rel="noopener nofollow">#updating</a> <a href=".?query=tag:참고링크" class="tag" target="_blank" rel="noopener nofollow">#참고링크</a><br><br>]]></description><link>public\참고링크.html</link><guid isPermaLink="false">public/참고링크.md</guid><pubDate>Sat, 22 Mar 2025 07:43:52 GMT</pubDate></item><item><title><![CDATA[참조자]]></title><description/></item><item><title><![CDATA[index]]></title><description><![CDATA[<a class="tag" href="?query=tag:42Seoul" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#42Seoul</a> <a class="tag" href="?query=tag:algorithm" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#algorithm</a> <a class="tag" href="?query=tag:computer_science" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#computer_science</a> <a class="tag" href="?query=tag:cpp" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#cpp</a> <a class="tag" href="?query=tag:cryptograph" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#cryptograph</a> <a class="tag" href="?query=tag:database" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#database</a> <a class="tag" href="?query=tag:docker" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#docker</a> <a class="tag" href="?query=tag:ect" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#ect</a> <a class="tag" href="?query=tag:excalidraw" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#excalidraw</a> <a class="tag" href="?query=tag:ft_transcendence" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#ft_transcendence</a> <a class="tag" href="?query=tag:graph" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#graph</a> <a class="tag" href="?query=tag:graphics" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#graphics</a> <a class="tag" href="?query=tag:language" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#language</a> <a class="tag" href="?query=tag:language/c" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#language/c</a> <a class="tag" href="?query=tag:language/cpp" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#language/cpp</a> <a class="tag" href="?query=tag:language/css" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#language/css</a> <a class="tag" href="?query=tag:language/html" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#language/html</a> <a class="tag" href="?query=tag:language/JavaScript" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#language/JavaScript</a> <a class="tag" href="?query=tag:linux" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#linux</a> <a class="tag" href="?query=tag:linux/cmd" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#linux/cmd</a> <a class="tag" href="?query=tag:linux/system_call" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#linux/system_call</a> <a class="tag" href="?query=tag:math" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#math</a> <a class="tag" href="?query=tag:math/number_theory" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#math/number_theory</a> <a class="tag" href="?query=tag:memo" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#memo</a> <a class="tag" href="?query=tag:network" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#network</a> <a class="tag" href="?query=tag:security" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#security</a> <a class="tag" href="?query=tag:server" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#server</a> <a class="tag" href="?query=tag:server/web_server" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#server/web_server</a> <a class="tag" href="?query=tag:socket_programming" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#socket_programming</a> <a class="tag" href="?query=tag:uncomplete" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#uncomplete</a> <a class="tag" href="?query=tag:updating" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#updating</a> <a class="tag" href="?query=tag:web" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#web</a> 
 <br><br><br><br>]]></description><link>public\index.html</link><guid isPermaLink="false">public/index.md</guid><pubDate>Wed, 28 May 2025 17:14:01 GMT</pubDate></item></channel></rss>